import { E as ElementModel, D as DeploymentElementModel, A as AnyAux, f as DeploymentNodeModel, g as DeployedInstanceModel, h as RelationshipsAccum, R as RelationshipModel, i as DeploymentRelationModel } from '../shared/core.k4jahJ8j.js';
export { b as Aux, j as EdgeModel, d as LikeC4DeploymentModel, L as LikeC4Model, e as LikeC4ViewModel, N as NodeModel } from '../shared/core.k4jahJ8j.js';
import { F as Fqn, a as IteratorLike } from '../shared/core.Bhx0OGK8.js';
import { I as IterableContainer, R as ReorderedArray } from '../shared/core.BsAIrb_r.js';
import 'type-fest';
import '../shared/core.C9UbC1nX.js';

interface Connection<Elem = ElementModel | DeploymentElementModel, Id = string> {
    readonly id: Id;
    readonly source: Elem;
    readonly target: Elem;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    readonly boundary: Elem | null;
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    readonly expression: string;
    mergeWith(this: Connection<Elem, Id>, other: typeof this): typeof this;
    nonEmpty(): boolean;
    difference(this: Connection<Elem, Id>, other: typeof this): typeof this;
    intersect(this: Connection<Elem, Id>, other: typeof this): typeof this;
    equals(other: Connection): boolean;
}
declare namespace Connection {
    type ConnectionPredicate = <C extends Connection<{
        id: string;
    }, any>>(connection: C) => boolean;
    type ElementId = Fqn | string;
    export const isInside: (fqn: ElementId) => ConnectionPredicate;
    export const isDirectedBetween: (source: ElementId, target: ElementId) => ConnectionPredicate;
    export const isAnyBetween: (source: ElementId, target: ElementId) => ConnectionPredicate;
    export const isIncoming: (target: ElementId) => ConnectionPredicate;
    export const isOutgoing: (source: ElementId) => ConnectionPredicate;
    export const isAnyInOut: (source: ElementId) => ConnectionPredicate;
    export {  };
}

declare const customInspectSymbol: unique symbol;

/**
 * Connection is ephemeral entity, result of a resolving relationships between source and target.
 * Includes direct relationships and/or between their nested elements.
 */
declare class DeploymentConnectionModel<M extends AnyAux = AnyAux> implements Connection<DeploymentElementModel<M>, M['EdgeId']> {
    readonly source: DeploymentNodeModel<M> | DeployedInstanceModel<M>;
    readonly target: DeploymentNodeModel<M> | DeployedInstanceModel<M>;
    readonly relations: RelationshipsAccum<M>;
    constructor(source: DeploymentNodeModel<M> | DeployedInstanceModel<M>, target: DeploymentNodeModel<M> | DeployedInstanceModel<M>, relations: RelationshipsAccum<M>);
    readonly id: M['EdgeId'];
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    get expression(): string;
    private _boundary;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    get boundary(): DeploymentNodeModel<M> | null;
    nonEmpty(): boolean;
    [customInspectSymbol](depth: any, inspectOptions: any, inspect: any): string;
    toString(): string;
    /**
     * Check if connection contains deployment relation,
     * that is directly connected to source or target.
     */
    hasDirectDeploymentRelation(): boolean;
    values(): IteratorLike<RelationshipModel<M> | DeploymentRelationModel<M>>;
    /**
     * Merge with another connections, if it has the same source and target.
     * Returns new connection with union of relationships.
     */
    mergeWith(others: DeploymentConnectionModel<M>[]): DeploymentConnectionModel<M>;
    /**
     * Merge with another connection, if it has the same source and target.
     * Returns new connection with union of relationships.
     */
    mergeWith(other: DeploymentConnectionModel<M>): DeploymentConnectionModel<M>;
    difference(other: DeploymentConnectionModel<M>): DeploymentConnectionModel<M>;
    intersect(other: DeploymentConnectionModel<M>): DeploymentConnectionModel<M>;
    equals(other: Connection): boolean;
    /**
     * Creates a clone of the current `DeploymentConnectionModel` instance with optional overrides.
     * if `null` is provided in overrides, the corresponding relation set will be empty.
     */
    update(overrides?: {
        model?: ReadonlySet<RelationshipModel<M>> | null;
        deployment?: ReadonlySet<DeploymentRelationModel<M>> | null;
    }): DeploymentConnectionModel<M>;
}

/**
 * Connection refers to any relationships between two elements,
 * both direct and implicit ones (between their nested elements).
 *
 * Merges relationships together to an single edge on the diagram.
 */
declare class ConnectionModel<M extends AnyAux = AnyAux> implements Connection<ElementModel<M>, M['EdgeId']> {
    readonly source: ElementModel<M>;
    readonly target: ElementModel<M>;
    readonly relations: ReadonlySet<RelationshipModel<M>>;
    readonly id: M['EdgeId'];
    constructor(source: ElementModel<M>, target: ElementModel<M>, relations?: ReadonlySet<RelationshipModel<M>>);
    private _boundary;
    /**
     * Common ancestor of the source and target elements.
     * Represents the boundary of the connection.
     */
    get boundary(): ElementModel<M> | null;
    /**
     * Human readable expression of the connection
     * Mostly used for testing and debugging
     */
    get expression(): string;
    /**
     * Returns true if only includes relations between the source and target elements.
     */
    get isDirect(): boolean;
    /**
     * Returns true if includes relations between nested elements of the source and target elements.
     */
    get isImplicit(): boolean;
    get directRelations(): ReadonlySet<RelationshipModel<M>>;
    nonEmpty(): boolean;
    mergeWith(other: ConnectionModel<M>): ConnectionModel<M>;
    difference(other: ConnectionModel<M>): ConnectionModel<M>;
    intersect(other: ConnectionModel<M>): ConnectionModel<M>;
    equals(other: Connection): boolean;
    /**
     * Returns a new instance with the updated relations.
     *
     * @param relations - A readonly set of `RelationshipModel` instances representing the new relations.
     * @returns A new `ConnectionModel` instance with the updated relations.
     */
    update(relations: ReadonlySet<RelationshipModel<M>>): ConnectionModel<M>;
    [customInspectSymbol](depth: any, inspectOptions: any, inspect: any): string;
    toString(): string;
    /**
     * Creates a new connection with reversed direction (target becomes source and vice versa)
     * @param search - When true, attempts to find an existing connection between the reversed nodes
     */
    reversed(search?: boolean): ConnectionModel<M>;
}

/**
 * Check if connection is nested inside another connection
 * (i.e. between descendants)
 */
declare function isNestedConnection<T extends {
    id: string;
}>(parent: WithSourceTarget<NoInfer<T>>): (nested: WithSourceTarget<T>) => boolean;
declare function isNestedConnection<T extends {
    id: string;
}>(nested: WithSourceTarget<T>, parent: WithSourceTarget<T>): boolean;
type ConnectionElemId = Connection<{
    readonly id: string;
}, any>;
declare function findDeepestNestedConnection<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): C | null;
declare function sortDeepestFirst<C extends ConnectionElemId>(connections: ReadonlyArray<C>): C[];
type WithBoundary = {
    boundary: null | {
        id: string;
    };
};
declare function sortConnectionsByBoundaryHierarchy(sort?: 'asc' | 'desc'): <T extends WithBoundary, A extends IterableContainer<T>>(array: A) => ReorderedArray<A>;
declare function sortConnectionsByBoundaryHierarchy<T extends WithBoundary, A extends IterableContainer<T>>(array: A, sort?: 'asc' | 'desc'): ReorderedArray<A>;
/**
 * Find connections that includes given connection (i.e between it's ancestors)
 */
declare function findAscendingConnections<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): Array<C>;
/**
 * Find connections that includes given connection (i.e between it's descendants)
 */
declare function findDescendantConnections<C extends ConnectionElemId>(connections: ReadonlyArray<C>, connection: C): Array<C>;
declare function mergeConnections<C extends Connection>(connections: ReadonlyArray<C>): C[];
/**
 * Excludes the values existing in `other` array.
 * The output maintains the same order as the input.
 */
declare function differenceConnections<C extends Connection>(source: Iterable<C>, exclude: Iterable<C>): C[];
type WithSourceTarget<T = unknown> = {
    source: T;
    target: T;
};
declare function hasSameSourceTarget<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameSourceTarget<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
declare function hasSameSource<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameSource<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
declare function hasSameTarget<T>(a: WithSourceTarget<NoInfer<T>>): (b: WithSourceTarget<T>) => boolean;
declare function hasSameTarget<T>(a: WithSourceTarget<T>, b: WithSourceTarget<T>): boolean;
type WithId<T> = {
    id: T;
};
declare function isOutgoing<T extends string>(source: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isOutgoing<T extends string>(a: WithSourceTarget<WithId<T>>, source: WithId<T>): boolean;
declare function isIncoming<T extends string>(target: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isIncoming<T extends string>(a: WithSourceTarget<WithId<T>>, target: WithId<T>): boolean;
declare function isAnyInOut<T extends string>(source: WithId<NoInfer<T>>): (a: WithSourceTarget<WithId<T>>) => boolean;
declare function isAnyInOut<T extends string>(a: WithSourceTarget<WithId<T>>, source: WithId<T>): boolean;

/**
 * Resolve connection from source to target
 * If direction is `both`, also look for reverse connection
 *
 * @default direction directed
 */
declare function findConnection$1<M extends AnyAux>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction: 'directed'): readonly [DeploymentConnectionModel<M>] | readonly [];
declare function findConnection$1<M extends AnyAux>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction: 'both'): readonly [DeploymentConnectionModel<M>, DeploymentConnectionModel<M>] | readonly [DeploymentConnectionModel<M>] | readonly [];
declare function findConnection$1<M extends AnyAux>(source: DeploymentElementModel<M>, target: DeploymentElementModel<NoInfer<M>>, direction?: 'directed' | 'both'): readonly [DeploymentConnectionModel<M>, DeploymentConnectionModel<M>] | readonly [DeploymentConnectionModel<M>] | readonly [];
/**
 * Resolve all connections between element and others
 * By default, look for both directions.
 *
 * @default direction both
 */
declare function findConnectionsBetween$1<M extends AnyAux>(element: DeploymentElementModel<M>, others: Iterable<DeploymentElementModel<NoInfer<M>>>, direction?: 'directed' | 'both'): readonly DeploymentConnectionModel<M>[];
/**
 * Resolve all connections within a given set of elements
 */
declare function findConnectionsWithin$1<M extends AnyAux>(elements: Iterable<DeploymentElementModel<M>>): readonly DeploymentConnectionModel<M>[];

declare namespace find$1 {
  export { findConnection$1 as findConnection, findConnectionsBetween$1 as findConnectionsBetween, findConnectionsWithin$1 as findConnectionsWithin };
}

/**
 * Resolve connection from source to target
 *
 * @param direction - if 'both', also returns connection from target to source
 * @default `directed`
 */
declare function findConnection<M extends AnyAux>(source: ElementModel<M>, target: ElementModel<M>, direction?: 'directed' | 'both'): [ConnectionModel<M>, ConnectionModel<M>] | [ConnectionModel<M>] | [];
/**
 * Resolve all connections between element and others
 * @param direction - if 'directed', only look for outgoing connections from the element to others
 * @default `both`
 */
declare function findConnectionsBetween<M extends AnyAux>(element: ElementModel<M>, others: Iterable<ElementModel<NoInfer<M>>>, direction?: 'directed' | 'both'): readonly ConnectionModel<M>[];
/**
 * Resolve all connections within a given set of elements
 */
declare function findConnectionsWithin<M extends AnyAux>(elements: Iterable<ElementModel<M>>): readonly ConnectionModel<M>[];

declare const find_findConnection: typeof findConnection;
declare const find_findConnectionsBetween: typeof findConnectionsBetween;
declare const find_findConnectionsWithin: typeof findConnectionsWithin;
declare namespace find {
  export { find_findConnection as findConnection, find_findConnectionsBetween as findConnectionsBetween, find_findConnectionsWithin as findConnectionsWithin };
}

declare function isDeploymentNode(model: DeploymentElementModel): model is DeploymentNodeModel;
declare function isDeployedInstance(model: DeploymentElementModel): model is DeployedInstanceModel;

export { AnyAux, Connection, ConnectionModel, DeployedInstanceModel, DeploymentConnectionModel, DeploymentElementModel, DeploymentNodeModel, DeploymentRelationModel, ElementModel, RelationshipModel, find$1 as deploymentConnection, differenceConnections, findAscendingConnections, findDeepestNestedConnection, findDescendantConnections, hasSameSource, hasSameSourceTarget, hasSameTarget, isAnyInOut, isDeployedInstance, isDeploymentNode, isIncoming, isNestedConnection, isOutgoing, mergeConnections, find as modelConnection, sortConnectionsByBoundaryHierarchy, sortDeepestFirst };
