import { u, i as invariant, n as nonexhaustive } from './core.Btj1m6H6.mjs';

function o$1(a){return t=>!a(t)}

function n(e){return e==null}

function o(r){return Array.isArray(r)}

function t(...a){return u(e,a)}var e=(a,o)=>o.every(l=>l(a));

function y(...a){return u(r,a)}var r=(a,o)=>o.some(e=>e(a));

var DeploymentElement;
((DeploymentElement2) => {
  DeploymentElement2.isDeploymentNode = (el) => {
    return "kind" in el && !("element" in el);
  };
  DeploymentElement2.isInstance = (el) => {
    return "element" in el && !("kind" in el);
  };
})(DeploymentElement || (DeploymentElement = {}));

function AsFqn(name, parent) {
  return parent ? parent + "." + name : name;
}
const BorderStyles = ["solid", "dashed", "dotted", "none"];
var ElementKind;
((ElementKind2) => {
  ElementKind2.Group = "@group";
})(ElementKind || (ElementKind = {}));
const ElementShapes = [
  "rectangle",
  "person",
  "browser",
  "mobile",
  "cylinder",
  "storage",
  "queue"
];
const DefaultThemeColor = "primary";
const DefaultElementShape = "rectangle";
const DefaultShapeSize = "md";
const DefaultPaddingSize = "md";
const DefaultTextSize = "md";

function isElementRef(expr) {
  return "element" in expr;
}
function isExpandedElementExpr(expr) {
  return "expanded" in expr;
}
function isCustomElement(expr) {
  return "custom" in expr && (isElement(expr.custom.expr) || isElementWhere(expr.custom.expr));
}
function isWildcard(expr) {
  return "wildcard" in expr;
}
function isElementKindExpr(expr) {
  return "elementKind" in expr && "isEqual" in expr;
}
function isElementTagExpr(expr) {
  return "elementTag" in expr && "isEqual" in expr;
}
function isElement(expr) {
  return isElementRef(expr) || isWildcard(expr) || isElementKindExpr(expr) || isElementTagExpr(expr) || isExpandedElementExpr(expr);
}
function isElementWhere(expr) {
  return "where" in expr && isElement(expr.where.expr);
}
function isElementPredicateExpr(expr) {
  return isElement(expr) || isElementWhere(expr) || isCustomElement(expr);
}
function isRelation(expr) {
  return "source" in expr && "target" in expr;
}
function isInOut(expr) {
  return "inout" in expr;
}
function isIncoming(expr) {
  return "incoming" in expr;
}
function isOutgoing(expr) {
  return "outgoing" in expr;
}
function isRelationExpression(expr) {
  return isRelation(expr) || isInOut(expr) || isIncoming(expr) || isOutgoing(expr);
}
function isRelationWhere(expr) {
  return "where" in expr && isRelationExpression(expr.where.expr);
}
function isCustomRelationExpr(expr) {
  return "customRelation" in expr;
}
function isRelationPredicateExpr(expr) {
  return isRelationExpression(expr) || isRelationWhere(expr) || isCustomRelationExpr(expr);
}

const expression = {
  __proto__: null,
  isCustomElement: isCustomElement,
  isCustomRelationExpr: isCustomRelationExpr,
  isElement: isElement,
  isElementKindExpr: isElementKindExpr,
  isElementPredicateExpr: isElementPredicateExpr,
  isElementRef: isElementRef,
  isElementTagExpr: isElementTagExpr,
  isElementWhere: isElementWhere,
  isExpandedElementExpr: isExpandedElementExpr,
  isInOut: isInOut,
  isIncoming: isIncoming,
  isOutgoing: isOutgoing,
  isRelation: isRelation,
  isRelationExpression: isRelationExpression,
  isRelationPredicateExpr: isRelationPredicateExpr,
  isRelationWhere: isRelationWhere,
  isWildcard: isWildcard
};

var FqnRef;
((FqnRef2) => {
  FqnRef2.isInsideInstanceRef = (ref) => {
    return "deployment" in ref && "element" in ref;
  };
  FqnRef2.isDeploymentElementRef = (ref) => {
    return "deployment" in ref && !("element" in ref);
  };
  FqnRef2.isDeploymentRef = (ref) => {
    return !(0, FqnRef2.isModelRef)(ref);
  };
  FqnRef2.isModelRef = (ref) => {
    return "model" in ref;
  };
  FqnRef2.toDeploymentRef = (ref) => {
    invariant((0, FqnRef2.isDeploymentRef)(ref), "Expected DeploymentRef");
    return (0, FqnRef2.isInsideInstanceRef)(ref) ? {
      id: ref.deployment,
      element: ref.element
    } : {
      id: ref.deployment
    };
  };
})(FqnRef || (FqnRef = {}));
var FqnExpr;
((FqnExpr2) => {
  FqnExpr2.isWildcard = (expr) => {
    return "wildcard" in expr && expr.wildcard === true;
  };
  FqnExpr2.isModelRef = (ref) => {
    return "ref" in ref && FqnRef.isModelRef(ref.ref);
  };
  FqnExpr2.isDeploymentRef = (ref) => {
    return "ref" in ref && FqnRef.isDeploymentRef(ref.ref);
  };
})(FqnExpr || (FqnExpr = {}));
var RelationExpr;
((RelationExpr2) => {
  RelationExpr2.isDirect = (expr) => {
    return "source" in expr && "target" in expr;
  };
  RelationExpr2.isIncoming = (expr) => {
    return "incoming" in expr;
  };
  RelationExpr2.isOutgoing = (expr) => {
    return "outgoing" in expr;
  };
  RelationExpr2.isInOut = (expr) => {
    return "inout" in expr;
  };
  RelationExpr2.isWhere = (expr) => {
    return "where" in expr;
  };
})(RelationExpr || (RelationExpr = {}));
var ExpressionV2;
((ExpressionV22) => {
  ExpressionV22.isFqnExpr = (expr) => {
    return FqnExpr.isWildcard(expr) || FqnExpr.isModelRef(expr) || FqnExpr.isDeploymentRef(expr);
  };
  ExpressionV22.isRelation = (expr) => {
    return RelationExpr.isDirect(expr) || RelationExpr.isIncoming(expr) || RelationExpr.isOutgoing(expr) || RelationExpr.isInOut(expr);
  };
})(ExpressionV2 || (ExpressionV2 = {}));

const isTagEqual = (operator) => {
  return "tag" in operator;
};
const isKindEqual = (operator) => {
  return "kind" in operator;
};
const isParticipantOperator = (operator) => {
  return "participant" in operator;
};
const isNotOperator = (operator) => {
  return "not" in operator;
};
const isAndOperator = (operator) => {
  return "and" in operator;
};
const isOrOperator = (operator) => {
  return "or" in operator;
};
function whereOperatorAsPredicate(operator) {
  switch (true) {
    case isParticipantOperator(operator): {
      const participant = operator.participant;
      const participantPredicate = whereOperatorAsPredicate(operator.operator);
      return participantIs(participant, participantPredicate);
    }
    case isTagEqual(operator): {
      if ("eq" in operator.tag) {
        const tag2 = operator.tag.eq;
        return (value) => {
          return Array.isArray(value.tags) && value.tags.includes(tag2);
        };
      }
      const tag = operator.tag.neq;
      return (value) => {
        return !Array.isArray(value.tags) || !value.tags.includes(tag);
      };
    }
    case isKindEqual(operator): {
      if ("eq" in operator.kind) {
        const kind2 = operator.kind.eq;
        return (value) => {
          return value.kind === kind2;
        };
      }
      const kind = operator.kind.neq;
      return (value) => {
        return n(value.kind) || value.kind !== kind;
      };
    }
    case isNotOperator(operator): {
      const predicate = whereOperatorAsPredicate(operator.not);
      return o$1(predicate);
    }
    case isAndOperator(operator): {
      const predicates = operator.and.map(whereOperatorAsPredicate);
      return t(predicates);
    }
    case isOrOperator(operator): {
      const predicates = operator.or.map(whereOperatorAsPredicate);
      return y(predicates);
    }
    default:
      nonexhaustive(operator);
  }
}
function participantIs(participant, predicate) {
  return (value) => {
    if (!value.source || !value.target) {
      return false;
    }
    switch (participant) {
      case "source": {
        return predicate(value.source);
      }
      case "target": {
        return predicate(value.target);
      }
    }
  };
}

const DefaultLineStyle = "dashed";
const DefaultArrowType = "normal";
const DefaultRelationshipColor = "gray";

function isViewRulePredicate(rule) {
  return "include" in rule && Array.isArray(rule.include) || "exclude" in rule && Array.isArray(rule.exclude);
}
function isViewRuleGlobalPredicateRef(rule) {
  return "predicateId" in rule;
}
function isViewRuleStyle(rule) {
  return "style" in rule && "targets" in rule && Array.isArray(rule.targets);
}
function isViewRuleGlobalStyle(rule) {
  return "styleId" in rule;
}
function isAutoLayoutDirection(autoLayout) {
  return autoLayout === "TB" || autoLayout === "BT" || autoLayout === "LR" || autoLayout === "RL";
}
function isViewRuleAutoLayout(rule) {
  return "direction" in rule;
}
function isViewRuleGroup(rule) {
  return "title" in rule && "groupRules" in rule && Array.isArray(rule.groupRules);
}
function isDynamicViewParallelSteps(step) {
  return "__parallel" in step && o(step.__parallel);
}
function isDeploymentView(view) {
  return view.__ === "deployment";
}
function isDynamicView(view) {
  return view.__ === "dynamic";
}
function isElementView(view) {
  return n(view.__) || view.__ === "element";
}
function isExtendsElementView(view) {
  return isElementView(view) && "extends" in view;
}
function isScopedElementView(view) {
  return isElementView(view) && "viewOf" in view;
}
function stepEdgeId(step, parallelStep) {
  const id = `step-${String(step).padStart(2, "0")}`;
  return parallelStep ? `${id}.${parallelStep}` : id;
}
function isStepEdgeId(id) {
  return id.startsWith("step-");
}
function extractStep(id) {
  if (!isStepEdgeId(id)) {
    throw new Error(`Invalid step edge id: ${id}`);
  }
  return parseFloat(id.slice("step-".length));
}
function getParallelStepsPrefix(id) {
  if (isStepEdgeId(id) && id.includes(".")) {
    return id.slice(0, id.indexOf(".") + 1);
  }
  return null;
}
var ComputedNode;
((ComputedNode2) => {
  function modelRef(node) {
    return node.modelRef === 1 ? node.id : node.modelRef ?? null;
  }
  ComputedNode2.modelRef = modelRef;
  function deploymentRef(node) {
    return node.deploymentRef === 1 ? node.id : node.deploymentRef ?? null;
  }
  ComputedNode2.deploymentRef = deploymentRef;
  function isNodesGroup(node) {
    return node.kind === ElementKind.Group;
  }
  ComputedNode2.isNodesGroup = isNodesGroup;
})(ComputedNode || (ComputedNode = {}));
var ComputedView;
((ComputedView2) => {
  function isDeployment(view) {
    return view.__ === "deployment";
  }
  ComputedView2.isDeployment = isDeployment;
  function isDynamic(view) {
    return view.__ === "dynamic";
  }
  ComputedView2.isDynamic = isDynamic;
  function isElement(view) {
    return n(view.__) || view.__ === "element";
  }
  ComputedView2.isElement = isElement;
})(ComputedView || (ComputedView = {}));
function getBBoxCenter({
  x,
  y,
  width,
  height
}) {
  return {
    x: x + width / 2,
    y: y + height / 2
  };
}
var DiagramNode;
((DiagramNode2) => {
  function modelRef(node) {
    return node.modelRef === 1 ? node.id : node.modelRef ?? null;
  }
  DiagramNode2.modelRef = modelRef;
  function deploymentRef(node) {
    return node.deploymentRef === 1 ? node.id : node.deploymentRef ?? null;
  }
  DiagramNode2.deploymentRef = deploymentRef;
  function isNodesGroup(node) {
    return node.kind === ElementKind.Group;
  }
  DiagramNode2.isNodesGroup = isNodesGroup;
})(DiagramNode || (DiagramNode = {}));

export { isDeploymentView as $, AsFqn as A, BorderStyles as B, isRelationPredicateExpr as C, DefaultElementShape as D, ElementKind as E, isRelationWhere as F, isWildcard as G, ExpressionV2 as H, FqnExpr as I, FqnRef as J, isAndOperator as K, isKindEqual as L, isNotOperator as M, isOrOperator as N, isTagEqual as O, whereOperatorAsPredicate as P, DefaultArrowType as Q, RelationExpr as R, DefaultLineStyle as S, DefaultRelationshipColor as T, ComputedNode as U, ComputedView as V, DiagramNode as W, extractStep as X, getBBoxCenter as Y, getParallelStepsPrefix as Z, isAutoLayoutDirection as _, isElementView as a, isDynamicView as a0, isDynamicViewParallelSteps as a1, isStepEdgeId as a2, isViewRuleAutoLayout as a3, isViewRuleGlobalPredicateRef as a4, isViewRuleGlobalStyle as a5, isViewRuleGroup as a6, isViewRulePredicate as a7, isViewRuleStyle as a8, stepEdgeId as a9, o$1 as aa, y as ab, isElementPredicateExpr as b, DefaultThemeColor as c, DeploymentElement as d, isScopedElementView as e, expression as f, DefaultPaddingSize as g, DefaultShapeSize as h, isExtendsElementView as i, DefaultTextSize as j, ElementShapes as k, isCustomElement as l, isCustomRelationExpr as m, n, o, isElement as p, isElementKindExpr as q, isElementRef as r, isElementTagExpr as s, isElementWhere as t, isExpandedElementExpr as u, isIncoming as v, isInOut as w, isOutgoing as x, isRelation as y, isRelationExpression as z };
