import { LiteralUnion, Tagged, Simplify, UnionToIntersection, TupleToUnion } from 'type-fest';

declare const ThemeColors: readonly ["amber", "blue", "gray", "slate", "green", "indigo", "muted", "primary", "red", "secondary", "sky"];
type ThemeColor = typeof ThemeColors[number];
type HexColorLiteral = `#${string}`;
type ColorLiteral = HexColorLiteral;
type Color = LiteralUnion<ThemeColor, string>;
type ShapeSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
/**
 * For padding, margin, etc.
 */
type SpacingSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
type TextSize = 'xs' | 'sm' | 'md' | 'lg' | 'xl';
declare function isThemeColor(color: Color): color is ThemeColor;
interface ElementThemeColorValues {
    fill: ColorLiteral;
    stroke: ColorLiteral;
    hiContrast: ColorLiteral;
    loContrast: ColorLiteral;
}
type ElementThemeColors = {
    [key in ThemeColor]: ElementThemeColorValues;
};
interface RelationshipThemeColorValues {
    lineColor: ColorLiteral;
    labelBgColor: ColorLiteral;
    labelColor: ColorLiteral;
}
interface ThemeColorValues {
    elements: ElementThemeColorValues;
    relationships: RelationshipThemeColorValues;
}
type RelationshipThemeColors = {
    [key in ThemeColor]: RelationshipThemeColorValues;
};
interface LikeC4Theme {
    font: 'Arial';
    shadow: ColorLiteral;
    relationships: RelationshipThemeColors;
    elements: ElementThemeColors;
    sizes: {
        [key in ShapeSize]: {
            width: number;
            height: number;
        };
    };
    spacing: {
        [key in SpacingSize]: number;
    };
    textSizes: {
        [key in TextSize]: number;
    };
}

type NonEmptyArray<T> = [T, ...T[]];
type NonEmptyReadonlyArray<T> = readonly [T, ...T[]];
type IconUrl = Tagged<string, 'IconUrl'> | 'none';
type CustomColor = string;
type Point = readonly [x: number, y: number];
interface XYPoint {
    x: number;
    y: number;
}
type KeysOf<T> = keyof T extends infer K extends string ? K : never;
type AllNever<Expressions> = UnionToIntersection<{
    [Name in keyof Expressions]: {
        -readonly [Key in keyof Expressions[Name]]?: never;
    };
}[keyof Expressions]>;
/**
 * @example
 *   type Variant1 = {
 *     a: string
 *   }
 *   type Variant2 = {
 *     b: number
 *   }
 *
 *   type Variants = ExclusiveUnion<{
 *     Variant1: Variant1,
 *     Variant2: Variant2
 *   }>
 *
 *   Fail here
 *   const variant1: Variants = {
 *      a: 'one',
 *      b: 1
 *   }
 */
type ExclusiveUnion<Expressions> = Expressions extends object ? {
    [Name in keyof Expressions]: Simplify<Omit<AllNever<Expressions>, keyof Expressions[Name]> & Expressions[Name]>;
}[keyof Expressions] : Expressions;
/**
 * Copy from https://github.com/remeda/remeda/blob/main/src/internal/types/NTuple.ts
 * An array with *exactly* N elements in it.
 *
 * Only literal N values are supported. For very large N the type might result
 * in a recurse depth error. For negative N the type would result in an infinite
 * recursion. None of these have protections because this is an internal type!
 */
type NTuple<T, N extends number, Result extends Array<unknown> = []> = Result['length'] extends N ? Result : NTuple<T, N, [...Result, T]>;
type IteratorLike<T> = IteratorObject<T, BuiltinIteratorReturn>;
type Predicate<T> = (x: T) => boolean;

type Fqn<Id extends string = string> = Tagged<Id, 'Fqn'>;
declare function AsFqn(name: string, parent?: Fqn | null): Fqn;
declare const BorderStyles: readonly ["solid", "dashed", "dotted", "none"];
type BorderStyle = TupleToUnion<typeof BorderStyles>;
type ElementKind<Kinds extends string = string> = Tagged<Kinds, 'ElementKind'>;
declare namespace ElementKind {
    const Group: ElementKind;
}
declare const ElementShapes: readonly ["rectangle", "person", "browser", "mobile", "cylinder", "storage", "queue"];
type ElementShape = TupleToUnion<typeof ElementShapes>;
declare const DefaultThemeColor: ThemeColor;
declare const DefaultElementShape: ElementShape;
declare const DefaultShapeSize: ShapeSize;
declare const DefaultPaddingSize: SpacingSize;
declare const DefaultTextSize: TextSize;
interface ElementStyle {
    readonly border?: BorderStyle;
    /**
     * In percentage 0-100, 0 is fully transparent
     *
     * @default 100
     */
    readonly opacity?: number;
    /**
     * If true, the element is rendered as multiple shapes
     * @default false
     */
    readonly multiple?: boolean;
    /**
     * Shape size
     *
     * @default 'md'
     */
    readonly size?: ShapeSize;
    readonly padding?: SpacingSize;
    readonly textSize?: TextSize;
}
type Tag<Tags extends string = string> = Tagged<Tags, 'Tag'>;
interface TagSpec {
    readonly id: Tag;
    readonly style: ElementStyle;
}
interface Link {
    readonly title?: string;
    readonly url: string;
    readonly relative?: string;
}
interface TypedElement<Ids extends string, Kinds extends string, Tags extends string, MetadataKeys extends string = never> {
    readonly id: Fqn<Ids>;
    readonly kind: ElementKind<Kinds>;
    readonly title: string;
    readonly description: string | null;
    readonly technology: string | null;
    readonly tags: NonEmptyArray<Tag<Tags>> | null;
    readonly links: NonEmptyArray<Link> | null;
    readonly icon?: IconUrl;
    readonly shape?: ElementShape;
    readonly color?: Color;
    readonly style?: ElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<MetadataKeys, string>;
}
interface Element extends TypedElement<string, string, string, string> {
}
interface ElementKindSpecificationStyle {
    shape?: ElementShape;
    icon?: IconUrl;
    color?: Color;
    border?: BorderStyle;
    opacity?: number;
    size?: ShapeSize;
    padding?: SpacingSize;
    textSize?: TextSize;
}
interface ElementKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly style: ElementKindSpecificationStyle;
}

export { AsFqn as A, BorderStyles as B, type CustomColor as C, DefaultElementShape as D, type ExclusiveUnion as E, type Fqn as F, type RelationshipThemeColorValues as G, type HexColorLiteral as H, type IconUrl as I, type SpacingSize as J, type KeysOf as K, type LikeC4Theme as L, type TextSize as M, type NonEmptyArray as N, type ThemeColor as O, type Point as P, type RelationshipThemeColors as R, type ShapeSize as S, type ThemeColorValues as T, type XYPoint as X, type IteratorLike as a, type NonEmptyReadonlyArray as b, type NTuple as c, type Predicate as d, DefaultPaddingSize as e, DefaultShapeSize as f, DefaultTextSize as g, DefaultThemeColor as h, ElementKind as i, ElementShapes as j, type BorderStyle as k, type Element as l, type ElementKindSpecification as m, type ElementKindSpecificationStyle as n, type ElementShape as o, type ElementStyle as p, type Link as q, type Tag as r, type TagSpec as s, type TypedElement as t, isThemeColor as u, ThemeColors as v, type Color as w, type ColorLiteral as x, type ElementThemeColors as y, type ElementThemeColorValues as z };
