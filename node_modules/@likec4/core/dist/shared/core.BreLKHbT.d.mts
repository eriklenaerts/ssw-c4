import { Tagged, NonEmptyTuple, Simplify, MergeExclusive } from 'type-fest';
import { N as NonEmptyArray, F as Fqn, i as ElementKind, r as Tag, o as ElementShape, w as Color, I as IconUrl, k as BorderStyle, S as ShapeSize, E as ExclusiveUnion, p as ElementStyle, q as Link, P as Point, X as XYPoint, T as ThemeColorValues, J as SpacingSize, M as TextSize, O as ThemeColor, m as ElementKindSpecification, t as TypedElement } from './core.Bhx0OGK8.mjs';

type EqualOperator<V> = {
    eq: V;
    neq?: never;
} | {
    eq?: never;
    neq: V;
};
type AllNever = {
    not?: never;
    and?: never;
    or?: never;
    tag?: never;
    kind?: never;
    participant?: never;
};
type TagEqual<Tag> = Omit<AllNever, 'tag'> & {
    tag: EqualOperator<Tag>;
};
declare const isTagEqual: <Tag>(operator: WhereOperator<Tag, any>) => operator is TagEqual<Tag>;
type KindEqual<Kind> = Omit<AllNever, 'kind'> & {
    kind: EqualOperator<Kind>;
};
declare const isKindEqual: <Kind>(operator: WhereOperator<any, Kind>) => operator is KindEqual<Kind>;
type Participant = 'source' | 'target';
type ParticipantOperator<Tag, Kind> = Omit<AllNever, 'participant'> & {
    participant: Participant;
    operator: KindEqual<Kind> | TagEqual<Tag>;
};
type NotOperator<Tag, Kind> = Omit<AllNever, 'not'> & {
    not: WhereOperator<Tag, Kind>;
};
declare const isNotOperator: <Tag, Kind>(operator: WhereOperator<Tag, Kind>) => operator is NotOperator<Tag, Kind>;
type AndOperator<Tag, Kind> = Omit<AllNever, 'and'> & {
    and: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
declare const isAndOperator: <Tag, Kind>(operator: WhereOperator<Tag, Kind>) => operator is AndOperator<Tag, Kind>;
type OrOperator<Tag, Kind> = Omit<AllNever, 'or'> & {
    or: NonEmptyArray<WhereOperator<Tag, Kind>>;
};
declare const isOrOperator: <Tag, Kind>(operator: WhereOperator<Tag, Kind>) => operator is OrOperator<Tag, Kind>;
type WhereOperator<Tag, Kind> = TagEqual<Tag> | KindEqual<Kind> | ParticipantOperator<Tag, Kind> | NotOperator<Tag, Kind> | AndOperator<Tag, Kind> | OrOperator<Tag, Kind>;
type Filterable<FTag extends string | null = string | null, FKind extends string | null = string | null> = {
    tags?: readonly FTag[] | null;
    kind?: FKind;
    source?: Filterable<FTag, FKind>;
    target?: Filterable<FTag, FKind>;
};
type OperatorPredicate<V extends Filterable> = (value: V) => boolean;
declare function whereOperatorAsPredicate<FTag extends string | null = string | null, FKind extends string | null = string | null>(operator: WhereOperator<FTag, FKind>): OperatorPredicate<Filterable>;

interface BaseExpr {
    where?: never;
    element?: never;
    custom?: never;
    expanded?: never;
    elementKind?: never;
    elementTag?: never;
    isEqual?: never;
    isChildren?: never;
    isDescendants?: never;
    wildcard?: never;
    source?: never;
    target?: never;
    inout?: never;
    incoming?: never;
    outgoing?: never;
    customRelation?: never;
}
interface ElementRefExpr extends Omit<BaseExpr, 'element' | 'isChildren' | 'isDescendants'> {
    element: Fqn;
    isChildren?: boolean;
    isDescendants?: boolean;
}
declare function isElementRef(expr: Expression): expr is ElementRefExpr;
interface ExpandedElementExpr extends Omit<BaseExpr, 'expanded'> {
    expanded: Fqn;
}
declare function isExpandedElementExpr(expr: Expression): expr is ExpandedElementExpr;
interface CustomElementExpr extends Omit<BaseExpr, 'custom'> {
    custom: {
        expr: ElementExpression | ElementWhereExpr;
        title?: string;
        description?: string;
        technology?: string;
        notation?: string;
        shape?: ElementShape;
        color?: Color;
        icon?: IconUrl;
        border?: BorderStyle;
        opacity?: number;
        navigateTo?: ViewId;
        multiple?: boolean;
        size?: ShapeSize;
        padding?: ShapeSize;
        textSize?: ShapeSize;
    };
}
declare function isCustomElement(expr: Expression): expr is CustomElementExpr;
interface WildcardExpr extends Omit<BaseExpr, 'wildcard'> {
    wildcard: true;
}
declare function isWildcard(expr: Expression): expr is WildcardExpr;
interface ElementKindExpr extends Omit<BaseExpr, 'elementKind' | 'isEqual'> {
    elementKind: ElementKind;
    isEqual: boolean;
}
declare function isElementKindExpr(expr: Expression): expr is ElementKindExpr;
interface ElementTagExpr extends Omit<BaseExpr, 'elementTag' | 'isEqual'> {
    elementTag: Tag;
    isEqual: boolean;
}
declare function isElementTagExpr(expr: Expression): expr is ElementTagExpr;
type NonWilcard = ElementRefExpr | ElementKindExpr | ElementTagExpr | ExpandedElementExpr;
type ElementExpression = NonWilcard | WildcardExpr;
declare function isElement(expr: Expression): expr is ElementExpression;
interface ElementWhereExpr extends Omit<BaseExpr, 'where'> {
    where: {
        expr: ElementExpression;
        condition: WhereOperator<string, string>;
    };
}
declare function isElementWhere(expr: Expression): expr is ElementWhereExpr;
type ElementPredicateExpression = ElementExpression | ElementWhereExpr | CustomElementExpr;
declare function isElementPredicateExpr(expr: Expression): expr is ElementPredicateExpression;
interface DirectRelationExpr extends Omit<BaseExpr, 'source' | 'target'> {
    source: ElementExpression;
    target: ElementExpression;
    isBidirectional?: boolean;
}
declare function isRelation(expr: Expression): expr is DirectRelationExpr;
interface InOutExpr extends Omit<BaseExpr, 'inout'> {
    inout: ElementExpression;
}
declare function isInOut(expr: Expression): expr is InOutExpr;
interface IncomingExpr extends Omit<BaseExpr, 'incoming'> {
    incoming: ElementExpression;
}
declare function isIncoming(expr: Expression): expr is IncomingExpr;
interface OutgoingExpr extends Omit<BaseExpr, 'outgoing'> {
    outgoing: ElementExpression;
}
declare function isOutgoing(expr: Expression): expr is OutgoingExpr;
type RelationExpression = DirectRelationExpr | InOutExpr | IncomingExpr | OutgoingExpr;
declare function isRelationExpression(expr: Expression): expr is RelationExpression;
interface RelationWhereExpr extends Omit<BaseExpr, 'where'> {
    where: {
        expr: RelationExpression;
        condition: WhereOperator<string, string>;
    };
}
declare function isRelationWhere(expr: Expression): expr is RelationWhereExpr;
interface CustomRelationExpr extends Omit<BaseExpr, 'customRelation'> {
    customRelation: {
        relation: RelationExpression | RelationWhereExpr;
        title?: string;
        description?: string;
        technology?: string;
        notation?: string;
        navigateTo?: ViewId;
        notes?: string;
        color?: Color;
        line?: RelationshipLineType;
        head?: RelationshipArrowType;
        tail?: RelationshipArrowType;
    };
}
declare function isCustomRelationExpr(expr: Expression): expr is CustomRelationExpr;
type RelationPredicateExpression = RelationExpression | RelationWhereExpr | CustomRelationExpr;
declare function isRelationPredicateExpr(expr: Expression): expr is RelationPredicateExpression;
type Expression = ElementPredicateExpression | RelationPredicateExpression;

type expression_CustomElementExpr = CustomElementExpr;
type expression_CustomRelationExpr = CustomRelationExpr;
type expression_DirectRelationExpr = DirectRelationExpr;
type expression_ElementExpression = ElementExpression;
type expression_ElementKindExpr = ElementKindExpr;
type expression_ElementPredicateExpression = ElementPredicateExpression;
type expression_ElementRefExpr = ElementRefExpr;
type expression_ElementTagExpr = ElementTagExpr;
type expression_ElementWhereExpr = ElementWhereExpr;
type expression_ExpandedElementExpr = ExpandedElementExpr;
type expression_Expression = Expression;
type expression_InOutExpr = InOutExpr;
type expression_IncomingExpr = IncomingExpr;
type expression_NonWilcard = NonWilcard;
type expression_OutgoingExpr = OutgoingExpr;
type expression_RelationExpression = RelationExpression;
type expression_RelationPredicateExpression = RelationPredicateExpression;
type expression_RelationWhereExpr = RelationWhereExpr;
type expression_WildcardExpr = WildcardExpr;
declare const expression_isCustomElement: typeof isCustomElement;
declare const expression_isCustomRelationExpr: typeof isCustomRelationExpr;
declare const expression_isElement: typeof isElement;
declare const expression_isElementKindExpr: typeof isElementKindExpr;
declare const expression_isElementPredicateExpr: typeof isElementPredicateExpr;
declare const expression_isElementRef: typeof isElementRef;
declare const expression_isElementTagExpr: typeof isElementTagExpr;
declare const expression_isElementWhere: typeof isElementWhere;
declare const expression_isExpandedElementExpr: typeof isExpandedElementExpr;
declare const expression_isInOut: typeof isInOut;
declare const expression_isIncoming: typeof isIncoming;
declare const expression_isOutgoing: typeof isOutgoing;
declare const expression_isRelation: typeof isRelation;
declare const expression_isRelationExpression: typeof isRelationExpression;
declare const expression_isRelationPredicateExpr: typeof isRelationPredicateExpr;
declare const expression_isRelationWhere: typeof isRelationWhere;
declare const expression_isWildcard: typeof isWildcard;
declare namespace expression {
  export { type expression_CustomElementExpr as CustomElementExpr, type expression_CustomRelationExpr as CustomRelationExpr, type expression_DirectRelationExpr as DirectRelationExpr, type expression_ElementExpression as ElementExpression, type expression_ElementKindExpr as ElementKindExpr, type expression_ElementPredicateExpression as ElementPredicateExpression, type expression_ElementRefExpr as ElementRefExpr, type expression_ElementTagExpr as ElementTagExpr, type expression_ElementWhereExpr as ElementWhereExpr, type expression_ExpandedElementExpr as ExpandedElementExpr, type expression_Expression as Expression, type expression_InOutExpr as InOutExpr, type expression_IncomingExpr as IncomingExpr, type expression_NonWilcard as NonWilcard, type expression_OutgoingExpr as OutgoingExpr, type expression_RelationExpression as RelationExpression, type expression_RelationPredicateExpression as RelationPredicateExpression, type expression_RelationWhereExpr as RelationWhereExpr, type expression_WildcardExpr as WildcardExpr, expression_isCustomElement as isCustomElement, expression_isCustomRelationExpr as isCustomRelationExpr, expression_isElement as isElement, expression_isElementKindExpr as isElementKindExpr, expression_isElementPredicateExpr as isElementPredicateExpr, expression_isElementRef as isElementRef, expression_isElementTagExpr as isElementTagExpr, expression_isElementWhere as isElementWhere, expression_isExpandedElementExpr as isExpandedElementExpr, expression_isInOut as isInOut, expression_isIncoming as isIncoming, expression_isOutgoing as isOutgoing, expression_isRelation as isRelation, expression_isRelationExpression as isRelationExpression, expression_isRelationPredicateExpr as isRelationPredicateExpr, expression_isRelationWhere as isRelationWhere, expression_isWildcard as isWildcard };
}

declare namespace FqnRef {
    /**
     * Represents a reference to an instance within a deployment.
     *
     * @template D - The type representing the deployment fqn. Defaults to `Fqn`.
     * @template M - The type representing the model fqn. Defaults to `Fqn`.
     *
     * @property {D} deployment - TThe fully qualified name (FQN) of the deployed instance.
     * @property {M} element - The element reference within the deployment.
     */
    type InsideInstanceRef<D = Fqn, M = Fqn> = {
        deployment: D;
        element: M;
    };
    const isInsideInstanceRef: (ref: FqnRef) => ref is InsideInstanceRef;
    /**
     * Represents a reference to a deployment element.
     *
     * @template F - The type of the fully qualified name (FQN) of the deployment element. Defaults to `Fqn`.
     * @property {F} deployment - The fully qualified name (FQN) of the deployment element.
     */
    type DeploymentElementRef<F = Fqn> = {
        deployment: F;
    };
    const isDeploymentElementRef: (ref: FqnRef) => ref is DeploymentElementRef;
    type DeploymentRef<D = Fqn, M = Fqn> = DeploymentElementRef<D> | InsideInstanceRef<D, M>;
    const isDeploymentRef: (ref: FqnRef) => ref is DeploymentRef;
    /**
     * Reference to logical model element
     */
    type ModelRef<F = Fqn> = {
        model: F;
    };
    const isModelRef: (ref: FqnRef) => ref is ModelRef;
    const toDeploymentRef: (ref: FqnRef) => DeploymentRef;
}
type FqnRef<D = Fqn, M = Fqn> = ExclusiveUnion<{
    InsideInstanceRef: FqnRef.InsideInstanceRef<D, M>;
    DeploymentRef: FqnRef.DeploymentRef<D>;
    ModelRef: FqnRef.ModelRef<M>;
}>;
declare namespace FqnExpr {
    type Wildcard = {
        wildcard: true;
    };
    const isWildcard: (expr: ExpressionV2) => expr is Wildcard;
    type ModelRef<M = Fqn> = {
        ref: FqnRef.ModelRef<M>;
        selector?: PredicateSelector;
    };
    const isModelRef: (ref: ExpressionV2) => ref is ModelRef;
    type DeploymentRef<D = Fqn, M = Fqn> = {
        ref: FqnRef.DeploymentRef<D> | FqnRef.InsideInstanceRef<D, M>;
        selector?: PredicateSelector;
    };
    const isDeploymentRef: (ref: ExpressionV2) => ref is FqnExpr.DeploymentRef;
    type NonWildcard<D = Fqn, M = Fqn> = ExclusiveUnion<{
        ModelRef: ModelRef<M>;
        DeploymentRef: DeploymentRef<D, M>;
    }>;
}
type FqnExpr<D = Fqn, M = Fqn> = ExclusiveUnion<{
    Wildcard: FqnExpr.Wildcard;
    ModelRef: FqnExpr.ModelRef<M>;
    DeploymentRef: FqnExpr.DeploymentRef<D, M>;
}>;
declare namespace RelationExpr {
    type Direct<D = Fqn, M = Fqn> = {
        source: FqnExpr<D, M>;
        target: FqnExpr<D, M>;
        isBidirectional?: boolean;
    };
    const isDirect: (expr: ExpressionV2) => expr is Direct;
    type Incoming<D = Fqn, M = Fqn> = {
        incoming: FqnExpr<D, M>;
    };
    const isIncoming: (expr: ExpressionV2) => expr is Incoming;
    type Outgoing<D = Fqn, M = Fqn> = {
        outgoing: FqnExpr<D, M>;
    };
    const isOutgoing: (expr: ExpressionV2) => expr is Outgoing;
    type InOut<D = Fqn, M = Fqn> = {
        inout: FqnExpr<D, M>;
    };
    const isInOut: (expr: ExpressionV2) => expr is InOut;
    type Where<D = Fqn, M = Fqn> = {
        where: {
            expr: ExpressionV2<D, M>;
            condition: WhereOperator<string, string>;
        };
    };
    const isWhere: (expr: ExpressionV2) => expr is Where;
}
type RelationExpr<D = Fqn, M = Fqn> = ExclusiveUnion<{
    Direct: RelationExpr.Direct<D, M>;
    Incoming: RelationExpr.Incoming<D, M>;
    Outgoing: RelationExpr.Outgoing<D, M>;
    InOut: RelationExpr.InOut<D, M>;
    Where: RelationExpr.Where<D, M>;
}>;
/**
 * Represents a version 2 expression which can be one of several types.
 *
 * @template D - The type for the deployment FQN, defaults to `Fqn`.
 * @template M - The type for the model FQN, defaults to `Fqn`.
 */
type ExpressionV2<D = Fqn, M = Fqn> = ExclusiveUnion<{
    Wildcard: FqnExpr.Wildcard;
    ModelRef: FqnExpr.ModelRef<M>;
    DeploymentRef: FqnExpr.DeploymentRef<D, M>;
    Direct: RelationExpr.Direct<D, M>;
    Incoming: RelationExpr.Incoming<D, M>;
    Outgoing: RelationExpr.Outgoing<D, M>;
    InOut: RelationExpr.InOut<D, M>;
    RelationPredicateOrWhere: RelationExpr.Where<D, M>;
}>;
declare namespace ExpressionV2 {
    const isFqnExpr: (expr: ExpressionV2) => expr is FqnExpr;
    const isRelation: (expr: ExpressionV2) => expr is RelationExpr;
}

type GlobalPredicateId = Tagged<string, 'GlobalPredicateId'>;
type GlobalPredicates = NonEmptyArray<ViewRulePredicate>;
type GlobalDynamicPredicates = NonEmptyArray<DynamicViewIncludeRule>;
type GlobalStyleID = Tagged<string, 'GlobalStyleID'>;
type GlobalStyles = NonEmptyTuple<ViewRuleStyle>;
interface ModelGlobals {
    readonly predicates: Record<GlobalPredicateId, GlobalPredicates>;
    readonly dynamicPredicates: Record<GlobalPredicateId, GlobalDynamicPredicates>;
    readonly styles: Record<GlobalStyleID, GlobalStyles>;
}

type ElementNotation = {
    kinds: string[];
    shape: ElementShape;
    color: Color;
    title: string;
};

type ViewId<Id extends string = string> = Tagged<Id, 'ViewID'>;
type ViewRulePredicate = {
    include: Expression[];
    exclude?: never;
} | {
    include?: never;
    exclude: Expression[];
};
declare function isViewRulePredicate(rule: DeploymentViewRule): rule is DeploymentViewRulePredicate;
declare function isViewRulePredicate(rule: DynamicViewRule): rule is DynamicViewIncludeRule;
declare function isViewRulePredicate(rule: ViewRule): rule is ViewRulePredicate;
interface ViewRuleGlobalPredicateRef {
    predicateId: GlobalPredicateId;
}
declare function isViewRuleGlobalPredicateRef(rule: ViewRule): rule is ViewRuleGlobalPredicateRef;
interface ViewRuleStyle {
    targets: ElementExpression[];
    notation?: string;
    style: ElementStyle & {
        color?: Color;
        shape?: ElementShape;
        icon?: IconUrl;
    };
}
declare function isViewRuleStyle(rule: DeploymentViewRule): rule is DeploymentViewRuleStyle;
declare function isViewRuleStyle(rule: ViewRule): rule is ViewRuleStyle;
interface ViewRuleGlobalStyle {
    styleId: GlobalStyleID;
}
declare function isViewRuleGlobalStyle(rule: ViewRule): rule is ViewRuleGlobalStyle;
type ViewRuleStyleOrGlobalRef = ViewRuleStyle | ViewRuleGlobalStyle;
type AutoLayoutDirection = 'TB' | 'BT' | 'LR' | 'RL';
declare function isAutoLayoutDirection(autoLayout: unknown): autoLayout is AutoLayoutDirection;
interface ViewRuleAutoLayout {
    direction: AutoLayoutDirection;
    nodeSep?: number;
    rankSep?: number;
}
declare function isViewRuleAutoLayout(rule: DeploymentViewRule | DynamicViewRule | ViewRule): rule is ViewRuleAutoLayout;
interface ViewRuleGroup {
    groupRules: Array<ViewRulePredicate | ViewRuleGroup>;
    title: string | null;
    color?: Color;
    border?: BorderStyle;
    opacity?: number;
    multiple?: boolean;
    size?: ShapeSize;
    padding?: SpacingSize;
    textSize?: TextSize;
}
declare function isViewRuleGroup(rule: ViewRule): rule is ViewRuleGroup;
type ViewRule = ViewRulePredicate | ViewRuleGlobalPredicateRef | ViewRuleGroup | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface BasicView<ViewType extends 'element' | 'dynamic' | 'deployment', ViewIDs extends string, Tags extends string> {
    readonly __?: ViewType;
    readonly id: ViewId<ViewIDs>;
    readonly title: string | null;
    readonly description: string | null;
    readonly tags: NonEmptyArray<Tag<Tags>> | null;
    readonly links: NonEmptyArray<Link> | null;
    /**
     * URI to the source file of this view.
     * Undefined if the view is auto-generated.
     */
    readonly docUri?: string;
    /**
     * For all views we find common ancestor path.
     * This is used to generate relative paths, i.e.:
     * - "/home/project/index.c4" becomes "index.c4"
     * - "/home/project/subdir/views.c4" becomes "subdir/views.c4"
     *
     * Undefined if the view is auto-generated.
     */
    readonly relativePath?: string;
    /**
     * If the view is changed manually this field contains the layout data.
     */
    readonly manualLayout?: ViewManualLayout | undefined;
    readonly customColorDefinitions: CustomColorDefinitions;
}
interface BasicElementView<ViewIDs extends string, Tags extends string> extends BasicView<'element', ViewIDs, Tags> {
    readonly viewOf?: Fqn;
    readonly rules: ViewRule[];
}
interface ScopedElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
    readonly viewOf: Fqn;
}
interface ExtendsElementView<ViewIDs extends string, Tags extends string> extends BasicElementView<ViewIDs, Tags> {
    readonly extends: ViewId<ViewIDs>;
}
type ElementView<ViewIDs extends string = string, Tags extends string = string> = ScopedElementView<ViewIDs, Tags> | ExtendsElementView<ViewIDs, Tags> | BasicElementView<ViewIDs, Tags>;
interface DynamicViewStep {
    readonly source: Fqn;
    readonly target: Fqn;
    readonly title: string | null;
    readonly description?: string;
    readonly technology?: string;
    readonly notation?: string;
    readonly notes?: string;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly isBackward?: boolean;
    readonly navigateTo?: ViewId;
    __parallel?: never;
}
interface DynamicViewParallelSteps {
    readonly __parallel: DynamicViewStep[];
}
type DynamicViewStepOrParallel = DynamicViewStep | DynamicViewParallelSteps;
type DynamicViewIncludeRule = {
    include: ElementPredicateExpression[];
};
type DynamicViewRule = DynamicViewIncludeRule | ViewRuleGlobalPredicateRef | ViewRuleStyle | ViewRuleGlobalStyle | ViewRuleAutoLayout;
interface DynamicView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<'dynamic', ViewIDs, Tags> {
    readonly __: 'dynamic';
    readonly steps: DynamicViewStepOrParallel[];
    readonly rules: DynamicViewRule[];
}
declare function isDynamicViewParallelSteps(step: DynamicViewStepOrParallel): step is DynamicViewParallelSteps;
type CustomColorDefinitions = {
    [key: string]: ThemeColorValues;
};
type DeploymentViewRulePredicate = {
    include: ExpressionV2[];
    exclude?: never;
} | {
    include?: never;
    exclude: ExpressionV2[];
};
type DeploymentViewRuleStyle = {
    targets: FqnExpr[];
    notation?: string;
    style: ElementStyle & {
        color?: Color;
        shape?: ElementShape;
        icon?: IconUrl;
    };
};
type DeploymentViewRule = DeploymentViewRulePredicate | ViewRuleAutoLayout | DeploymentViewRuleStyle;
interface DeploymentView<ViewIDs extends string = string, Tags extends string = string> extends BasicView<'deployment', ViewIDs, Tags> {
    readonly __: 'deployment';
    readonly rules: DeploymentViewRule[];
}
type LikeC4View<ViewIDs extends string = string, Tags extends string = string> = ElementView<ViewIDs, Tags> | DynamicView<ViewIDs, Tags> | DeploymentView<ViewIDs, Tags>;
declare function isDeploymentView(view: LikeC4View): view is DeploymentView;
declare function isDeploymentView<V extends {
    __?: string;
}>(view: V): boolean;
declare function isDynamicView(view: LikeC4View): view is DynamicView;
declare function isElementView(view: LikeC4View): view is ElementView;
declare function isExtendsElementView(view: LikeC4View): view is ExtendsElementView<string, string>;
declare function isScopedElementView(view: LikeC4View): view is ScopedElementView<string, string>;
type NodeId<IDs extends string = string> = Tagged<IDs, 'Fqn'>;
type EdgeId = Tagged<string, 'EdgeId'>;
type StepEdgeIdLiteral = `step-${number}` | `step-${number}.${number}`;
type StepEdgeId = Tagged<StepEdgeIdLiteral, 'EdgeId'>;
declare function stepEdgeId(step: number, parallelStep?: number): StepEdgeId;
declare function isStepEdgeId(id: string): id is StepEdgeId;
declare function extractStep(id: EdgeId): number;
declare function getParallelStepsPrefix(id: string): string | null;
interface ComputedNode {
    id: NodeId;
    kind: string;
    parent: NodeId | null;
    /**
     * Reference to model element
     * If 1 - node id is a reference
     */
    modelRef?: 1 | Fqn;
    /**
     * Reference to deployment element
     * If 1 - node id is a reference
     */
    deploymentRef?: 1 | Fqn;
    title: string;
    description: string | null;
    technology: string | null;
    notation?: string;
    tags: NonEmptyArray<Tag> | null;
    links: NonEmptyArray<Link> | null;
    children: NodeId[];
    inEdges: EdgeId[];
    outEdges: EdgeId[];
    shape: ElementShape;
    color: Color;
    /**
     * @deprecated Use `style` instead
     */
    icon?: IconUrl;
    style: ElementStyle;
    navigateTo?: ViewId | null;
    level: number;
    depth?: number;
    /**
     * If this node was customized in the view
     */
    isCustomized?: boolean;
}
declare namespace ComputedNode {
    function modelRef(node: ComputedNode): Fqn | null;
    function deploymentRef(node: ComputedNode): Fqn | null;
    /**
     * Nodes group is a special kind of node, exisiting only in view
     */
    function isNodesGroup(node: ComputedNode): boolean;
}
interface ComputedEdge {
    id: EdgeId;
    parent: NodeId | null;
    source: NodeId;
    target: NodeId;
    label: string | null;
    description?: string;
    technology?: string;
    relations: RelationId[];
    kind?: RelationshipKind;
    notation?: string;
    notes?: string;
    color?: Color;
    line?: RelationshipLineType;
    head?: RelationshipArrowType;
    tail?: RelationshipArrowType;
    tags?: NonEmptyArray<Tag>;
    navigateTo?: ViewId;
    /**
     * If this edge is derived from custom relationship predicate
     */
    isCustomized?: boolean;
    /**
     * For layouting purposes
     * @default 'forward'
     */
    dir?: 'forward' | 'back' | 'both';
}
interface ViewWithHash {
    /**
     * Hash of the view object.
     * This is used to detect changes in layout
     */
    hash: string;
}
interface ViewWithNotation {
    notation?: {
        elements: ElementNotation[];
    };
}
interface ViewAutoLayout {
    direction: ViewRuleAutoLayout['direction'];
    rankSep?: number;
    nodeSep?: number;
}
interface ComputedElementView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ElementView<ViewIDs, Tags>, 'rules' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly extends?: ViewId<ViewIDs>;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    rules?: never;
    docUri?: never;
}
interface ComputedDynamicView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DynamicView<ViewIDs, Tags>, 'rules' | 'steps' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    steps?: never;
    rules?: never;
    docUri?: never;
}
interface ComputedDeploymentView<ViewIDs extends string = string, Tags extends string = string> extends Omit<DeploymentView<ViewIDs, Tags>, 'rules' | 'docUri'>, ViewWithHash, ViewWithNotation {
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: ComputedNode[];
    readonly edges: ComputedEdge[];
    rules?: never;
    docUri?: never;
}
type ComputedView<ViewIDs extends string = string, Tags extends string = string> = ComputedElementView<ViewIDs, Tags> | ComputedDynamicView<ViewIDs, Tags> | ComputedDeploymentView<ViewIDs, Tags>;
declare namespace ComputedView {
    function isDeployment(view: ComputedView): view is ComputedDeploymentView;
    function isDynamic(view: ComputedView): view is ComputedDynamicView;
    function isElement(view: ComputedView): view is ComputedElementView;
}
type BBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};
declare function getBBoxCenter({ x, y, width, height, }: BBox): XYPoint;
interface DiagramNode extends ComputedNode {
    width: number;
    height: number;
    position: Point;
    labelBBox: BBox;
}
declare namespace DiagramNode {
    function modelRef(node: DiagramNode): Fqn | null;
    function deploymentRef(node: DiagramNode): Fqn | null;
    /**
     * Nodes group is a special kind of node, exisiting only in view
     */
    function isNodesGroup(node: DiagramNode): boolean;
}
interface DiagramEdge extends ComputedEdge {
    points: NonEmptyArray<Point>;
    controlPoints?: NonEmptyArray<XYPoint>;
    labelBBox?: BBox | null;
    dotpos?: string;
}
interface DiagramView<ViewIDs extends string = string, Tags extends string = string> extends Omit<ComputedView<ViewIDs, Tags>, 'nodes' | 'edges' | 'manualLayout'> {
    readonly nodes: DiagramNode[];
    readonly edges: DiagramEdge[];
    readonly bounds: BBox;
    /**
     * If diagram has manual layout
     * But was changed and layout should be recalculated
     */
    hasLayoutDrift?: boolean;
    manualLayout?: never;
}
type ViewManualLayout = {
    readonly hash: string;
    readonly x: number;
    readonly y: number;
    readonly width: number;
    readonly height: number;
    readonly autoLayout: ViewAutoLayout;
    readonly nodes: Record<string, {
        isCompound: boolean;
        x: number;
        y: number;
        width: number;
        height: number;
    }>;
    readonly edges: Record<string, {
        dotpos?: string;
        points: NonEmptyArray<Point>;
        controlPoints?: NonEmptyArray<XYPoint>;
        labelBBox?: BBox;
    }>;
};

type RelationId = Tagged<string, 'RelationID'>;
type RelationshipKind<Kinds extends string = string> = Tagged<Kinds, 'RelationshipKind'>;
type RelationshipLineType = 'dashed' | 'solid' | 'dotted';
type RelationshipArrowType = 'none' | 'normal' | 'onormal' | 'dot' | 'odot' | 'diamond' | 'odiamond' | 'crow' | 'open' | 'vee';
declare const DefaultLineStyle: RelationshipLineType;
declare const DefaultArrowType: RelationshipArrowType;
declare const DefaultRelationshipColor: ThemeColor;
interface AbstractRelation {
    readonly id: RelationId;
    readonly title?: string;
    readonly description?: string;
    readonly technology?: string;
    readonly tags?: NonEmptyArray<Tag> | null;
    readonly kind?: RelationshipKind;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
    readonly links?: NonEmptyArray<Link> | null;
    readonly navigateTo?: ViewId;
    readonly metadata?: {
        [key: string]: string;
    };
}
interface ModelRelation extends AbstractRelation {
    readonly source: Fqn;
    readonly target: Fqn;
    readonly title: string;
}
interface RelationshipKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly color?: Color;
    readonly line?: RelationshipLineType;
    readonly head?: RelationshipArrowType;
    readonly tail?: RelationshipArrowType;
}

type DeploymentNodeKind<Kinds extends string = string> = Tagged<Kinds, 'DeploymentNodeKind'>;
type DeploymentElementStyle = ElementStyle & {
    readonly icon?: IconUrl;
    readonly shape?: ElementShape;
    readonly color?: Color;
};
interface DeploymentNodeKindSpecification {
    readonly technology?: string;
    readonly notation?: string;
    readonly style: DeploymentElementStyle;
}
interface DeploymentNode {
    readonly id: Fqn;
    readonly kind: DeploymentNodeKind;
    readonly title: string;
    readonly description?: string | null;
    readonly technology?: string | null;
    readonly tags?: NonEmptyArray<Tag> | null;
    readonly links?: NonEmptyArray<Link> | null;
    readonly style?: DeploymentElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<string, string>;
}
interface DeployedInstance {
    /**
     * Format: `<DeploymentNode Fqn>.<Instance Id>`
     * i.e parent fqn is deployment target
     */
    readonly id: Fqn;
    readonly element: Fqn;
    readonly title?: string;
    readonly description?: string | null;
    readonly technology?: string | null;
    readonly tags?: NonEmptyArray<Tag> | null;
    readonly links?: NonEmptyArray<Link> | null;
    readonly style?: DeploymentElementStyle;
    readonly notation?: string;
    readonly metadata?: Record<string, string>;
}
type DeploymentElement = Simplify<MergeExclusive<DeploymentNode, DeployedInstance>>;
declare namespace DeploymentElement {
    const isDeploymentNode: (el: DeploymentElement) => el is DeploymentNode;
    const isInstance: (el: DeploymentElement) => el is DeployedInstance;
}
type PredicateSelector = 'children' | 'expanded' | 'descendants';
interface DeploymentRef {
    readonly id: Fqn;
    readonly element?: Fqn;
}
/**
 * NOTE:
 */
interface DeploymentRelation extends AbstractRelation {
    readonly id: RelationId;
    readonly source: DeploymentRef;
    readonly target: DeploymentRef;
}

/**
 * Represents a LikeC4 model with customizable type parameters,
 * parsed from DSL or result from Builder
 *
 * !IMPORTANT: This is a low-level type, use `LikeC4Model` instead.
 * !NOTE: Views are not computed yet.
 *
 * @typeParam ElementKinds - Types of elements in the model (defaults to string)
 * @typeParam RelationKinds - Types of relationships (defaults to string)
 * @typeParam Tags - Types of tags that can be applied (defaults to string)
 * @typeParam Fqns - Fully Qualified Names for elements (defaults to string)
 * @typeParam Views - Types of views in the model (defaults to string)
 * @typeParam DeploymentFqns - Fully Qualified Names for deployment nodes (defaults to string)
 */
interface ParsedLikeC4Model<ElementKinds extends string = string, RelationKinds extends string = string, Tags extends string = string, Fqns extends string = string, Views extends string = string, DeploymentFqns extends string = string> {
    __?: never;
    specification: {
        tags: Tag<Tags>[];
        elements: Record<ElementKinds, ElementKindSpecification>;
        deployments: Record<DeploymentNodeKind, DeploymentNodeKindSpecification>;
        relationships: Record<RelationKinds, RelationshipKindSpecification>;
    };
    elements: Record<Fqns, TypedElement<Fqns, ElementKinds, Tags>>;
    relations: Record<RelationId, ModelRelation>;
    globals: ModelGlobals;
    views: Record<Views, LikeC4View<Views, Tags>>;
    /**
     * Deployment Model.
     */
    deployments: {
        elements: Record<DeploymentFqns, DeploymentElement>;
        relations: Record<RelationId, DeploymentRelation>;
    };
}
type AnyParsedLikeC4Model = ParsedLikeC4Model<any, any, any, any, any, any>;
/**
 * Hook to get types from dump
 */
type LikeC4ModelDump = {
    elements: {
        [kind: string]: object;
    };
    deployments: {
        elements: {
            [kind: string]: object;
        };
    };
    views: {
        [kind: string]: object;
    };
};
/**
 * Same as {@link ParsedLikeC4Model}, but with computed views or layouted views.
 */
interface GenericLikeC4Model<Fqns extends string = string, DeploymentFqns extends string = string, Views extends string = string, Tags extends string = string, T = 'computed' | 'layouted'> extends Omit<ParsedLikeC4Model<string, string, Tags, Fqns, Views, DeploymentFqns>, 'views' | '__'> {
    __?: T;
    views: Record<Views, ComputedView<Views> | DiagramView<Views>>;
}
interface ComputedLikeC4Model<Fqns extends string = string, DeploymentFqns extends string = string, Views extends string = string, Tags extends string = string> extends Omit<GenericLikeC4Model<Fqns, DeploymentFqns, Views, Tags, 'computed'>, 'views'> {
    views: Record<Views, ComputedView<Views>>;
}
interface LayoutedLikeC4Model<Fqns extends string = string, DeploymentFqns extends string = string, Views extends string = string, Tags extends string = string> extends Omit<GenericLikeC4Model<Fqns, DeploymentFqns, Views, Tags, 'layouted'>, 'views'> {
    __: 'layouted';
    views: Record<Views, DiagramView<Views, Tags>>;
}

export { type GlobalDynamicPredicates as $, type CustomElementExpr as A, type CustomRelationExpr as B, type ComputedLikeC4Model as C, DeploymentElement as D, type DirectRelationExpr as E, type ElementExpression as F, type ElementKindExpr as G, type ElementPredicateExpression as H, type ElementRefExpr as I, type ElementTagExpr as J, type ElementWhereExpr as K, type LikeC4View as L, type ExpandedElementExpr as M, type Expression as N, type IncomingExpr as O, type PredicateSelector as P, type InOutExpr as Q, type NonWilcard as R, type OutgoingExpr as S, type RelationExpression as T, type RelationPredicateExpression as U, type RelationWhereExpr as V, type WildcardExpr as W, ExpressionV2 as X, FqnExpr as Y, FqnRef as Z, RelationExpr as _, ComputedView as a, type CustomColorDefinitions as a$, type GlobalPredicateId as a0, type GlobalPredicates as a1, type GlobalStyleID as a2, type GlobalStyles as a3, type ModelGlobals as a4, type AnyParsedLikeC4Model as a5, type GenericLikeC4Model as a6, type LayoutedLikeC4Model as a7, type LikeC4ModelDump as a8, type ParsedLikeC4Model as a9, DiagramNode as aA, extractStep as aB, getBBoxCenter as aC, getParallelStepsPrefix as aD, isAutoLayoutDirection as aE, isDeploymentView as aF, isDynamicView as aG, isDynamicViewParallelSteps as aH, isElementView as aI, isExtendsElementView as aJ, isScopedElementView as aK, isStepEdgeId as aL, isViewRuleAutoLayout as aM, isViewRuleGlobalPredicateRef as aN, isViewRuleGlobalStyle as aO, isViewRuleGroup as aP, isViewRulePredicate as aQ, isViewRuleStyle as aR, stepEdgeId as aS, type AutoLayoutDirection as aT, type BasicElementView as aU, type BasicView as aV, type BBox as aW, type ComputedDeploymentView as aX, type ComputedDynamicView as aY, type ComputedEdge as aZ, type ComputedElementView as a_, isAndOperator as aa, isKindEqual as ab, isNotOperator as ac, isOrOperator as ad, isTagEqual as ae, whereOperatorAsPredicate as af, type AndOperator as ag, type EqualOperator as ah, type Filterable as ai, type KindEqual as aj, type NotOperator as ak, type OperatorPredicate as al, type OrOperator as am, type TagEqual as an, type WhereOperator as ao, DefaultArrowType as ap, DefaultLineStyle as aq, DefaultRelationshipColor as ar, type AbstractRelation as as, type ModelRelation as at, type RelationId as au, type RelationshipArrowType as av, type RelationshipKind as aw, type RelationshipKindSpecification as ax, type RelationshipLineType as ay, ComputedNode as az, type DeployedInstance as b, type DeploymentView as b0, type DeploymentViewRule as b1, type DeploymentViewRulePredicate as b2, type DeploymentViewRuleStyle as b3, type DiagramEdge as b4, type DiagramView as b5, type DynamicView as b6, type DynamicViewIncludeRule as b7, type DynamicViewParallelSteps as b8, type DynamicViewRule as b9, type DynamicViewStep as ba, type DynamicViewStepOrParallel as bb, type EdgeId as bc, type ElementView as bd, type ExtendsElementView as be, type NodeId as bf, type ScopedElementView as bg, type StepEdgeId as bh, type StepEdgeIdLiteral as bi, type ViewAutoLayout as bj, type ViewId as bk, type ViewManualLayout as bl, type ViewRule as bm, type ViewRuleAutoLayout as bn, type ViewRuleGlobalPredicateRef as bo, type ViewRuleGlobalStyle as bp, type ViewRuleGroup as bq, type ViewRulePredicate as br, type ViewRuleStyle as bs, type ViewRuleStyleOrGlobalRef as bt, type ViewWithHash as bu, type ViewWithNotation as bv, type ElementNotation as bw, type Participant as bx, type DeploymentElementStyle as c, type DeploymentNode as d, expression as e, type DeploymentNodeKind as f, type DeploymentNodeKindSpecification as g, type DeploymentRef as h, type DeploymentRelation as i, isCustomElement as j, isCustomRelationExpr as k, isElement as l, isElementKindExpr as m, isElementPredicateExpr as n, isElementRef as o, isElementTagExpr as p, isElementWhere as q, isExpandedElementExpr as r, isIncoming as s, isInOut as t, isOutgoing as u, isRelation as v, isRelationExpression as w, isRelationPredicateExpr as x, isRelationWhere as y, isWildcard as z };
