import { d as t, $ as n, k as commonAncestor, r as compareFqnHierarchically } from '../shared/core.FFJhmauw.mjs';
export { D as DefaultMap, e as DefaultWeakMap, f as LinkedList, q as Queue, S as Stack, j as ancestorsFqn, g as commonHead, o as compareByFqnHierarchically, h as compareNatural, L as difference, M as equalsSet, A as getOrCreate, a as hasAtLeast, s as hierarchyDistance, u as hierarchyLevel, E as ifilter, i as ifind, F as iflat, G as imap, N as intersection, v as isAncestor, w as isDescendantOf, H as isIterable, B as isNonEmptyArray, c as isSameHierarchy, C as isString, I as isome, J as iunique, n as nameFromFqn, R as objectHash, p as parentFqn, x as sortByFqnHierarchically, y as sortNaturalByFqn, z as sortParentsFirst, Q as stringHash, O as symmetricDifference, K as toArray, t as toSet, P as union } from '../shared/core.FFJhmauw.mjs';
import { i as invariant } from '../shared/core.Btj1m6H6.mjs';

function o(r,n){let e=Math.ceil(r),t=Math.floor(n);if(t<e)throw new RangeError(`randomInteger: The range [${r.toString()},${n.toString()}] contains no integer`);return Math.floor(Math.random()*(t-e+1)+e)}

function ireduce(arg1, arg2, arg3) {
  const reducer = n(arg3) ? arg2 : arg1;
  const initialValue = arg3 ?? arg2;
  invariant(t(reducer));
  function _reduce(iter) {
    let acc = initialValue;
    for (const value of iter) {
      acc = reducer(acc, value);
    }
    return acc;
  }
  return n(arg3) ? _reduce(arg1) : _reduce;
}

const DELAY = "LIKEC4_DELAY";
function delay(...args) {
  let ms = 100;
  if (args.length === 2) {
    ms = o(args[0], args[1]);
  } else if (args.length === 1) {
    ms = args[0];
  }
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(DELAY);
    }, ms ?? 100);
  });
}

const compareRelations = (a, b) => {
  const parentA = commonAncestor(a.source, a.target);
  const parentB = commonAncestor(b.source, b.target);
  if (parentA && !parentB) {
    return 1;
  }
  if (!parentA && parentB) {
    return -1;
  }
  const compareParents = parentA && parentB ? compareFqnHierarchically(parentA, parentB) : 0;
  if (compareParents !== 0) {
    return compareParents;
  }
  const compareSource = compareFqnHierarchically(a.source, b.source);
  if (compareSource !== 0) {
    return compareSource;
  }
  return compareFqnHierarchically(a.target, b.target);
};

export { commonAncestor, compareFqnHierarchically, compareRelations, delay, ireduce };
