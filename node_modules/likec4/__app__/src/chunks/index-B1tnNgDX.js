function O(t, e) {
  if (t.match(/^[a-z]+:\/\//i))
    return t;
  if (t.match(/^\/\//))
    return window.location.protocol + t;
  if (t.match(/^[a-z]+:/i))
    return t;
  const r = document.implementation.createHTMLDocument(), n = r.createElement("base"), s = r.createElement("a");
  return r.head.appendChild(n), r.body.appendChild(s), e && (n.href = e), s.href = t, s.href;
}
const _ = /* @__PURE__ */ (() => {
  let t = 0;
  const e = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (t += 1, `u${e()}${t}`);
})();
function h(t) {
  const e = [];
  for (let r = 0, n = t.length; r < n; r++)
    e.push(t[r]);
  return e;
}
function d(t, e) {
  const n = (t.ownerDocument.defaultView || window).getComputedStyle(t).getPropertyValue(e);
  return n ? parseFloat(n.replace("px", "")) : 0;
}
function W(t) {
  const e = d(t, "border-left-width"), r = d(t, "border-right-width");
  return t.clientWidth + e + r;
}
function q(t) {
  const e = d(t, "border-top-width"), r = d(t, "border-bottom-width");
  return t.clientHeight + e + r;
}
function A(t, e = {}) {
  const r = e.width || W(t), n = e.height || q(t);
  return { width: r, height: n };
}
function B() {
  let t, e;
  try {
    e = process;
  } catch {
  }
  const r = e && e.env ? e.env.devicePixelRatio : null;
  return r && (t = parseInt(r, 10), Number.isNaN(t) && (t = 1)), t || window.devicePixelRatio || 1;
}
const u = 16384;
function j(t) {
  (t.width > u || t.height > u) && (t.width > u && t.height > u ? t.width > t.height ? (t.height *= u / t.width, t.width = u) : (t.width *= u / t.height, t.height = u) : t.width > u ? (t.height *= u / t.width, t.width = u) : (t.width *= u / t.height, t.height = u));
}
function z(t, e = {}) {
  return t.toBlob ? new Promise((r) => {
    t.toBlob(r, e.type ? e.type : "image/png", e.quality ? e.quality : 1);
  }) : new Promise((r) => {
    const n = window.atob(t.toDataURL(e.type ? e.type : void 0, e.quality ? e.quality : void 0).split(",")[1]), s = n.length, i = new Uint8Array(s);
    for (let c = 0; c < s; c += 1)
      i[c] = n.charCodeAt(c);
    r(new Blob([i], {
      type: e.type ? e.type : "image/png"
    }));
  });
}
function y(t) {
  return new Promise((e, r) => {
    const n = new Image();
    n.onload = () => {
      n.decode().then(() => {
        requestAnimationFrame(() => e(n));
      });
    }, n.onerror = r, n.crossOrigin = "anonymous", n.decoding = "async", n.src = t;
  });
}
async function G(t) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(t)).then(encodeURIComponent).then((e) => `data:image/svg+xml;charset=utf-8,${e}`);
}
async function X(t, e, r) {
  const n = "http://www.w3.org/2000/svg", s = document.createElementNS(n, "svg"), i = document.createElementNS(n, "foreignObject");
  return s.setAttribute("width", `${e}`), s.setAttribute("height", `${r}`), s.setAttribute("viewBox", `0 0 ${e} ${r}`), i.setAttribute("width", "100%"), i.setAttribute("height", "100%"), i.setAttribute("x", "0"), i.setAttribute("y", "0"), i.setAttribute("externalResourcesRequired", "true"), s.appendChild(i), i.appendChild(t), G(s);
}
const l = (t, e) => {
  if (t instanceof e)
    return !0;
  const r = Object.getPrototypeOf(t);
  return r === null ? !1 : r.constructor.name === e.name || l(r, e);
};
function K(t) {
  const e = t.getPropertyValue("content");
  return `${t.cssText} content: '${e.replace(/'|"/g, "")}';`;
}
function J(t) {
  return h(t).map((e) => {
    const r = t.getPropertyValue(e), n = t.getPropertyPriority(e);
    return `${e}: ${r}${n ? " !important" : ""};`;
  }).join(" ");
}
function Q(t, e, r) {
  const n = `.${t}:${e}`, s = r.cssText ? K(r) : J(r);
  return document.createTextNode(`${n}{${s}}`);
}
function R(t, e, r) {
  const n = window.getComputedStyle(t, r), s = n.getPropertyValue("content");
  if (s === "" || s === "none")
    return;
  const i = _();
  try {
    e.className = `${e.className} ${i}`;
  } catch {
    return;
  }
  const c = document.createElement("style");
  c.appendChild(Q(i, r, n)), e.appendChild(c);
}
function Y(t, e) {
  R(t, e, ":before"), R(t, e, ":after");
}
const C = "application/font-woff", P = "image/jpeg", Z = {
  woff: C,
  woff2: C,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: P,
  jpeg: P,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function N(t) {
  const e = /\.([^./]*?)$/g.exec(t);
  return e ? e[1] : "";
}
function E(t) {
  const e = N(t).toLowerCase();
  return Z[e] || "";
}
function tt(t) {
  return t.split(/,/)[1];
}
function S(t) {
  return t.search(/^(data:)/) !== -1;
}
function et(t, e) {
  return `data:${e};base64,${t}`;
}
async function I(t, e, r) {
  const n = await fetch(t, e);
  if (n.status === 404)
    throw new Error(`Resource "${n.url}" not found`);
  const s = await n.blob();
  return new Promise((i, c) => {
    const a = new FileReader();
    a.onerror = c, a.onloadend = () => {
      try {
        i(r({ res: n, result: a.result }));
      } catch (o) {
        c(o);
      }
    }, a.readAsDataURL(s);
  });
}
const b = {};
function nt(t, e, r) {
  let n = t.replace(/\?.*/, "");
  return r && (n = t), /ttf|otf|eot|woff2?/i.test(n) && (n = n.replace(/.*\//, "")), e ? `[${e}]${n}` : n;
}
async function x(t, e, r) {
  const n = nt(t, e, r.includeQueryParams);
  if (b[n] != null)
    return b[n];
  r.cacheBust && (t += (/\?/.test(t) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let s;
  try {
    const i = await I(t, r.fetchRequestInit, ({ res: c, result: a }) => (e || (e = c.headers.get("Content-Type") || ""), tt(a)));
    s = et(i, e);
  } catch (i) {
    s = r.imagePlaceholder || "";
    let c = `Failed to fetch resource: ${t}`;
    i && (c = typeof i == "string" ? i : i.message), c && console.warn(c);
  }
  return b[n] = s, s;
}
async function rt(t) {
  const e = t.toDataURL();
  return e === "data:," ? t.cloneNode(!1) : y(e);
}
async function it(t, e) {
  if (t.currentSrc) {
    const i = document.createElement("canvas"), c = i.getContext("2d");
    i.width = t.clientWidth, i.height = t.clientHeight, c?.drawImage(t, 0, 0, i.width, i.height);
    const a = i.toDataURL();
    return y(a);
  }
  const r = t.poster, n = E(r), s = await x(r, n, e);
  return y(s);
}
async function st(t) {
  var e;
  try {
    if (!((e = t?.contentDocument) === null || e === void 0) && e.body)
      return await w(t.contentDocument.body, {}, !0);
  } catch {
  }
  return t.cloneNode(!1);
}
async function ct(t, e) {
  return l(t, HTMLCanvasElement) ? rt(t) : l(t, HTMLVideoElement) ? it(t, e) : l(t, HTMLIFrameElement) ? st(t) : t.cloneNode(D(t));
}
const at = (t) => t.tagName != null && t.tagName.toUpperCase() === "SLOT", D = (t) => t.tagName != null && t.tagName.toUpperCase() === "SVG";
async function ot(t, e, r) {
  var n, s;
  if (D(e))
    return e;
  let i = [];
  return at(t) && t.assignedNodes ? i = h(t.assignedNodes()) : l(t, HTMLIFrameElement) && (!((n = t.contentDocument) === null || n === void 0) && n.body) ? i = h(t.contentDocument.body.childNodes) : i = h(((s = t.shadowRoot) !== null && s !== void 0 ? s : t).childNodes), i.length === 0 || l(t, HTMLVideoElement) || await i.reduce((c, a) => c.then(() => w(a, r)).then((o) => {
    o && e.appendChild(o);
  }), Promise.resolve()), e;
}
function lt(t, e) {
  const r = e.style;
  if (!r)
    return;
  const n = window.getComputedStyle(t);
  n.cssText ? (r.cssText = n.cssText, r.transformOrigin = n.transformOrigin) : h(n).forEach((s) => {
    let i = n.getPropertyValue(s);
    s === "font-size" && i.endsWith("px") && (i = `${Math.floor(parseFloat(i.substring(0, i.length - 2))) - 0.1}px`), l(t, HTMLIFrameElement) && s === "display" && i === "inline" && (i = "block"), s === "d" && e.getAttribute("d") && (i = `path(${e.getAttribute("d")})`), r.setProperty(s, i, n.getPropertyPriority(s));
  });
}
function ut(t, e) {
  l(t, HTMLTextAreaElement) && (e.innerHTML = t.value), l(t, HTMLInputElement) && e.setAttribute("value", t.value);
}
function ft(t, e) {
  if (l(t, HTMLSelectElement)) {
    const r = e, n = Array.from(r.children).find((s) => t.value === s.getAttribute("value"));
    n && n.setAttribute("selected", "");
  }
}
function ht(t, e) {
  return l(e, Element) && (lt(t, e), Y(t, e), ut(t, e), ft(t, e)), e;
}
async function mt(t, e) {
  const r = t.querySelectorAll ? t.querySelectorAll("use") : [];
  if (r.length === 0)
    return t;
  const n = {};
  for (let i = 0; i < r.length; i++) {
    const a = r[i].getAttribute("xlink:href");
    if (a) {
      const o = t.querySelector(a), f = document.querySelector(a);
      !o && f && !n[a] && (n[a] = await w(f, e, !0));
    }
  }
  const s = Object.values(n);
  if (s.length) {
    const i = "http://www.w3.org/1999/xhtml", c = document.createElementNS(i, "svg");
    c.setAttribute("xmlns", i), c.style.position = "absolute", c.style.width = "0", c.style.height = "0", c.style.overflow = "hidden", c.style.display = "none";
    const a = document.createElementNS(i, "defs");
    c.appendChild(a);
    for (let o = 0; o < s.length; o++)
      a.appendChild(s[o]);
    t.appendChild(c);
  }
  return t;
}
async function w(t, e, r) {
  return !r && e.filter && !e.filter(t) ? null : Promise.resolve(t).then((n) => ct(n, e)).then((n) => ot(t, n, e)).then((n) => ht(t, n)).then((n) => mt(n, e));
}
const U = /url\((['"]?)([^'"]+?)\1\)/g, gt = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, dt = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function yt(t) {
  const e = t.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${e})(['"]?\\))`, "g");
}
function wt(t) {
  const e = [];
  return t.replace(U, (r, n, s) => (e.push(s), r)), e.filter((r) => !S(r));
}
async function pt(t, e, r, n, s) {
  try {
    const i = r ? O(e, r) : e, c = E(e);
    let a;
    return s || (a = await x(i, c, n)), t.replace(yt(e), `$1${a}$3`);
  } catch {
  }
  return t;
}
function bt(t, { preferredFontFormat: e }) {
  return e ? t.replace(dt, (r) => {
    for (; ; ) {
      const [n, , s] = gt.exec(r) || [];
      if (!s)
        return "";
      if (s === e)
        return `src: ${n};`;
    }
  }) : t;
}
function v(t) {
  return t.search(U) !== -1;
}
async function H(t, e, r) {
  if (!v(t))
    return t;
  const n = bt(t, r);
  return wt(n).reduce((i, c) => i.then((a) => pt(a, c, e, r)), Promise.resolve(n));
}
async function g(t, e, r) {
  var n;
  const s = (n = e.style) === null || n === void 0 ? void 0 : n.getPropertyValue(t);
  if (s) {
    const i = await H(s, null, r);
    return e.style.setProperty(t, i, e.style.getPropertyPriority(t)), !0;
  }
  return !1;
}
async function St(t, e) {
  await g("background", t, e) || await g("background-image", t, e), await g("mask", t, e) || await g("mask-image", t, e);
}
async function Et(t, e) {
  const r = l(t, HTMLImageElement);
  if (!(r && !S(t.src)) && !(l(t, SVGImageElement) && !S(t.href.baseVal)))
    return;
  const n = r ? t.src : t.href.baseVal, s = await x(n, E(n), e);
  await new Promise((i, c) => {
    t.onload = i, t.onerror = e.onImageErrorHandler ? (...o) => {
      try {
        i(e.onImageErrorHandler(...o));
      } catch (f) {
        c(f);
      }
    } : c;
    const a = t;
    a.decode && (a.decode = i), a.loading === "lazy" && (a.loading = "eager"), r ? (t.srcset = "", t.src = s) : t.href.baseVal = s;
  });
}
async function xt(t, e) {
  const n = h(t.childNodes).map((s) => V(s, e));
  await Promise.all(n).then(() => t);
}
async function V(t, e) {
  l(t, Element) && (await St(t, e), await Et(t, e), await xt(t, e));
}
function Rt(t, e) {
  const { style: r } = t;
  e.backgroundColor && (r.backgroundColor = e.backgroundColor), e.width && (r.width = `${e.width}px`), e.height && (r.height = `${e.height}px`);
  const n = e.style;
  return n != null && Object.keys(n).forEach((s) => {
    r[s] = n[s];
  }), t;
}
const $ = {};
async function T(t) {
  let e = $[t];
  if (e != null)
    return e;
  const n = await (await fetch(t)).text();
  return e = { url: t, cssText: n }, $[t] = e, e;
}
async function F(t, e) {
  let r = t.cssText;
  const n = /url\(["']?([^"')]+)["']?\)/g, i = (r.match(/url\([^)]+\)/g) || []).map(async (c) => {
    let a = c.replace(n, "$1");
    return a.startsWith("https://") || (a = new URL(a, t.url).href), I(a, e.fetchRequestInit, ({ result: o }) => (r = r.replace(c, `url(${o})`), [c, o]));
  });
  return Promise.all(i).then(() => r);
}
function L(t) {
  if (t == null)
    return [];
  const e = [], r = /(\/\*[\s\S]*?\*\/)/gi;
  let n = t.replace(r, "");
  const s = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const o = s.exec(n);
    if (o === null)
      break;
    e.push(o[0]);
  }
  n = n.replace(s, "");
  const i = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, c = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", a = new RegExp(c, "gi");
  for (; ; ) {
    let o = i.exec(n);
    if (o === null) {
      if (o = a.exec(n), o === null)
        break;
      i.lastIndex = a.lastIndex;
    } else
      a.lastIndex = i.lastIndex;
    e.push(o[0]);
  }
  return e;
}
async function Ct(t, e) {
  const r = [], n = [];
  return t.forEach((s) => {
    if ("cssRules" in s)
      try {
        h(s.cssRules || []).forEach((i, c) => {
          if (i.type === CSSRule.IMPORT_RULE) {
            let a = c + 1;
            const o = i.href, f = T(o).then((m) => F(m, e)).then((m) => L(m).forEach((p) => {
              try {
                s.insertRule(p, p.startsWith("@import") ? a += 1 : s.cssRules.length);
              } catch (M) {
                console.error("Error inserting rule from remote css", {
                  rule: p,
                  error: M
                });
              }
            })).catch((m) => {
              console.error("Error loading remote css", m.toString());
            });
            n.push(f);
          }
        });
      } catch (i) {
        const c = t.find((a) => a.href == null) || document.styleSheets[0];
        s.href != null && n.push(T(s.href).then((a) => F(a, e)).then((a) => L(a).forEach((o) => {
          c.insertRule(o, s.cssRules.length);
        })).catch((a) => {
          console.error("Error loading remote stylesheet", a);
        })), console.error("Error inlining remote css file", i);
      }
  }), Promise.all(n).then(() => (t.forEach((s) => {
    if ("cssRules" in s)
      try {
        h(s.cssRules || []).forEach((i) => {
          r.push(i);
        });
      } catch (i) {
        console.error(`Error while reading CSS rules from ${s.href}`, i);
      }
  }), r));
}
function Pt(t) {
  return t.filter((e) => e.type === CSSRule.FONT_FACE_RULE).filter((e) => v(e.style.getPropertyValue("src")));
}
async function $t(t, e) {
  if (t.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const r = h(t.ownerDocument.styleSheets), n = await Ct(r, e);
  return Pt(n);
}
function k(t) {
  return t.trim().replace(/["']/g, "");
}
function Tt(t) {
  const e = /* @__PURE__ */ new Set();
  function r(n) {
    (n.style.fontFamily || getComputedStyle(n).fontFamily).split(",").forEach((i) => {
      e.add(k(i));
    }), Array.from(n.children).forEach((i) => {
      i instanceof HTMLElement && r(i);
    });
  }
  return r(t), e;
}
async function Ft(t, e) {
  const r = await $t(t, e), n = Tt(t);
  return (await Promise.all(r.filter((i) => n.has(k(i.style.fontFamily))).map((i) => {
    const c = i.parentStyleSheet ? i.parentStyleSheet.href : null;
    return H(i.cssText, c, e);
  }))).join(`
`);
}
async function Lt(t, e) {
  const r = e.fontEmbedCSS != null ? e.fontEmbedCSS : e.skipFonts ? null : await Ft(t, e);
  if (r) {
    const n = document.createElement("style"), s = document.createTextNode(r);
    n.appendChild(s), t.firstChild ? t.insertBefore(n, t.firstChild) : t.appendChild(n);
  }
}
async function At(t, e = {}) {
  const { width: r, height: n } = A(t, e), s = await w(t, e, !0);
  return await Lt(s, e), await V(s, e), Rt(s, e), await X(s, r, n);
}
async function It(t, e = {}) {
  const { width: r, height: n } = A(t, e), s = await At(t, e), i = await y(s), c = document.createElement("canvas"), a = c.getContext("2d"), o = e.pixelRatio || B(), f = e.canvasWidth || r, m = e.canvasHeight || n;
  return c.width = f * o, c.height = m * o, e.skipAutoScale || j(c), c.style.width = `${f}`, c.style.height = `${m}`, e.backgroundColor && (a.fillStyle = e.backgroundColor, a.fillRect(0, 0, c.width, c.height)), a.drawImage(i, 0, 0, c.width, c.height), c;
}
async function Dt(t, e = {}) {
  const r = await It(t, e);
  return await z(r);
}
export {
  Dt as toBlob,
  It as toCanvas,
  At as toSvg
};
