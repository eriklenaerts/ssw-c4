import Yn, { useState as fe, createContext as Zn, useCallback as ue, useMemo as me, useContext as wt, useLayoutEffect as ca, useEffect as j, forwardRef as xr, memo as ie, useRef as J } from "react";
import { jsx as z, jsxs as se, Fragment as Se } from "react/jsx-runtime";
import { createPortal as vr } from "react-dom";
function la(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Wn = { exports: {} }, _r = {}, qn = { exports: {} }, br = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Xe = Yn;
function ua(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var da = typeof Object.is == "function" ? Object.is : ua, fa = Xe.useState, ha = Xe.useEffect, ga = Xe.useLayoutEffect, pa = Xe.useDebugValue;
function ma(e, t) {
  var n = t(), o = fa({ inst: { value: n, getSnapshot: t } }), r = o[0].inst, i = o[1];
  return ga(
    function() {
      r.value = n, r.getSnapshot = t, yn(r) && i({ inst: r });
    },
    [e, n, t]
  ), ha(
    function() {
      return yn(r) && i({ inst: r }), e(function() {
        yn(r) && i({ inst: r });
      });
    },
    [e]
  ), pa(n), n;
}
function yn(e) {
  var t = e.getSnapshot;
  e = e.value;
  try {
    var n = t();
    return !da(e, n);
  } catch {
    return !0;
  }
}
function ya(e, t) {
  return t();
}
var wa = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? ya : ma;
br.useSyncExternalStore = Xe.useSyncExternalStore !== void 0 ? Xe.useSyncExternalStore : wa;
qn.exports;
qn.exports = br;
var xa = qn.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Gt = Yn, va = xa;
function _a(e, t) {
  return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t;
}
var ba = typeof Object.is == "function" ? Object.is : _a, Ea = va.useSyncExternalStore, Sa = Gt.useRef, Na = Gt.useEffect, Ca = Gt.useMemo, Ma = Gt.useDebugValue;
_r.useSyncExternalStoreWithSelector = function(e, t, n, o, r) {
  var i = Sa(null);
  if (i.current === null) {
    var s = { hasValue: !1, value: null };
    i.current = s;
  } else s = i.current;
  i = Ca(
    function() {
      function c(h) {
        if (!l) {
          if (l = !0, d = h, h = o(h), r !== void 0 && s.hasValue) {
            var p = s.value;
            if (r(p, h))
              return u = p;
          }
          return u = h;
        }
        if (p = u, ba(d, h)) return p;
        var y = o(h);
        return r !== void 0 && r(p, y) ? (d = h, p) : (d = h, u = y);
      }
      var l = !1, d, u, f = n === void 0 ? null : n;
      return [
        function() {
          return c(t());
        },
        f === null ? void 0 : function() {
          return c(f());
        }
      ];
    },
    [t, n, o, r]
  );
  var a = Ea(e, i[0], i[1]);
  return Na(
    function() {
      s.hasValue = !0, s.value = a;
    },
    [a]
  ), Ma(a), a;
};
Wn.exports;
Wn.exports = _r;
var ka = Wn.exports;
const $a = /* @__PURE__ */ la(ka);
function re(e) {
  if (typeof e == "string" || typeof e == "number") return "" + e;
  let t = "";
  if (Array.isArray(e))
    for (let n = 0, o; n < e.length; n++)
      (o = re(e[n])) !== "" && (t += (t && " ") + o);
  else
    for (let n in e)
      e[n] && (t += (t && " ") + n);
  return t;
}
var Ia = { value: () => {
} };
function Kt() {
  for (var e = 0, t = arguments.length, n = {}, o; e < t; ++e) {
    if (!(o = arguments[e] + "") || o in n || /[\s.]/.test(o)) throw new Error("illegal type: " + o);
    n[o] = [];
  }
  return new zt(n);
}
function zt(e) {
  this._ = e;
}
function Aa(e, t) {
  return e.trim().split(/^|\s+/).map(function(n) {
    var o = "", r = n.indexOf(".");
    if (r >= 0 && (o = n.slice(r + 1), n = n.slice(0, r)), n && !t.hasOwnProperty(n)) throw new Error("unknown type: " + n);
    return { type: n, name: o };
  });
}
zt.prototype = Kt.prototype = {
  constructor: zt,
  on: function(e, t) {
    var n = this._, o = Aa(e + "", n), r, i = -1, s = o.length;
    if (arguments.length < 2) {
      for (; ++i < s; ) if ((r = (e = o[i]).type) && (r = Pa(n[r], e.name))) return r;
      return;
    }
    if (t != null && typeof t != "function") throw new Error("invalid callback: " + t);
    for (; ++i < s; )
      if (r = (e = o[i]).type) n[r] = yo(n[r], e.name, t);
      else if (t == null) for (r in n) n[r] = yo(n[r], e.name, null);
    return this;
  },
  copy: function() {
    var e = {}, t = this._;
    for (var n in t) e[n] = t[n].slice();
    return new zt(e);
  },
  call: function(e, t) {
    if ((r = arguments.length - 2) > 0) for (var n = new Array(r), o = 0, r, i; o < r; ++o) n[o] = arguments[o + 2];
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (i = this._[e], o = 0, r = i.length; o < r; ++o) i[o].value.apply(t, n);
  },
  apply: function(e, t, n) {
    if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
    for (var o = this._[e], r = 0, i = o.length; r < i; ++r) o[r].value.apply(t, n);
  }
};
function Pa(e, t) {
  for (var n = 0, o = e.length, r; n < o; ++n)
    if ((r = e[n]).name === t)
      return r.value;
}
function yo(e, t, n) {
  for (var o = 0, r = e.length; o < r; ++o)
    if (e[o].name === t) {
      e[o] = Ia, e = e.slice(0, o).concat(e.slice(o + 1));
      break;
    }
  return n != null && e.push({ name: t, value: n }), e;
}
var Mn = "http://www.w3.org/1999/xhtml";
const wo = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: Mn,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function Ut(e) {
  var t = e += "", n = t.indexOf(":");
  return n >= 0 && (t = e.slice(0, n)) !== "xmlns" && (e = e.slice(n + 1)), wo.hasOwnProperty(t) ? { space: wo[t], local: e } : e;
}
function za(e) {
  return function() {
    var t = this.ownerDocument, n = this.namespaceURI;
    return n === Mn && t.documentElement.namespaceURI === Mn ? t.createElement(e) : t.createElementNS(n, e);
  };
}
function Ta(e) {
  return function() {
    return this.ownerDocument.createElementNS(e.space, e.local);
  };
}
function Er(e) {
  var t = Ut(e);
  return (t.local ? Ta : za)(t);
}
function Da() {
}
function Gn(e) {
  return e == null ? Da : function() {
    return this.querySelector(e);
  };
}
function Ha(e) {
  typeof e != "function" && (e = Gn(e));
  for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r)
    for (var i = t[r], s = i.length, a = o[r] = new Array(s), c, l, d = 0; d < s; ++d)
      (c = i[d]) && (l = e.call(c, c.__data__, d, i)) && ("__data__" in c && (l.__data__ = c.__data__), a[d] = l);
  return new de(o, this._parents);
}
function Va(e) {
  return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
}
function Oa() {
  return [];
}
function Sr(e) {
  return e == null ? Oa : function() {
    return this.querySelectorAll(e);
  };
}
function Ra(e) {
  return function() {
    return Va(e.apply(this, arguments));
  };
}
function La(e) {
  typeof e == "function" ? e = Ra(e) : e = Sr(e);
  for (var t = this._groups, n = t.length, o = [], r = [], i = 0; i < n; ++i)
    for (var s = t[i], a = s.length, c, l = 0; l < a; ++l)
      (c = s[l]) && (o.push(e.call(c, c.__data__, l, s)), r.push(c));
  return new de(o, r);
}
function Nr(e) {
  return function() {
    return this.matches(e);
  };
}
function Cr(e) {
  return function(t) {
    return t.matches(e);
  };
}
var Ba = Array.prototype.find;
function Fa(e) {
  return function() {
    return Ba.call(this.children, e);
  };
}
function Xa() {
  return this.firstElementChild;
}
function Ya(e) {
  return this.select(e == null ? Xa : Fa(typeof e == "function" ? e : Cr(e)));
}
var Za = Array.prototype.filter;
function Wa() {
  return Array.from(this.children);
}
function qa(e) {
  return function() {
    return Za.call(this.children, e);
  };
}
function Ga(e) {
  return this.selectAll(e == null ? Wa : qa(typeof e == "function" ? e : Cr(e)));
}
function Ka(e) {
  typeof e != "function" && (e = Nr(e));
  for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r)
    for (var i = t[r], s = i.length, a = o[r] = [], c, l = 0; l < s; ++l)
      (c = i[l]) && e.call(c, c.__data__, l, i) && a.push(c);
  return new de(o, this._parents);
}
function Mr(e) {
  return new Array(e.length);
}
function Ua() {
  return new de(this._enter || this._groups.map(Mr), this._parents);
}
function Vt(e, t) {
  this.ownerDocument = e.ownerDocument, this.namespaceURI = e.namespaceURI, this._next = null, this._parent = e, this.__data__ = t;
}
Vt.prototype = {
  constructor: Vt,
  appendChild: function(e) {
    return this._parent.insertBefore(e, this._next);
  },
  insertBefore: function(e, t) {
    return this._parent.insertBefore(e, t);
  },
  querySelector: function(e) {
    return this._parent.querySelector(e);
  },
  querySelectorAll: function(e) {
    return this._parent.querySelectorAll(e);
  }
};
function Qa(e) {
  return function() {
    return e;
  };
}
function Ja(e, t, n, o, r, i) {
  for (var s = 0, a, c = t.length, l = i.length; s < l; ++s)
    (a = t[s]) ? (a.__data__ = i[s], o[s] = a) : n[s] = new Vt(e, i[s]);
  for (; s < c; ++s)
    (a = t[s]) && (r[s] = a);
}
function ja(e, t, n, o, r, i, s) {
  var a, c, l = /* @__PURE__ */ new Map(), d = t.length, u = i.length, f = new Array(d), h;
  for (a = 0; a < d; ++a)
    (c = t[a]) && (f[a] = h = s.call(c, c.__data__, a, t) + "", l.has(h) ? r[a] = c : l.set(h, c));
  for (a = 0; a < u; ++a)
    h = s.call(e, i[a], a, i) + "", (c = l.get(h)) ? (o[a] = c, c.__data__ = i[a], l.delete(h)) : n[a] = new Vt(e, i[a]);
  for (a = 0; a < d; ++a)
    (c = t[a]) && l.get(f[a]) === c && (r[a] = c);
}
function ec(e) {
  return e.__data__;
}
function tc(e, t) {
  if (!arguments.length) return Array.from(this, ec);
  var n = t ? ja : Ja, o = this._parents, r = this._groups;
  typeof e != "function" && (e = Qa(e));
  for (var i = r.length, s = new Array(i), a = new Array(i), c = new Array(i), l = 0; l < i; ++l) {
    var d = o[l], u = r[l], f = u.length, h = nc(e.call(d, d && d.__data__, l, o)), p = h.length, y = a[l] = new Array(p), _ = s[l] = new Array(p), x = c[l] = new Array(f);
    n(d, u, y, _, x, h, t);
    for (var b = 0, m = 0, w, N; b < p; ++b)
      if (w = y[b]) {
        for (b >= m && (m = b + 1); !(N = _[m]) && ++m < p; ) ;
        w._next = N || null;
      }
  }
  return s = new de(s, o), s._enter = a, s._exit = c, s;
}
function nc(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function oc() {
  return new de(this._exit || this._groups.map(Mr), this._parents);
}
function rc(e, t, n) {
  var o = this.enter(), r = this, i = this.exit();
  return typeof e == "function" ? (o = e(o), o && (o = o.selection())) : o = o.append(e + ""), t != null && (r = t(r), r && (r = r.selection())), n == null ? i.remove() : n(i), o && r ? o.merge(r).order() : r;
}
function ic(e) {
  for (var t = e.selection ? e.selection() : e, n = this._groups, o = t._groups, r = n.length, i = o.length, s = Math.min(r, i), a = new Array(r), c = 0; c < s; ++c)
    for (var l = n[c], d = o[c], u = l.length, f = a[c] = new Array(u), h, p = 0; p < u; ++p)
      (h = l[p] || d[p]) && (f[p] = h);
  for (; c < r; ++c)
    a[c] = n[c];
  return new de(a, this._parents);
}
function sc() {
  for (var e = this._groups, t = -1, n = e.length; ++t < n; )
    for (var o = e[t], r = o.length - 1, i = o[r], s; --r >= 0; )
      (s = o[r]) && (i && s.compareDocumentPosition(i) ^ 4 && i.parentNode.insertBefore(s, i), i = s);
  return this;
}
function ac(e) {
  e || (e = cc);
  function t(u, f) {
    return u && f ? e(u.__data__, f.__data__) : !u - !f;
  }
  for (var n = this._groups, o = n.length, r = new Array(o), i = 0; i < o; ++i) {
    for (var s = n[i], a = s.length, c = r[i] = new Array(a), l, d = 0; d < a; ++d)
      (l = s[d]) && (c[d] = l);
    c.sort(t);
  }
  return new de(r, this._parents).order();
}
function cc(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function lc() {
  var e = arguments[0];
  return arguments[0] = this, e.apply(null, arguments), this;
}
function uc() {
  return Array.from(this);
}
function dc() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], r = 0, i = o.length; r < i; ++r) {
      var s = o[r];
      if (s) return s;
    }
  return null;
}
function fc() {
  let e = 0;
  for (const t of this) ++e;
  return e;
}
function hc() {
  return !this.node();
}
function gc(e) {
  for (var t = this._groups, n = 0, o = t.length; n < o; ++n)
    for (var r = t[n], i = 0, s = r.length, a; i < s; ++i)
      (a = r[i]) && e.call(a, a.__data__, i, r);
  return this;
}
function pc(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function mc(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function yc(e, t) {
  return function() {
    this.setAttribute(e, t);
  };
}
function wc(e, t) {
  return function() {
    this.setAttributeNS(e.space, e.local, t);
  };
}
function xc(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttribute(e) : this.setAttribute(e, n);
  };
}
function vc(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? this.removeAttributeNS(e.space, e.local) : this.setAttributeNS(e.space, e.local, n);
  };
}
function _c(e, t) {
  var n = Ut(e);
  if (arguments.length < 2) {
    var o = this.node();
    return n.local ? o.getAttributeNS(n.space, n.local) : o.getAttribute(n);
  }
  return this.each((t == null ? n.local ? mc : pc : typeof t == "function" ? n.local ? vc : xc : n.local ? wc : yc)(n, t));
}
function kr(e) {
  return e.ownerDocument && e.ownerDocument.defaultView || e.document && e || e.defaultView;
}
function bc(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Ec(e, t, n) {
  return function() {
    this.style.setProperty(e, t, n);
  };
}
function Sc(e, t, n) {
  return function() {
    var o = t.apply(this, arguments);
    o == null ? this.style.removeProperty(e) : this.style.setProperty(e, o, n);
  };
}
function Nc(e, t, n) {
  return arguments.length > 1 ? this.each((t == null ? bc : typeof t == "function" ? Sc : Ec)(e, t, n ?? "")) : Ye(this.node(), e);
}
function Ye(e, t) {
  return e.style.getPropertyValue(t) || kr(e).getComputedStyle(e, null).getPropertyValue(t);
}
function Cc(e) {
  return function() {
    delete this[e];
  };
}
function Mc(e, t) {
  return function() {
    this[e] = t;
  };
}
function kc(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    n == null ? delete this[e] : this[e] = n;
  };
}
function $c(e, t) {
  return arguments.length > 1 ? this.each((t == null ? Cc : typeof t == "function" ? kc : Mc)(e, t)) : this.node()[e];
}
function $r(e) {
  return e.trim().split(/^|\s+/);
}
function Kn(e) {
  return e.classList || new Ir(e);
}
function Ir(e) {
  this._node = e, this._names = $r(e.getAttribute("class") || "");
}
Ir.prototype = {
  add: function(e) {
    var t = this._names.indexOf(e);
    t < 0 && (this._names.push(e), this._node.setAttribute("class", this._names.join(" ")));
  },
  remove: function(e) {
    var t = this._names.indexOf(e);
    t >= 0 && (this._names.splice(t, 1), this._node.setAttribute("class", this._names.join(" ")));
  },
  contains: function(e) {
    return this._names.indexOf(e) >= 0;
  }
};
function Ar(e, t) {
  for (var n = Kn(e), o = -1, r = t.length; ++o < r; ) n.add(t[o]);
}
function Pr(e, t) {
  for (var n = Kn(e), o = -1, r = t.length; ++o < r; ) n.remove(t[o]);
}
function Ic(e) {
  return function() {
    Ar(this, e);
  };
}
function Ac(e) {
  return function() {
    Pr(this, e);
  };
}
function Pc(e, t) {
  return function() {
    (t.apply(this, arguments) ? Ar : Pr)(this, e);
  };
}
function zc(e, t) {
  var n = $r(e + "");
  if (arguments.length < 2) {
    for (var o = Kn(this.node()), r = -1, i = n.length; ++r < i; ) if (!o.contains(n[r])) return !1;
    return !0;
  }
  return this.each((typeof t == "function" ? Pc : t ? Ic : Ac)(n, t));
}
function Tc() {
  this.textContent = "";
}
function Dc(e) {
  return function() {
    this.textContent = e;
  };
}
function Hc(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.textContent = t ?? "";
  };
}
function Vc(e) {
  return arguments.length ? this.each(e == null ? Tc : (typeof e == "function" ? Hc : Dc)(e)) : this.node().textContent;
}
function Oc() {
  this.innerHTML = "";
}
function Rc(e) {
  return function() {
    this.innerHTML = e;
  };
}
function Lc(e) {
  return function() {
    var t = e.apply(this, arguments);
    this.innerHTML = t ?? "";
  };
}
function Bc(e) {
  return arguments.length ? this.each(e == null ? Oc : (typeof e == "function" ? Lc : Rc)(e)) : this.node().innerHTML;
}
function Fc() {
  this.nextSibling && this.parentNode.appendChild(this);
}
function Xc() {
  return this.each(Fc);
}
function Yc() {
  this.previousSibling && this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function Zc() {
  return this.each(Yc);
}
function Wc(e) {
  var t = typeof e == "function" ? e : Er(e);
  return this.select(function() {
    return this.appendChild(t.apply(this, arguments));
  });
}
function qc() {
  return null;
}
function Gc(e, t) {
  var n = typeof e == "function" ? e : Er(e), o = t == null ? qc : typeof t == "function" ? t : Gn(t);
  return this.select(function() {
    return this.insertBefore(n.apply(this, arguments), o.apply(this, arguments) || null);
  });
}
function Kc() {
  var e = this.parentNode;
  e && e.removeChild(this);
}
function Uc() {
  return this.each(Kc);
}
function Qc() {
  var e = this.cloneNode(!1), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function Jc() {
  var e = this.cloneNode(!0), t = this.parentNode;
  return t ? t.insertBefore(e, this.nextSibling) : e;
}
function jc(e) {
  return this.select(e ? Jc : Qc);
}
function el(e) {
  return arguments.length ? this.property("__data__", e) : this.node().__data__;
}
function tl(e) {
  return function(t) {
    e.call(this, t, this.__data__);
  };
}
function nl(e) {
  return e.trim().split(/^|\s+/).map(function(t) {
    var n = "", o = t.indexOf(".");
    return o >= 0 && (n = t.slice(o + 1), t = t.slice(0, o)), { type: t, name: n };
  });
}
function ol(e) {
  return function() {
    var t = this.__on;
    if (t) {
      for (var n = 0, o = -1, r = t.length, i; n < r; ++n)
        i = t[n], (!e.type || i.type === e.type) && i.name === e.name ? this.removeEventListener(i.type, i.listener, i.options) : t[++o] = i;
      ++o ? t.length = o : delete this.__on;
    }
  };
}
function rl(e, t, n) {
  return function() {
    var o = this.__on, r, i = tl(t);
    if (o) {
      for (var s = 0, a = o.length; s < a; ++s)
        if ((r = o[s]).type === e.type && r.name === e.name) {
          this.removeEventListener(r.type, r.listener, r.options), this.addEventListener(r.type, r.listener = i, r.options = n), r.value = t;
          return;
        }
    }
    this.addEventListener(e.type, i, n), r = { type: e.type, name: e.name, value: t, listener: i, options: n }, o ? o.push(r) : this.__on = [r];
  };
}
function il(e, t, n) {
  var o = nl(e + ""), r, i = o.length, s;
  if (arguments.length < 2) {
    var a = this.node().__on;
    if (a) {
      for (var c = 0, l = a.length, d; c < l; ++c)
        for (r = 0, d = a[c]; r < i; ++r)
          if ((s = o[r]).type === d.type && s.name === d.name)
            return d.value;
    }
    return;
  }
  for (a = t ? rl : ol, r = 0; r < i; ++r) this.each(a(o[r], t, n));
  return this;
}
function zr(e, t, n) {
  var o = kr(e), r = o.CustomEvent;
  typeof r == "function" ? r = new r(t, n) : (r = o.document.createEvent("Event"), n ? (r.initEvent(t, n.bubbles, n.cancelable), r.detail = n.detail) : r.initEvent(t, !1, !1)), e.dispatchEvent(r);
}
function sl(e, t) {
  return function() {
    return zr(this, e, t);
  };
}
function al(e, t) {
  return function() {
    return zr(this, e, t.apply(this, arguments));
  };
}
function cl(e, t) {
  return this.each((typeof t == "function" ? al : sl)(e, t));
}
function* ll() {
  for (var e = this._groups, t = 0, n = e.length; t < n; ++t)
    for (var o = e[t], r = 0, i = o.length, s; r < i; ++r)
      (s = o[r]) && (yield s);
}
var Tr = [null];
function de(e, t) {
  this._groups = e, this._parents = t;
}
function xt() {
  return new de([[document.documentElement]], Tr);
}
function ul() {
  return this;
}
de.prototype = xt.prototype = {
  constructor: de,
  select: Ha,
  selectAll: La,
  selectChild: Ya,
  selectChildren: Ga,
  filter: Ka,
  data: tc,
  enter: Ua,
  exit: oc,
  join: rc,
  merge: ic,
  selection: ul,
  order: sc,
  sort: ac,
  call: lc,
  nodes: uc,
  node: dc,
  size: fc,
  empty: hc,
  each: gc,
  attr: _c,
  style: Nc,
  property: $c,
  classed: zc,
  text: Vc,
  html: Bc,
  raise: Xc,
  lower: Zc,
  append: Wc,
  insert: Gc,
  remove: Uc,
  clone: jc,
  datum: el,
  on: il,
  dispatch: cl,
  [Symbol.iterator]: ll
};
function le(e) {
  return typeof e == "string" ? new de([[document.querySelector(e)]], [document.documentElement]) : new de([[e]], Tr);
}
function dl(e) {
  let t;
  for (; t = e.sourceEvent; ) e = t;
  return e;
}
function he(e, t) {
  if (e = dl(e), t === void 0 && (t = e.currentTarget), t) {
    var n = t.ownerSVGElement || t;
    if (n.createSVGPoint) {
      var o = n.createSVGPoint();
      return o.x = e.clientX, o.y = e.clientY, o = o.matrixTransform(t.getScreenCTM().inverse()), [o.x, o.y];
    }
    if (t.getBoundingClientRect) {
      var r = t.getBoundingClientRect();
      return [e.clientX - r.left - t.clientLeft, e.clientY - r.top - t.clientTop];
    }
  }
  return [e.pageX, e.pageY];
}
const fl = { passive: !1 }, ct = { capture: !0, passive: !1 };
function wn(e) {
  e.stopImmediatePropagation();
}
function Be(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function Dr(e) {
  var t = e.document.documentElement, n = le(e).on("dragstart.drag", Be, ct);
  "onselectstart" in t ? n.on("selectstart.drag", Be, ct) : (t.__noselect = t.style.MozUserSelect, t.style.MozUserSelect = "none");
}
function Hr(e, t) {
  var n = e.document.documentElement, o = le(e).on("dragstart.drag", null);
  t && (o.on("click.drag", Be, ct), setTimeout(function() {
    o.on("click.drag", null);
  }, 0)), "onselectstart" in n ? o.on("selectstart.drag", null) : (n.style.MozUserSelect = n.__noselect, delete n.__noselect);
}
const St = (e) => () => e;
function kn(e, {
  sourceEvent: t,
  subject: n,
  target: o,
  identifier: r,
  active: i,
  x: s,
  y: a,
  dx: c,
  dy: l,
  dispatch: d
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    subject: { value: n, enumerable: !0, configurable: !0 },
    target: { value: o, enumerable: !0, configurable: !0 },
    identifier: { value: r, enumerable: !0, configurable: !0 },
    active: { value: i, enumerable: !0, configurable: !0 },
    x: { value: s, enumerable: !0, configurable: !0 },
    y: { value: a, enumerable: !0, configurable: !0 },
    dx: { value: c, enumerable: !0, configurable: !0 },
    dy: { value: l, enumerable: !0, configurable: !0 },
    _: { value: d }
  });
}
kn.prototype.on = function() {
  var e = this._.on.apply(this._, arguments);
  return e === this._ ? this : e;
};
function hl(e) {
  return !e.ctrlKey && !e.button;
}
function gl() {
  return this.parentNode;
}
function pl(e, t) {
  return t ?? { x: e.x, y: e.y };
}
function ml() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function Vr() {
  var e = hl, t = gl, n = pl, o = ml, r = {}, i = Kt("start", "drag", "end"), s = 0, a, c, l, d, u = 0;
  function f(w) {
    w.on("mousedown.drag", h).filter(o).on("touchstart.drag", _).on("touchmove.drag", x, fl).on("touchend.drag touchcancel.drag", b).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function h(w, N) {
    if (!(d || !e.call(this, w, N))) {
      var k = m(this, t.call(this, w, N), w, N, "mouse");
      k && (le(w.view).on("mousemove.drag", p, ct).on("mouseup.drag", y, ct), Dr(w.view), wn(w), l = !1, a = w.clientX, c = w.clientY, k("start", w));
    }
  }
  function p(w) {
    if (Be(w), !l) {
      var N = w.clientX - a, k = w.clientY - c;
      l = N * N + k * k > u;
    }
    r.mouse("drag", w);
  }
  function y(w) {
    le(w.view).on("mousemove.drag mouseup.drag", null), Hr(w.view, l), Be(w), r.mouse("end", w);
  }
  function _(w, N) {
    if (e.call(this, w, N)) {
      var k = w.changedTouches, S = t.call(this, w, N), P = k.length, I, A;
      for (I = 0; I < P; ++I)
        (A = m(this, S, w, N, k[I].identifier, k[I])) && (wn(w), A("start", w, k[I]));
    }
  }
  function x(w) {
    var N = w.changedTouches, k = N.length, S, P;
    for (S = 0; S < k; ++S)
      (P = r[N[S].identifier]) && (Be(w), P("drag", w, N[S]));
  }
  function b(w) {
    var N = w.changedTouches, k = N.length, S, P;
    for (d && clearTimeout(d), d = setTimeout(function() {
      d = null;
    }, 500), S = 0; S < k; ++S)
      (P = r[N[S].identifier]) && (wn(w), P("end", w, N[S]));
  }
  function m(w, N, k, S, P, I) {
    var A = i.copy(), V = he(I || k, N), D, H, g;
    if ((g = n.call(w, new kn("beforestart", {
      sourceEvent: k,
      target: f,
      identifier: P,
      active: s,
      x: V[0],
      y: V[1],
      dx: 0,
      dy: 0,
      dispatch: A
    }), S)) != null)
      return D = g.x - V[0] || 0, H = g.y - V[1] || 0, function E(v, M, $) {
        var C = V, T;
        switch (v) {
          case "start":
            r[P] = E, T = s++;
            break;
          case "end":
            delete r[P], --s;
          case "drag":
            V = he($ || M, N), T = s;
            break;
        }
        A.call(
          v,
          w,
          new kn(v, {
            sourceEvent: M,
            subject: g,
            target: f,
            identifier: P,
            active: T,
            x: V[0] + D,
            y: V[1] + H,
            dx: V[0] - C[0],
            dy: V[1] - C[1],
            dispatch: A
          }),
          S
        );
      };
  }
  return f.filter = function(w) {
    return arguments.length ? (e = typeof w == "function" ? w : St(!!w), f) : e;
  }, f.container = function(w) {
    return arguments.length ? (t = typeof w == "function" ? w : St(w), f) : t;
  }, f.subject = function(w) {
    return arguments.length ? (n = typeof w == "function" ? w : St(w), f) : n;
  }, f.touchable = function(w) {
    return arguments.length ? (o = typeof w == "function" ? w : St(!!w), f) : o;
  }, f.on = function() {
    var w = i.on.apply(i, arguments);
    return w === i ? f : w;
  }, f.clickDistance = function(w) {
    return arguments.length ? (u = (w = +w) * w, f) : Math.sqrt(u);
  }, f;
}
function Un(e, t, n) {
  e.prototype = t.prototype = n, n.constructor = e;
}
function Or(e, t) {
  var n = Object.create(e.prototype);
  for (var o in t) n[o] = t[o];
  return n;
}
function vt() {
}
var lt = 0.7, Ot = 1 / lt, Fe = "\\s*([+-]?\\d+)\\s*", ut = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", we = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", yl = /^#([0-9a-f]{3,8})$/, wl = new RegExp(`^rgb\\(${Fe},${Fe},${Fe}\\)$`), xl = new RegExp(`^rgb\\(${we},${we},${we}\\)$`), vl = new RegExp(`^rgba\\(${Fe},${Fe},${Fe},${ut}\\)$`), _l = new RegExp(`^rgba\\(${we},${we},${we},${ut}\\)$`), bl = new RegExp(`^hsl\\(${ut},${we},${we}\\)$`), El = new RegExp(`^hsla\\(${ut},${we},${we},${ut}\\)$`), xo = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
Un(vt, dt, {
  copy(e) {
    return Object.assign(new this.constructor(), this, e);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: vo,
  // Deprecated! Use color.formatHex.
  formatHex: vo,
  formatHex8: Sl,
  formatHsl: Nl,
  formatRgb: _o,
  toString: _o
});
function vo() {
  return this.rgb().formatHex();
}
function Sl() {
  return this.rgb().formatHex8();
}
function Nl() {
  return Rr(this).formatHsl();
}
function _o() {
  return this.rgb().formatRgb();
}
function dt(e) {
  var t, n;
  return e = (e + "").trim().toLowerCase(), (t = yl.exec(e)) ? (n = t[1].length, t = parseInt(t[1], 16), n === 6 ? bo(t) : n === 3 ? new ce(t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, (t & 15) << 4 | t & 15, 1) : n === 8 ? Nt(t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, (t & 255) / 255) : n === 4 ? Nt(t >> 12 & 15 | t >> 8 & 240, t >> 8 & 15 | t >> 4 & 240, t >> 4 & 15 | t & 240, ((t & 15) << 4 | t & 15) / 255) : null) : (t = wl.exec(e)) ? new ce(t[1], t[2], t[3], 1) : (t = xl.exec(e)) ? new ce(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, 1) : (t = vl.exec(e)) ? Nt(t[1], t[2], t[3], t[4]) : (t = _l.exec(e)) ? Nt(t[1] * 255 / 100, t[2] * 255 / 100, t[3] * 255 / 100, t[4]) : (t = bl.exec(e)) ? No(t[1], t[2] / 100, t[3] / 100, 1) : (t = El.exec(e)) ? No(t[1], t[2] / 100, t[3] / 100, t[4]) : xo.hasOwnProperty(e) ? bo(xo[e]) : e === "transparent" ? new ce(NaN, NaN, NaN, 0) : null;
}
function bo(e) {
  return new ce(e >> 16 & 255, e >> 8 & 255, e & 255, 1);
}
function Nt(e, t, n, o) {
  return o <= 0 && (e = t = n = NaN), new ce(e, t, n, o);
}
function Cl(e) {
  return e instanceof vt || (e = dt(e)), e ? (e = e.rgb(), new ce(e.r, e.g, e.b, e.opacity)) : new ce();
}
function $n(e, t, n, o) {
  return arguments.length === 1 ? Cl(e) : new ce(e, t, n, o ?? 1);
}
function ce(e, t, n, o) {
  this.r = +e, this.g = +t, this.b = +n, this.opacity = +o;
}
Un(ce, $n, Or(vt, {
  brighter(e) {
    return e = e == null ? Ot : Math.pow(Ot, e), new ce(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? lt : Math.pow(lt, e), new ce(this.r * e, this.g * e, this.b * e, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new ce(De(this.r), De(this.g), De(this.b), Rt(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
  },
  hex: Eo,
  // Deprecated! Use color.formatHex.
  formatHex: Eo,
  formatHex8: Ml,
  formatRgb: So,
  toString: So
}));
function Eo() {
  return `#${Te(this.r)}${Te(this.g)}${Te(this.b)}`;
}
function Ml() {
  return `#${Te(this.r)}${Te(this.g)}${Te(this.b)}${Te((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function So() {
  const e = Rt(this.opacity);
  return `${e === 1 ? "rgb(" : "rgba("}${De(this.r)}, ${De(this.g)}, ${De(this.b)}${e === 1 ? ")" : `, ${e})`}`;
}
function Rt(e) {
  return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
}
function De(e) {
  return Math.max(0, Math.min(255, Math.round(e) || 0));
}
function Te(e) {
  return e = De(e), (e < 16 ? "0" : "") + e.toString(16);
}
function No(e, t, n, o) {
  return o <= 0 ? e = t = n = NaN : n <= 0 || n >= 1 ? e = t = NaN : t <= 0 && (e = NaN), new ge(e, t, n, o);
}
function Rr(e) {
  if (e instanceof ge) return new ge(e.h, e.s, e.l, e.opacity);
  if (e instanceof vt || (e = dt(e)), !e) return new ge();
  if (e instanceof ge) return e;
  e = e.rgb();
  var t = e.r / 255, n = e.g / 255, o = e.b / 255, r = Math.min(t, n, o), i = Math.max(t, n, o), s = NaN, a = i - r, c = (i + r) / 2;
  return a ? (t === i ? s = (n - o) / a + (n < o) * 6 : n === i ? s = (o - t) / a + 2 : s = (t - n) / a + 4, a /= c < 0.5 ? i + r : 2 - i - r, s *= 60) : a = c > 0 && c < 1 ? 0 : s, new ge(s, a, c, e.opacity);
}
function kl(e, t, n, o) {
  return arguments.length === 1 ? Rr(e) : new ge(e, t, n, o ?? 1);
}
function ge(e, t, n, o) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +o;
}
Un(ge, kl, Or(vt, {
  brighter(e) {
    return e = e == null ? Ot : Math.pow(Ot, e), new ge(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? lt : Math.pow(lt, e), new ge(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = this.h % 360 + (this.h < 0) * 360, t = isNaN(e) || isNaN(this.s) ? 0 : this.s, n = this.l, o = n + (n < 0.5 ? n : 1 - n) * t, r = 2 * n - o;
    return new ce(
      xn(e >= 240 ? e - 240 : e + 120, r, o),
      xn(e, r, o),
      xn(e < 120 ? e + 240 : e - 120, r, o),
      this.opacity
    );
  },
  clamp() {
    return new ge(Co(this.h), Ct(this.s), Ct(this.l), Rt(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  },
  formatHsl() {
    const e = Rt(this.opacity);
    return `${e === 1 ? "hsl(" : "hsla("}${Co(this.h)}, ${Ct(this.s) * 100}%, ${Ct(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
  }
}));
function Co(e) {
  return e = (e || 0) % 360, e < 0 ? e + 360 : e;
}
function Ct(e) {
  return Math.max(0, Math.min(1, e || 0));
}
function xn(e, t, n) {
  return (e < 60 ? t + (n - t) * e / 60 : e < 180 ? n : e < 240 ? t + (n - t) * (240 - e) / 60 : t) * 255;
}
const Lr = (e) => () => e;
function $l(e, t) {
  return function(n) {
    return e + n * t;
  };
}
function Il(e, t, n) {
  return e = Math.pow(e, n), t = Math.pow(t, n) - e, n = 1 / n, function(o) {
    return Math.pow(e + o * t, n);
  };
}
function Al(e) {
  return (e = +e) == 1 ? Br : function(t, n) {
    return n - t ? Il(t, n, e) : Lr(isNaN(t) ? n : t);
  };
}
function Br(e, t) {
  var n = t - e;
  return n ? $l(e, n) : Lr(isNaN(e) ? t : e);
}
const Mo = function e(t) {
  var n = Al(t);
  function o(r, i) {
    var s = n((r = $n(r)).r, (i = $n(i)).r), a = n(r.g, i.g), c = n(r.b, i.b), l = Br(r.opacity, i.opacity);
    return function(d) {
      return r.r = s(d), r.g = a(d), r.b = c(d), r.opacity = l(d), r + "";
    };
  }
  return o.gamma = e, o;
}(1);
function $e(e, t) {
  return e = +e, t = +t, function(n) {
    return e * (1 - n) + t * n;
  };
}
var In = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, vn = new RegExp(In.source, "g");
function Pl(e) {
  return function() {
    return e;
  };
}
function zl(e) {
  return function(t) {
    return e(t) + "";
  };
}
function Tl(e, t) {
  var n = In.lastIndex = vn.lastIndex = 0, o, r, i, s = -1, a = [], c = [];
  for (e = e + "", t = t + ""; (o = In.exec(e)) && (r = vn.exec(t)); )
    (i = r.index) > n && (i = t.slice(n, i), a[s] ? a[s] += i : a[++s] = i), (o = o[0]) === (r = r[0]) ? a[s] ? a[s] += r : a[++s] = r : (a[++s] = null, c.push({ i: s, x: $e(o, r) })), n = vn.lastIndex;
  return n < t.length && (i = t.slice(n), a[s] ? a[s] += i : a[++s] = i), a.length < 2 ? c[0] ? zl(c[0].x) : Pl(t) : (t = c.length, function(l) {
    for (var d = 0, u; d < t; ++d) a[(u = c[d]).i] = u.x(l);
    return a.join("");
  });
}
var ko = 180 / Math.PI, An = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function Fr(e, t, n, o, r, i) {
  var s, a, c;
  return (s = Math.sqrt(e * e + t * t)) && (e /= s, t /= s), (c = e * n + t * o) && (n -= e * c, o -= t * c), (a = Math.sqrt(n * n + o * o)) && (n /= a, o /= a, c /= a), e * o < t * n && (e = -e, t = -t, c = -c, s = -s), {
    translateX: r,
    translateY: i,
    rotate: Math.atan2(t, e) * ko,
    skewX: Math.atan(c) * ko,
    scaleX: s,
    scaleY: a
  };
}
var Mt;
function Dl(e) {
  const t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(e + "");
  return t.isIdentity ? An : Fr(t.a, t.b, t.c, t.d, t.e, t.f);
}
function Hl(e) {
  return e == null || (Mt || (Mt = document.createElementNS("http://www.w3.org/2000/svg", "g")), Mt.setAttribute("transform", e), !(e = Mt.transform.baseVal.consolidate())) ? An : (e = e.matrix, Fr(e.a, e.b, e.c, e.d, e.e, e.f));
}
function Xr(e, t, n, o) {
  function r(l) {
    return l.length ? l.pop() + " " : "";
  }
  function i(l, d, u, f, h, p) {
    if (l !== u || d !== f) {
      var y = h.push("translate(", null, t, null, n);
      p.push({ i: y - 4, x: $e(l, u) }, { i: y - 2, x: $e(d, f) });
    } else (u || f) && h.push("translate(" + u + t + f + n);
  }
  function s(l, d, u, f) {
    l !== d ? (l - d > 180 ? d += 360 : d - l > 180 && (l += 360), f.push({ i: u.push(r(u) + "rotate(", null, o) - 2, x: $e(l, d) })) : d && u.push(r(u) + "rotate(" + d + o);
  }
  function a(l, d, u, f) {
    l !== d ? f.push({ i: u.push(r(u) + "skewX(", null, o) - 2, x: $e(l, d) }) : d && u.push(r(u) + "skewX(" + d + o);
  }
  function c(l, d, u, f, h, p) {
    if (l !== u || d !== f) {
      var y = h.push(r(h) + "scale(", null, ",", null, ")");
      p.push({ i: y - 4, x: $e(l, u) }, { i: y - 2, x: $e(d, f) });
    } else (u !== 1 || f !== 1) && h.push(r(h) + "scale(" + u + "," + f + ")");
  }
  return function(l, d) {
    var u = [], f = [];
    return l = e(l), d = e(d), i(l.translateX, l.translateY, d.translateX, d.translateY, u, f), s(l.rotate, d.rotate, u, f), a(l.skewX, d.skewX, u, f), c(l.scaleX, l.scaleY, d.scaleX, d.scaleY, u, f), l = d = null, function(h) {
      for (var p = -1, y = f.length, _; ++p < y; ) u[(_ = f[p]).i] = _.x(h);
      return u.join("");
    };
  };
}
var Vl = Xr(Dl, "px, ", "px)", "deg)"), Ol = Xr(Hl, ", ", ")", ")"), Rl = 1e-12;
function $o(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function Ll(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function Bl(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const Fl = function e(t, n, o) {
  function r(i, s) {
    var a = i[0], c = i[1], l = i[2], d = s[0], u = s[1], f = s[2], h = d - a, p = u - c, y = h * h + p * p, _, x;
    if (y < Rl)
      x = Math.log(f / l) / t, _ = function(S) {
        return [
          a + S * h,
          c + S * p,
          l * Math.exp(t * S * x)
        ];
      };
    else {
      var b = Math.sqrt(y), m = (f * f - l * l + o * y) / (2 * l * n * b), w = (f * f - l * l - o * y) / (2 * f * n * b), N = Math.log(Math.sqrt(m * m + 1) - m), k = Math.log(Math.sqrt(w * w + 1) - w);
      x = (k - N) / t, _ = function(S) {
        var P = S * x, I = $o(N), A = l / (n * b) * (I * Bl(t * P + N) - Ll(N));
        return [
          a + A * h,
          c + A * p,
          l * I / $o(t * P + N)
        ];
      };
    }
    return _.duration = x * 1e3 * t / Math.SQRT2, _;
  }
  return r.rho = function(i) {
    var s = Math.max(1e-3, +i), a = s * s, c = a * a;
    return e(s, a, c);
  }, r;
}(Math.SQRT2, 2, 4);
var Ze = 0, rt = 0, nt = 0, Yr = 1e3, Lt, it, Bt = 0, Ve = 0, Qt = 0, ft = typeof performance == "object" && performance.now ? performance : Date, Zr = typeof window == "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(e) {
  setTimeout(e, 17);
};
function Qn() {
  return Ve || (Zr(Xl), Ve = ft.now() + Qt);
}
function Xl() {
  Ve = 0;
}
function Ft() {
  this._call = this._time = this._next = null;
}
Ft.prototype = Wr.prototype = {
  constructor: Ft,
  restart: function(e, t, n) {
    if (typeof e != "function") throw new TypeError("callback is not a function");
    n = (n == null ? Qn() : +n) + (t == null ? 0 : +t), !this._next && it !== this && (it ? it._next = this : Lt = this, it = this), this._call = e, this._time = n, Pn();
  },
  stop: function() {
    this._call && (this._call = null, this._time = 1 / 0, Pn());
  }
};
function Wr(e, t, n) {
  var o = new Ft();
  return o.restart(e, t, n), o;
}
function Yl() {
  Qn(), ++Ze;
  for (var e = Lt, t; e; )
    (t = Ve - e._time) >= 0 && e._call.call(void 0, t), e = e._next;
  --Ze;
}
function Io() {
  Ve = (Bt = ft.now()) + Qt, Ze = rt = 0;
  try {
    Yl();
  } finally {
    Ze = 0, Wl(), Ve = 0;
  }
}
function Zl() {
  var e = ft.now(), t = e - Bt;
  t > Yr && (Qt -= t, Bt = e);
}
function Wl() {
  for (var e, t = Lt, n, o = 1 / 0; t; )
    t._call ? (o > t._time && (o = t._time), e = t, t = t._next) : (n = t._next, t._next = null, t = e ? e._next = n : Lt = n);
  it = e, Pn(o);
}
function Pn(e) {
  if (!Ze) {
    rt && (rt = clearTimeout(rt));
    var t = e - Ve;
    t > 24 ? (e < 1 / 0 && (rt = setTimeout(Io, e - ft.now() - Qt)), nt && (nt = clearInterval(nt))) : (nt || (Bt = ft.now(), nt = setInterval(Zl, Yr)), Ze = 1, Zr(Io));
  }
}
function Ao(e, t, n) {
  var o = new Ft();
  return t = t == null ? 0 : +t, o.restart((r) => {
    o.stop(), e(r + t);
  }, t, n), o;
}
var ql = Kt("start", "end", "cancel", "interrupt"), Gl = [], qr = 0, Po = 1, zn = 2, Tt = 3, zo = 4, Tn = 5, Dt = 6;
function Jt(e, t, n, o, r, i) {
  var s = e.__transition;
  if (!s) e.__transition = {};
  else if (n in s) return;
  Kl(e, n, {
    name: t,
    index: o,
    // For context during callback.
    group: r,
    // For context during callback.
    on: ql,
    tween: Gl,
    time: i.time,
    delay: i.delay,
    duration: i.duration,
    ease: i.ease,
    timer: null,
    state: qr
  });
}
function Jn(e, t) {
  var n = ye(e, t);
  if (n.state > qr) throw new Error("too late; already scheduled");
  return n;
}
function xe(e, t) {
  var n = ye(e, t);
  if (n.state > Tt) throw new Error("too late; already running");
  return n;
}
function ye(e, t) {
  var n = e.__transition;
  if (!n || !(n = n[t])) throw new Error("transition not found");
  return n;
}
function Kl(e, t, n) {
  var o = e.__transition, r;
  o[t] = n, n.timer = Wr(i, 0, n.time);
  function i(l) {
    n.state = Po, n.timer.restart(s, n.delay, n.time), n.delay <= l && s(l - n.delay);
  }
  function s(l) {
    var d, u, f, h;
    if (n.state !== Po) return c();
    for (d in o)
      if (h = o[d], h.name === n.name) {
        if (h.state === Tt) return Ao(s);
        h.state === zo ? (h.state = Dt, h.timer.stop(), h.on.call("interrupt", e, e.__data__, h.index, h.group), delete o[d]) : +d < t && (h.state = Dt, h.timer.stop(), h.on.call("cancel", e, e.__data__, h.index, h.group), delete o[d]);
      }
    if (Ao(function() {
      n.state === Tt && (n.state = zo, n.timer.restart(a, n.delay, n.time), a(l));
    }), n.state = zn, n.on.call("start", e, e.__data__, n.index, n.group), n.state === zn) {
      for (n.state = Tt, r = new Array(f = n.tween.length), d = 0, u = -1; d < f; ++d)
        (h = n.tween[d].value.call(e, e.__data__, n.index, n.group)) && (r[++u] = h);
      r.length = u + 1;
    }
  }
  function a(l) {
    for (var d = l < n.duration ? n.ease.call(null, l / n.duration) : (n.timer.restart(c), n.state = Tn, 1), u = -1, f = r.length; ++u < f; )
      r[u].call(e, d);
    n.state === Tn && (n.on.call("end", e, e.__data__, n.index, n.group), c());
  }
  function c() {
    n.state = Dt, n.timer.stop(), delete o[t];
    for (var l in o) return;
    delete e.__transition;
  }
}
function Ht(e, t) {
  var n = e.__transition, o, r, i = !0, s;
  if (n) {
    t = t == null ? null : t + "";
    for (s in n) {
      if ((o = n[s]).name !== t) {
        i = !1;
        continue;
      }
      r = o.state > zn && o.state < Tn, o.state = Dt, o.timer.stop(), o.on.call(r ? "interrupt" : "cancel", e, e.__data__, o.index, o.group), delete n[s];
    }
    i && delete e.__transition;
  }
}
function Ul(e) {
  return this.each(function() {
    Ht(this, e);
  });
}
function Ql(e, t) {
  var n, o;
  return function() {
    var r = xe(this, e), i = r.tween;
    if (i !== n) {
      o = n = i;
      for (var s = 0, a = o.length; s < a; ++s)
        if (o[s].name === t) {
          o = o.slice(), o.splice(s, 1);
          break;
        }
    }
    r.tween = o;
  };
}
function Jl(e, t, n) {
  var o, r;
  if (typeof n != "function") throw new Error();
  return function() {
    var i = xe(this, e), s = i.tween;
    if (s !== o) {
      r = (o = s).slice();
      for (var a = { name: t, value: n }, c = 0, l = r.length; c < l; ++c)
        if (r[c].name === t) {
          r[c] = a;
          break;
        }
      c === l && r.push(a);
    }
    i.tween = r;
  };
}
function jl(e, t) {
  var n = this._id;
  if (e += "", arguments.length < 2) {
    for (var o = ye(this.node(), n).tween, r = 0, i = o.length, s; r < i; ++r)
      if ((s = o[r]).name === e)
        return s.value;
    return null;
  }
  return this.each((t == null ? Ql : Jl)(n, e, t));
}
function jn(e, t, n) {
  var o = e._id;
  return e.each(function() {
    var r = xe(this, o);
    (r.value || (r.value = {}))[t] = n.apply(this, arguments);
  }), function(r) {
    return ye(r, o).value[t];
  };
}
function Gr(e, t) {
  var n;
  return (typeof t == "number" ? $e : t instanceof dt ? Mo : (n = dt(t)) ? (t = n, Mo) : Tl)(e, t);
}
function eu(e) {
  return function() {
    this.removeAttribute(e);
  };
}
function tu(e) {
  return function() {
    this.removeAttributeNS(e.space, e.local);
  };
}
function nu(e, t, n) {
  var o, r = n + "", i;
  return function() {
    var s = this.getAttribute(e);
    return s === r ? null : s === o ? i : i = t(o = s, n);
  };
}
function ou(e, t, n) {
  var o, r = n + "", i;
  return function() {
    var s = this.getAttributeNS(e.space, e.local);
    return s === r ? null : s === o ? i : i = t(o = s, n);
  };
}
function ru(e, t, n) {
  var o, r, i;
  return function() {
    var s, a = n(this), c;
    return a == null ? void this.removeAttribute(e) : (s = this.getAttribute(e), c = a + "", s === c ? null : s === o && c === r ? i : (r = c, i = t(o = s, a)));
  };
}
function iu(e, t, n) {
  var o, r, i;
  return function() {
    var s, a = n(this), c;
    return a == null ? void this.removeAttributeNS(e.space, e.local) : (s = this.getAttributeNS(e.space, e.local), c = a + "", s === c ? null : s === o && c === r ? i : (r = c, i = t(o = s, a)));
  };
}
function su(e, t) {
  var n = Ut(e), o = n === "transform" ? Ol : Gr;
  return this.attrTween(e, typeof t == "function" ? (n.local ? iu : ru)(n, o, jn(this, "attr." + e, t)) : t == null ? (n.local ? tu : eu)(n) : (n.local ? ou : nu)(n, o, t));
}
function au(e, t) {
  return function(n) {
    this.setAttribute(e, t.call(this, n));
  };
}
function cu(e, t) {
  return function(n) {
    this.setAttributeNS(e.space, e.local, t.call(this, n));
  };
}
function lu(e, t) {
  var n, o;
  function r() {
    var i = t.apply(this, arguments);
    return i !== o && (n = (o = i) && cu(e, i)), n;
  }
  return r._value = t, r;
}
function uu(e, t) {
  var n, o;
  function r() {
    var i = t.apply(this, arguments);
    return i !== o && (n = (o = i) && au(e, i)), n;
  }
  return r._value = t, r;
}
function du(e, t) {
  var n = "attr." + e;
  if (arguments.length < 2) return (n = this.tween(n)) && n._value;
  if (t == null) return this.tween(n, null);
  if (typeof t != "function") throw new Error();
  var o = Ut(e);
  return this.tween(n, (o.local ? lu : uu)(o, t));
}
function fu(e, t) {
  return function() {
    Jn(this, e).delay = +t.apply(this, arguments);
  };
}
function hu(e, t) {
  return t = +t, function() {
    Jn(this, e).delay = t;
  };
}
function gu(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? fu : hu)(t, e)) : ye(this.node(), t).delay;
}
function pu(e, t) {
  return function() {
    xe(this, e).duration = +t.apply(this, arguments);
  };
}
function mu(e, t) {
  return t = +t, function() {
    xe(this, e).duration = t;
  };
}
function yu(e) {
  var t = this._id;
  return arguments.length ? this.each((typeof e == "function" ? pu : mu)(t, e)) : ye(this.node(), t).duration;
}
function wu(e, t) {
  if (typeof t != "function") throw new Error();
  return function() {
    xe(this, e).ease = t;
  };
}
function xu(e) {
  var t = this._id;
  return arguments.length ? this.each(wu(t, e)) : ye(this.node(), t).ease;
}
function vu(e, t) {
  return function() {
    var n = t.apply(this, arguments);
    if (typeof n != "function") throw new Error();
    xe(this, e).ease = n;
  };
}
function _u(e) {
  if (typeof e != "function") throw new Error();
  return this.each(vu(this._id, e));
}
function bu(e) {
  typeof e != "function" && (e = Nr(e));
  for (var t = this._groups, n = t.length, o = new Array(n), r = 0; r < n; ++r)
    for (var i = t[r], s = i.length, a = o[r] = [], c, l = 0; l < s; ++l)
      (c = i[l]) && e.call(c, c.__data__, l, i) && a.push(c);
  return new Ee(o, this._parents, this._name, this._id);
}
function Eu(e) {
  if (e._id !== this._id) throw new Error();
  for (var t = this._groups, n = e._groups, o = t.length, r = n.length, i = Math.min(o, r), s = new Array(o), a = 0; a < i; ++a)
    for (var c = t[a], l = n[a], d = c.length, u = s[a] = new Array(d), f, h = 0; h < d; ++h)
      (f = c[h] || l[h]) && (u[h] = f);
  for (; a < o; ++a)
    s[a] = t[a];
  return new Ee(s, this._parents, this._name, this._id);
}
function Su(e) {
  return (e + "").trim().split(/^|\s+/).every(function(t) {
    var n = t.indexOf(".");
    return n >= 0 && (t = t.slice(0, n)), !t || t === "start";
  });
}
function Nu(e, t, n) {
  var o, r, i = Su(t) ? Jn : xe;
  return function() {
    var s = i(this, e), a = s.on;
    a !== o && (r = (o = a).copy()).on(t, n), s.on = r;
  };
}
function Cu(e, t) {
  var n = this._id;
  return arguments.length < 2 ? ye(this.node(), n).on.on(e) : this.each(Nu(n, e, t));
}
function Mu(e) {
  return function() {
    var t = this.parentNode;
    for (var n in this.__transition) if (+n !== e) return;
    t && t.removeChild(this);
  };
}
function ku() {
  return this.on("end.remove", Mu(this._id));
}
function $u(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Gn(e));
  for (var o = this._groups, r = o.length, i = new Array(r), s = 0; s < r; ++s)
    for (var a = o[s], c = a.length, l = i[s] = new Array(c), d, u, f = 0; f < c; ++f)
      (d = a[f]) && (u = e.call(d, d.__data__, f, a)) && ("__data__" in d && (u.__data__ = d.__data__), l[f] = u, Jt(l[f], t, n, f, l, ye(d, n)));
  return new Ee(i, this._parents, t, n);
}
function Iu(e) {
  var t = this._name, n = this._id;
  typeof e != "function" && (e = Sr(e));
  for (var o = this._groups, r = o.length, i = [], s = [], a = 0; a < r; ++a)
    for (var c = o[a], l = c.length, d, u = 0; u < l; ++u)
      if (d = c[u]) {
        for (var f = e.call(d, d.__data__, u, c), h, p = ye(d, n), y = 0, _ = f.length; y < _; ++y)
          (h = f[y]) && Jt(h, t, n, y, f, p);
        i.push(f), s.push(d);
      }
  return new Ee(i, s, t, n);
}
var Au = xt.prototype.constructor;
function Pu() {
  return new Au(this._groups, this._parents);
}
function zu(e, t) {
  var n, o, r;
  return function() {
    var i = Ye(this, e), s = (this.style.removeProperty(e), Ye(this, e));
    return i === s ? null : i === n && s === o ? r : r = t(n = i, o = s);
  };
}
function Kr(e) {
  return function() {
    this.style.removeProperty(e);
  };
}
function Tu(e, t, n) {
  var o, r = n + "", i;
  return function() {
    var s = Ye(this, e);
    return s === r ? null : s === o ? i : i = t(o = s, n);
  };
}
function Du(e, t, n) {
  var o, r, i;
  return function() {
    var s = Ye(this, e), a = n(this), c = a + "";
    return a == null && (c = a = (this.style.removeProperty(e), Ye(this, e))), s === c ? null : s === o && c === r ? i : (r = c, i = t(o = s, a));
  };
}
function Hu(e, t) {
  var n, o, r, i = "style." + t, s = "end." + i, a;
  return function() {
    var c = xe(this, e), l = c.on, d = c.value[i] == null ? a || (a = Kr(t)) : void 0;
    (l !== n || r !== d) && (o = (n = l).copy()).on(s, r = d), c.on = o;
  };
}
function Vu(e, t, n) {
  var o = (e += "") == "transform" ? Vl : Gr;
  return t == null ? this.styleTween(e, zu(e, o)).on("end.style." + e, Kr(e)) : typeof t == "function" ? this.styleTween(e, Du(e, o, jn(this, "style." + e, t))).each(Hu(this._id, e)) : this.styleTween(e, Tu(e, o, t), n).on("end.style." + e, null);
}
function Ou(e, t, n) {
  return function(o) {
    this.style.setProperty(e, t.call(this, o), n);
  };
}
function Ru(e, t, n) {
  var o, r;
  function i() {
    var s = t.apply(this, arguments);
    return s !== r && (o = (r = s) && Ou(e, s, n)), o;
  }
  return i._value = t, i;
}
function Lu(e, t, n) {
  var o = "style." + (e += "");
  if (arguments.length < 2) return (o = this.tween(o)) && o._value;
  if (t == null) return this.tween(o, null);
  if (typeof t != "function") throw new Error();
  return this.tween(o, Ru(e, t, n ?? ""));
}
function Bu(e) {
  return function() {
    this.textContent = e;
  };
}
function Fu(e) {
  return function() {
    var t = e(this);
    this.textContent = t ?? "";
  };
}
function Xu(e) {
  return this.tween("text", typeof e == "function" ? Fu(jn(this, "text", e)) : Bu(e == null ? "" : e + ""));
}
function Yu(e) {
  return function(t) {
    this.textContent = e.call(this, t);
  };
}
function Zu(e) {
  var t, n;
  function o() {
    var r = e.apply(this, arguments);
    return r !== n && (t = (n = r) && Yu(r)), t;
  }
  return o._value = e, o;
}
function Wu(e) {
  var t = "text";
  if (arguments.length < 1) return (t = this.tween(t)) && t._value;
  if (e == null) return this.tween(t, null);
  if (typeof e != "function") throw new Error();
  return this.tween(t, Zu(e));
}
function qu() {
  for (var e = this._name, t = this._id, n = Ur(), o = this._groups, r = o.length, i = 0; i < r; ++i)
    for (var s = o[i], a = s.length, c, l = 0; l < a; ++l)
      if (c = s[l]) {
        var d = ye(c, t);
        Jt(c, e, n, l, s, {
          time: d.time + d.delay + d.duration,
          delay: 0,
          duration: d.duration,
          ease: d.ease
        });
      }
  return new Ee(o, this._parents, e, n);
}
function Gu() {
  var e, t, n = this, o = n._id, r = n.size();
  return new Promise(function(i, s) {
    var a = { value: s }, c = { value: function() {
      --r === 0 && i();
    } };
    n.each(function() {
      var l = xe(this, o), d = l.on;
      d !== e && (t = (e = d).copy(), t._.cancel.push(a), t._.interrupt.push(a), t._.end.push(c)), l.on = t;
    }), r === 0 && i();
  });
}
var Ku = 0;
function Ee(e, t, n, o) {
  this._groups = e, this._parents = t, this._name = n, this._id = o;
}
function Ur() {
  return ++Ku;
}
var ve = xt.prototype;
Ee.prototype = {
  constructor: Ee,
  select: $u,
  selectAll: Iu,
  selectChild: ve.selectChild,
  selectChildren: ve.selectChildren,
  filter: bu,
  merge: Eu,
  selection: Pu,
  transition: qu,
  call: ve.call,
  nodes: ve.nodes,
  node: ve.node,
  size: ve.size,
  empty: ve.empty,
  each: ve.each,
  on: Cu,
  attr: su,
  attrTween: du,
  style: Vu,
  styleTween: Lu,
  text: Xu,
  textTween: Wu,
  remove: ku,
  tween: jl,
  delay: gu,
  duration: yu,
  ease: xu,
  easeVarying: _u,
  end: Gu,
  [Symbol.iterator]: ve[Symbol.iterator]
};
function Uu(e) {
  return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
}
var Qu = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: Uu
};
function Ju(e, t) {
  for (var n; !(n = e.__transition) || !(n = n[t]); )
    if (!(e = e.parentNode))
      throw new Error(`transition ${t} not found`);
  return n;
}
function ju(e) {
  var t, n;
  e instanceof Ee ? (t = e._id, e = e._name) : (t = Ur(), (n = Qu).time = Qn(), e = e == null ? null : e + "");
  for (var o = this._groups, r = o.length, i = 0; i < r; ++i)
    for (var s = o[i], a = s.length, c, l = 0; l < a; ++l)
      (c = s[l]) && Jt(c, e, t, l, s, n || Ju(c, t));
  return new Ee(o, this._parents, e, t);
}
xt.prototype.interrupt = Ul;
xt.prototype.transition = ju;
const kt = (e) => () => e;
function ed(e, {
  sourceEvent: t,
  target: n,
  transform: o,
  dispatch: r
}) {
  Object.defineProperties(this, {
    type: { value: e, enumerable: !0, configurable: !0 },
    sourceEvent: { value: t, enumerable: !0, configurable: !0 },
    target: { value: n, enumerable: !0, configurable: !0 },
    transform: { value: o, enumerable: !0, configurable: !0 },
    _: { value: r }
  });
}
function _e(e, t, n) {
  this.k = e, this.x = t, this.y = n;
}
_e.prototype = {
  constructor: _e,
  scale: function(e) {
    return e === 1 ? this : new _e(this.k * e, this.x, this.y);
  },
  translate: function(e, t) {
    return e === 0 & t === 0 ? this : new _e(this.k, this.x + this.k * e, this.y + this.k * t);
  },
  apply: function(e) {
    return [e[0] * this.k + this.x, e[1] * this.k + this.y];
  },
  applyX: function(e) {
    return e * this.k + this.x;
  },
  applyY: function(e) {
    return e * this.k + this.y;
  },
  invert: function(e) {
    return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
  },
  invertX: function(e) {
    return (e - this.x) / this.k;
  },
  invertY: function(e) {
    return (e - this.y) / this.k;
  },
  rescaleX: function(e) {
    return e.copy().domain(e.range().map(this.invertX, this).map(e.invert, e));
  },
  rescaleY: function(e) {
    return e.copy().domain(e.range().map(this.invertY, this).map(e.invert, e));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var jt = new _e(1, 0, 0);
Qr.prototype = _e.prototype;
function Qr(e) {
  for (; !e.__zoom; ) if (!(e = e.parentNode)) return jt;
  return e.__zoom;
}
function _n(e) {
  e.stopImmediatePropagation();
}
function ot(e) {
  e.preventDefault(), e.stopImmediatePropagation();
}
function td(e) {
  return (!e.ctrlKey || e.type === "wheel") && !e.button;
}
function nd() {
  var e = this;
  return e instanceof SVGElement ? (e = e.ownerSVGElement || e, e.hasAttribute("viewBox") ? (e = e.viewBox.baseVal, [[e.x, e.y], [e.x + e.width, e.y + e.height]]) : [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]]) : [[0, 0], [e.clientWidth, e.clientHeight]];
}
function To() {
  return this.__zoom || jt;
}
function od(e) {
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * (e.ctrlKey ? 10 : 1);
}
function rd() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function id(e, t, n) {
  var o = e.invertX(t[0][0]) - n[0][0], r = e.invertX(t[1][0]) - n[1][0], i = e.invertY(t[0][1]) - n[0][1], s = e.invertY(t[1][1]) - n[1][1];
  return e.translate(
    r > o ? (o + r) / 2 : Math.min(0, o) || Math.max(0, r),
    s > i ? (i + s) / 2 : Math.min(0, i) || Math.max(0, s)
  );
}
function Jr() {
  var e = td, t = nd, n = id, o = od, r = rd, i = [0, 1 / 0], s = [[-1 / 0, -1 / 0], [1 / 0, 1 / 0]], a = 250, c = Fl, l = Kt("start", "zoom", "end"), d, u, f, h = 500, p = 150, y = 0, _ = 10;
  function x(g) {
    g.property("__zoom", To).on("wheel.zoom", P, { passive: !1 }).on("mousedown.zoom", I).on("dblclick.zoom", A).filter(r).on("touchstart.zoom", V).on("touchmove.zoom", D).on("touchend.zoom touchcancel.zoom", H).style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  x.transform = function(g, E, v, M) {
    var $ = g.selection ? g.selection() : g;
    $.property("__zoom", To), g !== $ ? N(g, E, v, M) : $.interrupt().each(function() {
      k(this, arguments).event(M).start().zoom(null, typeof E == "function" ? E.apply(this, arguments) : E).end();
    });
  }, x.scaleBy = function(g, E, v, M) {
    x.scaleTo(g, function() {
      var $ = this.__zoom.k, C = typeof E == "function" ? E.apply(this, arguments) : E;
      return $ * C;
    }, v, M);
  }, x.scaleTo = function(g, E, v, M) {
    x.transform(g, function() {
      var $ = t.apply(this, arguments), C = this.__zoom, T = v == null ? w($) : typeof v == "function" ? v.apply(this, arguments) : v, O = C.invert(T), R = typeof E == "function" ? E.apply(this, arguments) : E;
      return n(m(b(C, R), T, O), $, s);
    }, v, M);
  }, x.translateBy = function(g, E, v, M) {
    x.transform(g, function() {
      return n(this.__zoom.translate(
        typeof E == "function" ? E.apply(this, arguments) : E,
        typeof v == "function" ? v.apply(this, arguments) : v
      ), t.apply(this, arguments), s);
    }, null, M);
  }, x.translateTo = function(g, E, v, M, $) {
    x.transform(g, function() {
      var C = t.apply(this, arguments), T = this.__zoom, O = M == null ? w(C) : typeof M == "function" ? M.apply(this, arguments) : M;
      return n(jt.translate(O[0], O[1]).scale(T.k).translate(
        typeof E == "function" ? -E.apply(this, arguments) : -E,
        typeof v == "function" ? -v.apply(this, arguments) : -v
      ), C, s);
    }, M, $);
  };
  function b(g, E) {
    return E = Math.max(i[0], Math.min(i[1], E)), E === g.k ? g : new _e(E, g.x, g.y);
  }
  function m(g, E, v) {
    var M = E[0] - v[0] * g.k, $ = E[1] - v[1] * g.k;
    return M === g.x && $ === g.y ? g : new _e(g.k, M, $);
  }
  function w(g) {
    return [(+g[0][0] + +g[1][0]) / 2, (+g[0][1] + +g[1][1]) / 2];
  }
  function N(g, E, v, M) {
    g.on("start.zoom", function() {
      k(this, arguments).event(M).start();
    }).on("interrupt.zoom end.zoom", function() {
      k(this, arguments).event(M).end();
    }).tween("zoom", function() {
      var $ = this, C = arguments, T = k($, C).event(M), O = t.apply($, C), R = v == null ? w(O) : typeof v == "function" ? v.apply($, C) : v, W = Math.max(O[1][0] - O[0][0], O[1][1] - O[0][1]), Y = $.__zoom, F = typeof E == "function" ? E.apply($, C) : E, Z = c(Y.invert(R).concat(W / Y.k), F.invert(R).concat(W / F.k));
      return function(L) {
        if (L === 1) L = F;
        else {
          var X = Z(L), K = W / X[2];
          L = new _e(K, R[0] - X[0] * K, R[1] - X[1] * K);
        }
        T.zoom(null, L);
      };
    });
  }
  function k(g, E, v) {
    return !v && g.__zooming || new S(g, E);
  }
  function S(g, E) {
    this.that = g, this.args = E, this.active = 0, this.sourceEvent = null, this.extent = t.apply(g, E), this.taps = 0;
  }
  S.prototype = {
    event: function(g) {
      return g && (this.sourceEvent = g), this;
    },
    start: function() {
      return ++this.active === 1 && (this.that.__zooming = this, this.emit("start")), this;
    },
    zoom: function(g, E) {
      return this.mouse && g !== "mouse" && (this.mouse[1] = E.invert(this.mouse[0])), this.touch0 && g !== "touch" && (this.touch0[1] = E.invert(this.touch0[0])), this.touch1 && g !== "touch" && (this.touch1[1] = E.invert(this.touch1[0])), this.that.__zoom = E, this.emit("zoom"), this;
    },
    end: function() {
      return --this.active === 0 && (delete this.that.__zooming, this.emit("end")), this;
    },
    emit: function(g) {
      var E = le(this.that).datum();
      l.call(
        g,
        this.that,
        new ed(g, {
          sourceEvent: this.sourceEvent,
          target: x,
          transform: this.that.__zoom,
          dispatch: l
        }),
        E
      );
    }
  };
  function P(g, ...E) {
    if (!e.apply(this, arguments)) return;
    var v = k(this, E).event(g), M = this.__zoom, $ = Math.max(i[0], Math.min(i[1], M.k * Math.pow(2, o.apply(this, arguments)))), C = he(g);
    if (v.wheel)
      (v.mouse[0][0] !== C[0] || v.mouse[0][1] !== C[1]) && (v.mouse[1] = M.invert(v.mouse[0] = C)), clearTimeout(v.wheel);
    else {
      if (M.k === $) return;
      v.mouse = [C, M.invert(C)], Ht(this), v.start();
    }
    ot(g), v.wheel = setTimeout(T, p), v.zoom("mouse", n(m(b(M, $), v.mouse[0], v.mouse[1]), v.extent, s));
    function T() {
      v.wheel = null, v.end();
    }
  }
  function I(g, ...E) {
    if (f || !e.apply(this, arguments)) return;
    var v = g.currentTarget, M = k(this, E, !0).event(g), $ = le(g.view).on("mousemove.zoom", R, !0).on("mouseup.zoom", W, !0), C = he(g, v), T = g.clientX, O = g.clientY;
    Dr(g.view), _n(g), M.mouse = [C, this.__zoom.invert(C)], Ht(this), M.start();
    function R(Y) {
      if (ot(Y), !M.moved) {
        var F = Y.clientX - T, Z = Y.clientY - O;
        M.moved = F * F + Z * Z > y;
      }
      M.event(Y).zoom("mouse", n(m(M.that.__zoom, M.mouse[0] = he(Y, v), M.mouse[1]), M.extent, s));
    }
    function W(Y) {
      $.on("mousemove.zoom mouseup.zoom", null), Hr(Y.view, M.moved), ot(Y), M.event(Y).end();
    }
  }
  function A(g, ...E) {
    if (e.apply(this, arguments)) {
      var v = this.__zoom, M = he(g.changedTouches ? g.changedTouches[0] : g, this), $ = v.invert(M), C = v.k * (g.shiftKey ? 0.5 : 2), T = n(m(b(v, C), M, $), t.apply(this, E), s);
      ot(g), a > 0 ? le(this).transition().duration(a).call(N, T, M, g) : le(this).call(x.transform, T, M, g);
    }
  }
  function V(g, ...E) {
    if (e.apply(this, arguments)) {
      var v = g.touches, M = v.length, $ = k(this, E, g.changedTouches.length === M).event(g), C, T, O, R;
      for (_n(g), T = 0; T < M; ++T)
        O = v[T], R = he(O, this), R = [R, this.__zoom.invert(R), O.identifier], $.touch0 ? !$.touch1 && $.touch0[2] !== R[2] && ($.touch1 = R, $.taps = 0) : ($.touch0 = R, C = !0, $.taps = 1 + !!d);
      d && (d = clearTimeout(d)), C && ($.taps < 2 && (u = R[0], d = setTimeout(function() {
        d = null;
      }, h)), Ht(this), $.start());
    }
  }
  function D(g, ...E) {
    if (this.__zooming) {
      var v = k(this, E).event(g), M = g.changedTouches, $ = M.length, C, T, O, R;
      for (ot(g), C = 0; C < $; ++C)
        T = M[C], O = he(T, this), v.touch0 && v.touch0[2] === T.identifier ? v.touch0[0] = O : v.touch1 && v.touch1[2] === T.identifier && (v.touch1[0] = O);
      if (T = v.that.__zoom, v.touch1) {
        var W = v.touch0[0], Y = v.touch0[1], F = v.touch1[0], Z = v.touch1[1], L = (L = F[0] - W[0]) * L + (L = F[1] - W[1]) * L, X = (X = Z[0] - Y[0]) * X + (X = Z[1] - Y[1]) * X;
        T = b(T, Math.sqrt(L / X)), O = [(W[0] + F[0]) / 2, (W[1] + F[1]) / 2], R = [(Y[0] + Z[0]) / 2, (Y[1] + Z[1]) / 2];
      } else if (v.touch0) O = v.touch0[0], R = v.touch0[1];
      else return;
      v.zoom("touch", n(m(T, O, R), v.extent, s));
    }
  }
  function H(g, ...E) {
    if (this.__zooming) {
      var v = k(this, E).event(g), M = g.changedTouches, $ = M.length, C, T;
      for (_n(g), f && clearTimeout(f), f = setTimeout(function() {
        f = null;
      }, h), C = 0; C < $; ++C)
        T = M[C], v.touch0 && v.touch0[2] === T.identifier ? delete v.touch0 : v.touch1 && v.touch1[2] === T.identifier && delete v.touch1;
      if (v.touch1 && !v.touch0 && (v.touch0 = v.touch1, delete v.touch1), v.touch0) v.touch0[1] = this.__zoom.invert(v.touch0[0]);
      else if (v.end(), v.taps === 2 && (T = he(T, this), Math.hypot(u[0] - T[0], u[1] - T[1]) < _)) {
        var O = le(this).on("dblclick.zoom");
        O && O.apply(this, arguments);
      }
    }
  }
  return x.wheelDelta = function(g) {
    return arguments.length ? (o = typeof g == "function" ? g : kt(+g), x) : o;
  }, x.filter = function(g) {
    return arguments.length ? (e = typeof g == "function" ? g : kt(!!g), x) : e;
  }, x.touchable = function(g) {
    return arguments.length ? (r = typeof g == "function" ? g : kt(!!g), x) : r;
  }, x.extent = function(g) {
    return arguments.length ? (t = typeof g == "function" ? g : kt([[+g[0][0], +g[0][1]], [+g[1][0], +g[1][1]]]), x) : t;
  }, x.scaleExtent = function(g) {
    return arguments.length ? (i[0] = +g[0], i[1] = +g[1], x) : [i[0], i[1]];
  }, x.translateExtent = function(g) {
    return arguments.length ? (s[0][0] = +g[0][0], s[1][0] = +g[1][0], s[0][1] = +g[0][1], s[1][1] = +g[1][1], x) : [[s[0][0], s[0][1]], [s[1][0], s[1][1]]];
  }, x.constrain = function(g) {
    return arguments.length ? (n = g, x) : n;
  }, x.duration = function(g) {
    return arguments.length ? (a = +g, x) : a;
  }, x.interpolate = function(g) {
    return arguments.length ? (c = g, x) : c;
  }, x.on = function() {
    var g = l.on.apply(l, arguments);
    return g === l ? x : g;
  }, x.clickDistance = function(g) {
    return arguments.length ? (y = (g = +g) * g, x) : Math.sqrt(y);
  }, x.tapDistance = function(g) {
    return arguments.length ? (_ = +g, x) : _;
  }, x;
}
const Ne = {
  error001: () => "[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001",
  error002: () => "It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.",
  error003: (e) => `Node type "${e}" not found. Using fallback type "default".`,
  error004: () => "The React Flow parent container needs a width and a height to render the graph.",
  error005: () => "Only child nodes can use a parent extent.",
  error006: () => "Can't create edge. An edge needs a source and a target.",
  error007: (e) => `The old edge with id=${e} does not exist.`,
  error009: (e) => `Marker type "${e}" doesn't exist.`,
  error008: (e, { id: t, sourceHandle: n, targetHandle: o }) => `Couldn't create edge for ${e} handle id: "${e === "source" ? n : o}", edge id: ${t}.`,
  error010: () => "Handle: No node id found. Make sure to only use a Handle inside a custom Node.",
  error011: (e) => `Edge type "${e}" not found. Using fallback type "default".`,
  error012: (e) => `Node with id "${e}" does not exist, it may have been removed. This can happen when a node is deleted before the "onNodeClick" handler is called.`,
  error013: (e = "react") => `It seems that you haven't loaded the styles. Please import '@xyflow/${e}/dist/style.css' or base.css to make sure everything is working properly.`,
  error014: () => "useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID."
}, ht = [
  [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],
  [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
], jr = ["Enter", " ", "Escape"];
var We;
(function(e) {
  e.Strict = "strict", e.Loose = "loose";
})(We || (We = {}));
var He;
(function(e) {
  e.Free = "free", e.Vertical = "vertical", e.Horizontal = "horizontal";
})(He || (He = {}));
var gt;
(function(e) {
  e.Partial = "partial", e.Full = "full";
})(gt || (gt = {}));
const ei = {
  inProgress: !1,
  isValid: null,
  from: null,
  fromHandle: null,
  fromPosition: null,
  fromNode: null,
  to: null,
  toHandle: null,
  toPosition: null,
  toNode: null
};
var Ie;
(function(e) {
  e.Bezier = "default", e.Straight = "straight", e.Step = "step", e.SmoothStep = "smoothstep", e.SimpleBezier = "simplebezier";
})(Ie || (Ie = {}));
var Xt;
(function(e) {
  e.Arrow = "arrow", e.ArrowClosed = "arrowclosed";
})(Xt || (Xt = {}));
var B;
(function(e) {
  e.Left = "left", e.Top = "top", e.Right = "right", e.Bottom = "bottom";
})(B || (B = {}));
const Do = {
  [B.Left]: B.Right,
  [B.Right]: B.Left,
  [B.Top]: B.Bottom,
  [B.Bottom]: B.Top
};
function ti(e) {
  return e === null ? null : e ? "valid" : "invalid";
}
const ni = (e) => "id" in e && "source" in e && "target" in e, sd = (e) => "id" in e && "position" in e && !("source" in e) && !("target" in e), eo = (e) => "id" in e && "internals" in e && !("source" in e) && !("target" in e), _t = (e, t = [0, 0]) => {
  const { width: n, height: o } = Ce(e), r = e.origin ?? t, i = n * r[0], s = o * r[1];
  return {
    x: e.position.x - i,
    y: e.position.y - s
  };
}, ad = (e, t = { nodeOrigin: [0, 0], nodeLookup: void 0 }) => {
  if (e.length === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  const n = e.reduce((o, r) => {
    const i = typeof r == "string";
    let s = !t.nodeLookup && !i ? r : void 0;
    t.nodeLookup && (s = i ? t.nodeLookup.get(r) : eo(r) ? r : t.nodeLookup.get(r.id));
    const a = s ? Yt(s, t.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };
    return en(o, a);
  }, { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 });
  return tn(n);
}, Ue = (e, t = {}) => {
  if (e.size === 0)
    return { x: 0, y: 0, width: 0, height: 0 };
  let n = { x: 1 / 0, y: 1 / 0, x2: -1 / 0, y2: -1 / 0 };
  return e.forEach((o) => {
    if (t.filter === void 0 || t.filter(o)) {
      const r = Yt(o);
      n = en(n, r);
    }
  }), tn(n);
}, oi = (e, t, [n, o, r] = [0, 0, 1], i = !1, s = !1) => {
  const a = {
    ...bt(t, [n, o, r]),
    width: t.width / r,
    height: t.height / r
  }, c = [];
  for (const l of e.values()) {
    const { measured: d, selectable: u = !0, hidden: f = !1 } = l;
    if (s && !u || f)
      continue;
    const h = d.width ?? l.width ?? l.initialWidth ?? null, p = d.height ?? l.height ?? l.initialHeight ?? null, y = pt(a, Ge(l)), _ = (h ?? 0) * (p ?? 0), x = i && y > 0;
    (!l.internals.handleBounds || x || y >= _ || l.dragging) && c.push(l);
  }
  return c;
}, cd = (e, t) => {
  const n = /* @__PURE__ */ new Set();
  return e.forEach((o) => {
    n.add(o.id);
  }), t.filter((o) => n.has(o.source) || n.has(o.target));
};
function Dn(e, t) {
  const n = /* @__PURE__ */ new Map(), o = t?.nodes ? new Set(t.nodes.map((r) => r.id)) : null;
  return e.forEach((r) => {
    r.measured.width && r.measured.height && (t?.includeHiddenNodes || !r.hidden) && (!o || o.has(r.id)) && n.set(r.id, r);
  }), n;
}
async function Hn({ nodes: e, width: t, height: n, panZoom: o, minZoom: r, maxZoom: i }, s) {
  if (e.size === 0)
    return Promise.resolve(!1);
  const a = Ue(e), c = to(a, t, n, s?.minZoom ?? r, s?.maxZoom ?? i, s?.padding ?? 0.1);
  return await o.setViewport(c, { duration: s?.duration }), Promise.resolve(!0);
}
function ri({ nodeId: e, nextPosition: t, nodeLookup: n, nodeOrigin: o = [0, 0], nodeExtent: r, onError: i }) {
  const s = n.get(e), a = s.parentId ? n.get(s.parentId) : void 0, { x: c, y: l } = a ? a.internals.positionAbsolute : { x: 0, y: 0 }, d = s.origin ?? o;
  let u = r;
  if (s.extent === "parent" && !s.expandParent)
    if (!a)
      i?.("005", Ne.error005());
    else {
      const h = a.measured.width, p = a.measured.height;
      h && p && (u = [
        [c, l],
        [c + h, l + p]
      ]);
    }
  else a && Ke(s.extent) && (u = [
    [s.extent[0][0] + c, s.extent[0][1] + l],
    [s.extent[1][0] + c, s.extent[1][1] + l]
  ]);
  const f = Ke(u) ? Oe(t, u, s.measured) : t;
  return {
    position: {
      x: f.x - c + s.measured.width * d[0],
      y: f.y - l + s.measured.height * d[1]
    },
    positionAbsolute: f
  };
}
async function ld({ nodesToRemove: e = [], edgesToRemove: t = [], nodes: n, edges: o, onBeforeDelete: r }) {
  const i = new Set(e.map((f) => f.id)), s = [];
  for (const f of n) {
    if (f.deletable === !1)
      continue;
    const h = i.has(f.id), p = !h && f.parentId && s.find((y) => y.id === f.parentId);
    (h || p) && s.push(f);
  }
  const a = new Set(t.map((f) => f.id)), c = o.filter((f) => f.deletable !== !1), d = cd(s, c);
  for (const f of c)
    a.has(f.id) && !d.find((p) => p.id === f.id) && d.push(f);
  if (!r)
    return {
      edges: d,
      nodes: s
    };
  const u = await r({
    nodes: s,
    edges: d
  });
  return typeof u == "boolean" ? u ? { edges: d, nodes: s } : { edges: [], nodes: [] } : u;
}
const qe = (e, t = 0, n = 1) => Math.min(Math.max(e, t), n), Oe = (e = { x: 0, y: 0 }, t, n) => ({
  x: qe(e.x, t[0][0], t[1][0] - (n?.width ?? 0)),
  y: qe(e.y, t[0][1], t[1][1] - (n?.height ?? 0))
});
function ii(e, t, n) {
  const { width: o, height: r } = Ce(n), { x: i, y: s } = n.internals.positionAbsolute;
  return Oe(e, [
    [i, s],
    [i + o, s + r]
  ], t);
}
const Ho = (e, t, n) => e < t ? qe(Math.abs(e - t), 1, t) / t : e > n ? -qe(Math.abs(e - n), 1, t) / t : 0, si = (e, t, n = 15, o = 40) => {
  const r = Ho(e.x, o, t.width - o) * n, i = Ho(e.y, o, t.height - o) * n;
  return [r, i];
}, en = (e, t) => ({
  x: Math.min(e.x, t.x),
  y: Math.min(e.y, t.y),
  x2: Math.max(e.x2, t.x2),
  y2: Math.max(e.y2, t.y2)
}), Vn = ({ x: e, y: t, width: n, height: o }) => ({
  x: e,
  y: t,
  x2: e + n,
  y2: t + o
}), tn = ({ x: e, y: t, x2: n, y2: o }) => ({
  x: e,
  y: t,
  width: n - e,
  height: o - t
}), Ge = (e, t = [0, 0]) => {
  const { x: n, y: o } = eo(e) ? e.internals.positionAbsolute : _t(e, t);
  return {
    x: n,
    y: o,
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}, Yt = (e, t = [0, 0]) => {
  const { x: n, y: o } = eo(e) ? e.internals.positionAbsolute : _t(e, t);
  return {
    x: n,
    y: o,
    x2: n + (e.measured?.width ?? e.width ?? e.initialWidth ?? 0),
    y2: o + (e.measured?.height ?? e.height ?? e.initialHeight ?? 0)
  };
}, ai = (e, t) => tn(en(Vn(e), Vn(t))), pt = (e, t) => {
  const n = Math.max(0, Math.min(e.x + e.width, t.x + t.width) - Math.max(e.x, t.x)), o = Math.max(0, Math.min(e.y + e.height, t.y + t.height) - Math.max(e.y, t.y));
  return Math.ceil(n * o);
}, Vo = (e) => pe(e.width) && pe(e.height) && pe(e.x) && pe(e.y), pe = (e) => !isNaN(e) && isFinite(e), ud = (e, t) => {
}, nn = (e, t = [1, 1]) => ({
  x: t[0] * Math.round(e.x / t[0]),
  y: t[1] * Math.round(e.y / t[1])
}), bt = ({ x: e, y: t }, [n, o, r], i = !1, s = [1, 1]) => {
  const a = {
    x: (e - n) / r,
    y: (t - o) / r
  };
  return i ? nn(a, s) : a;
}, ci = ({ x: e, y: t }, [n, o, r]) => ({
  x: e * r + n,
  y: t * r + o
}), to = (e, t, n, o, r, i) => {
  const s = t / (e.width * (1 + i)), a = n / (e.height * (1 + i)), c = Math.min(s, a), l = qe(c, o, r), d = e.x + e.width / 2, u = e.y + e.height / 2, f = t / 2 - d * l, h = n / 2 - u * l;
  return { x: f, y: h, zoom: l };
}, Zt = () => typeof navigator < "u" && navigator?.userAgent?.indexOf("Mac") >= 0;
function Ke(e) {
  return e !== void 0 && e !== "parent";
}
function Ce(e) {
  return {
    width: e.measured?.width ?? e.width ?? e.initialWidth ?? 0,
    height: e.measured?.height ?? e.height ?? e.initialHeight ?? 0
  };
}
function li(e) {
  return (e.measured?.width ?? e.width ?? e.initialWidth) !== void 0 && (e.measured?.height ?? e.height ?? e.initialHeight) !== void 0;
}
function ui(e, t = { width: 0, height: 0 }, n, o, r) {
  const i = { ...e }, s = o.get(n);
  if (s) {
    const a = s.origin || r;
    i.x += s.internals.positionAbsolute.x - (t.width ?? 0) * a[0], i.y += s.internals.positionAbsolute.y - (t.height ?? 0) * a[1];
  }
  return i;
}
function Oo(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function st(e, { snapGrid: t = [0, 0], snapToGrid: n = !1, transform: o, containerBounds: r }) {
  const { x: i, y: s } = be(e), a = bt({ x: i - (r?.left ?? 0), y: s - (r?.top ?? 0) }, o), { x: c, y: l } = n ? nn(a, t) : a;
  return {
    xSnapped: c,
    ySnapped: l,
    ...a
  };
}
const on = (e) => ({
  width: e.offsetWidth,
  height: e.offsetHeight
}), di = (e) => e?.getRootNode?.() || window?.document, dd = ["INPUT", "SELECT", "TEXTAREA"];
function On(e) {
  const t = e.composedPath?.()?.[0] || e.target;
  return t?.nodeType !== 1 ? !1 : dd.includes(t.nodeName) || t.hasAttribute("contenteditable") || !!t.closest(".nokey");
}
const fi = (e) => "clientX" in e, be = (e, t) => {
  const n = fi(e), o = n ? e.clientX : e.touches?.[0].clientX, r = n ? e.clientY : e.touches?.[0].clientY;
  return {
    x: o - (t?.left ?? 0),
    y: r - (t?.top ?? 0)
  };
}, Ro = (e, t, n, o, r) => {
  const i = t.querySelectorAll(`.${e}`);
  return !i || !i.length ? null : Array.from(i).map((s) => {
    const a = s.getBoundingClientRect();
    return {
      id: s.getAttribute("data-handleid"),
      type: e,
      nodeId: r,
      position: s.getAttribute("data-handlepos"),
      x: (a.left - n.left) / o,
      y: (a.top - n.top) / o,
      ...on(s)
    };
  });
};
function hi({ sourceX: e, sourceY: t, targetX: n, targetY: o, sourceControlX: r, sourceControlY: i, targetControlX: s, targetControlY: a }) {
  const c = e * 0.125 + r * 0.375 + s * 0.375 + n * 0.125, l = t * 0.125 + i * 0.375 + a * 0.375 + o * 0.125, d = Math.abs(c - e), u = Math.abs(l - t);
  return [c, l, d, u];
}
function $t(e, t) {
  return e >= 0 ? 0.5 * e : t * 25 * Math.sqrt(-e);
}
function Lo({ pos: e, x1: t, y1: n, x2: o, y2: r, c: i }) {
  switch (e) {
    case B.Left:
      return [t - $t(t - o, i), n];
    case B.Right:
      return [t + $t(o - t, i), n];
    case B.Top:
      return [t, n - $t(n - r, i)];
    case B.Bottom:
      return [t, n + $t(r - n, i)];
  }
}
function gi({ sourceX: e, sourceY: t, sourcePosition: n = B.Bottom, targetX: o, targetY: r, targetPosition: i = B.Top, curvature: s = 0.25 }) {
  const [a, c] = Lo({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: r,
    c: s
  }), [l, d] = Lo({
    pos: i,
    x1: o,
    y1: r,
    x2: e,
    y2: t,
    c: s
  }), [u, f, h, p] = hi({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: r,
    sourceControlX: a,
    sourceControlY: c,
    targetControlX: l,
    targetControlY: d
  });
  return [
    `M${e},${t} C${a},${c} ${l},${d} ${o},${r}`,
    u,
    f,
    h,
    p
  ];
}
function pi({ sourceX: e, sourceY: t, targetX: n, targetY: o }) {
  const r = Math.abs(n - e) / 2, i = n < e ? n + r : n - r, s = Math.abs(o - t) / 2, a = o < t ? o + s : o - s;
  return [i, a, r, s];
}
function fd({ sourceNode: e, targetNode: t, selected: n = !1, zIndex: o = 0, elevateOnSelect: r = !1 }) {
  if (!r)
    return o;
  const i = n || t.selected || e.selected, s = Math.max(e.internals.z || 0, t.internals.z || 0, 1e3);
  return o + (i ? s : 0);
}
function hd({ sourceNode: e, targetNode: t, width: n, height: o, transform: r }) {
  const i = en(Yt(e), Yt(t));
  i.x === i.x2 && (i.x2 += 1), i.y === i.y2 && (i.y2 += 1);
  const s = {
    x: -r[0] / r[2],
    y: -r[1] / r[2],
    width: n / r[2],
    height: o / r[2]
  };
  return pt(s, tn(i)) > 0;
}
const gd = ({ source: e, sourceHandle: t, target: n, targetHandle: o }) => `xy-edge__${e}${t || ""}-${n}${o || ""}`, pd = (e, t) => t.some((n) => n.source === e.source && n.target === e.target && (n.sourceHandle === e.sourceHandle || !n.sourceHandle && !e.sourceHandle) && (n.targetHandle === e.targetHandle || !n.targetHandle && !e.targetHandle)), md = (e, t) => {
  if (!e.source || !e.target)
    return t;
  let n;
  return ni(e) ? n = { ...e } : n = {
    ...e,
    id: gd(e)
  }, pd(n, t) ? t : (n.sourceHandle === null && delete n.sourceHandle, n.targetHandle === null && delete n.targetHandle, t.concat(n));
};
function mi({ sourceX: e, sourceY: t, targetX: n, targetY: o }) {
  const [r, i, s, a] = pi({
    sourceX: e,
    sourceY: t,
    targetX: n,
    targetY: o
  });
  return [`M ${e},${t}L ${n},${o}`, r, i, s, a];
}
const Bo = {
  [B.Left]: { x: -1, y: 0 },
  [B.Right]: { x: 1, y: 0 },
  [B.Top]: { x: 0, y: -1 },
  [B.Bottom]: { x: 0, y: 1 }
}, yd = ({ source: e, sourcePosition: t = B.Bottom, target: n }) => t === B.Left || t === B.Right ? e.x < n.x ? { x: 1, y: 0 } : { x: -1, y: 0 } : e.y < n.y ? { x: 0, y: 1 } : { x: 0, y: -1 }, Fo = (e, t) => Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
function wd({ source: e, sourcePosition: t = B.Bottom, target: n, targetPosition: o = B.Top, center: r, offset: i }) {
  const s = Bo[t], a = Bo[o], c = { x: e.x + s.x * i, y: e.y + s.y * i }, l = { x: n.x + a.x * i, y: n.y + a.y * i }, d = yd({
    source: c,
    sourcePosition: t,
    target: l
  }), u = d.x !== 0 ? "x" : "y", f = d[u];
  let h = [], p, y;
  const _ = { x: 0, y: 0 }, x = { x: 0, y: 0 }, [b, m, w, N] = pi({
    sourceX: e.x,
    sourceY: e.y,
    targetX: n.x,
    targetY: n.y
  });
  if (s[u] * a[u] === -1) {
    p = r.x ?? b, y = r.y ?? m;
    const S = [
      { x: p, y: c.y },
      { x: p, y: l.y }
    ], P = [
      { x: c.x, y },
      { x: l.x, y }
    ];
    s[u] === f ? h = u === "x" ? S : P : h = u === "x" ? P : S;
  } else {
    const S = [{ x: c.x, y: l.y }], P = [{ x: l.x, y: c.y }];
    if (u === "x" ? h = s.x === f ? P : S : h = s.y === f ? S : P, t === o) {
      const H = Math.abs(e[u] - n[u]);
      if (H <= i) {
        const g = Math.min(i - 1, i - H);
        s[u] === f ? _[u] = (c[u] > e[u] ? -1 : 1) * g : x[u] = (l[u] > n[u] ? -1 : 1) * g;
      }
    }
    if (t !== o) {
      const H = u === "x" ? "y" : "x", g = s[u] === a[H], E = c[H] > l[H], v = c[H] < l[H];
      (s[u] === 1 && (!g && E || g && v) || s[u] !== 1 && (!g && v || g && E)) && (h = u === "x" ? S : P);
    }
    const I = { x: c.x + _.x, y: c.y + _.y }, A = { x: l.x + x.x, y: l.y + x.y }, V = Math.max(Math.abs(I.x - h[0].x), Math.abs(A.x - h[0].x)), D = Math.max(Math.abs(I.y - h[0].y), Math.abs(A.y - h[0].y));
    V >= D ? (p = (I.x + A.x) / 2, y = h[0].y) : (p = h[0].x, y = (I.y + A.y) / 2);
  }
  return [[
    e,
    { x: c.x + _.x, y: c.y + _.y },
    ...h,
    { x: l.x + x.x, y: l.y + x.y },
    n
  ], p, y, w, N];
}
function xd(e, t, n, o) {
  const r = Math.min(Fo(e, t) / 2, Fo(t, n) / 2, o), { x: i, y: s } = t;
  if (e.x === i && i === n.x || e.y === s && s === n.y)
    return `L${i} ${s}`;
  if (e.y === s) {
    const l = e.x < n.x ? -1 : 1, d = e.y < n.y ? 1 : -1;
    return `L ${i + r * l},${s}Q ${i},${s} ${i},${s + r * d}`;
  }
  const a = e.x < n.x ? 1 : -1, c = e.y < n.y ? -1 : 1;
  return `L ${i},${s + r * c}Q ${i},${s} ${i + r * a},${s}`;
}
function Rn({ sourceX: e, sourceY: t, sourcePosition: n = B.Bottom, targetX: o, targetY: r, targetPosition: i = B.Top, borderRadius: s = 5, centerX: a, centerY: c, offset: l = 20 }) {
  const [d, u, f, h, p] = wd({
    source: { x: e, y: t },
    sourcePosition: n,
    target: { x: o, y: r },
    targetPosition: i,
    center: { x: a, y: c },
    offset: l
  });
  return [d.reduce((_, x, b) => {
    let m = "";
    return b > 0 && b < d.length - 1 ? m = xd(d[b - 1], x, d[b + 1], s) : m = `${b === 0 ? "M" : "L"}${x.x} ${x.y}`, _ += m, _;
  }, ""), u, f, h, p];
}
function Xo(e) {
  return e && !!(e.internals.handleBounds || e.handles?.length) && !!(e.measured.width || e.width || e.initialWidth);
}
function vd(e) {
  const { sourceNode: t, targetNode: n } = e;
  if (!Xo(t) || !Xo(n))
    return null;
  const o = t.internals.handleBounds || Yo(t.handles), r = n.internals.handleBounds || Yo(n.handles), i = Zo(o?.source ?? [], e.sourceHandle), s = Zo(
    // when connection type is loose we can define all handles as sources and connect source -> source
    e.connectionMode === We.Strict ? r?.target ?? [] : (r?.target ?? []).concat(r?.source ?? []),
    e.targetHandle
  );
  if (!i || !s)
    return e.onError?.("008", Ne.error008(i ? "target" : "source", {
      id: e.id,
      sourceHandle: e.sourceHandle,
      targetHandle: e.targetHandle
    })), null;
  const a = i?.position || B.Bottom, c = s?.position || B.Top, l = mt(t, i, a), d = mt(n, s, c);
  return {
    sourceX: l.x,
    sourceY: l.y,
    targetX: d.x,
    targetY: d.y,
    sourcePosition: a,
    targetPosition: c
  };
}
function Yo(e) {
  if (!e)
    return null;
  const t = [], n = [];
  for (const o of e)
    o.width = o.width ?? 1, o.height = o.height ?? 1, o.type === "source" ? t.push(o) : o.type === "target" && n.push(o);
  return {
    source: t,
    target: n
  };
}
function mt(e, t, n = B.Left, o = !1) {
  const r = (t?.x ?? 0) + e.internals.positionAbsolute.x, i = (t?.y ?? 0) + e.internals.positionAbsolute.y, { width: s, height: a } = t ?? Ce(e);
  if (o)
    return { x: r + s / 2, y: i + a / 2 };
  switch (t?.position ?? n) {
    case B.Top:
      return { x: r + s / 2, y: i };
    case B.Right:
      return { x: r + s, y: i + a / 2 };
    case B.Bottom:
      return { x: r + s / 2, y: i + a };
    case B.Left:
      return { x: r, y: i + a / 2 };
  }
}
function Zo(e, t) {
  return e && (t ? e.find((n) => n.id === t) : e[0]) || null;
}
function Ln(e, t) {
  return e ? typeof e == "string" ? e : `${t ? `${t}__` : ""}${Object.keys(e).sort().map((o) => `${o}=${e[o]}`).join("&")}` : "";
}
function _d(e, { id: t, defaultColor: n, defaultMarkerStart: o, defaultMarkerEnd: r }) {
  const i = /* @__PURE__ */ new Set();
  return e.reduce((s, a) => ([a.markerStart || o, a.markerEnd || r].forEach((c) => {
    if (c && typeof c == "object") {
      const l = Ln(c, t);
      i.has(l) || (s.push({ id: l, color: c.color || n, ...c }), i.add(l));
    }
  }), s), []).sort((s, a) => s.id.localeCompare(a.id));
}
function bd(e, t, n, o, r) {
  let i = 0.5;
  r === "start" ? i = 0 : r === "end" && (i = 1);
  let s = [
    (e.x + e.width * i) * t.zoom + t.x,
    e.y * t.zoom + t.y - o
  ], a = [-100 * i, -100];
  switch (n) {
    case B.Right:
      s = [
        (e.x + e.width) * t.zoom + t.x + o,
        (e.y + e.height * i) * t.zoom + t.y
      ], a = [0, -100 * i];
      break;
    case B.Bottom:
      s[1] = (e.y + e.height) * t.zoom + t.y + o, a[1] = 0;
      break;
    case B.Left:
      s = [
        e.x * t.zoom + t.x - o,
        (e.y + e.height * i) * t.zoom + t.y
      ], a = [-100, -100 * i];
      break;
  }
  return `translate(${s[0]}px, ${s[1]}px) translate(${a[0]}%, ${a[1]}%)`;
}
const no = {
  nodeOrigin: [0, 0],
  nodeExtent: ht,
  elevateNodesOnSelect: !0,
  defaults: {}
}, Ed = {
  ...no,
  checkEquality: !0
};
function oo(e, t) {
  const n = { ...e };
  for (const o in t)
    t[o] !== void 0 && (n[o] = t[o]);
  return n;
}
function Sd(e, t, n) {
  const o = oo(no, n);
  for (const r of e.values())
    if (r.parentId)
      ro(r, e, t, o);
    else {
      const i = _t(r, o.nodeOrigin), s = Ke(r.extent) ? r.extent : o.nodeExtent, a = Oe(i, s, Ce(r));
      r.internals.positionAbsolute = a;
    }
}
function Bn(e, t, n, o) {
  const r = oo(Ed, o), i = new Map(t), s = r?.elevateNodesOnSelect ? 1e3 : 0;
  t.clear(), n.clear();
  for (const a of e) {
    let c = i.get(a.id);
    if (r.checkEquality && a === c?.internals.userNode)
      t.set(a.id, c);
    else {
      const l = _t(a, r.nodeOrigin), d = Ke(a.extent) ? a.extent : r.nodeExtent, u = Oe(l, d, Ce(a));
      c = {
        ...r.defaults,
        ...a,
        measured: {
          width: a.measured?.width,
          height: a.measured?.height
        },
        internals: {
          positionAbsolute: u,
          // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured
          handleBounds: a.measured ? c?.internals.handleBounds : void 0,
          z: yi(a, s),
          userNode: a
        }
      }, t.set(a.id, c);
    }
    a.parentId && ro(c, t, n, o);
  }
}
function Nd(e, t) {
  if (!e.parentId)
    return;
  const n = t.get(e.parentId);
  n ? n.set(e.id, e) : t.set(e.parentId, /* @__PURE__ */ new Map([[e.id, e]]));
}
function ro(e, t, n, o) {
  const { elevateNodesOnSelect: r, nodeOrigin: i, nodeExtent: s } = oo(no, o), a = e.parentId, c = t.get(a);
  if (!c) {
    console.warn(`Parent node ${a} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);
    return;
  }
  Nd(e, n);
  const l = r ? 1e3 : 0, { x: d, y: u, z: f } = Cd(e, c, i, s, l), { positionAbsolute: h } = e.internals, p = d !== h.x || u !== h.y;
  (p || f !== e.internals.z) && t.set(e.id, {
    ...e,
    internals: {
      ...e.internals,
      positionAbsolute: p ? { x: d, y: u } : h,
      z: f
    }
  });
}
function yi(e, t) {
  return (pe(e.zIndex) ? e.zIndex : 0) + (e.selected ? t : 0);
}
function Cd(e, t, n, o, r) {
  const { x: i, y: s } = t.internals.positionAbsolute, a = Ce(e), c = _t(e, n), l = Ke(e.extent) ? Oe(c, e.extent, a) : c;
  let d = Oe({ x: i + l.x, y: s + l.y }, o, a);
  e.extent === "parent" && (d = ii(d, a, t));
  const u = yi(e, r), f = t.internals.z ?? 0;
  return {
    x: d.x,
    y: d.y,
    z: f > u ? f : u
  };
}
function io(e, t, n, o = [0, 0]) {
  const r = [], i = /* @__PURE__ */ new Map();
  for (const s of e) {
    const a = t.get(s.parentId);
    if (!a)
      continue;
    const c = i.get(s.parentId)?.expandedRect ?? Ge(a), l = ai(c, s.rect);
    i.set(s.parentId, { expandedRect: l, parent: a });
  }
  return i.size > 0 && i.forEach(({ expandedRect: s, parent: a }, c) => {
    const l = a.internals.positionAbsolute, d = Ce(a), u = a.origin ?? o, f = s.x < l.x ? Math.round(Math.abs(l.x - s.x)) : 0, h = s.y < l.y ? Math.round(Math.abs(l.y - s.y)) : 0, p = Math.max(d.width, Math.round(s.width)), y = Math.max(d.height, Math.round(s.height)), _ = (p - d.width) * u[0], x = (y - d.height) * u[1];
    (f > 0 || h > 0 || _ || x) && (r.push({
      id: c,
      type: "position",
      position: {
        x: a.position.x - f + _,
        y: a.position.y - h + x
      }
    }), n.get(c)?.forEach((b) => {
      e.some((m) => m.id === b.id) || r.push({
        id: b.id,
        type: "position",
        position: {
          x: b.position.x + f,
          y: b.position.y + h
        }
      });
    })), (d.width < s.width || d.height < s.height || f || h) && r.push({
      id: c,
      type: "dimensions",
      setAttributes: !0,
      dimensions: {
        width: p + (f ? u[0] * f - _ : 0),
        height: y + (h ? u[1] * h - x : 0)
      }
    });
  }), r;
}
function Md(e, t, n, o, r, i) {
  const s = o?.querySelector(".xyflow__viewport");
  let a = !1;
  if (!s)
    return { changes: [], updatedInternals: a };
  const c = [], l = window.getComputedStyle(s), { m22: d } = new window.DOMMatrixReadOnly(l.transform), u = [];
  for (const f of e.values()) {
    const h = t.get(f.id);
    if (!h)
      continue;
    if (h.hidden) {
      t.set(h.id, {
        ...h,
        internals: {
          ...h.internals,
          handleBounds: void 0
        }
      }), a = !0;
      continue;
    }
    const p = on(f.nodeElement), y = h.measured.width !== p.width || h.measured.height !== p.height;
    if (!!(p.width && p.height && (y || !h.internals.handleBounds || f.force))) {
      const x = f.nodeElement.getBoundingClientRect(), b = Ke(h.extent) ? h.extent : i;
      let { positionAbsolute: m } = h.internals;
      h.parentId && h.extent === "parent" ? m = ii(m, p, t.get(h.parentId)) : b && (m = Oe(m, b, p));
      const w = {
        ...h,
        measured: p,
        internals: {
          ...h.internals,
          positionAbsolute: m,
          handleBounds: {
            source: Ro("source", f.nodeElement, x, d, h.id),
            target: Ro("target", f.nodeElement, x, d, h.id)
          }
        }
      };
      t.set(h.id, w), h.parentId && ro(w, t, n, { nodeOrigin: r }), a = !0, y && (c.push({
        id: h.id,
        type: "dimensions",
        dimensions: p
      }), h.expandParent && h.parentId && u.push({
        id: h.id,
        parentId: h.parentId,
        rect: Ge(w, r)
      }));
    }
  }
  if (u.length > 0) {
    const f = io(u, t, n, r);
    c.push(...f);
  }
  return { changes: c, updatedInternals: a };
}
async function kd({ delta: e, panZoom: t, transform: n, translateExtent: o, width: r, height: i }) {
  if (!t || !e.x && !e.y)
    return Promise.resolve(!1);
  const s = await t.setViewportConstrained({
    x: n[0] + e.x,
    y: n[1] + e.y,
    zoom: n[2]
  }, [
    [0, 0],
    [r, i]
  ], o), a = !!s && (s.x !== n[0] || s.y !== n[1] || s.k !== n[2]);
  return Promise.resolve(a);
}
function Wo(e, t, n, o, r, i) {
  let s = r;
  const a = o.get(s) || /* @__PURE__ */ new Map();
  o.set(s, a.set(n, t)), s = `${r}-${e}`;
  const c = o.get(s) || /* @__PURE__ */ new Map();
  if (o.set(s, c.set(n, t)), i) {
    s = `${r}-${e}-${i}`;
    const l = o.get(s) || /* @__PURE__ */ new Map();
    o.set(s, l.set(n, t));
  }
}
function wi(e, t, n) {
  e.clear(), t.clear();
  for (const o of n) {
    const { source: r, target: i, sourceHandle: s = null, targetHandle: a = null } = o, c = { edgeId: o.id, source: r, target: i, sourceHandle: s, targetHandle: a }, l = `${r}-${s}--${i}-${a}`, d = `${i}-${a}--${r}-${s}`;
    Wo("source", c, d, e, r, s), Wo("target", c, l, e, i, a), t.set(o.id, o);
  }
}
function xi(e, t) {
  if (!e.parentId)
    return !1;
  const n = t.get(e.parentId);
  return n ? n.selected ? !0 : xi(n, t) : !1;
}
function qo(e, t, n) {
  let o = e;
  do {
    if (o?.matches?.(t))
      return !0;
    if (o === n)
      return !1;
    o = o?.parentElement;
  } while (o);
  return !1;
}
function $d(e, t, n, o) {
  const r = /* @__PURE__ */ new Map();
  for (const [i, s] of e)
    if ((s.selected || s.id === o) && (!s.parentId || !xi(s, e)) && (s.draggable || t && typeof s.draggable > "u")) {
      const a = e.get(i);
      a && r.set(i, {
        id: i,
        position: a.position || { x: 0, y: 0 },
        distance: {
          x: n.x - a.internals.positionAbsolute.x,
          y: n.y - a.internals.positionAbsolute.y
        },
        extent: a.extent,
        parentId: a.parentId,
        origin: a.origin,
        expandParent: a.expandParent,
        internals: {
          positionAbsolute: a.internals.positionAbsolute || { x: 0, y: 0 }
        },
        measured: {
          width: a.measured.width ?? 0,
          height: a.measured.height ?? 0
        }
      });
    }
  return r;
}
function bn({ nodeId: e, dragItems: t, nodeLookup: n, dragging: o = !0 }) {
  const r = [];
  for (const [s, a] of t) {
    const c = n.get(s)?.internals.userNode;
    c && r.push({
      ...c,
      position: a.position,
      dragging: o
    });
  }
  if (!e)
    return [r[0], r];
  const i = n.get(e)?.internals.userNode;
  return [
    i ? {
      ...i,
      position: t.get(e)?.position || i.position,
      dragging: o
    } : r[0],
    r
  ];
}
function Id({ onNodeMouseDown: e, getStoreItems: t, onDragStart: n, onDrag: o, onDragStop: r }) {
  let i = { x: null, y: null }, s = 0, a = /* @__PURE__ */ new Map(), c = !1, l = { x: 0, y: 0 }, d = null, u = !1, f = null, h = !1;
  function p({ noDragClassName: _, handleSelector: x, domNode: b, isSelectable: m, nodeId: w, nodeClickDistance: N = 0 }) {
    f = le(b);
    function k({ x: A, y: V }, D) {
      const { nodeLookup: H, nodeExtent: g, snapGrid: E, snapToGrid: v, nodeOrigin: M, onNodeDrag: $, onSelectionDrag: C, onError: T, updateNodePositions: O } = t();
      i = { x: A, y: V };
      let R = !1, W = { x: 0, y: 0, x2: 0, y2: 0 };
      if (a.size > 1 && g) {
        const Y = Ue(a);
        W = Vn(Y);
      }
      for (const [Y, F] of a) {
        if (!H.has(Y))
          continue;
        let Z = { x: A - F.distance.x, y: V - F.distance.y };
        v && (Z = nn(Z, E));
        let L = [
          [g[0][0], g[0][1]],
          [g[1][0], g[1][1]]
        ];
        if (a.size > 1 && g && !F.extent) {
          const { positionAbsolute: te } = F.internals, Q = te.x - W.x + g[0][0], q = te.x + F.measured.width - W.x2 + g[1][0], U = te.y - W.y + g[0][1], oe = te.y + F.measured.height - W.y2 + g[1][1];
          L = [
            [Q, U],
            [q, oe]
          ];
        }
        const { position: X, positionAbsolute: K } = ri({
          nodeId: Y,
          nextPosition: Z,
          nodeLookup: H,
          nodeExtent: L,
          nodeOrigin: M,
          onError: T
        });
        R = R || F.position.x !== X.x || F.position.y !== X.y, F.position = X, F.internals.positionAbsolute = K;
      }
      if (R && (O(a, !0), D && (o || $ || !w && C))) {
        const [Y, F] = bn({
          nodeId: w,
          dragItems: a,
          nodeLookup: H
        });
        o?.(D, a, Y, F), $?.(D, Y, F), w || C?.(D, F);
      }
    }
    async function S() {
      if (!d)
        return;
      const { transform: A, panBy: V, autoPanSpeed: D, autoPanOnNodeDrag: H } = t();
      if (!H) {
        c = !1, cancelAnimationFrame(s);
        return;
      }
      const [g, E] = si(l, d, D);
      (g !== 0 || E !== 0) && (i.x = (i.x ?? 0) - g / A[2], i.y = (i.y ?? 0) - E / A[2], await V({ x: g, y: E }) && k(i, null)), s = requestAnimationFrame(S);
    }
    function P(A) {
      const { nodeLookup: V, multiSelectionActive: D, nodesDraggable: H, transform: g, snapGrid: E, snapToGrid: v, selectNodesOnDrag: M, onNodeDragStart: $, onSelectionDragStart: C, unselectNodesAndEdges: T } = t();
      u = !0, (!M || !m) && !D && w && (V.get(w)?.selected || T()), m && M && w && e?.(w);
      const O = st(A.sourceEvent, { transform: g, snapGrid: E, snapToGrid: v, containerBounds: d });
      if (i = O, a = $d(V, H, O, w), a.size > 0 && (n || $ || !w && C)) {
        const [R, W] = bn({
          nodeId: w,
          dragItems: a,
          nodeLookup: V
        });
        n?.(A.sourceEvent, a, R, W), $?.(A.sourceEvent, R, W), w || C?.(A.sourceEvent, W);
      }
    }
    const I = Vr().clickDistance(N).on("start", (A) => {
      const { domNode: V, nodeDragThreshold: D, transform: H, snapGrid: g, snapToGrid: E } = t();
      d = V?.getBoundingClientRect() || null, h = !1, D === 0 && P(A), i = st(A.sourceEvent, { transform: H, snapGrid: g, snapToGrid: E, containerBounds: d }), l = be(A.sourceEvent, d);
    }).on("drag", (A) => {
      const { autoPanOnNodeDrag: V, transform: D, snapGrid: H, snapToGrid: g, nodeDragThreshold: E, nodeLookup: v } = t(), M = st(A.sourceEvent, { transform: D, snapGrid: H, snapToGrid: g, containerBounds: d });
      if ((A.sourceEvent.type === "touchmove" && A.sourceEvent.touches.length > 1 || // if user deletes a node while dragging, we need to abort the drag to prevent errors
      w && !v.has(w)) && (h = !0), !h) {
        if (!c && V && u && (c = !0, S()), !u) {
          const $ = M.xSnapped - (i.x ?? 0), C = M.ySnapped - (i.y ?? 0);
          Math.sqrt($ * $ + C * C) > E && P(A);
        }
        (i.x !== M.xSnapped || i.y !== M.ySnapped) && a && u && (l = be(A.sourceEvent, d), k(M, A.sourceEvent));
      }
    }).on("end", (A) => {
      if (!(!u || h) && (c = !1, u = !1, cancelAnimationFrame(s), a.size > 0)) {
        const { nodeLookup: V, updateNodePositions: D, onNodeDragStop: H, onSelectionDragStop: g } = t();
        if (D(a, !1), r || H || !w && g) {
          const [E, v] = bn({
            nodeId: w,
            dragItems: a,
            nodeLookup: V,
            dragging: !1
          });
          r?.(A.sourceEvent, a, E, v), H?.(A.sourceEvent, E, v), w || g?.(A.sourceEvent, v);
        }
      }
    }).filter((A) => {
      const V = A.target;
      return !A.button && (!_ || !qo(V, `.${_}`, b)) && (!x || qo(V, x, b));
    });
    f.call(I);
  }
  function y() {
    f?.on(".drag", null);
  }
  return {
    update: p,
    destroy: y
  };
}
function Ad(e, t, n) {
  const o = [], r = {
    x: e.x - n,
    y: e.y - n,
    width: n * 2,
    height: n * 2
  };
  for (const i of t.values())
    pt(r, Ge(i)) > 0 && o.push(i);
  return o;
}
const Pd = 250;
function zd(e, t, n, o) {
  let r = [], i = 1 / 0;
  const s = Ad(e, n, t + Pd);
  for (const a of s) {
    const c = [...a.internals.handleBounds?.source ?? [], ...a.internals.handleBounds?.target ?? []];
    for (const l of c) {
      if (o.nodeId === l.nodeId && o.type === l.type && o.id === l.id)
        continue;
      const { x: d, y: u } = mt(a, l, l.position, !0), f = Math.sqrt(Math.pow(d - e.x, 2) + Math.pow(u - e.y, 2));
      f > t || (f < i ? (r = [{ ...l, x: d, y: u }], i = f) : f === i && r.push({ ...l, x: d, y: u }));
    }
  }
  if (!r.length)
    return null;
  if (r.length > 1) {
    const a = o.type === "source" ? "target" : "source";
    return r.find((c) => c.type === a) ?? r[0];
  }
  return r[0];
}
function vi(e, t, n, o, r, i = !1) {
  const s = o.get(e);
  if (!s)
    return null;
  const a = r === "strict" ? s.internals.handleBounds?.[t] : [...s.internals.handleBounds?.source ?? [], ...s.internals.handleBounds?.target ?? []], c = (n ? a?.find((l) => l.id === n) : a?.[0]) ?? null;
  return c && i ? { ...c, ...mt(s, c, c.position, !0) } : c;
}
function _i(e, t) {
  return e || (t?.classList.contains("target") ? "target" : t?.classList.contains("source") ? "source" : null);
}
function Td(e, t) {
  let n = null;
  return t ? n = !0 : e && !t && (n = !1), n;
}
const bi = () => !0;
function Dd(e, { connectionMode: t, connectionRadius: n, handleId: o, nodeId: r, edgeUpdaterType: i, isTarget: s, domNode: a, nodeLookup: c, lib: l, autoPanOnConnect: d, flowId: u, panBy: f, cancelConnection: h, onConnectStart: p, onConnect: y, onConnectEnd: _, isValidConnection: x = bi, onReconnectEnd: b, updateConnection: m, getTransform: w, getFromHandle: N, autoPanSpeed: k }) {
  const S = di(e.target);
  let P = 0, I;
  const { x: A, y: V } = be(e), D = S?.elementFromPoint(A, V), H = _i(i, D), g = a?.getBoundingClientRect();
  if (!g || !H)
    return;
  const E = vi(r, H, o, c, t);
  if (!E)
    return;
  let v = be(e, g), M = !1, $ = null, C = !1, T = null;
  function O() {
    if (!d || !g)
      return;
    const [K, te] = si(v, g, k);
    f({ x: K, y: te }), P = requestAnimationFrame(O);
  }
  const R = {
    ...E,
    nodeId: r,
    type: H,
    position: E.position
  }, W = c.get(r), F = {
    inProgress: !0,
    isValid: null,
    from: mt(W, R, B.Left, !0),
    fromHandle: R,
    fromPosition: R.position,
    fromNode: W,
    to: v,
    toHandle: null,
    toPosition: Do[R.position],
    toNode: null
  };
  m(F);
  let Z = F;
  p?.(e, { nodeId: r, handleId: o, handleType: H });
  function L(K) {
    if (!N() || !R) {
      X(K);
      return;
    }
    const te = w();
    v = be(K, g), I = zd(bt(v, te, !1, [1, 1]), n, c, R), M || (O(), M = !0);
    const Q = Ei(K, {
      handle: I,
      connectionMode: t,
      fromNodeId: r,
      fromHandleId: o,
      fromType: s ? "target" : "source",
      isValidConnection: x,
      doc: S,
      lib: l,
      flowId: u,
      nodeLookup: c
    });
    T = Q.handleDomNode, $ = Q.connection, C = Td(!!I, Q.isValid);
    const q = {
      // from stays the same
      ...Z,
      isValid: C,
      to: I && C ? ci({ x: I.x, y: I.y }, te) : v,
      toHandle: Q.toHandle,
      toPosition: C && Q.toHandle ? Q.toHandle.position : Do[R.position],
      toNode: Q.toHandle ? c.get(Q.toHandle.nodeId) : null
    };
    C && I && Z.toHandle && q.toHandle && Z.toHandle.type === q.toHandle.type && Z.toHandle.nodeId === q.toHandle.nodeId && Z.toHandle.id === q.toHandle.id && Z.to.x === q.to.x && Z.to.y === q.to.y || (m(q), Z = q);
  }
  function X(K) {
    (I || T) && $ && C && y?.($);
    const { inProgress: te, ...Q } = Z, q = {
      ...Q,
      toPosition: Z.toHandle ? Z.toPosition : null
    };
    _?.(K, q), i && b?.(K, q), h(), cancelAnimationFrame(P), M = !1, C = !1, $ = null, T = null, S.removeEventListener("mousemove", L), S.removeEventListener("mouseup", X), S.removeEventListener("touchmove", L), S.removeEventListener("touchend", X);
  }
  S.addEventListener("mousemove", L), S.addEventListener("mouseup", X), S.addEventListener("touchmove", L), S.addEventListener("touchend", X);
}
function Ei(e, { handle: t, connectionMode: n, fromNodeId: o, fromHandleId: r, fromType: i, doc: s, lib: a, flowId: c, isValidConnection: l = bi, nodeLookup: d }) {
  const u = i === "target", f = t ? s.querySelector(`.${a}-flow__handle[data-id="${c}-${t?.nodeId}-${t?.id}-${t?.type}"]`) : null, { x: h, y: p } = be(e), y = s.elementFromPoint(h, p), _ = y?.classList.contains(`${a}-flow__handle`) ? y : f, x = {
    handleDomNode: _,
    isValid: !1,
    connection: null,
    toHandle: null
  };
  if (_) {
    const b = _i(void 0, _), m = _.getAttribute("data-nodeid"), w = _.getAttribute("data-handleid"), N = _.classList.contains("connectable"), k = _.classList.contains("connectableend");
    if (!m || !b)
      return x;
    const S = {
      source: u ? m : o,
      sourceHandle: u ? w : r,
      target: u ? o : m,
      targetHandle: u ? r : w
    };
    x.connection = S;
    const I = N && k && (n === We.Strict ? u && b === "source" || !u && b === "target" : m !== o || w !== r);
    x.isValid = I && l(S), x.toHandle = vi(m, b, w, d, n, !1);
  }
  return x;
}
const Fn = {
  onPointerDown: Dd,
  isValid: Ei
};
function Hd({ domNode: e, panZoom: t, getTransform: n, getViewScale: o }) {
  const r = le(e);
  function i({ translateExtent: a, width: c, height: l, zoomStep: d = 10, pannable: u = !0, zoomable: f = !0, inversePan: h = !1 }) {
    const p = (m) => {
      const w = n();
      if (m.sourceEvent.type !== "wheel" || !t)
        return;
      const N = -m.sourceEvent.deltaY * (m.sourceEvent.deltaMode === 1 ? 0.05 : m.sourceEvent.deltaMode ? 1 : 2e-3) * d, k = w[2] * Math.pow(2, N);
      t.scaleTo(k);
    };
    let y = [0, 0];
    const _ = (m) => {
      (m.sourceEvent.type === "mousedown" || m.sourceEvent.type === "touchstart") && (y = [
        m.sourceEvent.clientX ?? m.sourceEvent.touches[0].clientX,
        m.sourceEvent.clientY ?? m.sourceEvent.touches[0].clientY
      ]);
    }, x = (m) => {
      const w = n();
      if (m.sourceEvent.type !== "mousemove" && m.sourceEvent.type !== "touchmove" || !t)
        return;
      const N = [
        m.sourceEvent.clientX ?? m.sourceEvent.touches[0].clientX,
        m.sourceEvent.clientY ?? m.sourceEvent.touches[0].clientY
      ], k = [N[0] - y[0], N[1] - y[1]];
      y = N;
      const S = o() * Math.max(w[2], Math.log(w[2])) * (h ? -1 : 1), P = {
        x: w[0] - k[0] * S,
        y: w[1] - k[1] * S
      }, I = [
        [0, 0],
        [c, l]
      ];
      t.setViewportConstrained({
        x: P.x,
        y: P.y,
        zoom: w[2]
      }, I, a);
    }, b = Jr().on("start", _).on("zoom", u ? x : null).on("zoom.wheel", f ? p : null);
    r.call(b, {});
  }
  function s() {
    r.on("zoom", null);
  }
  return {
    update: i,
    destroy: s,
    pointer: he
  };
}
const Vd = (e, t) => e.x !== t.x || e.y !== t.y || e.zoom !== t.k, rn = (e) => ({
  x: e.x,
  y: e.y,
  zoom: e.k
}), En = ({ x: e, y: t, zoom: n }) => jt.translate(e, t).scale(n), Re = (e, t) => e.target.closest(`.${t}`), Si = (e, t) => t === 2 && Array.isArray(e) && e.includes(2), Sn = (e, t = 0, n = () => {
}) => {
  const o = typeof t == "number" && t > 0;
  return o || n(), o ? e.transition().duration(t).on("end", n) : e;
}, Ni = (e) => {
  const t = e.ctrlKey && Zt() ? 10 : 1;
  return -e.deltaY * (e.deltaMode === 1 ? 0.05 : e.deltaMode ? 1 : 2e-3) * t;
};
function Od({ zoomPanValues: e, noWheelClassName: t, d3Selection: n, d3Zoom: o, panOnScrollMode: r, panOnScrollSpeed: i, zoomOnPinch: s, onPanZoomStart: a, onPanZoom: c, onPanZoomEnd: l }) {
  return (d) => {
    if (Re(d, t))
      return !1;
    d.preventDefault(), d.stopImmediatePropagation();
    const u = n.property("__zoom").k || 1;
    if (d.ctrlKey && s) {
      const _ = he(d), x = Ni(d), b = u * Math.pow(2, x);
      o.scaleTo(n, b, _, d);
      return;
    }
    const f = d.deltaMode === 1 ? 20 : 1;
    let h = r === He.Vertical ? 0 : d.deltaX * f, p = r === He.Horizontal ? 0 : d.deltaY * f;
    !Zt() && d.shiftKey && r !== He.Vertical && (h = d.deltaY * f, p = 0), o.translateBy(
      n,
      -(h / u) * i,
      -(p / u) * i,
      // @ts-ignore
      { internal: !0 }
    );
    const y = rn(n.property("__zoom"));
    clearTimeout(e.panScrollTimeout), e.isPanScrolling || (e.isPanScrolling = !0, a?.(d, y)), e.isPanScrolling && (c?.(d, y), e.panScrollTimeout = setTimeout(() => {
      l?.(d, y), e.isPanScrolling = !1;
    }, 150));
  };
}
function Rd({ noWheelClassName: e, preventScrolling: t, d3ZoomHandler: n }) {
  return function(o, r) {
    if (!t && o.type === "wheel" && !o.ctrlKey || Re(o, e))
      return null;
    o.preventDefault(), n.call(this, o, r);
  };
}
function Ld({ zoomPanValues: e, onDraggingChange: t, onPanZoomStart: n }) {
  return (o) => {
    if (o.sourceEvent?.internal)
      return;
    const r = rn(o.transform);
    e.mouseButton = o.sourceEvent?.button || 0, e.isZoomingOrPanning = !0, e.prevViewport = r, o.sourceEvent?.type === "mousedown" && t(!0), n && n?.(o.sourceEvent, r);
  };
}
function Bd({ zoomPanValues: e, panOnDrag: t, onPaneContextMenu: n, onTransformChange: o, onPanZoom: r }) {
  return (i) => {
    e.usedRightMouseButton = !!(n && Si(t, e.mouseButton ?? 0)), i.sourceEvent?.sync || o([i.transform.x, i.transform.y, i.transform.k]), r && !i.sourceEvent?.internal && r?.(i.sourceEvent, rn(i.transform));
  };
}
function Fd({ zoomPanValues: e, panOnDrag: t, panOnScroll: n, onDraggingChange: o, onPanZoomEnd: r, onPaneContextMenu: i }) {
  return (s) => {
    if (!s.sourceEvent?.internal && (e.isZoomingOrPanning = !1, i && Si(t, e.mouseButton ?? 0) && !e.usedRightMouseButton && s.sourceEvent && i(s.sourceEvent), e.usedRightMouseButton = !1, o(!1), r && Vd(e.prevViewport, s.transform))) {
      const a = rn(s.transform);
      e.prevViewport = a, clearTimeout(e.timerId), e.timerId = setTimeout(
        () => {
          r?.(s.sourceEvent, a);
        },
        // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll
        n ? 150 : 0
      );
    }
  };
}
function Xd({ zoomActivationKeyPressed: e, zoomOnScroll: t, zoomOnPinch: n, panOnDrag: o, panOnScroll: r, zoomOnDoubleClick: i, userSelectionActive: s, noWheelClassName: a, noPanClassName: c, lib: l }) {
  return (d) => {
    const u = e || t, f = n && d.ctrlKey;
    if (d.button === 1 && d.type === "mousedown" && (Re(d, `${l}-flow__node`) || Re(d, `${l}-flow__edge`)))
      return !0;
    if (!o && !u && !r && !i && !n || s || Re(d, a) && d.type === "wheel" || Re(d, c) && (d.type !== "wheel" || r && d.type === "wheel" && !e) || !n && d.ctrlKey && d.type === "wheel")
      return !1;
    if (!n && d.type === "touchstart" && d.touches?.length > 1)
      return d.preventDefault(), !1;
    if (!u && !r && !f && d.type === "wheel" || !o && (d.type === "mousedown" || d.type === "touchstart") || Array.isArray(o) && !o.includes(d.button) && d.type === "mousedown")
      return !1;
    const h = Array.isArray(o) && o.includes(d.button) || !d.button || d.button <= 1;
    return (!d.ctrlKey || d.type === "wheel") && h;
  };
}
function Yd({ domNode: e, minZoom: t, maxZoom: n, paneClickDistance: o, translateExtent: r, viewport: i, onPanZoom: s, onPanZoomStart: a, onPanZoomEnd: c, onDraggingChange: l }) {
  const d = {
    isZoomingOrPanning: !1,
    usedRightMouseButton: !1,
    prevViewport: { x: 0, y: 0, zoom: 0 },
    mouseButton: 0,
    timerId: void 0,
    panScrollTimeout: void 0,
    isPanScrolling: !1
  }, u = e.getBoundingClientRect(), f = Jr().clickDistance(!pe(o) || o < 0 ? 0 : o).scaleExtent([t, n]).translateExtent(r), h = le(e).call(f);
  m({
    x: i.x,
    y: i.y,
    zoom: qe(i.zoom, t, n)
  }, [
    [0, 0],
    [u.width, u.height]
  ], r);
  const p = h.on("wheel.zoom"), y = h.on("dblclick.zoom");
  f.wheelDelta(Ni);
  function _(D, H) {
    return h ? new Promise((g) => {
      f?.transform(Sn(h, H?.duration, () => g(!0)), D);
    }) : Promise.resolve(!1);
  }
  function x({ noWheelClassName: D, noPanClassName: H, onPaneContextMenu: g, userSelectionActive: E, panOnScroll: v, panOnDrag: M, panOnScrollMode: $, panOnScrollSpeed: C, preventScrolling: T, zoomOnPinch: O, zoomOnScroll: R, zoomOnDoubleClick: W, zoomActivationKeyPressed: Y, lib: F, onTransformChange: Z }) {
    E && !d.isZoomingOrPanning && b();
    const X = v && !Y && !E ? Od({
      zoomPanValues: d,
      noWheelClassName: D,
      d3Selection: h,
      d3Zoom: f,
      panOnScrollMode: $,
      panOnScrollSpeed: C,
      zoomOnPinch: O,
      onPanZoomStart: a,
      onPanZoom: s,
      onPanZoomEnd: c
    }) : Rd({
      noWheelClassName: D,
      preventScrolling: T,
      d3ZoomHandler: p
    });
    if (h.on("wheel.zoom", X, { passive: !1 }), !E) {
      const te = Ld({
        zoomPanValues: d,
        onDraggingChange: l,
        onPanZoomStart: a
      });
      f.on("start", te);
      const Q = Bd({
        zoomPanValues: d,
        panOnDrag: M,
        onPaneContextMenu: !!g,
        onPanZoom: s,
        onTransformChange: Z
      });
      f.on("zoom", Q);
      const q = Fd({
        zoomPanValues: d,
        panOnDrag: M,
        panOnScroll: v,
        onPaneContextMenu: g,
        onPanZoomEnd: c,
        onDraggingChange: l
      });
      f.on("end", q);
    }
    const K = Xd({
      zoomActivationKeyPressed: Y,
      panOnDrag: M,
      zoomOnScroll: R,
      panOnScroll: v,
      zoomOnDoubleClick: W,
      zoomOnPinch: O,
      userSelectionActive: E,
      noPanClassName: H,
      noWheelClassName: D,
      lib: F
    });
    f.filter(K), W ? h.on("dblclick.zoom", y) : h.on("dblclick.zoom", null);
  }
  function b() {
    f.on("zoom", null);
  }
  async function m(D, H, g) {
    const E = En(D), v = f?.constrain()(E, H, g);
    return v && await _(v), new Promise((M) => M(v));
  }
  async function w(D, H) {
    const g = En(D);
    return await _(g, H), new Promise((E) => E(g));
  }
  function N(D) {
    if (h) {
      const H = En(D), g = h.property("__zoom");
      (g.k !== D.zoom || g.x !== D.x || g.y !== D.y) && f?.transform(h, H, null, { sync: !0 });
    }
  }
  function k() {
    const D = h ? Qr(h.node()) : { x: 0, y: 0, k: 1 };
    return { x: D.x, y: D.y, zoom: D.k };
  }
  function S(D, H) {
    return h ? new Promise((g) => {
      f?.scaleTo(Sn(h, H?.duration, () => g(!0)), D);
    }) : Promise.resolve(!1);
  }
  function P(D, H) {
    return h ? new Promise((g) => {
      f?.scaleBy(Sn(h, H?.duration, () => g(!0)), D);
    }) : Promise.resolve(!1);
  }
  function I(D) {
    f?.scaleExtent(D);
  }
  function A(D) {
    f?.translateExtent(D);
  }
  function V(D) {
    const H = !pe(D) || D < 0 ? 0 : D;
    f?.clickDistance(H);
  }
  return {
    update: x,
    destroy: b,
    setViewport: w,
    setViewportConstrained: m,
    getViewport: k,
    scaleTo: S,
    scaleBy: P,
    setScaleExtent: I,
    setTranslateExtent: A,
    syncViewport: N,
    setClickDistance: V
  };
}
var at;
(function(e) {
  e.Line = "line", e.Handle = "handle";
})(at || (at = {}));
function Zd({ width: e, prevWidth: t, height: n, prevHeight: o, affectsX: r, affectsY: i }) {
  const s = e - t, a = n - o, c = [s > 0 ? 1 : s < 0 ? -1 : 0, a > 0 ? 1 : a < 0 ? -1 : 0];
  return s && r && (c[0] = c[0] * -1), a && i && (c[1] = c[1] * -1), c;
}
function Wd(e) {
  const t = e.includes("right") || e.includes("left"), n = e.includes("bottom") || e.includes("top"), o = e.includes("left"), r = e.includes("top");
  return {
    isHorizontal: t,
    isVertical: n,
    affectsX: o,
    affectsY: r
  };
}
function Me(e, t) {
  return Math.max(0, t - e);
}
function ke(e, t) {
  return Math.max(0, e - t);
}
function It(e, t, n) {
  return Math.max(0, t - e, e - n);
}
function Go(e, t) {
  return e ? !t : t;
}
function qd(e, t, n, o, r, i, s, a) {
  let { affectsX: c, affectsY: l } = t;
  const { isHorizontal: d, isVertical: u } = t, f = d && u, { xSnapped: h, ySnapped: p } = n, { minWidth: y, maxWidth: _, minHeight: x, maxHeight: b } = o, { x: m, y: w, width: N, height: k, aspectRatio: S } = e;
  let P = Math.floor(d ? h - e.pointerX : 0), I = Math.floor(u ? p - e.pointerY : 0);
  const A = N + (c ? -P : P), V = k + (l ? -I : I), D = -i[0] * N, H = -i[1] * k;
  let g = It(A, y, _), E = It(V, x, b);
  if (s) {
    let $ = 0, C = 0;
    c && P < 0 ? $ = Me(m + P + D, s[0][0]) : !c && P > 0 && ($ = ke(m + A + D, s[1][0])), l && I < 0 ? C = Me(w + I + H, s[0][1]) : !l && I > 0 && (C = ke(w + V + H, s[1][1])), g = Math.max(g, $), E = Math.max(E, C);
  }
  if (a) {
    let $ = 0, C = 0;
    c && P > 0 ? $ = ke(m + P, a[0][0]) : !c && P < 0 && ($ = Me(m + A, a[1][0])), l && I > 0 ? C = ke(w + I, a[0][1]) : !l && I < 0 && (C = Me(w + V, a[1][1])), g = Math.max(g, $), E = Math.max(E, C);
  }
  if (r) {
    if (d) {
      const $ = It(A / S, x, b) * S;
      if (g = Math.max(g, $), s) {
        let C = 0;
        !c && !l || c && !l && f ? C = ke(w + H + A / S, s[1][1]) * S : C = Me(w + H + (c ? P : -P) / S, s[0][1]) * S, g = Math.max(g, C);
      }
      if (a) {
        let C = 0;
        !c && !l || c && !l && f ? C = Me(w + A / S, a[1][1]) * S : C = ke(w + (c ? P : -P) / S, a[0][1]) * S, g = Math.max(g, C);
      }
    }
    if (u) {
      const $ = It(V * S, y, _) / S;
      if (E = Math.max(E, $), s) {
        let C = 0;
        !c && !l || l && !c && f ? C = ke(m + V * S + D, s[1][0]) / S : C = Me(m + (l ? I : -I) * S + D, s[0][0]) / S, E = Math.max(E, C);
      }
      if (a) {
        let C = 0;
        !c && !l || l && !c && f ? C = Me(m + V * S, a[1][0]) / S : C = ke(m + (l ? I : -I) * S, a[0][0]) / S, E = Math.max(E, C);
      }
    }
  }
  I = I + (I < 0 ? E : -E), P = P + (P < 0 ? g : -g), r && (f ? A > V * S ? I = (Go(c, l) ? -P : P) / S : P = (Go(c, l) ? -I : I) * S : d ? (I = P / S, l = c) : (P = I * S, c = l));
  const v = c ? m + P : m, M = l ? w + I : w;
  return {
    width: N + (c ? -P : P),
    height: k + (l ? -I : I),
    x: i[0] * P * (c ? -1 : 1) + v,
    y: i[1] * I * (l ? -1 : 1) + M
  };
}
const Ci = { width: 0, height: 0, x: 0, y: 0 }, Gd = {
  ...Ci,
  pointerX: 0,
  pointerY: 0,
  aspectRatio: 1
};
function Kd(e) {
  return [
    [0, 0],
    [e.measured.width, e.measured.height]
  ];
}
function Ud(e, t, n) {
  const o = t.position.x + e.position.x, r = t.position.y + e.position.y, i = e.measured.width ?? 0, s = e.measured.height ?? 0, a = n[0] * i, c = n[1] * s;
  return [
    [o - a, r - c],
    [o + i - a, r + s - c]
  ];
}
function Qd({ domNode: e, nodeId: t, getStoreItems: n, onChange: o, onEnd: r }) {
  const i = le(e);
  function s({ controlPosition: c, boundaries: l, keepAspectRatio: d, onResizeStart: u, onResize: f, onResizeEnd: h, shouldResize: p }) {
    let y = { ...Ci }, _ = { ...Gd };
    const x = Wd(c);
    let b, m = null, w = [], N, k, S;
    const P = Vr().on("start", (I) => {
      const { nodeLookup: A, transform: V, snapGrid: D, snapToGrid: H, nodeOrigin: g, paneDomNode: E } = n();
      if (b = A.get(t), !b)
        return;
      m = E?.getBoundingClientRect() ?? null;
      const { xSnapped: v, ySnapped: M } = st(I.sourceEvent, {
        transform: V,
        snapGrid: D,
        snapToGrid: H,
        containerBounds: m
      });
      y = {
        width: b.measured.width ?? 0,
        height: b.measured.height ?? 0,
        x: b.position.x ?? 0,
        y: b.position.y ?? 0
      }, _ = {
        ...y,
        pointerX: v,
        pointerY: M,
        aspectRatio: y.width / y.height
      }, N = void 0, b.parentId && (b.extent === "parent" || b.expandParent) && (N = A.get(b.parentId), k = N && b.extent === "parent" ? Kd(N) : void 0), w = [], S = void 0;
      for (const [$, C] of A)
        if (C.parentId === t && (w.push({
          id: $,
          position: { ...C.position },
          extent: C.extent
        }), C.extent === "parent" || C.expandParent)) {
          const T = Ud(C, b, C.origin ?? g);
          S ? S = [
            [Math.min(T[0][0], S[0][0]), Math.min(T[0][1], S[0][1])],
            [Math.max(T[1][0], S[1][0]), Math.max(T[1][1], S[1][1])]
          ] : S = T;
        }
      u?.(I, { ...y });
    }).on("drag", (I) => {
      const { transform: A, snapGrid: V, snapToGrid: D, nodeOrigin: H } = n(), g = st(I.sourceEvent, {
        transform: A,
        snapGrid: V,
        snapToGrid: D,
        containerBounds: m
      }), E = [];
      if (!b)
        return;
      const { x: v, y: M, width: $, height: C } = y, T = {}, O = b.origin ?? H, { width: R, height: W, x: Y, y: F } = qd(_, x, g, l, d, O, k, S), Z = R !== $, L = W !== C, X = Y !== v && Z, K = F !== M && L;
      if (!X && !K && !Z && !L)
        return;
      if ((X || K || O[0] === 1 || O[1] === 1) && (T.x = X ? Y : y.x, T.y = K ? F : y.y, y.x = T.x, y.y = T.y, w.length > 0)) {
        const U = Y - v, oe = F - M;
        for (const ae of w)
          ae.position = {
            x: ae.position.x - U + O[0] * (R - $),
            y: ae.position.y - oe + O[1] * (W - C)
          }, E.push(ae);
      }
      if ((Z || L) && (T.width = Z ? R : y.width, T.height = L ? W : y.height, y.width = T.width, y.height = T.height), N && b.expandParent) {
        const U = O[0] * (T.width ?? 0);
        T.x && T.x < U && (y.x = U, _.x = _.x - (T.x - U));
        const oe = O[1] * (T.height ?? 0);
        T.y && T.y < oe && (y.y = oe, _.y = _.y - (T.y - oe));
      }
      const te = Zd({
        width: y.width,
        prevWidth: $,
        height: y.height,
        prevHeight: C,
        affectsX: x.affectsX,
        affectsY: x.affectsY
      }), Q = { ...y, direction: te };
      p?.(I, Q) !== !1 && (f?.(I, Q), o(T, E));
    }).on("end", (I) => {
      h?.(I, { ...y }), r?.();
    });
    i.call(P);
  }
  function a() {
    i.on(".drag", null);
  }
  return {
    update: s,
    destroy: a
  };
}
const Jd = {}, Ko = (e) => {
  let t;
  const n = /* @__PURE__ */ new Set(), o = (d, u) => {
    const f = typeof d == "function" ? d(t) : d;
    if (!Object.is(f, t)) {
      const h = t;
      t = u ?? (typeof f != "object" || f === null) ? f : Object.assign({}, t, f), n.forEach((p) => p(t, h));
    }
  }, r = () => t, c = { setState: o, getState: r, getInitialState: () => l, subscribe: (d) => (n.add(d), () => n.delete(d)), destroy: () => {
    (Jd ? "production" : void 0) !== "production" && console.warn(
      "[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."
    ), n.clear();
  } }, l = t = e(o, r, c);
  return c;
}, jd = (e) => e ? Ko(e) : Ko, { useDebugValue: ef } = Yn, { useSyncExternalStoreWithSelector: tf } = $a, nf = (e) => e;
function Mi(e, t = nf, n) {
  const o = tf(
    e.subscribe,
    e.getState,
    e.getServerState || e.getInitialState,
    t,
    n
  );
  return ef(o), o;
}
const Uo = (e, t) => {
  const n = jd(e), o = (r, i = t) => Mi(n, r, i);
  return Object.assign(o, n), o;
}, of = (e, t) => e ? Uo(e, t) : Uo;
function ne(e, t) {
  if (Object.is(e, t))
    return !0;
  if (typeof e != "object" || e === null || typeof t != "object" || t === null)
    return !1;
  if (e instanceof Map && t instanceof Map) {
    if (e.size !== t.size) return !1;
    for (const [o, r] of e)
      if (!Object.is(r, t.get(o)))
        return !1;
    return !0;
  }
  if (e instanceof Set && t instanceof Set) {
    if (e.size !== t.size) return !1;
    for (const o of e)
      if (!t.has(o))
        return !1;
    return !0;
  }
  const n = Object.keys(e);
  if (n.length !== Object.keys(t).length)
    return !1;
  for (const o of n)
    if (!Object.prototype.hasOwnProperty.call(t, o) || !Object.is(e[o], t[o]))
      return !1;
  return !0;
}
const sn = Zn(null), rf = sn.Provider, ki = Ne.error001();
function G(e, t) {
  const n = wt(sn);
  if (n === null)
    throw new Error(ki);
  return Mi(n, e, t);
}
function ee() {
  const e = wt(sn);
  if (e === null)
    throw new Error(ki);
  return me(() => ({
    getState: e.getState,
    setState: e.setState,
    subscribe: e.subscribe
  }), [e]);
}
const Qo = { display: "none" }, sf = {
  position: "absolute",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0px, 0px, 0px, 0px)",
  clipPath: "inset(100%)"
}, $i = "react-flow__node-desc", Ii = "react-flow__edge-desc", af = "react-flow__aria-live", cf = (e) => e.ariaLiveMessage;
function lf({ rfId: e }) {
  const t = G(cf);
  return z("div", { id: `${af}-${e}`, "aria-live": "assertive", "aria-atomic": "true", style: sf, children: t });
}
function uf({ rfId: e, disableKeyboardA11y: t }) {
  return se(Se, { children: [se("div", { id: `${$i}-${e}`, style: Qo, children: ["Press enter or space to select a node.", !t && "You can then use the arrow keys to move the node around.", " Press delete to remove it and escape to cancel.", " "] }), z("div", { id: `${Ii}-${e}`, style: Qo, children: "Press enter or space to select an edge. You can then press delete to remove it or escape to cancel." }), !t && z(lf, { rfId: e })] });
}
const df = (e) => e.userSelectionActive ? "none" : "all", an = xr(({ position: e = "top-left", children: t, className: n, style: o, ...r }, i) => {
  const s = G(df), a = `${e}`.split("-");
  return z("div", { className: re(["react-flow__panel", n, ...a]), style: { ...o, pointerEvents: s }, ref: i, ...r, children: t });
});
an.displayName = "Panel";
function ff({ proOptions: e, position: t = "bottom-right" }) {
  return e?.hideAttribution ? null : z(an, { position: t, className: "react-flow__attribution", "data-message": "Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev", children: z("a", { href: "https://reactflow.dev", target: "_blank", rel: "noopener noreferrer", "aria-label": "React Flow attribution", children: "React Flow" }) });
}
const hf = (e) => {
  const t = [], n = [];
  for (const [, o] of e.nodeLookup)
    o.selected && t.push(o.internals.userNode);
  for (const [, o] of e.edgeLookup)
    o.selected && n.push(o);
  return { selectedNodes: t, selectedEdges: n };
}, At = (e) => e.id;
function gf(e, t) {
  return ne(e.selectedNodes.map(At), t.selectedNodes.map(At)) && ne(e.selectedEdges.map(At), t.selectedEdges.map(At));
}
function pf({ onSelectionChange: e }) {
  const t = ee(), { selectedNodes: n, selectedEdges: o } = G(hf, gf);
  return j(() => {
    const r = { nodes: n, edges: o };
    e?.(r), t.getState().onSelectionChangeHandlers.forEach((i) => i(r));
  }, [n, o, e]), null;
}
const mf = (e) => !!e.onSelectionChangeHandlers;
function yf({ onSelectionChange: e }) {
  const t = G(mf);
  return e || t ? z(pf, { onSelectionChange: e }) : null;
}
const Ai = [0, 0], wf = { x: 0, y: 0, zoom: 1 }, xf = [
  "nodes",
  "edges",
  "defaultNodes",
  "defaultEdges",
  "onConnect",
  "onConnectStart",
  "onConnectEnd",
  "onClickConnectStart",
  "onClickConnectEnd",
  "nodesDraggable",
  "nodesConnectable",
  "nodesFocusable",
  "edgesFocusable",
  "edgesReconnectable",
  "elevateNodesOnSelect",
  "elevateEdgesOnSelect",
  "minZoom",
  "maxZoom",
  "nodeExtent",
  "onNodesChange",
  "onEdgesChange",
  "elementsSelectable",
  "connectionMode",
  "snapGrid",
  "snapToGrid",
  "translateExtent",
  "connectOnClick",
  "defaultEdgeOptions",
  "fitView",
  "fitViewOptions",
  "onNodesDelete",
  "onEdgesDelete",
  "onDelete",
  "onNodeDrag",
  "onNodeDragStart",
  "onNodeDragStop",
  "onSelectionDrag",
  "onSelectionDragStart",
  "onSelectionDragStop",
  "onMoveStart",
  "onMove",
  "onMoveEnd",
  "noPanClassName",
  "nodeOrigin",
  "autoPanOnConnect",
  "autoPanOnNodeDrag",
  "onError",
  "connectionRadius",
  "isValidConnection",
  "selectNodesOnDrag",
  "nodeDragThreshold",
  "onBeforeDelete",
  "debug",
  "autoPanSpeed",
  "paneClickDistance"
], Jo = [...xf, "rfId"], vf = (e) => ({
  setNodes: e.setNodes,
  setEdges: e.setEdges,
  setMinZoom: e.setMinZoom,
  setMaxZoom: e.setMaxZoom,
  setTranslateExtent: e.setTranslateExtent,
  setNodeExtent: e.setNodeExtent,
  reset: e.reset,
  setDefaultNodesAndEdges: e.setDefaultNodesAndEdges,
  setPaneClickDistance: e.setPaneClickDistance
}), jo = {
  /*
   * these are values that are also passed directly to other components
   * than the StoreUpdater. We can reduce the number of setStore calls
   * by setting the same values here as prev fields.
   */
  translateExtent: ht,
  nodeOrigin: Ai,
  minZoom: 0.5,
  maxZoom: 2,
  elementsSelectable: !0,
  noPanClassName: "nopan",
  rfId: "1",
  paneClickDistance: 0
};
function _f(e) {
  const { setNodes: t, setEdges: n, setMinZoom: o, setMaxZoom: r, setTranslateExtent: i, setNodeExtent: s, reset: a, setDefaultNodesAndEdges: c, setPaneClickDistance: l } = G(vf, ne), d = ee();
  j(() => (c(e.defaultNodes, e.defaultEdges), () => {
    u.current = jo, a();
  }), []);
  const u = J(jo);
  return j(
    () => {
      for (const f of Jo) {
        const h = e[f], p = u.current[f];
        h !== p && (typeof e[f] > "u" || (f === "nodes" ? t(h) : f === "edges" ? n(h) : f === "minZoom" ? o(h) : f === "maxZoom" ? r(h) : f === "translateExtent" ? i(h) : f === "nodeExtent" ? s(h) : f === "paneClickDistance" ? l(h) : f === "fitView" ? d.setState({ fitViewOnInit: h }) : f === "fitViewOptions" ? d.setState({ fitViewOnInitOptions: h }) : d.setState({ [f]: h })));
      }
      u.current = e;
    },
    // Only re-run the effect if one of the fields we track changes
    Jo.map((f) => e[f])
  ), null;
}
function er() {
  return typeof window > "u" || !window.matchMedia ? null : window.matchMedia("(prefers-color-scheme: dark)");
}
function bf(e) {
  const [t, n] = fe(e === "system" ? null : e);
  return j(() => {
    if (e !== "system") {
      n(e);
      return;
    }
    const o = er(), r = () => n(o?.matches ? "dark" : "light");
    return r(), o?.addEventListener("change", r), () => {
      o?.removeEventListener("change", r);
    };
  }, [e]), t !== null ? t : er()?.matches ? "dark" : "light";
}
const tr = typeof document < "u" ? document : null;
function yt(e = null, t = { target: tr, actInsideInputWithModifier: !0 }) {
  const [n, o] = fe(!1), r = J(!1), i = J(/* @__PURE__ */ new Set([])), [s, a] = me(() => {
    if (e !== null) {
      const l = (Array.isArray(e) ? e : [e]).filter((u) => typeof u == "string").map((u) => u.replace("+", `
`).replace(`

`, `
+`).split(`
`)), d = l.reduce((u, f) => u.concat(...f), []);
      return [l, d];
    }
    return [[], []];
  }, [e]);
  return j(() => {
    const c = t?.target || tr;
    if (e !== null) {
      const l = (f) => {
        if (r.current = f.ctrlKey || f.metaKey || f.shiftKey, (!r.current || r.current && !t.actInsideInputWithModifier) && On(f))
          return !1;
        const p = or(f.code, a);
        i.current.add(f[p]), nr(s, i.current, !1) && (f.preventDefault(), o(!0));
      }, d = (f) => {
        if ((!r.current || r.current && !t.actInsideInputWithModifier) && On(f))
          return !1;
        const p = or(f.code, a);
        nr(s, i.current, !0) ? (o(!1), i.current.clear()) : i.current.delete(f[p]), f.key === "Meta" && i.current.clear(), r.current = !1;
      }, u = () => {
        i.current.clear(), o(!1);
      };
      return c?.addEventListener("keydown", l), c?.addEventListener("keyup", d), window.addEventListener("blur", u), window.addEventListener("contextmenu", u), () => {
        c?.removeEventListener("keydown", l), c?.removeEventListener("keyup", d), window.removeEventListener("blur", u), window.removeEventListener("contextmenu", u);
      };
    }
  }, [e, o]), n;
}
function nr(e, t, n) {
  return e.filter((o) => n || o.length === t.size).some((o) => o.every((r) => t.has(r)));
}
function or(e, t) {
  return t.includes(e) ? "code" : "key";
}
const Ef = () => {
  const e = ee();
  return me(() => ({
    zoomIn: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomOut: (t) => {
      const { panZoom: n } = e.getState();
      return n ? n.scaleBy(1 / 1.2, { duration: t?.duration }) : Promise.resolve(!1);
    },
    zoomTo: (t, n) => {
      const { panZoom: o } = e.getState();
      return o ? o.scaleTo(t, { duration: n?.duration }) : Promise.resolve(!1);
    },
    getZoom: () => e.getState().transform[2],
    setViewport: async (t, n) => {
      const { transform: [o, r, i], panZoom: s } = e.getState();
      return s ? (await s.setViewport({
        x: t.x ?? o,
        y: t.y ?? r,
        zoom: t.zoom ?? i
      }, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    getViewport: () => {
      const [t, n, o] = e.getState().transform;
      return { x: t, y: n, zoom: o };
    },
    fitView: (t) => {
      const { nodeLookup: n, minZoom: o, maxZoom: r, panZoom: i, domNode: s } = e.getState();
      if (!i || !s)
        return Promise.resolve(!1);
      const a = Dn(n, t), { width: c, height: l } = on(s);
      return Hn({
        nodes: a,
        width: c,
        height: l,
        minZoom: o,
        maxZoom: r,
        panZoom: i
      }, t);
    },
    setCenter: async (t, n, o) => {
      const { width: r, height: i, maxZoom: s, panZoom: a } = e.getState(), c = typeof o?.zoom < "u" ? o.zoom : s, l = r / 2 - t * c, d = i / 2 - n * c;
      return a ? (await a.setViewport({
        x: l,
        y: d,
        zoom: c
      }, { duration: o?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    fitBounds: async (t, n) => {
      const { width: o, height: r, minZoom: i, maxZoom: s, panZoom: a } = e.getState(), c = to(t, o, r, i, s, n?.padding ?? 0.1);
      return a ? (await a.setViewport(c, { duration: n?.duration }), Promise.resolve(!0)) : Promise.resolve(!1);
    },
    screenToFlowPosition: (t, n = {}) => {
      const { transform: o, snapGrid: r, snapToGrid: i, domNode: s } = e.getState();
      if (!s)
        return t;
      const { x: a, y: c } = s.getBoundingClientRect(), l = {
        x: t.x - a,
        y: t.y - c
      }, d = n.snapGrid ?? r, u = n.snapToGrid ?? i;
      return bt(l, o, u, d);
    },
    flowToScreenPosition: (t) => {
      const { transform: n, domNode: o } = e.getState();
      if (!o)
        return t;
      const { x: r, y: i } = o.getBoundingClientRect(), s = ci(t, n);
      return {
        x: s.x + r,
        y: s.y + i
      };
    }
  }), []);
};
function Pi(e, t) {
  const n = [], o = /* @__PURE__ */ new Map(), r = [];
  for (const i of e)
    if (i.type === "add") {
      r.push(i);
      continue;
    } else if (i.type === "remove" || i.type === "replace")
      o.set(i.id, [i]);
    else {
      const s = o.get(i.id);
      s ? s.push(i) : o.set(i.id, [i]);
    }
  for (const i of t) {
    const s = o.get(i.id);
    if (!s) {
      n.push(i);
      continue;
    }
    if (s[0].type === "remove")
      continue;
    if (s[0].type === "replace") {
      n.push({ ...s[0].item });
      continue;
    }
    const a = { ...i };
    for (const c of s)
      Sf(c, a);
    n.push(a);
  }
  return r.length && r.forEach((i) => {
    i.index !== void 0 ? n.splice(i.index, 0, { ...i.item }) : n.push({ ...i.item });
  }), n;
}
function Sf(e, t) {
  switch (e.type) {
    case "select": {
      t.selected = e.selected;
      break;
    }
    case "position": {
      typeof e.position < "u" && (t.position = e.position), typeof e.dragging < "u" && (t.dragging = e.dragging);
      break;
    }
    case "dimensions": {
      typeof e.dimensions < "u" && (t.measured ??= {}, t.measured.width = e.dimensions.width, t.measured.height = e.dimensions.height, e.setAttributes && (t.width = e.dimensions.width, t.height = e.dimensions.height)), typeof e.resizing == "boolean" && (t.resizing = e.resizing);
      break;
    }
  }
}
function zi(e, t) {
  return Pi(e, t);
}
function Ti(e, t) {
  return Pi(e, t);
}
function ze(e, t) {
  return {
    id: e,
    type: "select",
    selected: t
  };
}
function Le(e, t = /* @__PURE__ */ new Set(), n = !1) {
  const o = [];
  for (const [r, i] of e) {
    const s = t.has(r);
    !(i.selected === void 0 && !s) && i.selected !== s && (n && (i.selected = s), o.push(ze(i.id, s)));
  }
  return o;
}
function rr({ items: e = [], lookup: t }) {
  const n = [], o = new Map(e.map((r) => [r.id, r]));
  for (const [r, i] of e.entries()) {
    const s = t.get(i.id), a = s?.internals?.userNode ?? s;
    a !== void 0 && a !== i && n.push({ id: i.id, item: i, type: "replace" }), a === void 0 && n.push({ item: i, type: "add", index: r });
  }
  for (const [r] of t)
    o.get(r) === void 0 && n.push({ id: r, type: "remove" });
  return n;
}
function ir(e) {
  return {
    id: e.id,
    type: "remove"
  };
}
const sr = (e) => sd(e), Nf = (e) => ni(e);
function Di(e) {
  return xr(e);
}
const Cf = typeof window < "u" ? ca : j;
function ar(e) {
  const [t, n] = fe(BigInt(0)), [o] = fe(() => Mf(() => n((r) => r + BigInt(1))));
  return Cf(() => {
    const r = o.get();
    r.length && (e(r), o.reset());
  }, [t]), o;
}
function Mf(e) {
  let t = [];
  return {
    get: () => t,
    reset: () => {
      t = [];
    },
    push: (n) => {
      t.push(n), e();
    }
  };
}
const Hi = Zn(null);
function kf({ children: e }) {
  const t = ee(), n = ue((a) => {
    const { nodes: c = [], setNodes: l, hasDefaultNodes: d, onNodesChange: u, nodeLookup: f } = t.getState();
    let h = c;
    for (const p of a)
      h = typeof p == "function" ? p(h) : p;
    d ? l(h) : u && u(rr({
      items: h,
      lookup: f
    }));
  }, []), o = ar(n), r = ue((a) => {
    const { edges: c = [], setEdges: l, hasDefaultEdges: d, onEdgesChange: u, edgeLookup: f } = t.getState();
    let h = c;
    for (const p of a)
      h = typeof p == "function" ? p(h) : p;
    d ? l(h) : u && u(rr({
      items: h,
      lookup: f
    }));
  }, []), i = ar(r), s = me(() => ({ nodeQueue: o, edgeQueue: i }), []);
  return z(Hi.Provider, { value: s, children: e });
}
function $f() {
  const e = wt(Hi);
  if (!e)
    throw new Error("useBatchContext must be used within a BatchProvider");
  return e;
}
const If = (e) => !!e.panZoom;
function so() {
  const e = Ef(), t = ee(), n = $f(), o = G(If), r = me(() => {
    const i = (u) => t.getState().nodeLookup.get(u), s = (u) => {
      n.nodeQueue.push(u);
    }, a = (u) => {
      n.edgeQueue.push(u);
    }, c = (u) => {
      const { nodeLookup: f, nodeOrigin: h } = t.getState(), p = sr(u) ? u : f.get(u.id), y = p.parentId ? ui(p.position, p.measured, p.parentId, f, h) : p.position, _ = {
        ...p,
        position: y,
        width: p.measured?.width ?? p.width,
        height: p.measured?.height ?? p.height
      };
      return Ge(_);
    }, l = (u, f, h = { replace: !1 }) => {
      s((p) => p.map((y) => {
        if (y.id === u) {
          const _ = typeof f == "function" ? f(y) : f;
          return h.replace && sr(_) ? _ : { ...y, ..._ };
        }
        return y;
      }));
    }, d = (u, f, h = { replace: !1 }) => {
      a((p) => p.map((y) => {
        if (y.id === u) {
          const _ = typeof f == "function" ? f(y) : f;
          return h.replace && Nf(_) ? _ : { ...y, ..._ };
        }
        return y;
      }));
    };
    return {
      getNodes: () => t.getState().nodes.map((u) => ({ ...u })),
      getNode: (u) => i(u)?.internals.userNode,
      getInternalNode: i,
      getEdges: () => {
        const { edges: u = [] } = t.getState();
        return u.map((f) => ({ ...f }));
      },
      getEdge: (u) => t.getState().edgeLookup.get(u),
      setNodes: s,
      setEdges: a,
      addNodes: (u) => {
        const f = Array.isArray(u) ? u : [u];
        n.nodeQueue.push((h) => [...h, ...f]);
      },
      addEdges: (u) => {
        const f = Array.isArray(u) ? u : [u];
        n.edgeQueue.push((h) => [...h, ...f]);
      },
      toObject: () => {
        const { nodes: u = [], edges: f = [], transform: h } = t.getState(), [p, y, _] = h;
        return {
          nodes: u.map((x) => ({ ...x })),
          edges: f.map((x) => ({ ...x })),
          viewport: {
            x: p,
            y,
            zoom: _
          }
        };
      },
      deleteElements: async ({ nodes: u = [], edges: f = [] }) => {
        const { nodes: h, edges: p, onNodesDelete: y, onEdgesDelete: _, triggerNodeChanges: x, triggerEdgeChanges: b, onDelete: m, onBeforeDelete: w } = t.getState(), { nodes: N, edges: k } = await ld({
          nodesToRemove: u,
          edgesToRemove: f,
          nodes: h,
          edges: p,
          onBeforeDelete: w
        }), S = k.length > 0, P = N.length > 0;
        if (S) {
          const I = k.map(ir);
          _?.(k), b(I);
        }
        if (P) {
          const I = N.map(ir);
          y?.(N), x(I);
        }
        return (P || S) && m?.({ nodes: N, edges: k }), { deletedNodes: N, deletedEdges: k };
      },
      getIntersectingNodes: (u, f = !0, h) => {
        const p = Vo(u), y = p ? u : c(u), _ = h !== void 0;
        return y ? (h || t.getState().nodes).filter((x) => {
          const b = t.getState().nodeLookup.get(x.id);
          if (b && !p && (x.id === u.id || !b.internals.positionAbsolute))
            return !1;
          const m = Ge(_ ? x : b), w = pt(m, y);
          return f && w > 0 || w >= y.width * y.height;
        }) : [];
      },
      isNodeIntersecting: (u, f, h = !0) => {
        const y = Vo(u) ? u : c(u);
        if (!y)
          return !1;
        const _ = pt(y, f);
        return h && _ > 0 || _ >= y.width * y.height;
      },
      updateNode: l,
      updateNodeData: (u, f, h = { replace: !1 }) => {
        l(u, (p) => {
          const y = typeof f == "function" ? f(p) : f;
          return h.replace ? { ...p, data: y } : { ...p, data: { ...p.data, ...y } };
        }, h);
      },
      updateEdge: d,
      updateEdgeData: (u, f, h = { replace: !1 }) => {
        d(u, (p) => {
          const y = typeof f == "function" ? f(p) : f;
          return h.replace ? { ...p, data: y } : { ...p, data: { ...p.data, ...y } };
        }, h);
      },
      getNodesBounds: (u) => {
        const { nodeLookup: f, nodeOrigin: h } = t.getState();
        return ad(u, { nodeLookup: f, nodeOrigin: h });
      },
      getHandleConnections: ({ type: u, id: f, nodeId: h }) => Array.from(t.getState().connectionLookup.get(`${h}-${u}${f ? `-${f}` : ""}`)?.values() ?? []),
      getNodeConnections: ({ type: u, handleId: f, nodeId: h }) => Array.from(t.getState().connectionLookup.get(`${h}${u ? f ? `-${u}-${f}` : `-${u}` : ""}`)?.values() ?? [])
    };
  }, []);
  return me(() => ({
    ...r,
    ...e,
    viewportInitialized: o
  }), [o]);
}
const cr = (e) => e.selected, Af = { actInsideInputWithModifier: !1 }, Pf = typeof window < "u" ? window : void 0;
function zf({ deleteKeyCode: e, multiSelectionKeyCode: t }) {
  const n = ee(), { deleteElements: o } = so(), r = yt(e, Af), i = yt(t, { target: Pf });
  j(() => {
    if (r) {
      const { edges: s, nodes: a } = n.getState();
      o({ nodes: a.filter(cr), edges: s.filter(cr) }), n.setState({ nodesSelectionActive: !1 });
    }
  }, [r]), j(() => {
    n.setState({ multiSelectionActive: i });
  }, [i]);
}
function Tf(e) {
  const t = ee();
  j(() => {
    const n = () => {
      if (!e.current)
        return !1;
      const o = on(e.current);
      (o.height === 0 || o.width === 0) && t.getState().onError?.("004", Ne.error004()), t.setState({ width: o.width || 500, height: o.height || 500 });
    };
    if (e.current) {
      n(), window.addEventListener("resize", n);
      const o = new ResizeObserver(() => n());
      return o.observe(e.current), () => {
        window.removeEventListener("resize", n), o && e.current && o.unobserve(e.current);
      };
    }
  }, []);
}
const cn = {
  position: "absolute",
  width: "100%",
  height: "100%",
  top: 0,
  left: 0
}, Df = (e) => ({
  userSelectionActive: e.userSelectionActive,
  lib: e.lib
});
function Hf({ onPaneContextMenu: e, zoomOnScroll: t = !0, zoomOnPinch: n = !0, panOnScroll: o = !1, panOnScrollSpeed: r = 0.5, panOnScrollMode: i = He.Free, zoomOnDoubleClick: s = !0, panOnDrag: a = !0, defaultViewport: c, translateExtent: l, minZoom: d, maxZoom: u, zoomActivationKeyCode: f, preventScrolling: h = !0, children: p, noWheelClassName: y, noPanClassName: _, onViewportChange: x, isControlledViewport: b, paneClickDistance: m }) {
  const w = ee(), N = J(null), { userSelectionActive: k, lib: S } = G(Df, ne), P = yt(f), I = J();
  Tf(N);
  const A = ue((V) => {
    x?.({ x: V[0], y: V[1], zoom: V[2] }), b || w.setState({ transform: V });
  }, [x, b]);
  return j(() => {
    if (N.current) {
      I.current = Yd({
        domNode: N.current,
        minZoom: d,
        maxZoom: u,
        translateExtent: l,
        viewport: c,
        paneClickDistance: m,
        onDraggingChange: (g) => w.setState({ paneDragging: g }),
        onPanZoomStart: (g, E) => {
          const { onViewportChangeStart: v, onMoveStart: M } = w.getState();
          M?.(g, E), v?.(E);
        },
        onPanZoom: (g, E) => {
          const { onViewportChange: v, onMove: M } = w.getState();
          M?.(g, E), v?.(E);
        },
        onPanZoomEnd: (g, E) => {
          const { onViewportChangeEnd: v, onMoveEnd: M } = w.getState();
          M?.(g, E), v?.(E);
        }
      });
      const { x: V, y: D, zoom: H } = I.current.getViewport();
      return w.setState({
        panZoom: I.current,
        transform: [V, D, H],
        domNode: N.current.closest(".react-flow")
      }), () => {
        I.current?.destroy();
      };
    }
  }, []), j(() => {
    I.current?.update({
      onPaneContextMenu: e,
      zoomOnScroll: t,
      zoomOnPinch: n,
      panOnScroll: o,
      panOnScrollSpeed: r,
      panOnScrollMode: i,
      zoomOnDoubleClick: s,
      panOnDrag: a,
      zoomActivationKeyPressed: P,
      preventScrolling: h,
      noPanClassName: _,
      userSelectionActive: k,
      noWheelClassName: y,
      lib: S,
      onTransformChange: A
    });
  }, [
    e,
    t,
    n,
    o,
    r,
    i,
    s,
    a,
    P,
    h,
    _,
    k,
    y,
    S,
    A
  ]), z("div", { className: "react-flow__renderer", ref: N, style: cn, children: p });
}
const Vf = (e) => ({
  userSelectionActive: e.userSelectionActive,
  userSelectionRect: e.userSelectionRect
});
function Of() {
  const { userSelectionActive: e, userSelectionRect: t } = G(Vf, ne);
  return e && t ? z("div", { className: "react-flow__selection react-flow__container", style: {
    width: t.width,
    height: t.height,
    transform: `translate(${t.x}px, ${t.y}px)`
  } }) : null;
}
const Nn = (e, t) => (n) => {
  n.target === t.current && e?.(n);
}, Rf = (e) => ({
  userSelectionActive: e.userSelectionActive,
  elementsSelectable: e.elementsSelectable,
  dragging: e.paneDragging
});
function Lf({ isSelecting: e, selectionKeyPressed: t, selectionMode: n = gt.Full, panOnDrag: o, selectionOnDrag: r, onSelectionStart: i, onSelectionEnd: s, onPaneClick: a, onPaneContextMenu: c, onPaneScroll: l, onPaneMouseEnter: d, onPaneMouseMove: u, onPaneMouseLeave: f, children: h }) {
  const p = ee(), { userSelectionActive: y, elementsSelectable: _, dragging: x } = G(Rf, ne), b = _ && (e || y), m = J(null), w = J(), N = J(/* @__PURE__ */ new Set()), k = J(/* @__PURE__ */ new Set()), S = J(!1), P = J(!1), I = (v) => {
    if (S.current) {
      S.current = !1;
      return;
    }
    a?.(v), p.getState().resetSelectedElements(), p.setState({ nodesSelectionActive: !1 });
  }, A = (v) => {
    if (Array.isArray(o) && o?.includes(2)) {
      v.preventDefault();
      return;
    }
    c?.(v);
  }, V = l ? (v) => l(v) : void 0, D = (v) => {
    const { resetSelectedElements: M, domNode: $ } = p.getState();
    if (w.current = $?.getBoundingClientRect(), !_ || !e || v.button !== 0 || v.target !== m.current || !w.current)
      return;
    v.target?.setPointerCapture?.(v.pointerId), P.current = !0, S.current = !1;
    const { x: C, y: T } = be(v.nativeEvent, w.current);
    M(), p.setState({
      userSelectionRect: {
        width: 0,
        height: 0,
        startX: C,
        startY: T,
        x: C,
        y: T
      }
    }), i?.(v);
  }, H = (v) => {
    const { userSelectionRect: M, transform: $, nodeLookup: C, edgeLookup: T, connectionLookup: O, triggerNodeChanges: R, triggerEdgeChanges: W, defaultEdgeOptions: Y } = p.getState();
    if (!w.current || !M)
      return;
    S.current = !0;
    const { x: F, y: Z } = be(v.nativeEvent, w.current), { startX: L, startY: X } = M, K = {
      startX: L,
      startY: X,
      x: F < L ? F : L,
      y: Z < X ? Z : X,
      width: Math.abs(F - L),
      height: Math.abs(Z - X)
    }, te = N.current, Q = k.current;
    N.current = new Set(oi(C, K, $, n === gt.Partial, !0).map((U) => U.id)), k.current = /* @__PURE__ */ new Set();
    const q = Y?.selectable ?? !0;
    for (const U of N.current) {
      const oe = O.get(U);
      if (oe)
        for (const { edgeId: ae } of oe.values()) {
          const Pe = T.get(ae);
          Pe && (Pe.selectable ?? q) && k.current.add(ae);
        }
    }
    if (!Oo(te, N.current)) {
      const U = Le(C, N.current, !0);
      R(U);
    }
    if (!Oo(Q, k.current)) {
      const U = Le(T, k.current);
      W(U);
    }
    p.setState({
      userSelectionRect: K,
      userSelectionActive: !0,
      nodesSelectionActive: !1
    });
  }, g = (v) => {
    if (v.button !== 0 || !P.current)
      return;
    v.target?.releasePointerCapture?.(v.pointerId);
    const { userSelectionRect: M } = p.getState();
    !y && M && v.target === m.current && I?.(v), p.setState({
      userSelectionActive: !1,
      userSelectionRect: null,
      nodesSelectionActive: N.current.size > 0
    }), s?.(v), (t || r) && (S.current = !1), P.current = !1;
  }, E = o === !0 || Array.isArray(o) && o.includes(0);
  return se("div", { className: re(["react-flow__pane", { draggable: E, dragging: x, selection: e }]), onClick: b ? void 0 : Nn(I, m), onContextMenu: Nn(A, m), onWheel: Nn(V, m), onPointerEnter: b ? void 0 : d, onPointerDown: b ? D : u, onPointerMove: b ? H : u, onPointerUp: b ? g : void 0, onPointerLeave: f, ref: m, style: cn, children: [h, z(Of, {})] });
}
function Xn({ id: e, store: t, unselect: n = !1, nodeRef: o }) {
  const { addSelectedNodes: r, unselectNodesAndEdges: i, multiSelectionActive: s, nodeLookup: a, onError: c } = t.getState(), l = a.get(e);
  if (!l) {
    c?.("012", Ne.error012(e));
    return;
  }
  t.setState({ nodesSelectionActive: !1 }), l.selected ? (n || l.selected && s) && (i({ nodes: [l], edges: [] }), requestAnimationFrame(() => o?.current?.blur())) : r([e]);
}
function Vi({ nodeRef: e, disabled: t = !1, noDragClassName: n, handleSelector: o, nodeId: r, isSelectable: i, nodeClickDistance: s }) {
  const a = ee(), [c, l] = fe(!1), d = J();
  return j(() => {
    d.current = Id({
      getStoreItems: () => a.getState(),
      onNodeMouseDown: (u) => {
        Xn({
          id: u,
          store: a,
          nodeRef: e
        });
      },
      onDragStart: () => {
        l(!0);
      },
      onDragStop: () => {
        l(!1);
      }
    });
  }, []), j(() => {
    if (t)
      d.current?.destroy();
    else if (e.current)
      return d.current?.update({
        noDragClassName: n,
        handleSelector: o,
        domNode: e.current,
        isSelectable: i,
        nodeId: r,
        nodeClickDistance: s
      }), () => {
        d.current?.destroy();
      };
  }, [n, o, t, i, e, r]), c;
}
const Bf = (e) => (t) => t.selected && (t.draggable || e && typeof t.draggable > "u");
function Oi() {
  const e = ee();
  return ue((n) => {
    const { nodeExtent: o, snapToGrid: r, snapGrid: i, nodesDraggable: s, onError: a, updateNodePositions: c, nodeLookup: l, nodeOrigin: d } = e.getState(), u = /* @__PURE__ */ new Map(), f = Bf(s), h = r ? i[0] : 5, p = r ? i[1] : 5, y = n.direction.x * h * n.factor, _ = n.direction.y * p * n.factor;
    for (const [, x] of l) {
      if (!f(x))
        continue;
      let b = {
        x: x.internals.positionAbsolute.x + y,
        y: x.internals.positionAbsolute.y + _
      };
      r && (b = nn(b, i));
      const { position: m, positionAbsolute: w } = ri({
        nodeId: x.id,
        nextPosition: b,
        nodeLookup: l,
        nodeExtent: o,
        nodeOrigin: d,
        onError: a
      });
      x.position = m, x.internals.positionAbsolute = w, u.set(x.id, x);
    }
    c(u);
  }, []);
}
const ao = Zn(null), Ff = ao.Provider;
ao.Consumer;
const co = () => wt(ao), Xf = (e) => ({
  connectOnClick: e.connectOnClick,
  noPanClassName: e.noPanClassName,
  rfId: e.rfId
}), Yf = (e, t, n) => (o) => {
  const { connectionClickStartHandle: r, connectionMode: i, connection: s } = o, { fromHandle: a, toHandle: c, isValid: l } = s, d = c?.nodeId === e && c?.id === t && c?.type === n;
  return {
    connectingFrom: a?.nodeId === e && a?.id === t && a?.type === n,
    connectingTo: d,
    clickConnecting: r?.nodeId === e && r?.id === t && r?.type === n,
    isPossibleEndHandle: i === We.Strict ? a?.type !== n : e !== a?.nodeId || t !== a?.id,
    connectionInProcess: !!a,
    valid: d && l
  };
};
function Zf({ type: e = "source", position: t = B.Top, isValidConnection: n, isConnectable: o = !0, isConnectableStart: r = !0, isConnectableEnd: i = !0, id: s, onConnect: a, children: c, className: l, onMouseDown: d, onTouchStart: u, ...f }, h) {
  const p = s || null, y = e === "target", _ = ee(), x = co(), { connectOnClick: b, noPanClassName: m, rfId: w } = G(Xf, ne), { connectingFrom: N, connectingTo: k, clickConnecting: S, isPossibleEndHandle: P, connectionInProcess: I, valid: A } = G(Yf(x, p, e), ne);
  x || _.getState().onError?.("010", Ne.error010());
  const V = (g) => {
    const { defaultEdgeOptions: E, onConnect: v, hasDefaultEdges: M } = _.getState(), $ = {
      ...E,
      ...g
    };
    if (M) {
      const { edges: C, setEdges: T } = _.getState();
      T(md($, C));
    }
    v?.($), a?.($);
  }, D = (g) => {
    if (!x)
      return;
    const E = fi(g.nativeEvent);
    if (r && (E && g.button === 0 || !E)) {
      const v = _.getState();
      Fn.onPointerDown(g.nativeEvent, {
        autoPanOnConnect: v.autoPanOnConnect,
        connectionMode: v.connectionMode,
        connectionRadius: v.connectionRadius,
        domNode: v.domNode,
        nodeLookup: v.nodeLookup,
        lib: v.lib,
        isTarget: y,
        handleId: p,
        nodeId: x,
        flowId: v.rfId,
        panBy: v.panBy,
        cancelConnection: v.cancelConnection,
        onConnectStart: v.onConnectStart,
        onConnectEnd: v.onConnectEnd,
        updateConnection: v.updateConnection,
        onConnect: V,
        isValidConnection: n || v.isValidConnection,
        getTransform: () => _.getState().transform,
        getFromHandle: () => _.getState().connection.fromHandle,
        autoPanSpeed: v.autoPanSpeed
      });
    }
    E ? d?.(g) : u?.(g);
  }, H = (g) => {
    const { onClickConnectStart: E, onClickConnectEnd: v, connectionClickStartHandle: M, connectionMode: $, isValidConnection: C, lib: T, rfId: O, nodeLookup: R, connection: W } = _.getState();
    if (!x || !M && !r)
      return;
    if (!M) {
      E?.(g.nativeEvent, { nodeId: x, handleId: p, handleType: e }), _.setState({ connectionClickStartHandle: { nodeId: x, type: e, id: p } });
      return;
    }
    const Y = di(g.target), F = n || C, { connection: Z, isValid: L } = Fn.isValid(g.nativeEvent, {
      handle: {
        nodeId: x,
        id: p,
        type: e
      },
      connectionMode: $,
      fromNodeId: M.nodeId,
      fromHandleId: M.id || null,
      fromType: M.type,
      isValidConnection: F,
      flowId: O,
      doc: Y,
      lib: T,
      nodeLookup: R
    });
    L && Z && V(Z);
    const X = structuredClone(W);
    delete X.inProgress, X.toPosition = X.toHandle ? X.toHandle.position : null, v?.(g, X), _.setState({ connectionClickStartHandle: null });
  };
  return z("div", { "data-handleid": p, "data-nodeid": x, "data-handlepos": t, "data-id": `${w}-${x}-${p}-${e}`, className: re([
    "react-flow__handle",
    `react-flow__handle-${t}`,
    "nodrag",
    m,
    l,
    {
      source: !y,
      target: y,
      connectable: o,
      connectablestart: r,
      connectableend: i,
      clickconnecting: S,
      connectingfrom: N,
      connectingto: k,
      valid: A,
      /*
       * shows where you can start a connection from
       * and where you can end it while connecting
       */
      connectionindicator: o && (!I || P) && (I ? i : r)
    }
  ]), onMouseDown: D, onTouchStart: D, onClick: b ? H : void 0, ref: h, ...f, children: c });
}
const Wt = ie(Di(Zf));
function Wf({ data: e, isConnectable: t, sourcePosition: n = B.Bottom }) {
  return se(Se, { children: [e?.label, z(Wt, { type: "source", position: n, isConnectable: t })] });
}
function qf({ data: e, isConnectable: t, targetPosition: n = B.Top, sourcePosition: o = B.Bottom }) {
  return se(Se, { children: [z(Wt, { type: "target", position: n, isConnectable: t }), e?.label, z(Wt, { type: "source", position: o, isConnectable: t })] });
}
function Gf() {
  return null;
}
function Kf({ data: e, isConnectable: t, targetPosition: n = B.Top }) {
  return se(Se, { children: [z(Wt, { type: "target", position: n, isConnectable: t }), e?.label] });
}
const qt = {
  ArrowUp: { x: 0, y: -1 },
  ArrowDown: { x: 0, y: 1 },
  ArrowLeft: { x: -1, y: 0 },
  ArrowRight: { x: 1, y: 0 }
}, lr = {
  input: Wf,
  default: qf,
  output: Kf,
  group: Gf
};
function Uf(e) {
  return e.internals.handleBounds === void 0 ? {
    width: e.width ?? e.initialWidth ?? e.style?.width,
    height: e.height ?? e.initialHeight ?? e.style?.height
  } : {
    width: e.width ?? e.style?.width,
    height: e.height ?? e.style?.height
  };
}
const Qf = (e) => {
  const { width: t, height: n, x: o, y: r } = Ue(e.nodeLookup, {
    filter: (i) => !!i.selected
  });
  return {
    width: pe(t) ? t : null,
    height: pe(n) ? n : null,
    userSelectionActive: e.userSelectionActive,
    transformString: `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]}) translate(${o}px,${r}px)`
  };
};
function Jf({ onSelectionContextMenu: e, noPanClassName: t, disableKeyboardA11y: n }) {
  const o = ee(), { width: r, height: i, transformString: s, userSelectionActive: a } = G(Qf, ne), c = Oi(), l = J(null);
  if (j(() => {
    n || l.current?.focus({
      preventScroll: !0
    });
  }, [n]), Vi({
    nodeRef: l
  }), a || !r || !i)
    return null;
  const d = e ? (f) => {
    const h = o.getState().nodes.filter((p) => p.selected);
    e(f, h);
  } : void 0, u = (f) => {
    Object.prototype.hasOwnProperty.call(qt, f.key) && (f.preventDefault(), c({
      direction: qt[f.key],
      factor: f.shiftKey ? 4 : 1
    }));
  };
  return z("div", { className: re(["react-flow__nodesselection", "react-flow__container", t]), style: {
    transform: s
  }, children: z("div", { ref: l, className: "react-flow__nodesselection-rect", onContextMenu: d, tabIndex: n ? void 0 : -1, onKeyDown: n ? void 0 : u, style: {
    width: r,
    height: i
  } }) });
}
const ur = typeof window < "u" ? window : void 0, jf = (e) => ({ nodesSelectionActive: e.nodesSelectionActive, userSelectionActive: e.userSelectionActive });
function Ri({ children: e, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: o, onPaneMouseLeave: r, onPaneContextMenu: i, onPaneScroll: s, paneClickDistance: a, deleteKeyCode: c, selectionKeyCode: l, selectionOnDrag: d, selectionMode: u, onSelectionStart: f, onSelectionEnd: h, multiSelectionKeyCode: p, panActivationKeyCode: y, zoomActivationKeyCode: _, elementsSelectable: x, zoomOnScroll: b, zoomOnPinch: m, panOnScroll: w, panOnScrollSpeed: N, panOnScrollMode: k, zoomOnDoubleClick: S, panOnDrag: P, defaultViewport: I, translateExtent: A, minZoom: V, maxZoom: D, preventScrolling: H, onSelectionContextMenu: g, noWheelClassName: E, noPanClassName: v, disableKeyboardA11y: M, onViewportChange: $, isControlledViewport: C }) {
  const { nodesSelectionActive: T, userSelectionActive: O } = G(jf), R = yt(l, { target: ur }), W = yt(y, { target: ur }), Y = W || P, F = W || w, Z = d && Y !== !0, L = R || O || Z;
  return zf({ deleteKeyCode: c, multiSelectionKeyCode: p }), z(Hf, { onPaneContextMenu: i, elementsSelectable: x, zoomOnScroll: b, zoomOnPinch: m, panOnScroll: F, panOnScrollSpeed: N, panOnScrollMode: k, zoomOnDoubleClick: S, panOnDrag: !R && Y, defaultViewport: I, translateExtent: A, minZoom: V, maxZoom: D, zoomActivationKeyCode: _, preventScrolling: H, noWheelClassName: E, noPanClassName: v, onViewportChange: $, isControlledViewport: C, paneClickDistance: a, children: se(Lf, { onSelectionStart: f, onSelectionEnd: h, onPaneClick: t, onPaneMouseEnter: n, onPaneMouseMove: o, onPaneMouseLeave: r, onPaneContextMenu: i, onPaneScroll: s, panOnDrag: Y, isSelecting: !!L, selectionMode: u, selectionKeyPressed: R, selectionOnDrag: Z, children: [e, T && z(Jf, { onSelectionContextMenu: g, noPanClassName: v, disableKeyboardA11y: M })] }) });
}
Ri.displayName = "FlowRenderer";
const eh = ie(Ri), th = (e) => (t) => e ? oi(t.nodeLookup, { x: 0, y: 0, width: t.width, height: t.height }, t.transform, !0).map((n) => n.id) : Array.from(t.nodeLookup.keys());
function nh(e) {
  return G(ue(th(e), [e]), ne);
}
const oh = (e) => e.updateNodeInternals;
function rh() {
  const e = G(oh), [t] = fe(() => typeof ResizeObserver > "u" ? null : new ResizeObserver((n) => {
    const o = /* @__PURE__ */ new Map();
    n.forEach((r) => {
      const i = r.target.getAttribute("data-id");
      o.set(i, {
        id: i,
        nodeElement: r.target,
        force: !0
      });
    }), e(o);
  }));
  return j(() => () => {
    t?.disconnect();
  }, [t]), t;
}
function ih({ node: e, nodeType: t, hasDimensions: n, resizeObserver: o }) {
  const r = ee(), i = J(null), s = J(null), a = J(e.sourcePosition), c = J(e.targetPosition), l = J(t), d = n && !!e.internals.handleBounds;
  return j(() => {
    i.current && !e.hidden && (!d || s.current !== i.current) && (s.current && o?.unobserve(s.current), o?.observe(i.current), s.current = i.current);
  }, [d, e.hidden]), j(() => () => {
    s.current && (o?.unobserve(s.current), s.current = null);
  }, []), j(() => {
    if (i.current) {
      const u = l.current !== t, f = a.current !== e.sourcePosition, h = c.current !== e.targetPosition;
      (u || f || h) && (l.current = t, a.current = e.sourcePosition, c.current = e.targetPosition, r.getState().updateNodeInternals(/* @__PURE__ */ new Map([[e.id, { id: e.id, nodeElement: i.current, force: !0 }]])));
    }
  }, [e.id, t, e.sourcePosition, e.targetPosition]), i;
}
function sh({ id: e, onClick: t, onMouseEnter: n, onMouseMove: o, onMouseLeave: r, onContextMenu: i, onDoubleClick: s, nodesDraggable: a, elementsSelectable: c, nodesConnectable: l, nodesFocusable: d, resizeObserver: u, noDragClassName: f, noPanClassName: h, disableKeyboardA11y: p, rfId: y, nodeTypes: _, nodeClickDistance: x, onError: b }) {
  const { node: m, internals: w, isParent: N } = G((L) => {
    const X = L.nodeLookup.get(e), K = L.parentLookup.has(e);
    return {
      node: X,
      internals: X.internals,
      isParent: K
    };
  }, ne);
  let k = m.type || "default", S = _?.[k] || lr[k];
  S === void 0 && (b?.("003", Ne.error003(k)), k = "default", S = lr.default);
  const P = !!(m.draggable || a && typeof m.draggable > "u"), I = !!(m.selectable || c && typeof m.selectable > "u"), A = !!(m.connectable || l && typeof m.connectable > "u"), V = !!(m.focusable || d && typeof m.focusable > "u"), D = ee(), H = li(m), g = ih({ node: m, nodeType: k, hasDimensions: H, resizeObserver: u }), E = Vi({
    nodeRef: g,
    disabled: m.hidden || !P,
    noDragClassName: f,
    handleSelector: m.dragHandle,
    nodeId: e,
    isSelectable: I,
    nodeClickDistance: x
  }), v = Oi();
  if (m.hidden)
    return null;
  const M = Ce(m), $ = Uf(m), C = I || P || t || n || o || r, T = n ? (L) => n(L, { ...w.userNode }) : void 0, O = o ? (L) => o(L, { ...w.userNode }) : void 0, R = r ? (L) => r(L, { ...w.userNode }) : void 0, W = i ? (L) => i(L, { ...w.userNode }) : void 0, Y = s ? (L) => s(L, { ...w.userNode }) : void 0, F = (L) => {
    const { selectNodesOnDrag: X, nodeDragThreshold: K } = D.getState();
    I && (!X || !P || K > 0) && Xn({
      id: e,
      store: D,
      nodeRef: g
    }), t && t(L, { ...w.userNode });
  }, Z = (L) => {
    if (!(On(L.nativeEvent) || p))
      if (jr.includes(L.key) && I) {
        const X = L.key === "Escape";
        Xn({
          id: e,
          store: D,
          unselect: X,
          nodeRef: g
        });
      } else P && m.selected && Object.prototype.hasOwnProperty.call(qt, L.key) && (L.preventDefault(), D.setState({
        ariaLiveMessage: `Moved selected node ${L.key.replace("Arrow", "").toLowerCase()}. New position, x: ${~~w.positionAbsolute.x}, y: ${~~w.positionAbsolute.y}`
      }), v({
        direction: qt[L.key],
        factor: L.shiftKey ? 4 : 1
      }));
  };
  return z("div", { className: re([
    "react-flow__node",
    `react-flow__node-${k}`,
    {
      // this is overwritable by passing `nopan` as a class name
      [h]: P
    },
    m.className,
    {
      selected: m.selected,
      selectable: I,
      parent: N,
      draggable: P,
      dragging: E
    }
  ]), ref: g, style: {
    zIndex: w.z,
    transform: `translate(${w.positionAbsolute.x}px,${w.positionAbsolute.y}px)`,
    pointerEvents: C ? "all" : "none",
    visibility: H ? "visible" : "hidden",
    ...m.style,
    ...$
  }, "data-id": e, "data-testid": `rf__node-${e}`, onMouseEnter: T, onMouseMove: O, onMouseLeave: R, onContextMenu: W, onClick: F, onDoubleClick: Y, onKeyDown: V ? Z : void 0, tabIndex: V ? 0 : void 0, role: V ? "button" : void 0, "aria-describedby": p ? void 0 : `${$i}-${y}`, "aria-label": m.ariaLabel, children: z(Ff, { value: e, children: z(S, { id: e, data: m.data, type: k, positionAbsoluteX: w.positionAbsolute.x, positionAbsoluteY: w.positionAbsolute.y, selected: m.selected ?? !1, selectable: I, draggable: P, deletable: m.deletable ?? !0, isConnectable: A, sourcePosition: m.sourcePosition, targetPosition: m.targetPosition, dragging: E, dragHandle: m.dragHandle, zIndex: w.z, parentId: m.parentId, ...M }) }) });
}
const ah = (e) => ({
  nodesDraggable: e.nodesDraggable,
  nodesConnectable: e.nodesConnectable,
  nodesFocusable: e.nodesFocusable,
  elementsSelectable: e.elementsSelectable,
  onError: e.onError
});
function Li(e) {
  const { nodesDraggable: t, nodesConnectable: n, nodesFocusable: o, elementsSelectable: r, onError: i } = G(ah, ne), s = nh(e.onlyRenderVisibleElements), a = rh();
  return z("div", { className: "react-flow__nodes", style: cn, children: s.map((c) => (
    /*
     * The split of responsibilities between NodeRenderer and
     * NodeComponentWrapper may appear weird. However, it’s designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For example, when you’re dragging a single node, that node gets
     * updated multiple times per second. If `NodeRenderer` were to update
     * every time, it would have to re-run the `nodes.map()` loop every
     * time. This gets pricey with hundreds of nodes, especially if every
     * loop cycle does more than just rendering a JSX element!
     *
     * As a result of this choice, we took the following implementation
     * decisions:
     * - NodeRenderer subscribes *only* to node IDs – and therefore
     *   rerender *only* when visible nodes are added or removed.
     * - NodeRenderer performs all operations the result of which can be
     *   shared between nodes (such as creating the `ResizeObserver`
     *   instance, or subscribing to `selector`). This means extra prop
     *   drilling into `NodeComponentWrapper`, but it means we need to run
     *   these operations only once – instead of once per node.
     * - Any operations that you’d normally write inside `nodes.map` are
     *   moved into `NodeComponentWrapper`. This ensures they are
     *   memorized – so if `NodeRenderer` *has* to rerender, it only
     *   needs to regenerate the list of nodes, nothing else.
     */
    z(sh, { id: c, nodeTypes: e.nodeTypes, nodeExtent: e.nodeExtent, onClick: e.onNodeClick, onMouseEnter: e.onNodeMouseEnter, onMouseMove: e.onNodeMouseMove, onMouseLeave: e.onNodeMouseLeave, onContextMenu: e.onNodeContextMenu, onDoubleClick: e.onNodeDoubleClick, noDragClassName: e.noDragClassName, noPanClassName: e.noPanClassName, rfId: e.rfId, disableKeyboardA11y: e.disableKeyboardA11y, resizeObserver: a, nodesDraggable: t, nodesConnectable: n, nodesFocusable: o, elementsSelectable: r, nodeClickDistance: e.nodeClickDistance, onError: i }, c)
  )) });
}
Li.displayName = "NodeRenderer";
const ch = ie(Li);
function lh(e) {
  return G(ue((n) => {
    if (!e)
      return n.edges.map((r) => r.id);
    const o = [];
    if (n.width && n.height)
      for (const r of n.edges) {
        const i = n.nodeLookup.get(r.source), s = n.nodeLookup.get(r.target);
        i && s && hd({
          sourceNode: i,
          targetNode: s,
          width: n.width,
          height: n.height,
          transform: n.transform
        }) && o.push(r.id);
      }
    return o;
  }, [e]), ne);
}
const uh = ({ color: e = "none", strokeWidth: t = 1 }) => z("polyline", { style: {
  stroke: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", fill: "none", points: "-5,-4 0,0 -5,4" }), dh = ({ color: e = "none", strokeWidth: t = 1 }) => z("polyline", { style: {
  stroke: e,
  fill: e,
  strokeWidth: t
}, strokeLinecap: "round", strokeLinejoin: "round", points: "-5,-4 0,0 -5,4 -5,-4" }), dr = {
  [Xt.Arrow]: uh,
  [Xt.ArrowClosed]: dh
};
function fh(e) {
  const t = ee();
  return me(() => Object.prototype.hasOwnProperty.call(dr, e) ? dr[e] : (t.getState().onError?.("009", Ne.error009(e)), null), [e]);
}
const hh = ({ id: e, type: t, color: n, width: o = 12.5, height: r = 12.5, markerUnits: i = "strokeWidth", strokeWidth: s, orient: a = "auto-start-reverse" }) => {
  const c = fh(t);
  return c ? z("marker", { className: "react-flow__arrowhead", id: e, markerWidth: `${o}`, markerHeight: `${r}`, viewBox: "-10 -10 20 20", markerUnits: i, orient: a, refX: "0", refY: "0", children: z(c, { color: n, strokeWidth: s }) }) : null;
}, Bi = ({ defaultColor: e, rfId: t }) => {
  const n = G((i) => i.edges), o = G((i) => i.defaultEdgeOptions), r = me(() => _d(n, {
    id: t,
    defaultColor: e,
    defaultMarkerStart: o?.markerStart,
    defaultMarkerEnd: o?.markerEnd
  }), [n, o, t, e]);
  return r.length ? z("svg", { className: "react-flow__marker", children: z("defs", { children: r.map((i) => z(hh, { id: i.id, type: i.type, color: i.color, width: i.width, height: i.height, markerUnits: i.markerUnits, strokeWidth: i.strokeWidth, orient: i.orient }, i.id)) }) }) : null;
};
Bi.displayName = "MarkerDefinitions";
var gh = ie(Bi);
function Fi({ x: e, y: t, label: n, labelStyle: o = {}, labelShowBg: r = !0, labelBgStyle: i = {}, labelBgPadding: s = [2, 4], labelBgBorderRadius: a = 2, children: c, className: l, ...d }) {
  const [u, f] = fe({ x: 1, y: 0, width: 0, height: 0 }), h = re(["react-flow__edge-textwrapper", l]), p = J(null);
  return j(() => {
    if (p.current) {
      const y = p.current.getBBox();
      f({
        x: y.x,
        y: y.y,
        width: y.width,
        height: y.height
      });
    }
  }, [n]), typeof n > "u" || !n ? null : se("g", { transform: `translate(${e - u.width / 2} ${t - u.height / 2})`, className: h, visibility: u.width ? "visible" : "hidden", ...d, children: [r && z("rect", { width: u.width + 2 * s[0], x: -s[0], y: -s[1], height: u.height + 2 * s[1], className: "react-flow__edge-textbg", style: i, rx: a, ry: a }), z("text", { className: "react-flow__edge-text", y: u.height / 2, dy: "0.3em", ref: p, style: o, children: n }), c] });
}
Fi.displayName = "EdgeText";
const ph = ie(Fi);
function ln({ path: e, labelX: t, labelY: n, label: o, labelStyle: r, labelShowBg: i, labelBgStyle: s, labelBgPadding: a, labelBgBorderRadius: c, interactionWidth: l = 20, ...d }) {
  return se(Se, { children: [z("path", { ...d, d: e, fill: "none", className: re(["react-flow__edge-path", d.className]) }), l && z("path", { d: e, fill: "none", strokeOpacity: 0, strokeWidth: l, className: "react-flow__edge-interaction" }), o && pe(t) && pe(n) ? z(ph, { x: t, y: n, label: o, labelStyle: r, labelShowBg: i, labelBgStyle: s, labelBgPadding: a, labelBgBorderRadius: c }) : null] });
}
function fr({ pos: e, x1: t, y1: n, x2: o, y2: r }) {
  return e === B.Left || e === B.Right ? [0.5 * (t + o), n] : [t, 0.5 * (n + r)];
}
function Xi({ sourceX: e, sourceY: t, sourcePosition: n = B.Bottom, targetX: o, targetY: r, targetPosition: i = B.Top }) {
  const [s, a] = fr({
    pos: n,
    x1: e,
    y1: t,
    x2: o,
    y2: r
  }), [c, l] = fr({
    pos: i,
    x1: o,
    y1: r,
    x2: e,
    y2: t
  }), [d, u, f, h] = hi({
    sourceX: e,
    sourceY: t,
    targetX: o,
    targetY: r,
    sourceControlX: s,
    sourceControlY: a,
    targetControlX: c,
    targetControlY: l
  });
  return [
    `M${e},${t} C${s},${a} ${c},${l} ${o},${r}`,
    d,
    u,
    f,
    h
  ];
}
function Yi(e) {
  return ie(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, sourcePosition: s = B.Bottom, targetPosition: a = B.Top, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: h, style: p, markerEnd: y, markerStart: _, interactionWidth: x }) => {
    const [b, m, w] = Xi({
      sourceX: n,
      sourceY: o,
      sourcePosition: s,
      targetX: r,
      targetY: i,
      targetPosition: a
    }), N = e.isInternal ? void 0 : t;
    return z(ln, { id: N, path: b, labelX: m, labelY: w, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: h, style: p, markerEnd: y, markerStart: _, interactionWidth: x });
  });
}
const mh = Yi({ isInternal: !1 }), Zi = Yi({ isInternal: !0 });
mh.displayName = "SimpleBezierEdge";
Zi.displayName = "SimpleBezierEdgeInternal";
function Wi(e) {
  return ie(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, label: s, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, sourcePosition: h = B.Bottom, targetPosition: p = B.Top, markerEnd: y, markerStart: _, pathOptions: x, interactionWidth: b }) => {
    const [m, w, N] = Rn({
      sourceX: n,
      sourceY: o,
      sourcePosition: h,
      targetX: r,
      targetY: i,
      targetPosition: p,
      borderRadius: x?.borderRadius,
      offset: x?.offset
    }), k = e.isInternal ? void 0 : t;
    return z(ln, { id: k, path: m, labelX: w, labelY: N, label: s, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, markerEnd: y, markerStart: _, interactionWidth: b });
  });
}
const qi = Wi({ isInternal: !1 }), Gi = Wi({ isInternal: !0 });
qi.displayName = "SmoothStepEdge";
Gi.displayName = "SmoothStepEdgeInternal";
function Ki(e) {
  return ie(({ id: t, ...n }) => {
    const o = e.isInternal ? void 0 : t;
    return z(qi, { ...n, id: o, pathOptions: me(() => ({ borderRadius: 0, offset: n.pathOptions?.offset }), [n.pathOptions?.offset]) });
  });
}
const yh = Ki({ isInternal: !1 }), Ui = Ki({ isInternal: !0 });
yh.displayName = "StepEdge";
Ui.displayName = "StepEdgeInternal";
function Qi(e) {
  return ie(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, label: s, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, markerEnd: h, markerStart: p, interactionWidth: y }) => {
    const [_, x, b] = mi({ sourceX: n, sourceY: o, targetX: r, targetY: i }), m = e.isInternal ? void 0 : t;
    return z(ln, { id: m, path: _, labelX: x, labelY: b, label: s, labelStyle: a, labelShowBg: c, labelBgStyle: l, labelBgPadding: d, labelBgBorderRadius: u, style: f, markerEnd: h, markerStart: p, interactionWidth: y });
  });
}
const wh = Qi({ isInternal: !1 }), Ji = Qi({ isInternal: !0 });
wh.displayName = "StraightEdge";
Ji.displayName = "StraightEdgeInternal";
function ji(e) {
  return ie(({ id: t, sourceX: n, sourceY: o, targetX: r, targetY: i, sourcePosition: s = B.Bottom, targetPosition: a = B.Top, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: h, style: p, markerEnd: y, markerStart: _, pathOptions: x, interactionWidth: b }) => {
    const [m, w, N] = gi({
      sourceX: n,
      sourceY: o,
      sourcePosition: s,
      targetX: r,
      targetY: i,
      targetPosition: a,
      curvature: x?.curvature
    }), k = e.isInternal ? void 0 : t;
    return z(ln, { id: k, path: m, labelX: w, labelY: N, label: c, labelStyle: l, labelShowBg: d, labelBgStyle: u, labelBgPadding: f, labelBgBorderRadius: h, style: p, markerEnd: y, markerStart: _, interactionWidth: b });
  });
}
const xh = ji({ isInternal: !1 }), es = ji({ isInternal: !0 });
xh.displayName = "BezierEdge";
es.displayName = "BezierEdgeInternal";
const hr = {
  default: es,
  straight: Ji,
  step: Ui,
  smoothstep: Gi,
  simplebezier: Zi
}, gr = {
  sourceX: null,
  sourceY: null,
  targetX: null,
  targetY: null,
  sourcePosition: null,
  targetPosition: null
}, vh = (e, t, n) => n === B.Left ? e - t : n === B.Right ? e + t : e, _h = (e, t, n) => n === B.Top ? e - t : n === B.Bottom ? e + t : e, pr = "react-flow__edgeupdater";
function mr({ position: e, centerX: t, centerY: n, radius: o = 10, onMouseDown: r, onMouseEnter: i, onMouseOut: s, type: a }) {
  return z("circle", { onMouseDown: r, onMouseEnter: i, onMouseOut: s, className: re([pr, `${pr}-${a}`]), cx: vh(t, o, e), cy: _h(n, o, e), r: o, stroke: "transparent", fill: "transparent" });
}
function bh({ isReconnectable: e, reconnectRadius: t, edge: n, sourceX: o, sourceY: r, targetX: i, targetY: s, sourcePosition: a, targetPosition: c, onReconnect: l, onReconnectStart: d, onReconnectEnd: u, setReconnecting: f, setUpdateHover: h }) {
  const p = ee(), y = (w, N) => {
    if (w.button !== 0)
      return;
    const { autoPanOnConnect: k, domNode: S, isValidConnection: P, connectionMode: I, connectionRadius: A, lib: V, onConnectStart: D, onConnectEnd: H, cancelConnection: g, nodeLookup: E, rfId: v, panBy: M, updateConnection: $ } = p.getState(), C = N.type === "target";
    f(!0), d?.(w, n, N.type);
    const T = (R, W) => {
      f(!1), u?.(R, n, N.type, W);
    }, O = (R) => l?.(n, R);
    Fn.onPointerDown(w.nativeEvent, {
      autoPanOnConnect: k,
      connectionMode: I,
      connectionRadius: A,
      domNode: S,
      handleId: N.id,
      nodeId: N.nodeId,
      nodeLookup: E,
      isTarget: C,
      edgeUpdaterType: N.type,
      lib: V,
      flowId: v,
      cancelConnection: g,
      panBy: M,
      isValidConnection: P,
      onConnect: O,
      onConnectStart: D,
      onConnectEnd: H,
      onReconnectEnd: T,
      updateConnection: $,
      getTransform: () => p.getState().transform,
      getFromHandle: () => p.getState().connection.fromHandle
    });
  }, _ = (w) => y(w, { nodeId: n.target, id: n.targetHandle ?? null, type: "target" }), x = (w) => y(w, { nodeId: n.source, id: n.sourceHandle ?? null, type: "source" }), b = () => h(!0), m = () => h(!1);
  return se(Se, { children: [(e === !0 || e === "source") && z(mr, { position: a, centerX: o, centerY: r, radius: t, onMouseDown: _, onMouseEnter: b, onMouseOut: m, type: "source" }), (e === !0 || e === "target") && z(mr, { position: c, centerX: i, centerY: s, radius: t, onMouseDown: x, onMouseEnter: b, onMouseOut: m, type: "target" })] });
}
function Eh({ id: e, edgesFocusable: t, edgesReconnectable: n, elementsSelectable: o, onClick: r, onDoubleClick: i, onContextMenu: s, onMouseEnter: a, onMouseMove: c, onMouseLeave: l, reconnectRadius: d, onReconnect: u, onReconnectStart: f, onReconnectEnd: h, rfId: p, edgeTypes: y, noPanClassName: _, onError: x, disableKeyboardA11y: b }) {
  let m = G((q) => q.edgeLookup.get(e));
  const w = G((q) => q.defaultEdgeOptions);
  m = w ? { ...w, ...m } : m;
  let N = m.type || "default", k = y?.[N] || hr[N];
  k === void 0 && (x?.("011", Ne.error011(N)), N = "default", k = hr.default);
  const S = !!(m.focusable || t && typeof m.focusable > "u"), P = typeof u < "u" && (m.reconnectable || n && typeof m.reconnectable > "u"), I = !!(m.selectable || o && typeof m.selectable > "u"), A = J(null), [V, D] = fe(!1), [H, g] = fe(!1), E = ee(), { zIndex: v, sourceX: M, sourceY: $, targetX: C, targetY: T, sourcePosition: O, targetPosition: R } = G(ue((q) => {
    const U = q.nodeLookup.get(m.source), oe = q.nodeLookup.get(m.target);
    if (!U || !oe)
      return {
        zIndex: m.zIndex,
        ...gr
      };
    const ae = vd({
      id: e,
      sourceNode: U,
      targetNode: oe,
      sourceHandle: m.sourceHandle || null,
      targetHandle: m.targetHandle || null,
      connectionMode: q.connectionMode,
      onError: x
    });
    return {
      zIndex: fd({
        selected: m.selected,
        zIndex: m.zIndex,
        sourceNode: U,
        targetNode: oe,
        elevateOnSelect: q.elevateEdgesOnSelect
      }),
      ...ae || gr
    };
  }, [m.source, m.target, m.sourceHandle, m.targetHandle, m.selected, m.zIndex]), ne), W = me(() => m.markerStart ? `url('#${Ln(m.markerStart, p)}')` : void 0, [m.markerStart, p]), Y = me(() => m.markerEnd ? `url('#${Ln(m.markerEnd, p)}')` : void 0, [m.markerEnd, p]);
  if (m.hidden || M === null || $ === null || C === null || T === null)
    return null;
  const F = (q) => {
    const { addSelectedEdges: U, unselectNodesAndEdges: oe, multiSelectionActive: ae } = E.getState();
    I && (E.setState({ nodesSelectionActive: !1 }), m.selected && ae ? (oe({ nodes: [], edges: [m] }), A.current?.blur()) : U([e])), r && r(q, m);
  }, Z = i ? (q) => {
    i(q, { ...m });
  } : void 0, L = s ? (q) => {
    s(q, { ...m });
  } : void 0, X = a ? (q) => {
    a(q, { ...m });
  } : void 0, K = c ? (q) => {
    c(q, { ...m });
  } : void 0, te = l ? (q) => {
    l(q, { ...m });
  } : void 0, Q = (q) => {
    if (!b && jr.includes(q.key) && I) {
      const { unselectNodesAndEdges: U, addSelectedEdges: oe } = E.getState();
      q.key === "Escape" ? (A.current?.blur(), U({ edges: [m] })) : oe([e]);
    }
  };
  return z("svg", { style: { zIndex: v }, children: se("g", { className: re([
    "react-flow__edge",
    `react-flow__edge-${N}`,
    m.className,
    _,
    {
      selected: m.selected,
      animated: m.animated,
      inactive: !I && !r,
      updating: V,
      selectable: I
    }
  ]), onClick: F, onDoubleClick: Z, onContextMenu: L, onMouseEnter: X, onMouseMove: K, onMouseLeave: te, onKeyDown: S ? Q : void 0, tabIndex: S ? 0 : void 0, role: S ? "button" : "img", "data-id": e, "data-testid": `rf__edge-${e}`, "aria-label": m.ariaLabel === null ? void 0 : m.ariaLabel || `Edge from ${m.source} to ${m.target}`, "aria-describedby": S ? `${Ii}-${p}` : void 0, ref: A, children: [!H && z(k, { id: e, source: m.source, target: m.target, type: m.type, selected: m.selected, animated: m.animated, selectable: I, deletable: m.deletable ?? !0, label: m.label, labelStyle: m.labelStyle, labelShowBg: m.labelShowBg, labelBgStyle: m.labelBgStyle, labelBgPadding: m.labelBgPadding, labelBgBorderRadius: m.labelBgBorderRadius, sourceX: M, sourceY: $, targetX: C, targetY: T, sourcePosition: O, targetPosition: R, data: m.data, style: m.style, sourceHandleId: m.sourceHandle, targetHandleId: m.targetHandle, markerStart: W, markerEnd: Y, pathOptions: "pathOptions" in m ? m.pathOptions : void 0, interactionWidth: m.interactionWidth }), P && z(bh, { edge: m, isReconnectable: P, reconnectRadius: d, onReconnect: u, onReconnectStart: f, onReconnectEnd: h, sourceX: M, sourceY: $, targetX: C, targetY: T, sourcePosition: O, targetPosition: R, setUpdateHover: D, setReconnecting: g })] }) });
}
const Sh = (e) => ({
  edgesFocusable: e.edgesFocusable,
  edgesReconnectable: e.edgesReconnectable,
  elementsSelectable: e.elementsSelectable,
  connectionMode: e.connectionMode,
  onError: e.onError
});
function ts({ defaultMarkerColor: e, onlyRenderVisibleElements: t, rfId: n, edgeTypes: o, noPanClassName: r, onReconnect: i, onEdgeContextMenu: s, onEdgeMouseEnter: a, onEdgeMouseMove: c, onEdgeMouseLeave: l, onEdgeClick: d, reconnectRadius: u, onEdgeDoubleClick: f, onReconnectStart: h, onReconnectEnd: p, disableKeyboardA11y: y }) {
  const { edgesFocusable: _, edgesReconnectable: x, elementsSelectable: b, onError: m } = G(Sh, ne), w = lh(t);
  return se("div", { className: "react-flow__edges", children: [z(gh, { defaultColor: e, rfId: n }), w.map((N) => z(Eh, { id: N, edgesFocusable: _, edgesReconnectable: x, elementsSelectable: b, noPanClassName: r, onReconnect: i, onContextMenu: s, onMouseEnter: a, onMouseMove: c, onMouseLeave: l, onClick: d, reconnectRadius: u, onDoubleClick: f, onReconnectStart: h, onReconnectEnd: p, rfId: n, onError: m, edgeTypes: o, disableKeyboardA11y: y }, N))] });
}
ts.displayName = "EdgeRenderer";
const Nh = ie(ts), Ch = (e) => `translate(${e.transform[0]}px,${e.transform[1]}px) scale(${e.transform[2]})`;
function Mh({ children: e }) {
  const t = G(Ch);
  return z("div", { className: "react-flow__viewport xyflow__viewport react-flow__container", style: { transform: t }, children: e });
}
function kh(e) {
  const t = so(), n = J(!1);
  j(() => {
    !n.current && t.viewportInitialized && e && (setTimeout(() => e(t), 1), n.current = !0);
  }, [e, t.viewportInitialized]);
}
const $h = (e) => e.panZoom?.syncViewport;
function Ih(e) {
  const t = G($h), n = ee();
  return j(() => {
    e && (t?.(e), n.setState({ transform: [e.x, e.y, e.zoom] }));
  }, [e, t]), null;
}
function Ah(e) {
  return e.connection.inProgress ? { ...e.connection, to: bt(e.connection.to, e.transform) } : { ...e.connection };
}
function Ph(e) {
  return Ah;
}
function zh(e) {
  const t = Ph();
  return G(t, ne);
}
const Th = (e) => ({
  nodesConnectable: e.nodesConnectable,
  isValid: e.connection.isValid,
  inProgress: e.connection.inProgress,
  width: e.width,
  height: e.height
});
function Dh({ containerStyle: e, style: t, type: n, component: o }) {
  const { nodesConnectable: r, width: i, height: s, isValid: a, inProgress: c } = G(Th, ne);
  return !(i && r && c) ? null : z("svg", { style: e, width: i, height: s, className: "react-flow__connectionline react-flow__container", children: z("g", { className: re(["react-flow__connection", ti(a)]), children: z(ns, { style: t, type: n, CustomComponent: o, isValid: a }) }) });
}
const ns = ({ style: e, type: t = Ie.Bezier, CustomComponent: n, isValid: o }) => {
  const { inProgress: r, from: i, fromNode: s, fromHandle: a, fromPosition: c, to: l, toNode: d, toHandle: u, toPosition: f } = zh();
  if (!r)
    return;
  if (n)
    return z(n, { connectionLineType: t, connectionLineStyle: e, fromNode: s, fromHandle: a, fromX: i.x, fromY: i.y, toX: l.x, toY: l.y, fromPosition: c, toPosition: f, connectionStatus: ti(o), toNode: d, toHandle: u });
  let h = "";
  const p = {
    sourceX: i.x,
    sourceY: i.y,
    sourcePosition: c,
    targetX: l.x,
    targetY: l.y,
    targetPosition: f
  };
  switch (t) {
    case Ie.Bezier:
      [h] = gi(p);
      break;
    case Ie.SimpleBezier:
      [h] = Xi(p);
      break;
    case Ie.Step:
      [h] = Rn({
        ...p,
        borderRadius: 0
      });
      break;
    case Ie.SmoothStep:
      [h] = Rn(p);
      break;
    default:
      [h] = mi(p);
  }
  return z("path", { d: h, fill: "none", className: "react-flow__connection-path", style: e });
};
ns.displayName = "ConnectionLine";
const Hh = {};
function yr(e = Hh) {
  J(e), ee(), j(() => {
  }, [e]);
}
function Vh() {
  ee(), J(!1), j(() => {
  }, []);
}
function os({ nodeTypes: e, edgeTypes: t, onInit: n, onNodeClick: o, onEdgeClick: r, onNodeDoubleClick: i, onEdgeDoubleClick: s, onNodeMouseEnter: a, onNodeMouseMove: c, onNodeMouseLeave: l, onNodeContextMenu: d, onSelectionContextMenu: u, onSelectionStart: f, onSelectionEnd: h, connectionLineType: p, connectionLineStyle: y, connectionLineComponent: _, connectionLineContainerStyle: x, selectionKeyCode: b, selectionOnDrag: m, selectionMode: w, multiSelectionKeyCode: N, panActivationKeyCode: k, zoomActivationKeyCode: S, deleteKeyCode: P, onlyRenderVisibleElements: I, elementsSelectable: A, defaultViewport: V, translateExtent: D, minZoom: H, maxZoom: g, preventScrolling: E, defaultMarkerColor: v, zoomOnScroll: M, zoomOnPinch: $, panOnScroll: C, panOnScrollSpeed: T, panOnScrollMode: O, zoomOnDoubleClick: R, panOnDrag: W, onPaneClick: Y, onPaneMouseEnter: F, onPaneMouseMove: Z, onPaneMouseLeave: L, onPaneScroll: X, onPaneContextMenu: K, paneClickDistance: te, nodeClickDistance: Q, onEdgeContextMenu: q, onEdgeMouseEnter: U, onEdgeMouseMove: oe, onEdgeMouseLeave: ae, reconnectRadius: Pe, onReconnect: un, onReconnectStart: dn, onReconnectEnd: fn, noDragClassName: Qe, noWheelClassName: hn, noPanClassName: Je, disableKeyboardA11y: je, nodeExtent: gn, rfId: et, viewport: tt, onViewportChange: Et }) {
  return yr(e), yr(t), Vh(), kh(n), Ih(tt), z(eh, { onPaneClick: Y, onPaneMouseEnter: F, onPaneMouseMove: Z, onPaneMouseLeave: L, onPaneContextMenu: K, onPaneScroll: X, paneClickDistance: te, deleteKeyCode: P, selectionKeyCode: b, selectionOnDrag: m, selectionMode: w, onSelectionStart: f, onSelectionEnd: h, multiSelectionKeyCode: N, panActivationKeyCode: k, zoomActivationKeyCode: S, elementsSelectable: A, zoomOnScroll: M, zoomOnPinch: $, zoomOnDoubleClick: R, panOnScroll: C, panOnScrollSpeed: T, panOnScrollMode: O, panOnDrag: W, defaultViewport: V, translateExtent: D, minZoom: H, maxZoom: g, onSelectionContextMenu: u, preventScrolling: E, noDragClassName: Qe, noWheelClassName: hn, noPanClassName: Je, disableKeyboardA11y: je, onViewportChange: Et, isControlledViewport: !!tt, children: se(Mh, { children: [z(Nh, { edgeTypes: t, onEdgeClick: r, onEdgeDoubleClick: s, onReconnect: un, onReconnectStart: dn, onReconnectEnd: fn, onlyRenderVisibleElements: I, onEdgeContextMenu: q, onEdgeMouseEnter: U, onEdgeMouseMove: oe, onEdgeMouseLeave: ae, reconnectRadius: Pe, defaultMarkerColor: v, noPanClassName: Je, disableKeyboardA11y: je, rfId: et }), z(Dh, { style: y, type: p, component: _, containerStyle: x }), z("div", { className: "react-flow__edgelabel-renderer" }), z(ch, { nodeTypes: e, onNodeClick: o, onNodeDoubleClick: i, onNodeMouseEnter: a, onNodeMouseMove: c, onNodeMouseLeave: l, onNodeContextMenu: d, nodeClickDistance: Q, onlyRenderVisibleElements: I, noPanClassName: Je, noDragClassName: Qe, disableKeyboardA11y: je, nodeExtent: gn, rfId: et }), z("div", { className: "react-flow__viewport-portal" })] }) });
}
os.displayName = "GraphView";
const Oh = ie(os), wr = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: s, nodeOrigin: a, nodeExtent: c } = {}) => {
  const l = /* @__PURE__ */ new Map(), d = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), f = /* @__PURE__ */ new Map(), h = o ?? t ?? [], p = n ?? e ?? [], y = a ?? [0, 0], _ = c ?? ht;
  wi(u, f, h), Bn(p, l, d, {
    nodeOrigin: y,
    nodeExtent: _,
    elevateNodesOnSelect: !1
  });
  let x = [0, 0, 1];
  if (s && r && i) {
    const b = Ue(l, {
      filter: (k) => !!((k.width || k.initialWidth) && (k.height || k.initialHeight))
    }), { x: m, y: w, zoom: N } = to(b, r, i, 0.5, 2, 0.1);
    x = [m, w, N];
  }
  return {
    rfId: "1",
    width: 0,
    height: 0,
    transform: x,
    nodes: p,
    nodeLookup: l,
    parentLookup: d,
    edges: h,
    edgeLookup: f,
    connectionLookup: u,
    onNodesChange: null,
    onEdgesChange: null,
    hasDefaultNodes: n !== void 0,
    hasDefaultEdges: o !== void 0,
    panZoom: null,
    minZoom: 0.5,
    maxZoom: 2,
    translateExtent: ht,
    nodeExtent: _,
    nodesSelectionActive: !1,
    userSelectionActive: !1,
    userSelectionRect: null,
    connectionMode: We.Strict,
    domNode: null,
    paneDragging: !1,
    noPanClassName: "nopan",
    nodeOrigin: y,
    nodeDragThreshold: 1,
    snapGrid: [15, 15],
    snapToGrid: !1,
    nodesDraggable: !0,
    nodesConnectable: !0,
    nodesFocusable: !0,
    edgesFocusable: !0,
    edgesReconnectable: !0,
    elementsSelectable: !0,
    elevateNodesOnSelect: !0,
    elevateEdgesOnSelect: !1,
    fitViewOnInit: !1,
    fitViewDone: !1,
    fitViewOnInitOptions: void 0,
    selectNodesOnDrag: !0,
    multiSelectionActive: !1,
    connection: { ...ei },
    connectionClickStartHandle: null,
    connectOnClick: !0,
    ariaLiveMessage: "",
    autoPanOnConnect: !0,
    autoPanOnNodeDrag: !0,
    autoPanSpeed: 15,
    connectionRadius: 20,
    onError: ud,
    isValidConnection: void 0,
    onSelectionChangeHandlers: [],
    lib: "react",
    debug: !1
  };
}, Rh = ({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, width: r, height: i, fitView: s, nodeOrigin: a, nodeExtent: c }) => of((l, d) => ({
  ...wr({ nodes: e, edges: t, width: r, height: i, fitView: s, nodeOrigin: a, nodeExtent: c, defaultNodes: n, defaultEdges: o }),
  setNodes: (u) => {
    const { nodeLookup: f, parentLookup: h, nodeOrigin: p, elevateNodesOnSelect: y } = d();
    Bn(u, f, h, {
      nodeOrigin: p,
      nodeExtent: c,
      elevateNodesOnSelect: y,
      checkEquality: !0
    }), l({ nodes: u });
  },
  setEdges: (u) => {
    const { connectionLookup: f, edgeLookup: h } = d();
    wi(f, h, u), l({ edges: u });
  },
  setDefaultNodesAndEdges: (u, f) => {
    if (u) {
      const { setNodes: h } = d();
      h(u), l({ hasDefaultNodes: !0 });
    }
    if (f) {
      const { setEdges: h } = d();
      h(f), l({ hasDefaultEdges: !0 });
    }
  },
  /*
   * Every node gets registerd at a ResizeObserver. Whenever a node
   * changes its dimensions, this function is called to measure the
   * new dimensions and update the nodes.
   */
  updateNodeInternals: (u, f = { triggerFitView: !0 }) => {
    const { triggerNodeChanges: h, nodeLookup: p, parentLookup: y, fitViewOnInit: _, fitViewDone: x, fitViewOnInitOptions: b, domNode: m, nodeOrigin: w, nodeExtent: N, debug: k, fitViewSync: S } = d(), { changes: P, updatedInternals: I } = Md(u, p, y, m, w, N);
    if (I) {
      if (Sd(p, y, { nodeOrigin: w, nodeExtent: N }), f.triggerFitView) {
        let A = x;
        !x && _ && (A = S({
          ...b,
          nodes: b?.nodes
        })), l({ fitViewDone: A });
      } else
        l({});
      P?.length > 0 && (k && console.log("React Flow: trigger node changes", P), h?.(P));
    }
  },
  updateNodePositions: (u, f = !1) => {
    const h = [], p = [];
    for (const [y, _] of u) {
      const x = !!(_?.expandParent && _?.parentId && _?.position), b = {
        id: y,
        type: "position",
        position: x ? {
          x: Math.max(0, _.position.x),
          y: Math.max(0, _.position.y)
        } : _.position,
        dragging: f
      };
      x && h.push({
        id: y,
        parentId: _.parentId,
        rect: {
          ..._.internals.positionAbsolute,
          width: _.measured.width,
          height: _.measured.height
        }
      }), p.push(b);
    }
    if (h.length > 0) {
      const { nodeLookup: y, parentLookup: _, nodeOrigin: x } = d(), b = io(h, y, _, x);
      p.push(...b);
    }
    d().triggerNodeChanges(p);
  },
  triggerNodeChanges: (u) => {
    const { onNodesChange: f, setNodes: h, nodes: p, hasDefaultNodes: y, debug: _ } = d();
    if (u?.length) {
      if (y) {
        const x = zi(u, p);
        h(x);
      }
      _ && console.log("React Flow: trigger node changes", u), f?.(u);
    }
  },
  triggerEdgeChanges: (u) => {
    const { onEdgesChange: f, setEdges: h, edges: p, hasDefaultEdges: y, debug: _ } = d();
    if (u?.length) {
      if (y) {
        const x = Ti(u, p);
        h(x);
      }
      _ && console.log("React Flow: trigger edge changes", u), f?.(u);
    }
  },
  addSelectedNodes: (u) => {
    const { multiSelectionActive: f, edgeLookup: h, nodeLookup: p, triggerNodeChanges: y, triggerEdgeChanges: _ } = d();
    if (f) {
      const x = u.map((b) => ze(b, !0));
      y(x);
      return;
    }
    y(Le(p, /* @__PURE__ */ new Set([...u]), !0)), _(Le(h));
  },
  addSelectedEdges: (u) => {
    const { multiSelectionActive: f, edgeLookup: h, nodeLookup: p, triggerNodeChanges: y, triggerEdgeChanges: _ } = d();
    if (f) {
      const x = u.map((b) => ze(b, !0));
      _(x);
      return;
    }
    _(Le(h, /* @__PURE__ */ new Set([...u]))), y(Le(p, /* @__PURE__ */ new Set(), !0));
  },
  unselectNodesAndEdges: ({ nodes: u, edges: f } = {}) => {
    const { edges: h, nodes: p, nodeLookup: y, triggerNodeChanges: _, triggerEdgeChanges: x } = d(), b = u || p, m = f || h, w = b.map((k) => {
      const S = y.get(k.id);
      return S && (S.selected = !1), ze(k.id, !1);
    }), N = m.map((k) => ze(k.id, !1));
    _(w), x(N);
  },
  setMinZoom: (u) => {
    const { panZoom: f, maxZoom: h } = d();
    f?.setScaleExtent([u, h]), l({ minZoom: u });
  },
  setMaxZoom: (u) => {
    const { panZoom: f, minZoom: h } = d();
    f?.setScaleExtent([h, u]), l({ maxZoom: u });
  },
  setTranslateExtent: (u) => {
    d().panZoom?.setTranslateExtent(u), l({ translateExtent: u });
  },
  setPaneClickDistance: (u) => {
    d().panZoom?.setClickDistance(u);
  },
  resetSelectedElements: () => {
    const { edges: u, nodes: f, triggerNodeChanges: h, triggerEdgeChanges: p } = d(), y = f.reduce((x, b) => b.selected ? [...x, ze(b.id, !1)] : x, []), _ = u.reduce((x, b) => b.selected ? [...x, ze(b.id, !1)] : x, []);
    h(y), p(_);
  },
  setNodeExtent: (u) => {
    const { nodes: f, nodeLookup: h, parentLookup: p, nodeOrigin: y, elevateNodesOnSelect: _, nodeExtent: x } = d();
    u[0][0] === x[0][0] && u[0][1] === x[0][1] && u[1][0] === x[1][0] && u[1][1] === x[1][1] || (Bn(f, h, p, {
      nodeOrigin: y,
      nodeExtent: u,
      elevateNodesOnSelect: _,
      checkEquality: !1
    }), l({ nodeExtent: u }));
  },
  panBy: (u) => {
    const { transform: f, width: h, height: p, panZoom: y, translateExtent: _ } = d();
    return kd({ delta: u, panZoom: y, transform: f, translateExtent: _, width: h, height: p });
  },
  fitView: (u) => {
    const { panZoom: f, width: h, height: p, minZoom: y, maxZoom: _, nodeLookup: x } = d();
    if (!f)
      return Promise.resolve(!1);
    const b = Dn(x, u);
    return Hn({
      nodes: b,
      width: h,
      height: p,
      panZoom: f,
      minZoom: y,
      maxZoom: _
    }, u);
  },
  /*
   * we can't call an asnychronous function in updateNodeInternals
   * for that we created this sync version of fitView
   */
  fitViewSync: (u) => {
    const { panZoom: f, width: h, height: p, minZoom: y, maxZoom: _, nodeLookup: x } = d();
    if (!f)
      return !1;
    const b = Dn(x, u);
    return Hn({
      nodes: b,
      width: h,
      height: p,
      panZoom: f,
      minZoom: y,
      maxZoom: _
    }, u), b.size > 0;
  },
  cancelConnection: () => {
    l({
      connection: { ...ei }
    });
  },
  updateConnection: (u) => {
    l({ connection: u });
  },
  reset: () => l({ ...wr() })
}), Object.is);
function Lh({ initialNodes: e, initialEdges: t, defaultNodes: n, defaultEdges: o, initialWidth: r, initialHeight: i, fitView: s, nodeOrigin: a, nodeExtent: c, children: l }) {
  const [d] = fe(() => Rh({
    nodes: e,
    edges: t,
    defaultNodes: n,
    defaultEdges: o,
    width: r,
    height: i,
    fitView: s,
    nodeOrigin: a,
    nodeExtent: c
  }));
  return z(rf, { value: d, children: z(kf, { children: l }) });
}
function Bh({ children: e, nodes: t, edges: n, defaultNodes: o, defaultEdges: r, width: i, height: s, fitView: a, nodeOrigin: c, nodeExtent: l }) {
  return wt(sn) ? z(Se, { children: e }) : z(Lh, { initialNodes: t, initialEdges: n, defaultNodes: o, defaultEdges: r, initialWidth: i, initialHeight: s, fitView: a, nodeOrigin: c, nodeExtent: l, children: e });
}
const Fh = {
  width: "100%",
  height: "100%",
  overflow: "hidden",
  position: "relative",
  zIndex: 0
};
function Xh({ nodes: e, edges: t, defaultNodes: n, defaultEdges: o, className: r, nodeTypes: i, edgeTypes: s, onNodeClick: a, onEdgeClick: c, onInit: l, onMove: d, onMoveStart: u, onMoveEnd: f, onConnect: h, onConnectStart: p, onConnectEnd: y, onClickConnectStart: _, onClickConnectEnd: x, onNodeMouseEnter: b, onNodeMouseMove: m, onNodeMouseLeave: w, onNodeContextMenu: N, onNodeDoubleClick: k, onNodeDragStart: S, onNodeDrag: P, onNodeDragStop: I, onNodesDelete: A, onEdgesDelete: V, onDelete: D, onSelectionChange: H, onSelectionDragStart: g, onSelectionDrag: E, onSelectionDragStop: v, onSelectionContextMenu: M, onSelectionStart: $, onSelectionEnd: C, onBeforeDelete: T, connectionMode: O, connectionLineType: R = Ie.Bezier, connectionLineStyle: W, connectionLineComponent: Y, connectionLineContainerStyle: F, deleteKeyCode: Z = "Backspace", selectionKeyCode: L = "Shift", selectionOnDrag: X = !1, selectionMode: K = gt.Full, panActivationKeyCode: te = "Space", multiSelectionKeyCode: Q = Zt() ? "Meta" : "Control", zoomActivationKeyCode: q = Zt() ? "Meta" : "Control", snapToGrid: U, snapGrid: oe, onlyRenderVisibleElements: ae = !1, selectNodesOnDrag: Pe, nodesDraggable: un, nodesConnectable: dn, nodesFocusable: fn, nodeOrigin: Qe = Ai, edgesFocusable: hn, edgesReconnectable: Je, elementsSelectable: je = !0, defaultViewport: gn = wf, minZoom: et = 0.5, maxZoom: tt = 2, translateExtent: Et = ht, preventScrolling: as = !0, nodeExtent: pn, defaultMarkerColor: cs = "#b1b1b7", zoomOnScroll: ls = !0, zoomOnPinch: us = !0, panOnScroll: ds = !1, panOnScrollSpeed: fs = 0.5, panOnScrollMode: hs = He.Free, zoomOnDoubleClick: gs = !0, panOnDrag: ps = !0, onPaneClick: ms, onPaneMouseEnter: ys, onPaneMouseMove: ws, onPaneMouseLeave: xs, onPaneScroll: vs, onPaneContextMenu: _s, paneClickDistance: lo = 0, nodeClickDistance: bs = 0, children: Es, onReconnect: Ss, onReconnectStart: Ns, onReconnectEnd: Cs, onEdgeContextMenu: Ms, onEdgeDoubleClick: ks, onEdgeMouseEnter: $s, onEdgeMouseMove: Is, onEdgeMouseLeave: As, reconnectRadius: Ps = 10, onNodesChange: zs, onEdgesChange: Ts, noDragClassName: Ds = "nodrag", noWheelClassName: Hs = "nowheel", noPanClassName: uo = "nopan", fitView: fo, fitViewOptions: Vs, connectOnClick: Os, attributionPosition: Rs, proOptions: Ls, defaultEdgeOptions: Bs, elevateNodesOnSelect: Fs, elevateEdgesOnSelect: Xs, disableKeyboardA11y: ho = !1, autoPanOnConnect: Ys, autoPanOnNodeDrag: Zs, autoPanSpeed: Ws, connectionRadius: qs, isValidConnection: Gs, onError: Ks, style: Us, id: go, nodeDragThreshold: Qs, viewport: Js, onViewportChange: js, width: ea, height: ta, colorMode: na = "light", debug: oa, onScroll: po, ...ra }, ia) {
  const mn = go || "1", sa = bf(na), aa = ue((mo) => {
    mo.currentTarget.scrollTo({ top: 0, left: 0, behavior: "instant" }), po?.(mo);
  }, [po]);
  return z("div", { "data-testid": "rf__wrapper", ...ra, onScroll: aa, style: { ...Us, ...Fh }, ref: ia, className: re(["react-flow", r, sa]), id: go, children: se(Bh, { nodes: e, edges: t, width: ea, height: ta, fitView: fo, nodeOrigin: Qe, nodeExtent: pn, children: [z(Oh, { onInit: l, onNodeClick: a, onEdgeClick: c, onNodeMouseEnter: b, onNodeMouseMove: m, onNodeMouseLeave: w, onNodeContextMenu: N, onNodeDoubleClick: k, nodeTypes: i, edgeTypes: s, connectionLineType: R, connectionLineStyle: W, connectionLineComponent: Y, connectionLineContainerStyle: F, selectionKeyCode: L, selectionOnDrag: X, selectionMode: K, deleteKeyCode: Z, multiSelectionKeyCode: Q, panActivationKeyCode: te, zoomActivationKeyCode: q, onlyRenderVisibleElements: ae, defaultViewport: gn, translateExtent: Et, minZoom: et, maxZoom: tt, preventScrolling: as, zoomOnScroll: ls, zoomOnPinch: us, zoomOnDoubleClick: gs, panOnScroll: ds, panOnScrollSpeed: fs, panOnScrollMode: hs, panOnDrag: ps, onPaneClick: ms, onPaneMouseEnter: ys, onPaneMouseMove: ws, onPaneMouseLeave: xs, onPaneScroll: vs, onPaneContextMenu: _s, paneClickDistance: lo, nodeClickDistance: bs, onSelectionContextMenu: M, onSelectionStart: $, onSelectionEnd: C, onReconnect: Ss, onReconnectStart: Ns, onReconnectEnd: Cs, onEdgeContextMenu: Ms, onEdgeDoubleClick: ks, onEdgeMouseEnter: $s, onEdgeMouseMove: Is, onEdgeMouseLeave: As, reconnectRadius: Ps, defaultMarkerColor: cs, noDragClassName: Ds, noWheelClassName: Hs, noPanClassName: uo, rfId: mn, disableKeyboardA11y: ho, nodeExtent: pn, viewport: Js, onViewportChange: js }), z(_f, { nodes: e, edges: t, defaultNodes: n, defaultEdges: o, onConnect: h, onConnectStart: p, onConnectEnd: y, onClickConnectStart: _, onClickConnectEnd: x, nodesDraggable: un, nodesConnectable: dn, nodesFocusable: fn, edgesFocusable: hn, edgesReconnectable: Je, elementsSelectable: je, elevateNodesOnSelect: Fs, elevateEdgesOnSelect: Xs, minZoom: et, maxZoom: tt, nodeExtent: pn, onNodesChange: zs, onEdgesChange: Ts, snapToGrid: U, snapGrid: oe, connectionMode: O, translateExtent: Et, connectOnClick: Os, defaultEdgeOptions: Bs, fitView: fo, fitViewOptions: Vs, onNodesDelete: A, onEdgesDelete: V, onDelete: D, onNodeDragStart: S, onNodeDrag: P, onNodeDragStop: I, onSelectionDrag: E, onSelectionDragStart: g, onSelectionDragStop: v, onMove: d, onMoveStart: u, onMoveEnd: f, noPanClassName: uo, nodeOrigin: Qe, rfId: mn, autoPanOnConnect: Ys, autoPanOnNodeDrag: Zs, autoPanSpeed: Ws, onError: Ks, connectionRadius: qs, isValidConnection: Gs, selectNodesOnDrag: Pe, nodeDragThreshold: Qs, onBeforeDelete: T, paneClickDistance: lo, debug: oa }), z(yf, { onSelectionChange: H }), Es, z(ff, { proOptions: Ls, position: Rs }), z(uf, { rfId: mn, disableKeyboardA11y: ho })] }) });
}
var _g = Di(Xh);
const Yh = (e) => e.domNode?.querySelector(".react-flow__edgelabel-renderer");
function bg({ children: e }) {
  const t = G(Yh);
  return t ? vr(e, t) : null;
}
function Eg(e) {
  const [t, n] = fe(e), o = ue((r) => n((i) => zi(r, i)), []);
  return [t, n, o];
}
function Sg(e) {
  const [t, n] = fe(e), o = ue((r) => n((i) => Ti(r, i)), []);
  return [t, n, o];
}
function Ng({ onStart: e, onChange: t, onEnd: n }) {
  const o = ee();
  j(() => {
    o.setState({ onViewportChangeStart: e });
  }, [e]), j(() => {
    o.setState({ onViewportChange: t });
  }, [t]), j(() => {
    o.setState({ onViewportChangeEnd: n });
  }, [n]);
}
function Cg(e) {
  return G(ue((n) => n.nodeLookup.get(e), [e]), ne);
}
function Zh({ dimensions: e, lineWidth: t, variant: n, className: o }) {
  return z("path", { strokeWidth: t, d: `M${e[0] / 2} 0 V${e[1]} M0 ${e[1] / 2} H${e[0]}`, className: re(["react-flow__background-pattern", n, o]) });
}
function Wh({ radius: e, className: t }) {
  return z("circle", { cx: e, cy: e, r: e, className: re(["react-flow__background-pattern", "dots", t]) });
}
var Ae;
(function(e) {
  e.Lines = "lines", e.Dots = "dots", e.Cross = "cross";
})(Ae || (Ae = {}));
const qh = {
  [Ae.Dots]: 1,
  [Ae.Lines]: 1,
  [Ae.Cross]: 6
}, Gh = (e) => ({ transform: e.transform, patternId: `pattern-${e.rfId}` });
function rs({
  id: e,
  variant: t = Ae.Dots,
  // only used for dots and cross
  gap: n = 20,
  // only used for lines and cross
  size: o,
  lineWidth: r = 1,
  offset: i = 0,
  color: s,
  bgColor: a,
  style: c,
  className: l,
  patternClassName: d
}) {
  const u = J(null), { transform: f, patternId: h } = G(Gh, ne), p = o || qh[t], y = t === Ae.Dots, _ = t === Ae.Cross, x = Array.isArray(n) ? n : [n, n], b = [x[0] * f[2] || 1, x[1] * f[2] || 1], m = p * f[2], w = Array.isArray(i) ? i : [i, i], N = _ ? [m, m] : b, k = [
    w[0] * f[2] || 1 + N[0] / 2,
    w[1] * f[2] || 1 + N[1] / 2
  ], S = `${h}${e || ""}`;
  return se("svg", { className: re(["react-flow__background", l]), style: {
    ...c,
    ...cn,
    "--xy-background-color-props": a,
    "--xy-background-pattern-color-props": s
  }, ref: u, "data-testid": "rf__background", children: [z("pattern", { id: S, x: f[0] % b[0], y: f[1] % b[1], width: b[0], height: b[1], patternUnits: "userSpaceOnUse", patternTransform: `translate(-${k[0]},-${k[1]})`, children: y ? z(Wh, { radius: m / 2, className: d }) : z(Zh, { dimensions: N, lineWidth: r, variant: t, className: d }) }), z("rect", { x: "0", y: "0", width: "100%", height: "100%", fill: `url(#${S})` })] });
}
rs.displayName = "Background";
const Mg = ie(rs);
function Kh() {
  return z("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32", children: z("path", { d: "M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z" }) });
}
function Uh() {
  return z("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 5", children: z("path", { d: "M0 0h32v4.2H0z" }) });
}
function Qh() {
  return z("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 30", children: z("path", { d: "M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z" }) });
}
function Jh() {
  return z("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: z("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z" }) });
}
function jh() {
  return z("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 25 32", children: z("path", { d: "M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z" }) });
}
function Pt({ children: e, className: t, ...n }) {
  return z("button", { type: "button", className: re(["react-flow__controls-button", t]), ...n, children: e });
}
const eg = (e) => ({
  isInteractive: e.nodesDraggable || e.nodesConnectable || e.elementsSelectable,
  minZoomReached: e.transform[2] <= e.minZoom,
  maxZoomReached: e.transform[2] >= e.maxZoom
});
function is({ style: e, showZoom: t = !0, showFitView: n = !0, showInteractive: o = !0, fitViewOptions: r, onZoomIn: i, onZoomOut: s, onFitView: a, onInteractiveChange: c, className: l, children: d, position: u = "bottom-left", orientation: f = "vertical", "aria-label": h = "React Flow controls" }) {
  const p = ee(), { isInteractive: y, minZoomReached: _, maxZoomReached: x } = G(eg, ne), { zoomIn: b, zoomOut: m, fitView: w } = so(), N = () => {
    b(), i?.();
  }, k = () => {
    m(), s?.();
  }, S = () => {
    w(r), a?.();
  }, P = () => {
    p.setState({
      nodesDraggable: !y,
      nodesConnectable: !y,
      elementsSelectable: !y
    }), c?.(!y);
  };
  return se(an, { className: re(["react-flow__controls", f === "horizontal" ? "horizontal" : "vertical", l]), position: u, style: e, "data-testid": "rf__controls", "aria-label": h, children: [t && se(Se, { children: [z(Pt, { onClick: N, className: "react-flow__controls-zoomin", title: "zoom in", "aria-label": "zoom in", disabled: x, children: z(Kh, {}) }), z(Pt, { onClick: k, className: "react-flow__controls-zoomout", title: "zoom out", "aria-label": "zoom out", disabled: _, children: z(Uh, {}) })] }), n && z(Pt, { className: "react-flow__controls-fitview", onClick: S, title: "fit view", "aria-label": "fit view", children: z(Qh, {}) }), o && z(Pt, { className: "react-flow__controls-interactive", onClick: P, title: "toggle interactivity", "aria-label": "toggle interactivity", children: y ? z(jh, {}) : z(Jh, {}) }), d] });
}
is.displayName = "Controls";
ie(is);
function tg({ id: e, x: t, y: n, width: o, height: r, style: i, color: s, strokeColor: a, strokeWidth: c, className: l, borderRadius: d, shapeRendering: u, selected: f, onClick: h }) {
  const { background: p, backgroundColor: y } = i || {}, _ = s || p || y;
  return z("rect", { className: re(["react-flow__minimap-node", { selected: f }, l]), x: t, y: n, rx: d, ry: d, width: o, height: r, style: {
    fill: _,
    stroke: a,
    strokeWidth: c
  }, shapeRendering: u, onClick: h ? (x) => h(x, e) : void 0 });
}
const ng = ie(tg), og = (e) => e.nodes.map((t) => t.id), Cn = (e) => e instanceof Function ? e : () => e;
function rg({
  nodeStrokeColor: e,
  nodeColor: t,
  nodeClassName: n = "",
  nodeBorderRadius: o = 5,
  nodeStrokeWidth: r,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: i = ng,
  onClick: s
}) {
  const a = G(og, ne), c = Cn(t), l = Cn(e), d = Cn(n), u = typeof window > "u" || window.chrome ? "crispEdges" : "geometricPrecision";
  return z(Se, { children: a.map((f) => (
    /*
     * The split of responsibilities between MiniMapNodes and
     * NodeComponentWrapper may appear weird. However, it’s designed to
     * minimize the cost of updates when individual nodes change.
     *
     * For more details, see a similar commit in `NodeRenderer/index.tsx`.
     */
    z(sg, { id: f, nodeColorFunc: c, nodeStrokeColorFunc: l, nodeClassNameFunc: d, nodeBorderRadius: o, nodeStrokeWidth: r, NodeComponent: i, onClick: s, shapeRendering: u }, f)
  )) });
}
function ig({ id: e, nodeColorFunc: t, nodeStrokeColorFunc: n, nodeClassNameFunc: o, nodeBorderRadius: r, nodeStrokeWidth: i, shapeRendering: s, NodeComponent: a, onClick: c }) {
  const { node: l, x: d, y: u, width: f, height: h } = G((p) => {
    const y = p.nodeLookup.get(e), { x: _, y: x } = y.internals.positionAbsolute, { width: b, height: m } = Ce(y);
    return {
      node: y,
      x: _,
      y: x,
      width: b,
      height: m
    };
  }, ne);
  return !l || l.hidden || !li(l) ? null : z(a, { x: d, y: u, width: f, height: h, style: l.style, selected: !!l.selected, className: o(l), color: t(l), borderRadius: r, strokeColor: n(l), strokeWidth: i, shapeRendering: s, onClick: c, id: l.id });
}
const sg = ie(ig);
var ag = ie(rg);
const cg = 200, lg = 150, ug = (e) => {
  const t = {
    x: -e.transform[0] / e.transform[2],
    y: -e.transform[1] / e.transform[2],
    width: e.width / e.transform[2],
    height: e.height / e.transform[2]
  };
  return {
    viewBB: t,
    boundingRect: e.nodeLookup.size > 0 ? ai(Ue(e.nodeLookup), t) : t,
    rfId: e.rfId,
    panZoom: e.panZoom,
    translateExtent: e.translateExtent,
    flowWidth: e.width,
    flowHeight: e.height
  };
}, dg = "react-flow__minimap-desc";
function ss({
  style: e,
  className: t,
  nodeStrokeColor: n,
  nodeColor: o,
  nodeClassName: r = "",
  nodeBorderRadius: i = 5,
  nodeStrokeWidth: s,
  /*
   * We need to rename the prop to be `CapitalCase` so that JSX will render it as
   * a component properly.
   */
  nodeComponent: a,
  bgColor: c,
  maskColor: l,
  maskStrokeColor: d,
  maskStrokeWidth: u,
  position: f = "bottom-right",
  onClick: h,
  onNodeClick: p,
  pannable: y = !1,
  zoomable: _ = !1,
  ariaLabel: x = "React Flow mini map",
  inversePan: b,
  zoomStep: m = 10,
  offsetScale: w = 5
}) {
  const N = ee(), k = J(null), { boundingRect: S, viewBB: P, rfId: I, panZoom: A, translateExtent: V, flowWidth: D, flowHeight: H } = G(ug, ne), g = e?.width ?? cg, E = e?.height ?? lg, v = S.width / g, M = S.height / E, $ = Math.max(v, M), C = $ * g, T = $ * E, O = w * $, R = S.x - (C - S.width) / 2 - O, W = S.y - (T - S.height) / 2 - O, Y = C + O * 2, F = T + O * 2, Z = `${dg}-${I}`, L = J(0), X = J();
  L.current = $, j(() => {
    if (k.current && A)
      return X.current = Hd({
        domNode: k.current,
        panZoom: A,
        getTransform: () => N.getState().transform,
        getViewScale: () => L.current
      }), () => {
        X.current?.destroy();
      };
  }, [A]), j(() => {
    X.current?.update({
      translateExtent: V,
      width: D,
      height: H,
      inversePan: b,
      pannable: y,
      zoomStep: m,
      zoomable: _
    });
  }, [y, _, b, m, V, D, H]);
  const K = h ? (Q) => {
    const [q, U] = X.current?.pointer(Q) || [0, 0];
    h(Q, { x: q, y: U });
  } : void 0, te = p ? ue((Q, q) => {
    const U = N.getState().nodeLookup.get(q);
    p(Q, U);
  }, []) : void 0;
  return z(an, { position: f, style: {
    ...e,
    "--xy-minimap-background-color-props": typeof c == "string" ? c : void 0,
    "--xy-minimap-mask-background-color-props": typeof l == "string" ? l : void 0,
    "--xy-minimap-mask-stroke-color-props": typeof d == "string" ? d : void 0,
    "--xy-minimap-mask-stroke-width-props": typeof u == "number" ? u * $ : void 0,
    "--xy-minimap-node-background-color-props": typeof o == "string" ? o : void 0,
    "--xy-minimap-node-stroke-color-props": typeof n == "string" ? n : void 0,
    "--xy-minimap-node-stroke-width-props": typeof s == "string" ? s : void 0
  }, className: re(["react-flow__minimap", t]), "data-testid": "rf__minimap", children: se("svg", { width: g, height: E, viewBox: `${R} ${W} ${Y} ${F}`, className: "react-flow__minimap-svg", role: "img", "aria-labelledby": Z, ref: k, onClick: K, children: [x && z("title", { id: Z, children: x }), z(ag, { onClick: te, nodeColor: o, nodeStrokeColor: n, nodeBorderRadius: i, nodeClassName: r, nodeStrokeWidth: s, nodeComponent: a }), z("path", { className: "react-flow__minimap-mask", d: `M${R - O},${W - O}h${Y + O * 2}v${F + O * 2}h${-Y - O * 2}z
        M${P.x},${P.y}h${P.width}v${P.height}h${-P.width}z`, fillRule: "evenodd", pointerEvents: "none" })] }) });
}
ss.displayName = "MiniMap";
ie(ss);
function fg({ nodeId: e, position: t, variant: n = at.Handle, className: o, style: r = {}, children: i, color: s, minWidth: a = 10, minHeight: c = 10, maxWidth: l = Number.MAX_VALUE, maxHeight: d = Number.MAX_VALUE, keepAspectRatio: u = !1, shouldResize: f, onResizeStart: h, onResize: p, onResizeEnd: y }) {
  const _ = co(), x = typeof e == "string" ? e : _, b = ee(), m = J(null), w = n === at.Line ? "right" : "bottom-right", N = t ?? w, k = J(null);
  j(() => {
    if (!(!m.current || !x))
      return k.current || (k.current = Qd({
        domNode: m.current,
        nodeId: x,
        getStoreItems: () => {
          const { nodeLookup: A, transform: V, snapGrid: D, snapToGrid: H, nodeOrigin: g, domNode: E } = b.getState();
          return {
            nodeLookup: A,
            transform: V,
            snapGrid: D,
            snapToGrid: H,
            nodeOrigin: g,
            paneDomNode: E
          };
        },
        onChange: (A, V) => {
          const { triggerNodeChanges: D, nodeLookup: H, parentLookup: g, nodeOrigin: E } = b.getState(), v = [], M = { x: A.x, y: A.y }, $ = H.get(x);
          if ($ && $.expandParent && $.parentId) {
            const C = $.origin ?? E, T = A.width ?? $.measured.width, O = A.height ?? $.measured.height, R = {
              id: $.id,
              parentId: $.parentId,
              rect: {
                width: T,
                height: O,
                ...ui({
                  x: A.x ?? $.position.x,
                  y: A.y ?? $.position.y
                }, { width: T, height: O }, $.parentId, H, C)
              }
            }, W = io([R], H, g, E);
            v.push(...W), M.x = A.x ? Math.max(C[0] * T, A.x) : void 0, M.y = A.y ? Math.max(C[1] * O, A.y) : void 0;
          }
          if (M.x !== void 0 && M.y !== void 0) {
            const C = {
              id: x,
              type: "position",
              position: { ...M }
            };
            v.push(C);
          }
          if (A.width !== void 0 && A.height !== void 0) {
            const C = {
              id: x,
              type: "dimensions",
              resizing: !0,
              setAttributes: !0,
              dimensions: {
                width: A.width,
                height: A.height
              }
            };
            v.push(C);
          }
          for (const C of V) {
            const T = {
              ...C,
              type: "position"
            };
            v.push(T);
          }
          D(v);
        },
        onEnd: () => {
          const A = {
            id: x,
            type: "dimensions",
            resizing: !1
          };
          b.getState().triggerNodeChanges([A]);
        }
      })), k.current.update({
        controlPosition: N,
        boundaries: {
          minWidth: a,
          minHeight: c,
          maxWidth: l,
          maxHeight: d
        },
        keepAspectRatio: u,
        onResizeStart: h,
        onResize: p,
        onResizeEnd: y,
        shouldResize: f
      }), () => {
        k.current?.destroy();
      };
  }, [
    N,
    a,
    c,
    l,
    d,
    u,
    h,
    p,
    y,
    f
  ]);
  const S = N.split("-"), P = n === at.Line ? "borderColor" : "backgroundColor", I = s ? { ...r, [P]: s } : r;
  return z("div", { className: re(["react-flow__resize-control", "nodrag", ...S, n, o]), ref: m, style: I, children: i });
}
ie(fg);
const hg = (e) => e.domNode?.querySelector(".react-flow__renderer");
function gg({ children: e }) {
  const t = G(hg);
  return t ? vr(e, t) : null;
}
const pg = (e, t) => e?.internals.positionAbsolute.x !== t?.internals.positionAbsolute.x || e?.internals.positionAbsolute.y !== t?.internals.positionAbsolute.y || e?.measured.width !== t?.measured.width || e?.measured.height !== t?.measured.height || e?.selected !== t?.selected || e?.internals.z !== t?.internals.z, mg = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const [n, o] of e)
    if (pg(o, t.get(n)))
      return !1;
  return !0;
}, yg = (e) => ({
  x: e.transform[0],
  y: e.transform[1],
  zoom: e.transform[2],
  selectedNodesCount: e.nodes.filter((t) => t.selected).length
});
function kg({ nodeId: e, children: t, className: n, style: o, isVisible: r, position: i = B.Top, offset: s = 10, align: a = "center", ...c }) {
  const l = co(), d = ue((N) => (Array.isArray(e) ? e : [e || l || ""]).reduce((P, I) => {
    const A = N.nodeLookup.get(I);
    return A && P.set(A.id, A), P;
  }, /* @__PURE__ */ new Map()), [e, l]), u = G(d, mg), { x: f, y: h, zoom: p, selectedNodesCount: y } = G(yg, ne);
  if (!(typeof r == "boolean" ? r : u.size === 1 && u.values().next().value?.selected && y === 1) || !u.size)
    return null;
  const x = Ue(u), b = Array.from(u.values()), m = Math.max(...b.map((N) => N.internals.z + 1)), w = {
    position: "absolute",
    transform: bd(x, { x: f, y: h, zoom: p }, i, s, a),
    zIndex: m,
    ...o
  };
  return z(gg, { children: z("div", { style: w, className: re(["react-flow__node-toolbar", n]), ...c, "data-id": b.reduce((N, k) => `${N}${k.id} `, "").trim(), children: t }) });
}
export {
  ln as B,
  bg as E,
  Wt as H,
  kg as N,
  B as P,
  Lh as R,
  Sg as a,
  Mg as b,
  Ae as c,
  ee as d,
  G as e,
  so as f,
  Cg as g,
  Ce as h,
  _g as i,
  Ng as j,
  la as k,
  gi as l,
  an as m,
  to as n,
  Ti as o,
  zi as p,
  Zt as q,
  ai as r,
  tn as s,
  Ge as t,
  Eg as u,
  ka as w
};
