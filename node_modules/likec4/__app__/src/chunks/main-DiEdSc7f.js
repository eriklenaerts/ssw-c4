import { jsx as d, jsxs as b, Fragment as H } from "react/jsx-runtime";
import { createRoot as mv } from "react-dom/client";
import { L as jt, c as gv, S as yv, O as ap, a as bt, u as Vn, b as lp, d as vv, i as wv, n as Bn, R as xv, e as bv, f as kv, g as Sv } from "./tanstack-router-B97XgOdm.js";
import * as Yr from "react";
import { createContext as Le, useRef as J, useId as kl, useContext as oe, useInsertionEffect as cp, useCallback as dt, useMemo as ce, useEffect as ie, Children as _v, isValidElement as Cv, useLayoutEffect as as, useState as ge, forwardRef as an, Fragment as Sl, createElement as pi, Component as up, createRef as Ev, memo as nt, use as Pv, useTransition as _l, useSyncExternalStore as Tv, useDeferredValue as Mv, Suspense as Av, lazy as Iv } from "react";
import { e as Da, f as mi, a as $, G as K, g as le, h as dp, M as Dv, c as j, B as A, t as Nv, i as q, j as Rv, A as se, k as Cl, l as Ri, m as Li, n as $i, S as be, o as jn, p as hp, q as _r, r as fp, s as wn, v as El, w as Pl, x as Na, y as Ru, z as _t, D as pp, E as Ro, F as vt, H as Ra, J as Tl, K as Cr, L as Lu, N as Re, O as Lv, Q as mp, P as ls, R as gp, U as Xr, V as Er, W as Kr, T as wt, X as cs, Y as yp, Z as $v, _ as zv, $ as Ov, C as Pr, a0 as gi, a1 as Ml, a2 as Al, a3 as Il, a4 as Tr, a5 as Qt, a6 as Qe, a7 as xt, a8 as Ft, a9 as vp, aa as La, ab as wp, ac as Vv, ad as Bv, ae as jv, af as gr, ag as Fv, ah as Wv, ai as Hv, aj as xp, ak as Ys, al as qv, am as Gv, an as Uv, ao as Yv, ap as Xv, aq as $u, ar as bp, as as Kv, at as Zv, au as kp, av as zu, aw as uo, ax as Jv, ay as Qv, az as e1, aA as t1, aB as n1, aC as i1, aD as r1, aE as Sp, aF as _p, aG as o1, aH as Cp, aI as Dl, b as Ou, aJ as s1, aK as a1, aL as l1, aM as c1, u as Nl, aN as Yn, aO as u1, aP as d1, aQ as h1, aR as f1, aS as p1, aT as m1, aU as g1, aV as y1, aW as Rl, aX as v1, aY as w1 } from "./mantine-Dy50iVbn.js";
import { withOverviewGraph as us, ComponentName as Lo, isDevelopment as Ep, krokiD2SvgUrl as x1, useHashHistory as b1, basepath as k1 } from "../const.js";
import { useLikeC4Model as Fn } from "virtual:likec4/model";
import { RenderIcon as zi } from "../icons.js";
import { d as ds, e as Ll, f as Pp, g as S1, h as Ut, b as Vu, c as Xs, i as _1, j as C1, w as E1, E as P1, H as Nt, P as Rt, N as T1, k as M1, l as Tp, R as $l, m as hs, n as zl, o as Mp, p as Ap, u as A1, a as I1, q as D1, r as Bu, s as N1, t as R1 } from "./likec4-DgZMMrvs.js";
import { Queue as Ip, whereOperatorAsPredicate as L1, nonNullable as xe, ElementKind as cr, DiagramNode as ct, invariant as me, hasAtLeast as Dp, nonexhaustive as Pt, isStepEdgeId as Np, extractStep as $1, DefaultShapeSize as z1, DefaultTextSize as O1, DefaultPaddingSize as V1, compareNatural as Ol, nameFromFqn as Vl, defaultTheme as Bl, ElementShapes as B1, computeRelationshipsView as ju, toArray as Mr, sortParentsFirst as An, DefaultMap as xi, isDescendantOf as Rp, isAncestor as Ar, ancestorsFqn as j1, isScopedElementView as F1, isDeploymentView as Lp, delay as W1, compareRelations as H1, compareFqnHierarchically as q1, ifilter as G1, getBBoxCenter as Fu, getParallelStepsPrefix as Wu } from "@likec4/core";
import { ComputedView as U1 } from "@likec4/core/types";
import { usePreviewUrl as Y1 } from "virtual:likec4/previews";
import { computeRelationshipsView as Hu } from "@likec4/core/compute-view";
var X1 = "_1u4wf800", K1 = "_1u4wf801", Z1 = "_1u4wf802", J1 = "_1u4wf803", Q1 = "_1u4wf804", ew = "_1u4wf805";
function tw() {
  return /* @__PURE__ */ d(Da, { className: J1, children: /* @__PURE__ */ b("div", { className: Z1, children: [
    /* @__PURE__ */ d("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 362 145", className: K1, children: /* @__PURE__ */ d(
      "path",
      {
        fill: "currentColor",
        d: "M62.6 142c-2.133 0-3.2-1.067-3.2-3.2V118h-56c-2 0-3-1-3-3V92.8c0-1.333.4-2.733 1.2-4.2L58.2 4c.8-1.333 2.067-2 3.8-2h28c2 0 3 1 3 3v85.4h11.2c.933 0 1.733.333 2.4 1 .667.533 1 1.267 1 2.2v21.2c0 .933-.333 1.733-1 2.4-.667.533-1.467.8-2.4.8H93v20.8c0 2.133-1.067 3.2-3.2 3.2H62.6zM33 90.4h26.4V51.2L33 90.4zM181.67 144.6c-7.333 0-14.333-1.333-21-4-6.666-2.667-12.866-6.733-18.6-12.2-5.733-5.467-10.266-13-13.6-22.6-3.333-9.6-5-20.667-5-33.2 0-12.533 1.667-23.6 5-33.2 3.334-9.6 7.867-17.133 13.6-22.6 5.734-5.467 11.934-9.533 18.6-12.2 6.667-2.8 13.667-4.2 21-4.2 7.467 0 14.534 1.4 21.2 4.2 6.667 2.667 12.8 6.733 18.4 12.2 5.734 5.467 10.267 13 13.6 22.6 3.334 9.6 5 20.667 5 33.2 0 12.533-1.666 23.6-5 33.2-3.333 9.6-7.866 17.133-13.6 22.6-5.6 5.467-11.733 9.533-18.4 12.2-6.666 2.667-13.733 4-21.2 4zm0-31c9.067 0 15.6-3.733 19.6-11.2 4.134-7.6 6.2-17.533 6.2-29.8s-2.066-22.2-6.2-29.8c-4.133-7.6-10.666-11.4-19.6-11.4-8.933 0-15.466 3.8-19.6 11.4-4 7.6-6 17.533-6 29.8s2 22.2 6 29.8c4.134 7.467 10.667 11.2 19.6 11.2zM316.116 142c-2.134 0-3.2-1.067-3.2-3.2V118h-56c-2 0-3-1-3-3V92.8c0-1.333.4-2.733 1.2-4.2l56.6-84.6c.8-1.333 2.066-2 3.8-2h28c2 0 3 1 3 3v85.4h11.2c.933 0 1.733.333 2.4 1 .666.533 1 1.267 1 2.2v21.2c0 .933-.334 1.733-1 2.4-.667.533-1.467.8-2.4.8h-11.2v20.8c0 2.133-1.067 3.2-3.2 3.2h-27.2zm-29.6-51.6h26.4V51.2l-26.4 39.2z"
      }
    ) }),
    /* @__PURE__ */ b("div", { className: X1, children: [
      /* @__PURE__ */ d(mi, { className: ew, children: "Nothing to see here" }),
      /* @__PURE__ */ d($, { c: "dimmed", size: "lg", ta: "center", className: Q1, children: "Page you are trying to open does not exist. You may have mistyped the address, or the page has been moved to another URL. If you think this is an error contact support." }),
      /* @__PURE__ */ d(K, { justify: "center", children: /* @__PURE__ */ d(le, { component: jt, to: "/", search: !0, startTransition: !0, size: "md", children: "Take me back to home page" }) })
    ] })
  ] }) });
}
const Ir = Le({});
function Oi(e) {
  const n = J(null);
  return n.current === null && (n.current = e()), n.current;
}
const fs = /* @__PURE__ */ Le(null), bi = Le({
  transformPagePoint: (e) => e,
  isStatic: !1,
  reducedMotion: "never"
});
class nw extends Yr.Component {
  getSnapshotBeforeUpdate(n) {
    const i = this.props.childRef.current;
    if (i && n.isPresent && !this.props.isPresent) {
      const r = i.offsetParent, o = r instanceof HTMLElement && r.offsetWidth || 0, s = this.props.sizeRef.current;
      s.height = i.offsetHeight || 0, s.width = i.offsetWidth || 0, s.top = i.offsetTop, s.left = i.offsetLeft, s.right = o - s.width - s.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function iw({ children: e, isPresent: n, anchorX: i }) {
  const r = kl(), o = J(null), s = J({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  }), { nonce: a } = oe(bi);
  return cp(() => {
    const { width: l, height: c, top: u, left: f, right: h } = s.current;
    if (n || !o.current || !l || !c)
      return;
    const p = i === "left" ? `left: ${f}` : `right: ${h}`;
    o.current.dataset.motionPopId = r;
    const m = document.createElement("style");
    return a && (m.nonce = a), document.head.appendChild(m), m.sheet && m.sheet.insertRule(`
          [data-motion-pop-id="${r}"] {
            position: absolute !important;
            width: ${l}px !important;
            height: ${c}px !important;
            ${p}px !important;
            top: ${u}px !important;
          }
        `), () => {
      document.head.removeChild(m);
    };
  }, [n]), d(nw, { isPresent: n, childRef: o, sizeRef: s, children: Yr.cloneElement(e, { ref: o }) });
}
const rw = ({ children: e, initial: n, isPresent: i, onExitComplete: r, custom: o, presenceAffectsLayout: s, mode: a, anchorX: l }) => {
  const c = Oi(ow), u = kl(), f = dt((p) => {
    c.set(p, !0);
    for (const m of c.values())
      if (!m)
        return;
    r && r();
  }, [c, r]), h = ce(
    () => ({
      id: u,
      initial: n,
      isPresent: i,
      custom: o,
      onExitComplete: f,
      register: (p) => (c.set(p, !1), () => c.delete(p))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    s ? [Math.random(), f] : [i, f]
  );
  return ce(() => {
    c.forEach((p, m) => c.set(m, !1));
  }, [i]), Yr.useEffect(() => {
    !i && !c.size && r && r();
  }, [i]), a === "popLayout" && (e = d(iw, { isPresent: i, anchorX: l, children: e })), d(fs.Provider, { value: h, children: e });
};
function ow() {
  return /* @__PURE__ */ new Map();
}
function $p(e = !0) {
  const n = oe(fs);
  if (n === null)
    return [!0, null];
  const { isPresent: i, onExitComplete: r, register: o } = n, s = kl();
  ie(() => {
    e && o(s);
  }, [e]);
  const a = dt(() => e && r && r(s), [s, r, e]);
  return !i && r ? [!1, a] : [!0];
}
const ho = (e) => e.key || "";
function qu(e) {
  const n = [];
  return _v.forEach(e, (i) => {
    Cv(i) && n.push(i);
  }), n;
}
const jl = typeof window < "u", Fl = jl ? as : ie, ht = ({ children: e, custom: n, initial: i = !0, onExitComplete: r, presenceAffectsLayout: o = !0, mode: s = "sync", propagate: a = !1, anchorX: l = "left" }) => {
  const [c, u] = $p(a), f = ce(() => qu(e), [e]), h = a && !c ? [] : f.map(ho), p = J(!0), m = J(f), g = Oi(() => /* @__PURE__ */ new Map()), [y, v] = ge(f), [w, x] = ge(f);
  Fl(() => {
    p.current = !1, m.current = f;
    for (let S = 0; S < w.length; S++) {
      const P = ho(w[S]);
      h.includes(P) ? g.delete(P) : g.get(P) !== !0 && g.set(P, !1);
    }
  }, [w, h.length, h.join("-")]);
  const k = [];
  if (f !== y) {
    let S = [...f];
    for (let P = 0; P < w.length; P++) {
      const C = w[P], T = ho(C);
      h.includes(T) || (S.splice(P, 0, C), k.push(C));
    }
    return s === "wait" && k.length && (S = k), x(qu(S)), v(f), null;
  }
  const { forceRender: _ } = oe(Ir);
  return d(H, { children: w.map((S) => {
    const P = ho(S), C = a && !c ? !1 : f === w || h.includes(P), T = () => {
      if (g.has(P))
        g.set(P, !0);
      else
        return;
      let M = !0;
      g.forEach((D) => {
        D || (M = !1);
      }), M && (_?.(), x(m.current), a && u?.(), r && r());
    };
    return d(rw, { isPresent: C, initial: !p.current || i ? void 0 : !1, custom: n, presenceAffectsLayout: o, mode: s, onExitComplete: C ? void 0 : T, anchorX: l, children: S }, P);
  }) });
}, sw = Le(null);
function aw() {
  const e = J(!1);
  return Fl(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e;
}
const tt = /* @__NO_SIDE_EFFECTS__ */ (e) => e;
let zp = tt;
// @__NO_SIDE_EFFECTS__
function Wl(e) {
  let n;
  return () => (n === void 0 && (n = e()), n);
}
const In = /* @__NO_SIDE_EFFECTS__ */ (e, n, i) => {
  const r = n - e;
  return r === 0 ? 1 : (i - e) / r;
}, Tt = /* @__NO_SIDE_EFFECTS__ */ (e) => e * 1e3, Mt = /* @__NO_SIDE_EFFECTS__ */ (e) => e / 1e3, lw = {
  useManualTiming: !1
}, fo = [
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function cw(e, n) {
  let i = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Set(), o = !1, s = !1;
  const a = /* @__PURE__ */ new WeakSet();
  let l = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function c(f) {
    a.has(f) && (u.schedule(f), e()), f(l);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (f, h = !1, p = !1) => {
      const g = p && o ? i : r;
      return h && a.add(f), g.has(f) || g.add(f), f;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (f) => {
      r.delete(f), a.delete(f);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (f) => {
      if (l = f, o) {
        s = !0;
        return;
      }
      o = !0, [i, r] = [r, i], i.forEach(c), i.clear(), o = !1, s && (s = !1, u.process(f));
    }
  };
  return u;
}
const uw = 40;
function Op(e, n) {
  let i = !1, r = !0;
  const o = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, s = () => i = !0, a = fo.reduce((w, x) => (w[x] = cw(s), w), {}), { read: l, resolveKeyframes: c, update: u, preRender: f, render: h, postRender: p } = a, m = () => {
    const w = performance.now();
    i = !1, o.delta = r ? 1e3 / 60 : Math.max(Math.min(w - o.timestamp, uw), 1), o.timestamp = w, o.isProcessing = !0, l.process(o), c.process(o), u.process(o), f.process(o), h.process(o), p.process(o), o.isProcessing = !1, i && n && (r = !1, e(m));
  }, g = () => {
    i = !0, r = !0, o.isProcessing || e(m);
  };
  return { schedule: fo.reduce((w, x) => {
    const k = a[x];
    return w[x] = (_, S = !1, P = !1) => (i || g(), k.schedule(_, S, P)), w;
  }, {}), cancel: (w) => {
    for (let x = 0; x < fo.length; x++)
      a[fo[x]].cancel(w);
  }, state: o, steps: a };
}
const { schedule: fe, cancel: tn, state: Ne, steps: Ks } = Op(typeof requestAnimationFrame < "u" ? requestAnimationFrame : tt, !0);
function dw() {
  const e = aw(), [n, i] = ge(0), r = dt(() => {
    e.current && i(n + 1);
  }, [n]);
  return [dt(() => fe.postRender(r), [r]), n];
}
const hw = (e) => !e.isLayoutDirty && e.willUpdate(!1);
function Gu() {
  const e = /* @__PURE__ */ new Set(), n = /* @__PURE__ */ new WeakMap(), i = () => e.forEach(hw);
  return {
    add: (r) => {
      e.add(r), n.set(r, r.addEventListener("willUpdate", i));
    },
    remove: (r) => {
      e.delete(r);
      const o = n.get(r);
      o && (o(), n.delete(r)), i();
    },
    dirty: i
  };
}
const Vp = (e) => e === !0, fw = (e) => Vp(e === !0) || e === "id", ki = ({ children: e, id: n, inherit: i = !0 }) => {
  const r = oe(Ir), o = oe(sw), [s, a] = dw(), l = J(null), c = r.id || o;
  l.current === null && (fw(i) && c && (n = n ? c + "-" + n : c), l.current = {
    id: n,
    group: Vp(i) && r.group || Gu()
  });
  const u = ce(() => ({ ...l.current, forceRender: s }), [a]);
  return d(Ir.Provider, { value: u, children: e });
}, Hl = Le({ strict: !1 }), Uu = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, Si = {};
for (const e in Uu)
  Si[e] = {
    isEnabled: (n) => Uu[e].some((i) => !!n[i])
  };
function Yu(e) {
  for (const n in e)
    Si[n] = {
      ...Si[n],
      ...e[n]
    };
}
function pw({ children: e, features: n, strict: i = !1 }) {
  const [, r] = ge(!Zs(n)), o = J(void 0);
  if (!Zs(n)) {
    const { renderer: s, ...a } = n;
    o.current = s, Yu(a);
  }
  return ie(() => {
    Zs(n) && n().then(({ renderer: s, ...a }) => {
      Yu(a), o.current = s, r(!0);
    });
  }, []), d(Hl.Provider, { value: { renderer: o.current, strict: i }, children: e });
}
function Zs(e) {
  return typeof e == "function";
}
const mw = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function $o(e) {
  return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || mw.has(e);
}
let Bp = (e) => !$o(e);
function jp(e) {
  e && (Bp = (n) => n.startsWith("on") ? !$o(n) : e(n));
}
try {
  jp((void 0).default);
} catch {
}
function gw(e, n, i) {
  const r = {};
  for (const o in e)
    o === "values" && typeof e.values == "object" || (Bp(o) || i === !0 && $o(o) || !n && !$o(o) || // If trying to use native HTML drag events, forward drag listeners
    e.draggable && o.startsWith("onDrag")) && (r[o] = e[o]);
  return r;
}
function yw({ children: e, isValidProp: n, ...i }) {
  n && jp(n), i = { ...oe(bi), ...i }, i.isStatic = Oi(() => i.isStatic);
  const r = ce(() => i, [
    JSON.stringify(i.transition),
    i.transformPagePoint,
    i.reducedMotion
  ]);
  return d(bi.Provider, { value: r, children: e });
}
function vw(e) {
  if (typeof Proxy > "u")
    return e;
  const n = /* @__PURE__ */ new Map(), i = (...r) => e(...r);
  return new Proxy(i, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (r, o) => o === "create" ? e : (n.has(o) || n.set(o, e(o)), n.get(o))
  });
}
const ps = /* @__PURE__ */ Le({});
function ms(e) {
  return e !== null && typeof e == "object" && typeof e.start == "function";
}
function Dr(e) {
  return typeof e == "string" || Array.isArray(e);
}
const ql = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], Gl = ["initial", ...ql];
function gs(e) {
  return ms(e.animate) || Gl.some((n) => Dr(e[n]));
}
function Fp(e) {
  return !!(gs(e) || e.variants);
}
function ww(e, n) {
  if (gs(e)) {
    const { initial: i, animate: r } = e;
    return {
      initial: i === !1 || Dr(i) ? i : void 0,
      animate: Dr(r) ? r : void 0
    };
  }
  return e.inherit !== !1 ? n : {};
}
function xw(e) {
  const { initial: n, animate: i } = ww(e, oe(ps));
  return ce(() => ({ initial: n, animate: i }), [Xu(n), Xu(i)]);
}
function Xu(e) {
  return Array.isArray(e) ? e.join(" ") : e;
}
const bw = Symbol.for("motionComponentSymbol");
function si(e) {
  return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current");
}
function kw(e, n, i) {
  return dt(
    (r) => {
      r && e.onMount && e.onMount(r), n && (r ? n.mount(r) : n.unmount()), i && (typeof i == "function" ? i(r) : si(i) && (i.current = r));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [n]
  );
}
const Ul = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), Sw = "framerAppearId", Wp = "data-" + Ul(Sw), { schedule: Yl } = Op(queueMicrotask, !1), Hp = Le({});
function _w(e, n, i, r, o) {
  var s, a;
  const { visualElement: l } = oe(ps), c = oe(Hl), u = oe(fs), f = oe(bi).reducedMotion, h = J(null);
  r = r || c.renderer, !h.current && r && (h.current = r(e, {
    visualState: n,
    parent: l,
    props: i,
    presenceContext: u,
    blockInitialAnimation: u ? u.initial === !1 : !1,
    reducedMotionConfig: f
  }));
  const p = h.current, m = oe(Hp);
  p && !p.projection && o && (p.type === "html" || p.type === "svg") && Cw(h.current, i, o, m);
  const g = J(!1);
  cp(() => {
    p && g.current && p.update(i, u);
  });
  const y = i[Wp], v = J(!!y && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, y)) && ((a = window.MotionHasOptimisedAnimation) === null || a === void 0 ? void 0 : a.call(window, y)));
  return Fl(() => {
    p && (g.current = !0, window.MotionIsMounted = !0, p.updateFeatures(), Yl.render(p.render), v.current && p.animationState && p.animationState.animateChanges());
  }), ie(() => {
    p && (!v.current && p.animationState && p.animationState.animateChanges(), v.current && (queueMicrotask(() => {
      var w;
      (w = window.MotionHandoffMarkAsComplete) === null || w === void 0 || w.call(window, y);
    }), v.current = !1));
  }), p;
}
function Cw(e, n, i, r) {
  const { layoutId: o, layout: s, drag: a, dragConstraints: l, layoutScroll: c, layoutRoot: u } = n;
  e.projection = new i(e.latestValues, n["data-framer-portal-id"] ? void 0 : qp(e.parent)), e.projection.setOptions({
    layoutId: o,
    layout: s,
    alwaysMeasureLayout: !!a || l && si(l),
    visualElement: e,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof s == "string" ? s : "both",
    initialPromotionConfig: r,
    layoutScroll: c,
    layoutRoot: u
  });
}
function qp(e) {
  if (e)
    return e.options.allowProjection !== !1 ? e.projection : qp(e.parent);
}
function Ew({ preloadedFeatures: e, createVisualElement: n, useRender: i, useVisualState: r, Component: o }) {
  var s, a;
  function l(u, f) {
    let h;
    const p = {
      ...oe(bi),
      ...u,
      layoutId: Pw(u)
    }, { isStatic: m } = p, g = xw(u), y = r(u, m);
    if (!m && jl) {
      Tw();
      const v = Mw(p);
      h = v.MeasureLayout, g.visualElement = _w(o, y, p, n, v.ProjectionNode);
    }
    return b(ps.Provider, { value: g, children: [h && g.visualElement ? d(h, { visualElement: g.visualElement, ...p }) : null, i(o, u, kw(y, g.visualElement, f), y, m, g.visualElement)] });
  }
  l.displayName = `motion.${typeof o == "string" ? o : `create(${(a = (s = o.displayName) !== null && s !== void 0 ? s : o.name) !== null && a !== void 0 ? a : ""})`}`;
  const c = an(l);
  return c[bw] = o, c;
}
function Pw({ layoutId: e }) {
  const n = oe(Ir).id;
  return n && e !== void 0 ? n + "-" + e : e;
}
function Tw(e, n) {
  oe(Hl).strict;
}
function Mw(e) {
  const { drag: n, layout: i } = Si;
  if (!n && !i)
    return {};
  const r = { ...n, ...i };
  return {
    MeasureLayout: n?.isEnabled(e) || i?.isEnabled(e) ? r.MeasureLayout : void 0,
    ProjectionNode: r.ProjectionNode
  };
}
const Gp = (e) => (n) => typeof n == "string" && n.startsWith(e), Xl = /* @__PURE__ */ Gp("--"), Aw = /* @__PURE__ */ Gp("var(--"), Kl = (e) => Aw(e) ? Iw.test(e.split("/*")[0].trim()) : !1, Iw = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu, Nr = {};
function Dw(e) {
  for (const n in e)
    Nr[n] = e[n], Xl(n) && (Nr[n].isCSSVariable = !0);
}
const Vi = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], Wn = new Set(Vi);
function Up(e, { layout: n, layoutId: i }) {
  return Wn.has(e) || e.startsWith("origin") || (n || i !== void 0) && (!!Nr[e] || e === "opacity");
}
const Ie = (e) => !!(e && e.getVelocity), Yp = (e, n) => n && typeof e == "number" ? n.transform(e) : e, qt = (e, n, i) => i > n ? n : i < e ? e : i, Bi = {
  test: (e) => typeof e == "number",
  parse: parseFloat,
  transform: (e) => e
}, Rr = {
  ...Bi,
  transform: (e) => qt(0, 1, e)
}, po = {
  ...Bi,
  default: 1
}, Zr = (e) => ({
  test: (n) => typeof n == "string" && n.endsWith(e) && n.split(" ").length === 1,
  parse: parseFloat,
  transform: (n) => `${n}${e}`
}), Jt = /* @__PURE__ */ Zr("deg"), At = /* @__PURE__ */ Zr("%"), F = /* @__PURE__ */ Zr("px"), Nw = /* @__PURE__ */ Zr("vh"), Rw = /* @__PURE__ */ Zr("vw"), Ku = {
  ...At,
  parse: (e) => At.parse(e) / 100,
  transform: (e) => At.transform(e * 100)
}, Lw = {
  // Border props
  borderWidth: F,
  borderTopWidth: F,
  borderRightWidth: F,
  borderBottomWidth: F,
  borderLeftWidth: F,
  borderRadius: F,
  radius: F,
  borderTopLeftRadius: F,
  borderTopRightRadius: F,
  borderBottomRightRadius: F,
  borderBottomLeftRadius: F,
  // Positioning props
  width: F,
  maxWidth: F,
  height: F,
  maxHeight: F,
  top: F,
  right: F,
  bottom: F,
  left: F,
  // Spacing props
  padding: F,
  paddingTop: F,
  paddingRight: F,
  paddingBottom: F,
  paddingLeft: F,
  margin: F,
  marginTop: F,
  marginRight: F,
  marginBottom: F,
  marginLeft: F,
  // Misc
  backgroundPositionX: F,
  backgroundPositionY: F
}, $w = {
  rotate: Jt,
  rotateX: Jt,
  rotateY: Jt,
  rotateZ: Jt,
  scale: po,
  scaleX: po,
  scaleY: po,
  scaleZ: po,
  skew: Jt,
  skewX: Jt,
  skewY: Jt,
  distance: F,
  translateX: F,
  translateY: F,
  translateZ: F,
  x: F,
  y: F,
  z: F,
  perspective: F,
  transformPerspective: F,
  opacity: Rr,
  originX: Ku,
  originY: Ku,
  originZ: F
}, Zu = {
  ...Bi,
  transform: Math.round
}, Zl = {
  ...Lw,
  ...$w,
  zIndex: Zu,
  size: F,
  // SVG
  fillOpacity: Rr,
  strokeOpacity: Rr,
  numOctaves: Zu
}, zw = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, Ow = Vi.length;
function Vw(e, n, i) {
  let r = "", o = !0;
  for (let s = 0; s < Ow; s++) {
    const a = Vi[s], l = e[a];
    if (l === void 0)
      continue;
    let c = !0;
    if (typeof l == "number" ? c = l === (a.startsWith("scale") ? 1 : 0) : c = parseFloat(l) === 0, !c || i) {
      const u = Yp(l, Zl[a]);
      if (!c) {
        o = !1;
        const f = zw[a] || a;
        r += `${f}(${u}) `;
      }
      i && (n[a] = u);
    }
  }
  return r = r.trim(), i ? r = i(n, o ? "" : r) : o && (r = "none"), r;
}
function Jl(e, n, i) {
  const { style: r, vars: o, transformOrigin: s } = e;
  let a = !1, l = !1;
  for (const c in n) {
    const u = n[c];
    if (Wn.has(c)) {
      a = !0;
      continue;
    } else if (Xl(c)) {
      o[c] = u;
      continue;
    } else {
      const f = Yp(u, Zl[c]);
      c.startsWith("origin") ? (l = !0, s[c] = f) : r[c] = f;
    }
  }
  if (n.transform || (a || i ? r.transform = Vw(n, e.transform, i) : r.transform && (r.transform = "none")), l) {
    const { originX: c = "50%", originY: u = "50%", originZ: f = 0 } = s;
    r.transformOrigin = `${c} ${u} ${f}`;
  }
}
const Ql = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function Xp(e, n, i) {
  for (const r in n)
    !Ie(n[r]) && !Up(r, i) && (e[r] = n[r]);
}
function Bw({ transformTemplate: e }, n) {
  return ce(() => {
    const i = Ql();
    return Jl(i, n, e), Object.assign({}, i.vars, i.style);
  }, [n]);
}
function jw(e, n) {
  const i = e.style || {}, r = {};
  return Xp(r, i, e), Object.assign(r, Bw(e, n)), r;
}
function Fw(e, n) {
  const i = {}, r = jw(e, n);
  return e.drag && e.dragListener !== !1 && (i.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (i.tabIndex = 0), i.style = r, i;
}
const Ww = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function ec(e) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof e != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    e.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(Ww.indexOf(e) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(e))
    )
  );
}
const Hw = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, qw = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Gw(e, n, i = 1, r = 0, o = !0) {
  e.pathLength = 1;
  const s = o ? Hw : qw;
  e[s.offset] = F.transform(-r);
  const a = F.transform(n), l = F.transform(i);
  e[s.array] = `${a} ${l}`;
}
function Ju(e, n, i) {
  return typeof e == "string" ? e : F.transform(n + i * e);
}
function Uw(e, n, i) {
  const r = Ju(n, e.x, e.width), o = Ju(i, e.y, e.height);
  return `${r} ${o}`;
}
function tc(e, {
  attrX: n,
  attrY: i,
  attrScale: r,
  originX: o,
  originY: s,
  pathLength: a,
  pathSpacing: l = 1,
  pathOffset: c = 0,
  // This is object creation, which we try to avoid per-frame.
  ...u
}, f, h) {
  if (Jl(e, u, h), f) {
    e.style.viewBox && (e.attrs.viewBox = e.style.viewBox);
    return;
  }
  e.attrs = e.style, e.style = {};
  const { attrs: p, style: m, dimensions: g } = e;
  p.transform && (g && (m.transform = p.transform), delete p.transform), g && (o !== void 0 || s !== void 0 || m.transform) && (m.transformOrigin = Uw(g, o !== void 0 ? o : 0.5, s !== void 0 ? s : 0.5)), n !== void 0 && (p.x = n), i !== void 0 && (p.y = i), r !== void 0 && (p.scale = r), a !== void 0 && Gw(p, a, l, c, !1);
}
const Kp = () => ({
  ...Ql(),
  attrs: {}
}), nc = (e) => typeof e == "string" && e.toLowerCase() === "svg";
function Yw(e, n, i, r) {
  const o = ce(() => {
    const s = Kp();
    return tc(s, n, nc(r), e.transformTemplate), {
      ...s.attrs,
      style: { ...s.style }
    };
  }, [n]);
  if (e.style) {
    const s = {};
    Xp(s, e.style, e), o.style = { ...s, ...o.style };
  }
  return o;
}
function Xw(e = !1) {
  return (i, r, o, { latestValues: s }, a) => {
    const c = (ec(i) ? Yw : Fw)(r, s, a, i), u = gw(r, typeof i == "string", e), f = i !== Sl ? { ...u, ...c, ref: o } : {}, { children: h } = r, p = ce(() => Ie(h) ? h.get() : h, [h]);
    return pi(i, {
      ...f,
      children: p
    });
  };
}
function Qu(e) {
  const n = [{}, {}];
  return e?.values.forEach((i, r) => {
    n[0][r] = i.get(), n[1][r] = i.getVelocity();
  }), n;
}
function ic(e, n, i, r) {
  if (typeof n == "function") {
    const [o, s] = Qu(r);
    n = n(i !== void 0 ? i : e.custom, o, s);
  }
  if (typeof n == "string" && (n = e.variants && e.variants[n]), typeof n == "function") {
    const [o, s] = Qu(r);
    n = n(i !== void 0 ? i : e.custom, o, s);
  }
  return n;
}
const $a = (e) => Array.isArray(e), Kw = (e) => !!(e && typeof e == "object" && e.mix && e.toValue), Zw = (e) => $a(e) ? e[e.length - 1] || 0 : e;
function To(e) {
  const n = Ie(e) ? e.get() : e;
  return Kw(n) ? n.toValue() : n;
}
function Jw({ scrapeMotionValuesFromProps: e, createRenderState: n, onUpdate: i }, r, o, s) {
  const a = {
    latestValues: Qw(r, o, s, e),
    renderState: n()
  };
  return i && (a.onMount = (l) => i({ props: r, current: l, ...a }), a.onUpdate = (l) => i(l)), a;
}
const Zp = (e) => (n, i) => {
  const r = oe(ps), o = oe(fs), s = () => Jw(e, n, r, o);
  return i ? s() : Oi(s);
};
function Qw(e, n, i, r) {
  const o = {}, s = r(e, {});
  for (const p in s)
    o[p] = To(s[p]);
  let { initial: a, animate: l } = e;
  const c = gs(e), u = Fp(e);
  n && u && !c && e.inherit !== !1 && (a === void 0 && (a = n.initial), l === void 0 && (l = n.animate));
  let f = i ? i.initial === !1 : !1;
  f = f || a === !1;
  const h = f ? l : a;
  if (h && typeof h != "boolean" && !ms(h)) {
    const p = Array.isArray(h) ? h : [h];
    for (let m = 0; m < p.length; m++) {
      const g = ic(e, p[m]);
      if (g) {
        const { transitionEnd: y, transition: v, ...w } = g;
        for (const x in w) {
          let k = w[x];
          if (Array.isArray(k)) {
            const _ = f ? k.length - 1 : 0;
            k = k[_];
          }
          k !== null && (o[x] = k);
        }
        for (const x in y)
          o[x] = y[x];
      }
    }
  }
  return o;
}
function rc(e, n, i) {
  var r;
  const { style: o } = e, s = {};
  for (const a in o)
    (Ie(o[a]) || n.style && Ie(n.style[a]) || Up(a, e) || ((r = i?.getValue(a)) === null || r === void 0 ? void 0 : r.liveStyle) !== void 0) && (s[a] = o[a]);
  return s;
}
const ex = {
  useVisualState: Zp({
    scrapeMotionValuesFromProps: rc,
    createRenderState: Ql
  })
};
function Jp(e, n) {
  try {
    n.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect();
  } catch {
    n.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
function Qp(e, { style: n, vars: i }, r, o) {
  Object.assign(e.style, n, o && o.getProjectionStyles(r));
  for (const s in i)
    e.style.setProperty(s, i[s]);
}
const em = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function tm(e, n, i, r) {
  Qp(e, n, void 0, r);
  for (const o in n.attrs)
    e.setAttribute(em.has(o) ? o : Ul(o), n.attrs[o]);
}
function nm(e, n, i) {
  const r = rc(e, n, i);
  for (const o in e)
    if (Ie(e[o]) || Ie(n[o])) {
      const s = Vi.indexOf(o) !== -1 ? "attr" + o.charAt(0).toUpperCase() + o.substring(1) : o;
      r[s] = e[o];
    }
  return r;
}
const ed = ["x", "y", "width", "height", "cx", "cy", "r"], tx = {
  useVisualState: Zp({
    scrapeMotionValuesFromProps: nm,
    createRenderState: Kp,
    onUpdate: ({ props: e, prevProps: n, current: i, renderState: r, latestValues: o }) => {
      if (!i)
        return;
      let s = !!e.drag;
      if (!s) {
        for (const l in o)
          if (Wn.has(l)) {
            s = !0;
            break;
          }
      }
      if (!s)
        return;
      let a = !n;
      if (n)
        for (let l = 0; l < ed.length; l++) {
          const c = ed[l];
          e[c] !== n[c] && (a = !0);
        }
      a && fe.read(() => {
        Jp(i, r), fe.render(() => {
          tc(r, o, nc(i.tagName), e.transformTemplate), tm(i, r);
        });
      });
    }
  })
};
function nx(e, n) {
  return function(r, { forwardMotionProps: o } = { forwardMotionProps: !1 }) {
    const a = {
      ...ec(r) ? tx : ex,
      preloadedFeatures: e,
      useRender: Xw(o),
      createVisualElement: n,
      Component: r
    };
    return Ew(a);
  };
}
const ix = /* @__PURE__ */ nx(), re = /* @__PURE__ */ vw(ix);
function Lr(e, n, i) {
  const r = e.getProps();
  return ic(r, n, i !== void 0 ? i : r.custom, e);
}
const rx = /* @__PURE__ */ Wl(() => window.ScrollTimeline !== void 0);
class ox {
  constructor(n) {
    this.stop = () => this.runAll("stop"), this.animations = n.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((n) => "finished" in n ? n.finished : n));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(n) {
    return this.animations[0][n];
  }
  setAll(n, i) {
    for (let r = 0; r < this.animations.length; r++)
      this.animations[r][n] = i;
  }
  attachTimeline(n, i) {
    const r = this.animations.map((o) => {
      if (rx() && o.attachTimeline)
        return o.attachTimeline(n);
      if (typeof i == "function")
        return i(o);
    });
    return () => {
      r.forEach((o, s) => {
        o && o(), this.animations[s].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(n) {
    this.setAll("time", n);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(n) {
    this.setAll("speed", n);
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let n = 0;
    for (let i = 0; i < this.animations.length; i++)
      n = Math.max(n, this.animations[i].duration);
    return n;
  }
  runAll(n) {
    this.animations.forEach((i) => i[n]());
  }
  flatten() {
    this.runAll("flatten");
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
}
class im extends ox {
  then(n, i) {
    return Promise.all(this.animations).then(n).catch(i);
  }
}
function oc(e, n) {
  return e ? e[n] || e.default || e : void 0;
}
const zo = 2e4;
function sc(e) {
  let n = 0;
  const i = 50;
  let r = e.next(n);
  for (; !r.done && n < zo; )
    n += i, r = e.next(n);
  return n >= zo ? 1 / 0 : n;
}
function sx(e, n = 100, i) {
  const r = i({ ...e, keyframes: [0, n] }), o = Math.min(sc(r), zo);
  return {
    type: "keyframes",
    ease: (s) => r.next(o * s).value / n,
    duration: /* @__PURE__ */ Mt(o)
  };
}
function ys(e) {
  return typeof e == "function";
}
function td(e, n) {
  e.timeline = n, e.onfinish = null;
}
const ac = (e) => Array.isArray(e) && typeof e[0] == "number", ax = {
  linearEasing: void 0
};
function lx(e, n) {
  const i = /* @__PURE__ */ Wl(e);
  return () => {
    var r;
    return (r = ax[n]) !== null && r !== void 0 ? r : i();
  };
}
const Oo = /* @__PURE__ */ lx(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), rm = (e, n, i = 10) => {
  let r = "";
  const o = Math.max(Math.round(n / i), 2);
  for (let s = 0; s < o; s++)
    r += e(/* @__PURE__ */ In(0, o - 1, s)) + ", ";
  return `linear(${r.substring(0, r.length - 2)})`;
};
function om(e) {
  return !!(typeof e == "function" && Oo() || !e || typeof e == "string" && (e in za || Oo()) || ac(e) || Array.isArray(e) && e.every(om));
}
const ur = ([e, n, i, r]) => `cubic-bezier(${e}, ${n}, ${i}, ${r})`, za = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ ur([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ ur([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ ur([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ ur([0.33, 1.53, 0.69, 0.99])
};
function sm(e, n) {
  if (e)
    return typeof e == "function" && Oo() ? rm(e, n) : ac(e) ? ur(e) : Array.isArray(e) ? e.map((i) => sm(i, n) || za.easeOut) : za[e];
}
const gt = {
  x: !1,
  y: !1
};
function am() {
  return gt.x || gt.y;
}
function lm(e, n, i) {
  var r;
  if (e instanceof Element)
    return [e];
  if (typeof e == "string") {
    let o = document;
    const s = (r = i?.[e]) !== null && r !== void 0 ? r : o.querySelectorAll(e);
    return s ? Array.from(s) : [];
  }
  return Array.from(e);
}
function cm(e, n) {
  const i = lm(e), r = new AbortController(), o = {
    passive: !0,
    ...n,
    signal: r.signal
  };
  return [i, o, () => r.abort()];
}
function nd(e) {
  return !(e.pointerType === "touch" || am());
}
function cx(e, n, i = {}) {
  const [r, o, s] = cm(e, i), a = (l) => {
    if (!nd(l))
      return;
    const { target: c } = l, u = n(c, l);
    if (typeof u != "function" || !c)
      return;
    const f = (h) => {
      nd(h) && (u(h), c.removeEventListener("pointerleave", f));
    };
    c.addEventListener("pointerleave", f, o);
  };
  return r.forEach((l) => {
    l.addEventListener("pointerenter", a, o);
  }), s;
}
const um = (e, n) => n ? e === n ? !0 : um(e, n.parentElement) : !1, lc = (e) => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, ux = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function dx(e) {
  return ux.has(e.tagName) || e.tabIndex !== -1;
}
const dr = /* @__PURE__ */ new WeakSet();
function id(e) {
  return (n) => {
    n.key === "Enter" && e(n);
  };
}
function Js(e, n) {
  e.dispatchEvent(new PointerEvent("pointer" + n, { isPrimary: !0, bubbles: !0 }));
}
const hx = (e, n) => {
  const i = e.currentTarget;
  if (!i)
    return;
  const r = id(() => {
    if (dr.has(i))
      return;
    Js(i, "down");
    const o = id(() => {
      Js(i, "up");
    }), s = () => Js(i, "cancel");
    i.addEventListener("keyup", o, n), i.addEventListener("blur", s, n);
  });
  i.addEventListener("keydown", r, n), i.addEventListener("blur", () => i.removeEventListener("keydown", r), n);
};
function rd(e) {
  return lc(e) && !am();
}
function fx(e, n, i = {}) {
  const [r, o, s] = cm(e, i), a = (l) => {
    const c = l.currentTarget;
    if (!rd(l) || dr.has(c))
      return;
    dr.add(c);
    const u = n(c, l), f = (m, g) => {
      window.removeEventListener("pointerup", h), window.removeEventListener("pointercancel", p), !(!rd(m) || !dr.has(c)) && (dr.delete(c), typeof u == "function" && u(m, { success: g }));
    }, h = (m) => {
      f(m, i.useGlobalTarget || um(c, m.target));
    }, p = (m) => {
      f(m, !1);
    };
    window.addEventListener("pointerup", h, o), window.addEventListener("pointercancel", p, o);
  };
  return r.forEach((l) => {
    !dx(l) && l.getAttribute("tabindex") === null && (l.tabIndex = 0), (i.useGlobalTarget ? window : l).addEventListener("pointerdown", a, o), l.addEventListener("focus", (u) => hx(u, o), o);
  }), s;
}
function px(e) {
  return e === "x" || e === "y" ? gt[e] ? null : (gt[e] = !0, () => {
    gt[e] = !1;
  }) : gt.x || gt.y ? null : (gt.x = gt.y = !0, () => {
    gt.x = gt.y = !1;
  });
}
const dm = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...Vi
]);
let Mo;
function mx() {
  Mo = void 0;
}
const It = {
  now: () => (Mo === void 0 && It.set(Ne.isProcessing || lw.useManualTiming ? Ne.timestamp : performance.now()), Mo),
  set: (e) => {
    Mo = e, queueMicrotask(mx);
  }
};
function cc(e, n) {
  e.indexOf(n) === -1 && e.push(n);
}
function vs(e, n) {
  const i = e.indexOf(n);
  i > -1 && e.splice(i, 1);
}
class uc {
  constructor() {
    this.subscriptions = [];
  }
  add(n) {
    return cc(this.subscriptions, n), () => vs(this.subscriptions, n);
  }
  notify(n, i, r) {
    const o = this.subscriptions.length;
    if (o)
      if (o === 1)
        this.subscriptions[0](n, i, r);
      else
        for (let s = 0; s < o; s++) {
          const a = this.subscriptions[s];
          a && a(n, i, r);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
function hm(e, n) {
  return n ? e * (1e3 / n) : 0;
}
const od = 30, gx = (e) => !isNaN(parseFloat(e));
class yx {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(n, i = {}) {
    this.version = "12.4.2", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (r, o = !0) => {
      const s = It.now();
      this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), o && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(n), this.owner = i.owner;
  }
  setCurrent(n) {
    this.current = n, this.updatedAt = It.now(), this.canTrackVelocity === null && n !== void 0 && (this.canTrackVelocity = gx(this.current));
  }
  setPrevFrameValue(n = this.current) {
    this.prevFrameValue = n, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(n) {
    return this.on("change", n);
  }
  on(n, i) {
    this.events[n] || (this.events[n] = new uc());
    const r = this.events[n].add(i);
    return n === "change" ? () => {
      r(), fe.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : r;
  }
  clearListeners() {
    for (const n in this.events)
      this.events[n].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(n, i) {
    this.passiveEffect = n, this.stopPassiveEffect = i;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(n, i = !0) {
    !i || !this.passiveEffect ? this.updateAndNotify(n, i) : this.passiveEffect(n, this.updateAndNotify);
  }
  setWithVelocity(n, i, r) {
    this.set(i), this.prev = void 0, this.prevFrameValue = n, this.prevUpdatedAt = this.updatedAt - r;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(n, i = !0) {
    this.updateAndNotify(n), this.prev = n, this.prevUpdatedAt = this.prevFrameValue = void 0, i && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const n = It.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || n - this.updatedAt > od)
      return 0;
    const i = Math.min(this.updatedAt - this.prevUpdatedAt, od);
    return hm(parseFloat(this.current) - parseFloat(this.prevFrameValue), i);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(n) {
    return this.stop(), new Promise((i) => {
      this.hasAnimated = !0, this.animation = n(i), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function _i(e, n) {
  return new yx(e, n);
}
function vx(e, n, i) {
  e.hasValue(n) ? e.getValue(n).set(i) : e.addValue(n, _i(i));
}
function wx(e, n) {
  const i = Lr(e, n);
  let { transitionEnd: r = {}, transition: o = {}, ...s } = i || {};
  s = { ...s, ...r };
  for (const a in s) {
    const l = Zw(s[a]);
    vx(e, a, l);
  }
}
function xx(e) {
  return !!(Ie(e) && e.add);
}
function Oa(e, n) {
  const i = e.getValue("willChange");
  if (xx(i))
    return i.add(n);
}
function fm(e) {
  return e.props[Wp];
}
const pm = (e, n, i) => (((1 - 3 * i + 3 * n) * e + (3 * i - 6 * n)) * e + 3 * n) * e, bx = 1e-7, kx = 12;
function Sx(e, n, i, r, o) {
  let s, a, l = 0;
  do
    a = n + (i - n) / 2, s = pm(a, r, o) - e, s > 0 ? i = a : n = a;
  while (Math.abs(s) > bx && ++l < kx);
  return a;
}
function Jr(e, n, i, r) {
  if (e === n && i === r)
    return tt;
  const o = (s) => Sx(s, 0, 1, e, i);
  return (s) => s === 0 || s === 1 ? s : pm(o(s), n, r);
}
const mm = (e) => (n) => n <= 0.5 ? e(2 * n) / 2 : (2 - e(2 * (1 - n))) / 2, gm = (e) => (n) => 1 - e(1 - n), ym = /* @__PURE__ */ Jr(0.33, 1.53, 0.69, 0.99), dc = /* @__PURE__ */ gm(ym), vm = /* @__PURE__ */ mm(dc), wm = (e) => (e *= 2) < 1 ? 0.5 * dc(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))), hc = (e) => 1 - Math.sin(Math.acos(e)), xm = gm(hc), bm = mm(hc), km = (e) => /^0[^.\s]+$/u.test(e);
function _x(e) {
  return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || km(e) : !0;
}
const yr = (e) => Math.round(e * 1e5) / 1e5, fc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function Cx(e) {
  return e == null;
}
const Ex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, pc = (e, n) => (i) => !!(typeof i == "string" && Ex.test(i) && i.startsWith(e) || n && !Cx(i) && Object.prototype.hasOwnProperty.call(i, n)), Sm = (e, n, i) => (r) => {
  if (typeof r != "string")
    return r;
  const [o, s, a, l] = r.match(fc);
  return {
    [e]: parseFloat(o),
    [n]: parseFloat(s),
    [i]: parseFloat(a),
    alpha: l !== void 0 ? parseFloat(l) : 1
  };
}, Px = (e) => qt(0, 255, e), Qs = {
  ...Bi,
  transform: (e) => Math.round(Px(e))
}, xn = {
  test: /* @__PURE__ */ pc("rgb", "red"),
  parse: /* @__PURE__ */ Sm("red", "green", "blue"),
  transform: ({ red: e, green: n, blue: i, alpha: r = 1 }) => "rgba(" + Qs.transform(e) + ", " + Qs.transform(n) + ", " + Qs.transform(i) + ", " + yr(Rr.transform(r)) + ")"
};
function Tx(e) {
  let n = "", i = "", r = "", o = "";
  return e.length > 5 ? (n = e.substring(1, 3), i = e.substring(3, 5), r = e.substring(5, 7), o = e.substring(7, 9)) : (n = e.substring(1, 2), i = e.substring(2, 3), r = e.substring(3, 4), o = e.substring(4, 5), n += n, i += i, r += r, o += o), {
    red: parseInt(n, 16),
    green: parseInt(i, 16),
    blue: parseInt(r, 16),
    alpha: o ? parseInt(o, 16) / 255 : 1
  };
}
const Va = {
  test: /* @__PURE__ */ pc("#"),
  parse: Tx,
  transform: xn.transform
}, ai = {
  test: /* @__PURE__ */ pc("hsl", "hue"),
  parse: /* @__PURE__ */ Sm("hue", "saturation", "lightness"),
  transform: ({ hue: e, saturation: n, lightness: i, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + At.transform(yr(n)) + ", " + At.transform(yr(i)) + ", " + yr(Rr.transform(r)) + ")"
}, Oe = {
  test: (e) => xn.test(e) || Va.test(e) || ai.test(e),
  parse: (e) => xn.test(e) ? xn.parse(e) : ai.test(e) ? ai.parse(e) : Va.parse(e),
  transform: (e) => typeof e == "string" ? e : e.hasOwnProperty("red") ? xn.transform(e) : ai.transform(e)
}, Mx = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function Ax(e) {
  var n, i;
  return isNaN(e) && typeof e == "string" && (((n = e.match(fc)) === null || n === void 0 ? void 0 : n.length) || 0) + (((i = e.match(Mx)) === null || i === void 0 ? void 0 : i.length) || 0) > 0;
}
const _m = "number", Cm = "color", Ix = "var", Dx = "var(", sd = "${}", Nx = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function $r(e) {
  const n = e.toString(), i = [], r = {
    color: [],
    number: [],
    var: []
  }, o = [];
  let s = 0;
  const l = n.replace(Nx, (c) => (Oe.test(c) ? (r.color.push(s), o.push(Cm), i.push(Oe.parse(c))) : c.startsWith(Dx) ? (r.var.push(s), o.push(Ix), i.push(c)) : (r.number.push(s), o.push(_m), i.push(parseFloat(c))), ++s, sd)).split(sd);
  return { values: i, split: l, indexes: r, types: o };
}
function Em(e) {
  return $r(e).values;
}
function Pm(e) {
  const { split: n, types: i } = $r(e), r = n.length;
  return (o) => {
    let s = "";
    for (let a = 0; a < r; a++)
      if (s += n[a], o[a] !== void 0) {
        const l = i[a];
        l === _m ? s += yr(o[a]) : l === Cm ? s += Oe.transform(o[a]) : s += o[a];
      }
    return s;
  };
}
const Rx = (e) => typeof e == "number" ? 0 : e;
function Lx(e) {
  const n = Em(e);
  return Pm(e)(n.map(Rx));
}
const nn = {
  test: Ax,
  parse: Em,
  createTransformer: Pm,
  getAnimatableNone: Lx
}, $x = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function zx(e) {
  const [n, i] = e.slice(0, -1).split("(");
  if (n === "drop-shadow")
    return e;
  const [r] = i.match(fc) || [];
  if (!r)
    return e;
  const o = i.replace(r, "");
  let s = $x.has(n) ? 1 : 0;
  return r !== i && (s *= 100), n + "(" + s + o + ")";
}
const Ox = /\b([a-z-]*)\(.*?\)/gu, Ba = {
  ...nn,
  getAnimatableNone: (e) => {
    const n = e.match(Ox);
    return n ? n.map(zx).join(" ") : e;
  }
}, Vx = {
  ...Zl,
  // Color props
  color: Oe,
  backgroundColor: Oe,
  outlineColor: Oe,
  fill: Oe,
  stroke: Oe,
  // Border props
  borderColor: Oe,
  borderTopColor: Oe,
  borderRightColor: Oe,
  borderBottomColor: Oe,
  borderLeftColor: Oe,
  filter: Ba,
  WebkitFilter: Ba
}, mc = (e) => Vx[e];
function Tm(e, n) {
  let i = mc(e);
  return i !== Ba && (i = nn), i.getAnimatableNone ? i.getAnimatableNone(n) : void 0;
}
const Bx = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function jx(e, n, i) {
  let r = 0, o;
  for (; r < e.length && !o; ) {
    const s = e[r];
    typeof s == "string" && !Bx.has(s) && $r(s).values.length && (o = e[r]), r++;
  }
  if (o && i)
    for (const s of n)
      e[s] = Tm(i, o);
}
const ad = (e) => e === Bi || e === F, ld = (e, n) => parseFloat(e.split(", ")[n]), cd = (e, n) => (i, { transform: r }) => {
  if (r === "none" || !r)
    return 0;
  const o = r.match(/^matrix3d\((.+)\)$/u);
  if (o)
    return ld(o[1], n);
  {
    const s = r.match(/^matrix\((.+)\)$/u);
    return s ? ld(s[1], e) : 0;
  }
}, Fx = /* @__PURE__ */ new Set(["x", "y", "z"]), Wx = Vi.filter((e) => !Fx.has(e));
function Hx(e) {
  const n = [];
  return Wx.forEach((i) => {
    const r = e.getValue(i);
    r !== void 0 && (n.push([i, r.get()]), r.set(i.startsWith("scale") ? 1 : 0));
  }), n;
}
const Ci = {
  // Dimensions
  width: ({ x: e }, { paddingLeft: n = "0", paddingRight: i = "0" }) => e.max - e.min - parseFloat(n) - parseFloat(i),
  height: ({ y: e }, { paddingTop: n = "0", paddingBottom: i = "0" }) => e.max - e.min - parseFloat(n) - parseFloat(i),
  top: (e, { top: n }) => parseFloat(n),
  left: (e, { left: n }) => parseFloat(n),
  bottom: ({ y: e }, { top: n }) => parseFloat(n) + (e.max - e.min),
  right: ({ x: e }, { left: n }) => parseFloat(n) + (e.max - e.min),
  // Transform
  x: cd(4, 13),
  y: cd(5, 14)
};
Ci.translateX = Ci.x;
Ci.translateY = Ci.y;
const Cn = /* @__PURE__ */ new Set();
let ja = !1, Fa = !1;
function Mm() {
  if (Fa) {
    const e = Array.from(Cn).filter((r) => r.needsMeasurement), n = new Set(e.map((r) => r.element)), i = /* @__PURE__ */ new Map();
    n.forEach((r) => {
      const o = Hx(r);
      o.length && (i.set(r, o), r.render());
    }), e.forEach((r) => r.measureInitialState()), n.forEach((r) => {
      r.render();
      const o = i.get(r);
      o && o.forEach(([s, a]) => {
        var l;
        (l = r.getValue(s)) === null || l === void 0 || l.set(a);
      });
    }), e.forEach((r) => r.measureEndState()), e.forEach((r) => {
      r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY);
    });
  }
  Fa = !1, ja = !1, Cn.forEach((e) => e.complete()), Cn.clear();
}
function Am() {
  Cn.forEach((e) => {
    e.readKeyframes(), e.needsMeasurement && (Fa = !0);
  });
}
function qx() {
  Am(), Mm();
}
class gc {
  constructor(n, i, r, o, s, a = !1) {
    this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...n], this.onComplete = i, this.name = r, this.motionValue = o, this.element = s, this.isAsync = a;
  }
  scheduleResolve() {
    this.isScheduled = !0, this.isAsync ? (Cn.add(this), ja || (ja = !0, fe.read(Am), fe.resolveKeyframes(Mm))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: n, name: i, element: r, motionValue: o } = this;
    for (let s = 0; s < n.length; s++)
      if (n[s] === null)
        if (s === 0) {
          const a = o?.get(), l = n[n.length - 1];
          if (a !== void 0)
            n[0] = a;
          else if (r && i) {
            const c = r.readValue(i, l);
            c != null && (n[0] = c);
          }
          n[0] === void 0 && (n[0] = l), o && a === void 0 && o.set(n[0]);
        } else
          n[s] = n[s - 1];
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete() {
    this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Cn.delete(this);
  }
  cancel() {
    this.isComplete || (this.isScheduled = !1, Cn.delete(this));
  }
  resume() {
    this.isComplete || this.scheduleResolve();
  }
}
const Im = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e), Gx = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function Ux(e) {
  const n = Gx.exec(e);
  if (!n)
    return [,];
  const [, i, r, o] = n;
  return [`--${i ?? r}`, o];
}
function Dm(e, n, i = 1) {
  const [r, o] = Ux(e);
  if (!r)
    return;
  const s = window.getComputedStyle(n).getPropertyValue(r);
  if (s) {
    const a = s.trim();
    return Im(a) ? parseFloat(a) : a;
  }
  return Kl(o) ? Dm(o, n, i + 1) : o;
}
const Nm = (e) => (n) => n.test(e), Yx = {
  test: (e) => e === "auto",
  parse: (e) => e
}, Rm = [Bi, F, At, Jt, Rw, Nw, Yx], ud = (e) => Rm.find(Nm(e));
class Lm extends gc {
  constructor(n, i, r, o, s) {
    super(n, i, r, o, s, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: n, element: i, name: r } = this;
    if (!i || !i.current)
      return;
    super.readKeyframes();
    for (let c = 0; c < n.length; c++) {
      let u = n[c];
      if (typeof u == "string" && (u = u.trim(), Kl(u))) {
        const f = Dm(u, i.current);
        f !== void 0 && (n[c] = f), c === n.length - 1 && (this.finalKeyframe = u);
      }
    }
    if (this.resolveNoneKeyframes(), !dm.has(r) || n.length !== 2)
      return;
    const [o, s] = n, a = ud(o), l = ud(s);
    if (a !== l)
      if (ad(a) && ad(l))
        for (let c = 0; c < n.length; c++) {
          const u = n[c];
          typeof u == "string" && (n[c] = parseFloat(u));
        }
      else
        this.needsMeasurement = !0;
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: n, name: i } = this, r = [];
    for (let o = 0; o < n.length; o++)
      _x(n[o]) && r.push(o);
    r.length && jx(n, r, i);
  }
  measureInitialState() {
    const { element: n, unresolvedKeyframes: i, name: r } = this;
    if (!n || !n.current)
      return;
    r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Ci[r](n.measureViewportBox(), window.getComputedStyle(n.current)), i[0] = this.measuredOrigin;
    const o = i[i.length - 1];
    o !== void 0 && n.getValue(r, o).jump(o, !1);
  }
  measureEndState() {
    var n;
    const { element: i, name: r, unresolvedKeyframes: o } = this;
    if (!i || !i.current)
      return;
    const s = i.getValue(r);
    s && s.jump(this.measuredOrigin, !1);
    const a = o.length - 1, l = o[a];
    o[a] = Ci[r](i.measureViewportBox(), window.getComputedStyle(i.current)), l !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = l), !((n = this.removedTransforms) === null || n === void 0) && n.length && this.removedTransforms.forEach(([c, u]) => {
      i.getValue(c).set(u);
    }), this.resolveNoneKeyframes();
  }
}
const dd = (e, n) => n === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && // It's animatable if we have a string
(nn.test(e) || e === "0") && // And it contains numbers and/or colors
!e.startsWith("url("));
function Xx(e) {
  const n = e[0];
  if (e.length === 1)
    return !0;
  for (let i = 0; i < e.length; i++)
    if (e[i] !== n)
      return !0;
}
function Kx(e, n, i, r) {
  const o = e[0];
  if (o === null)
    return !1;
  if (n === "display" || n === "visibility")
    return !0;
  const s = e[e.length - 1], a = dd(o, n), l = dd(s, n);
  return !a || !l ? !1 : Xx(e) || (i === "spring" || ys(i)) && r;
}
const Zx = (e) => e !== null;
function ws(e, { repeat: n, repeatType: i = "loop" }, r) {
  const o = e.filter(Zx), s = n && i !== "loop" && n % 2 === 1 ? 0 : o.length - 1;
  return !s || r === void 0 ? o[s] : r;
}
const Jx = 40;
class $m {
  constructor({ autoplay: n = !0, delay: i = 0, type: r = "keyframes", repeat: o = 0, repeatDelay: s = 0, repeatType: a = "loop", ...l }) {
    this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = It.now(), this.options = {
      autoplay: n,
      delay: i,
      type: r,
      repeat: o,
      repeatDelay: s,
      repeatType: a,
      ...l
    }, this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    return this.resolvedAt ? this.resolvedAt - this.createdAt > Jx ? this.resolvedAt : this.createdAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    return !this._resolved && !this.hasAttemptedResolve && qx(), this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(n, i) {
    this.resolvedAt = It.now(), this.hasAttemptedResolve = !0;
    const { name: r, type: o, velocity: s, delay: a, onComplete: l, onUpdate: c, isGenerator: u } = this.options;
    if (!u && !Kx(n, r, o, s))
      if (a)
        this.options.duration = 0;
      else {
        c && c(ws(n, this.options, i)), l && l(), this.resolveFinishedPromise();
        return;
      }
    const f = this.initPlayback(n, i);
    f !== !1 && (this._resolved = {
      keyframes: n,
      finalKeyframe: i,
      ...f
    }, this.onPostResolved());
  }
  onPostResolved() {
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(n, i) {
    return this.currentFinishedPromise.then(n, i);
  }
  flatten() {
    this.options.type = "keyframes", this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise((n) => {
      this.resolveFinishedPromise = n;
    });
  }
}
const we = (e, n, i) => e + (n - e) * i;
function ea(e, n, i) {
  return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? e + (n - e) * 6 * i : i < 1 / 2 ? n : i < 2 / 3 ? e + (n - e) * (2 / 3 - i) * 6 : e;
}
function Qx({ hue: e, saturation: n, lightness: i, alpha: r }) {
  e /= 360, n /= 100, i /= 100;
  let o = 0, s = 0, a = 0;
  if (!n)
    o = s = a = i;
  else {
    const l = i < 0.5 ? i * (1 + n) : i + n - i * n, c = 2 * i - l;
    o = ea(c, l, e + 1 / 3), s = ea(c, l, e), a = ea(c, l, e - 1 / 3);
  }
  return {
    red: Math.round(o * 255),
    green: Math.round(s * 255),
    blue: Math.round(a * 255),
    alpha: r
  };
}
function Vo(e, n) {
  return (i) => i > 0 ? n : e;
}
const ta = (e, n, i) => {
  const r = e * e, o = i * (n * n - r) + r;
  return o < 0 ? 0 : Math.sqrt(o);
}, eb = [Va, xn, ai], tb = (e) => eb.find((n) => n.test(e));
function hd(e) {
  const n = tb(e);
  if (!n)
    return !1;
  let i = n.parse(e);
  return n === ai && (i = Qx(i)), i;
}
const fd = (e, n) => {
  const i = hd(e), r = hd(n);
  if (!i || !r)
    return Vo(e, n);
  const o = { ...i };
  return (s) => (o.red = ta(i.red, r.red, s), o.green = ta(i.green, r.green, s), o.blue = ta(i.blue, r.blue, s), o.alpha = we(i.alpha, r.alpha, s), xn.transform(o));
}, nb = (e, n) => (i) => n(e(i)), Qr = (...e) => e.reduce(nb), Wa = /* @__PURE__ */ new Set(["none", "hidden"]);
function ib(e, n) {
  return Wa.has(e) ? (i) => i <= 0 ? e : n : (i) => i >= 1 ? n : e;
}
function rb(e, n) {
  return (i) => we(e, n, i);
}
function yc(e) {
  return typeof e == "number" ? rb : typeof e == "string" ? Kl(e) ? Vo : Oe.test(e) ? fd : ab : Array.isArray(e) ? zm : typeof e == "object" ? Oe.test(e) ? fd : ob : Vo;
}
function zm(e, n) {
  const i = [...e], r = i.length, o = e.map((s, a) => yc(s)(s, n[a]));
  return (s) => {
    for (let a = 0; a < r; a++)
      i[a] = o[a](s);
    return i;
  };
}
function ob(e, n) {
  const i = { ...e, ...n }, r = {};
  for (const o in i)
    e[o] !== void 0 && n[o] !== void 0 && (r[o] = yc(e[o])(e[o], n[o]));
  return (o) => {
    for (const s in r)
      i[s] = r[s](o);
    return i;
  };
}
function sb(e, n) {
  var i;
  const r = [], o = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < n.values.length; s++) {
    const a = n.types[s], l = e.indexes[a][o[a]], c = (i = e.values[l]) !== null && i !== void 0 ? i : 0;
    r[s] = c, o[a]++;
  }
  return r;
}
const ab = (e, n) => {
  const i = nn.createTransformer(n), r = $r(e), o = $r(n);
  return r.indexes.var.length === o.indexes.var.length && r.indexes.color.length === o.indexes.color.length && r.indexes.number.length >= o.indexes.number.length ? Wa.has(e) && !o.values.length || Wa.has(n) && !r.values.length ? ib(e, n) : Qr(zm(sb(r, o), o.values), i) : Vo(e, n);
};
function Om(e, n, i) {
  return typeof e == "number" && typeof n == "number" && typeof i == "number" ? we(e, n, i) : yc(e)(e, n);
}
const lb = 5;
function Vm(e, n, i) {
  const r = Math.max(n - lb, 0);
  return hm(i - e(r), n - r);
}
const _e = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, pd = 1e-3;
function cb({ duration: e = _e.duration, bounce: n = _e.bounce, velocity: i = _e.velocity, mass: r = _e.mass }) {
  let o, s, a = 1 - n;
  a = qt(_e.minDamping, _e.maxDamping, a), e = qt(_e.minDuration, _e.maxDuration, /* @__PURE__ */ Mt(e)), a < 1 ? (o = (u) => {
    const f = u * a, h = f * e, p = f - i, m = Ha(u, a), g = Math.exp(-h);
    return pd - p / m * g;
  }, s = (u) => {
    const h = u * a * e, p = h * i + i, m = Math.pow(a, 2) * Math.pow(u, 2) * e, g = Math.exp(-h), y = Ha(Math.pow(u, 2), a);
    return (-o(u) + pd > 0 ? -1 : 1) * ((p - m) * g) / y;
  }) : (o = (u) => {
    const f = Math.exp(-u * e), h = (u - i) * e + 1;
    return -1e-3 + f * h;
  }, s = (u) => {
    const f = Math.exp(-u * e), h = (i - u) * (e * e);
    return f * h;
  });
  const l = 5 / e, c = db(o, s, l);
  if (e = /* @__PURE__ */ Tt(e), isNaN(c))
    return {
      stiffness: _e.stiffness,
      damping: _e.damping,
      duration: e
    };
  {
    const u = Math.pow(c, 2) * r;
    return {
      stiffness: u,
      damping: a * 2 * Math.sqrt(r * u),
      duration: e
    };
  }
}
const ub = 12;
function db(e, n, i) {
  let r = i;
  for (let o = 1; o < ub; o++)
    r = r - e(r) / n(r);
  return r;
}
function Ha(e, n) {
  return e * Math.sqrt(1 - n * n);
}
const hb = ["duration", "bounce"], fb = ["stiffness", "damping", "mass"];
function md(e, n) {
  return n.some((i) => e[i] !== void 0);
}
function pb(e) {
  let n = {
    velocity: _e.velocity,
    stiffness: _e.stiffness,
    damping: _e.damping,
    mass: _e.mass,
    isResolvedFromDuration: !1,
    ...e
  };
  if (!md(e, fb) && md(e, hb))
    if (e.visualDuration) {
      const i = e.visualDuration, r = 2 * Math.PI / (i * 1.2), o = r * r, s = 2 * qt(0.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(o);
      n = {
        ...n,
        mass: _e.mass,
        stiffness: o,
        damping: s
      };
    } else {
      const i = cb(e);
      n = {
        ...n,
        ...i,
        mass: _e.mass
      }, n.isResolvedFromDuration = !0;
    }
  return n;
}
function vc(e = _e.visualDuration, n = _e.bounce) {
  const i = typeof e != "object" ? {
    visualDuration: e,
    keyframes: [0, 1],
    bounce: n
  } : e;
  let { restSpeed: r, restDelta: o } = i;
  const s = i.keyframes[0], a = i.keyframes[i.keyframes.length - 1], l = { done: !1, value: s }, { stiffness: c, damping: u, mass: f, duration: h, velocity: p, isResolvedFromDuration: m } = pb({
    ...i,
    velocity: -/* @__PURE__ */ Mt(i.velocity || 0)
  }), g = p || 0, y = u / (2 * Math.sqrt(c * f)), v = a - s, w = /* @__PURE__ */ Mt(Math.sqrt(c / f)), x = Math.abs(v) < 5;
  r || (r = x ? _e.restSpeed.granular : _e.restSpeed.default), o || (o = x ? _e.restDelta.granular : _e.restDelta.default);
  let k;
  if (y < 1) {
    const S = Ha(w, y);
    k = (P) => {
      const C = Math.exp(-y * w * P);
      return a - C * ((g + y * w * v) / S * Math.sin(S * P) + v * Math.cos(S * P));
    };
  } else if (y === 1)
    k = (S) => a - Math.exp(-w * S) * (v + (g + w * v) * S);
  else {
    const S = w * Math.sqrt(y * y - 1);
    k = (P) => {
      const C = Math.exp(-y * w * P), T = Math.min(S * P, 300);
      return a - C * ((g + y * w * v) * Math.sinh(T) + S * v * Math.cosh(T)) / S;
    };
  }
  const _ = {
    calculatedDuration: m && h || null,
    next: (S) => {
      const P = k(S);
      if (m)
        l.done = S >= h;
      else {
        let C = 0;
        y < 1 && (C = S === 0 ? /* @__PURE__ */ Tt(g) : Vm(k, S, P));
        const T = Math.abs(C) <= r, M = Math.abs(a - P) <= o;
        l.done = T && M;
      }
      return l.value = l.done ? a : P, l;
    },
    toString: () => {
      const S = Math.min(sc(_), zo), P = rm((C) => _.next(S * C).value, S, 30);
      return S + "ms " + P;
    }
  };
  return _;
}
function gd({ keyframes: e, velocity: n = 0, power: i = 0.8, timeConstant: r = 325, bounceDamping: o = 10, bounceStiffness: s = 500, modifyTarget: a, min: l, max: c, restDelta: u = 0.5, restSpeed: f }) {
  const h = e[0], p = {
    done: !1,
    value: h
  }, m = (T) => l !== void 0 && T < l || c !== void 0 && T > c, g = (T) => l === void 0 ? c : c === void 0 || Math.abs(l - T) < Math.abs(c - T) ? l : c;
  let y = i * n;
  const v = h + y, w = a === void 0 ? v : a(v);
  w !== v && (y = w - h);
  const x = (T) => -y * Math.exp(-T / r), k = (T) => w + x(T), _ = (T) => {
    const M = x(T), D = k(T);
    p.done = Math.abs(M) <= u, p.value = p.done ? w : D;
  };
  let S, P;
  const C = (T) => {
    m(p.value) && (S = T, P = vc({
      keyframes: [p.value, g(p.value)],
      velocity: Vm(k, T, p.value),
      // TODO: This should be passing * 1000
      damping: o,
      stiffness: s,
      restDelta: u,
      restSpeed: f
    }));
  };
  return C(0), {
    calculatedDuration: null,
    next: (T) => {
      let M = !1;
      return !P && S === void 0 && (M = !0, _(T), C(T)), S !== void 0 && T >= S ? P.next(T - S) : (!M && _(T), p);
    }
  };
}
const mb = /* @__PURE__ */ Jr(0.42, 0, 1, 1), gb = /* @__PURE__ */ Jr(0, 0, 0.58, 1), Bm = /* @__PURE__ */ Jr(0.42, 0, 0.58, 1), jm = (e) => Array.isArray(e) && typeof e[0] != "number", yb = {
  linear: tt,
  easeIn: mb,
  easeInOut: Bm,
  easeOut: gb,
  circIn: hc,
  circInOut: bm,
  circOut: xm,
  backIn: dc,
  backInOut: vm,
  backOut: ym,
  anticipate: wm
}, yd = (e) => {
  if (ac(e)) {
    zp(e.length === 4);
    const [n, i, r, o] = e;
    return Jr(n, i, r, o);
  } else if (typeof e == "string")
    return yb[e];
  return e;
};
function vb(e, n, i) {
  const r = [], o = i || Om, s = e.length - 1;
  for (let a = 0; a < s; a++) {
    let l = o(e[a], e[a + 1]);
    if (n) {
      const c = Array.isArray(n) ? n[a] || tt : n;
      l = Qr(c, l);
    }
    r.push(l);
  }
  return r;
}
function wb(e, n, { clamp: i = !0, ease: r, mixer: o } = {}) {
  const s = e.length;
  if (zp(s === n.length), s === 1)
    return () => n[0];
  if (s === 2 && n[0] === n[1])
    return () => n[1];
  const a = e[0] === e[1];
  e[0] > e[s - 1] && (e = [...e].reverse(), n = [...n].reverse());
  const l = vb(n, r, o), c = l.length, u = (f) => {
    if (a && f < e[0])
      return n[0];
    let h = 0;
    if (c > 1)
      for (; h < e.length - 2 && !(f < e[h + 1]); h++)
        ;
    const p = /* @__PURE__ */ In(e[h], e[h + 1], f);
    return l[h](p);
  };
  return i ? (f) => u(qt(e[0], e[s - 1], f)) : u;
}
function Fm(e, n) {
  const i = e[e.length - 1];
  for (let r = 1; r <= n; r++) {
    const o = /* @__PURE__ */ In(0, n, r);
    e.push(we(i, 1, o));
  }
}
function Wm(e) {
  const n = [0];
  return Fm(n, e.length - 1), n;
}
function xb(e, n) {
  return e.map((i) => i * n);
}
function bb(e, n) {
  return e.map(() => n || Bm).splice(0, e.length - 1);
}
function Bo({ duration: e = 300, keyframes: n, times: i, ease: r = "easeInOut" }) {
  const o = jm(r) ? r.map(yd) : yd(r), s = {
    done: !1,
    value: n[0]
  }, a = xb(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    i && i.length === n.length ? i : Wm(n),
    e
  ), l = wb(a, n, {
    ease: Array.isArray(o) ? o : bb(n, o)
  });
  return {
    calculatedDuration: e,
    next: (c) => (s.value = l(c), s.done = c >= e, s)
  };
}
const kb = (e) => {
  const n = ({ timestamp: i }) => e(i);
  return {
    start: () => fe.update(n, !0),
    stop: () => tn(n),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => Ne.isProcessing ? Ne.timestamp : It.now()
  };
}, Sb = {
  decay: gd,
  inertia: gd,
  tween: Bo,
  keyframes: Bo,
  spring: vc
}, _b = (e) => e / 100;
class wc extends $m {
  constructor(n) {
    super(n), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
      if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
        return;
      this.teardown();
      const { onStop: c } = this.options;
      c && c();
    };
    const { name: i, motionValue: r, element: o, keyframes: s } = this.options, a = o?.KeyframeResolver || gc, l = (c, u) => this.onKeyframesResolved(c, u);
    this.resolver = new a(s, l, i, r, o), this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
  }
  initPlayback(n) {
    const { type: i = "keyframes", repeat: r = 0, repeatDelay: o = 0, repeatType: s, velocity: a = 0 } = this.options, l = ys(i) ? i : Sb[i] || Bo;
    let c, u;
    l !== Bo && typeof n[0] != "number" && (c = Qr(_b, Om(n[0], n[1])), n = [0, 100]);
    const f = l({ ...this.options, keyframes: n });
    s === "mirror" && (u = l({
      ...this.options,
      keyframes: [...n].reverse(),
      velocity: -a
    })), f.calculatedDuration === null && (f.calculatedDuration = sc(f));
    const { calculatedDuration: h } = f, p = h + o, m = p * (r + 1) - o;
    return {
      generator: f,
      mirroredGenerator: u,
      mapPercentToKeyframes: c,
      calculatedDuration: h,
      resolvedDuration: p,
      totalDuration: m
    };
  }
  onPostResolved() {
    const { autoplay: n = !0 } = this.options;
    this.play(), this.pendingPlayState === "paused" || !n ? this.pause() : this.state = this.pendingPlayState;
  }
  tick(n, i = !1) {
    const { resolved: r } = this;
    if (!r) {
      const { keyframes: T } = this.options;
      return { done: !0, value: T[T.length - 1] };
    }
    const { finalKeyframe: o, generator: s, mirroredGenerator: a, mapPercentToKeyframes: l, keyframes: c, calculatedDuration: u, totalDuration: f, resolvedDuration: h } = r;
    if (this.startTime === null)
      return s.next(0);
    const { delay: p, repeat: m, repeatType: g, repeatDelay: y, onUpdate: v } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, n) : this.speed < 0 && (this.startTime = Math.min(n - f / this.speed, this.startTime)), i ? this.currentTime = n : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(n - this.startTime) * this.speed;
    const w = this.currentTime - p * (this.speed >= 0 ? 1 : -1), x = this.speed >= 0 ? w < 0 : w > f;
    this.currentTime = Math.max(w, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = f);
    let k = this.currentTime, _ = s;
    if (m) {
      const T = Math.min(this.currentTime, f) / h;
      let M = Math.floor(T), D = T % 1;
      !D && T >= 1 && (D = 1), D === 1 && M--, M = Math.min(M, m + 1), !!(M % 2) && (g === "reverse" ? (D = 1 - D, y && (D -= y / h)) : g === "mirror" && (_ = a)), k = qt(0, 1, D) * h;
    }
    const S = x ? { done: !1, value: c[0] } : _.next(k);
    l && (S.value = l(S.value));
    let { done: P } = S;
    !x && u !== null && (P = this.speed >= 0 ? this.currentTime >= f : this.currentTime <= 0);
    const C = this.holdTime === null && (this.state === "finished" || this.state === "running" && P);
    return C && o !== void 0 && (S.value = ws(c, this.options, o)), v && v(S.value), C && this.finish(), S;
  }
  get duration() {
    const { resolved: n } = this;
    return n ? /* @__PURE__ */ Mt(n.calculatedDuration) : 0;
  }
  get time() {
    return /* @__PURE__ */ Mt(this.currentTime);
  }
  set time(n) {
    n = /* @__PURE__ */ Tt(n), this.currentTime = n, this.holdTime !== null || this.speed === 0 ? this.holdTime = n : this.driver && (this.startTime = this.driver.now() - n / this.speed);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(n) {
    const i = this.playbackSpeed !== n;
    this.playbackSpeed = n, i && (this.time = /* @__PURE__ */ Mt(this.currentTime));
  }
  play() {
    if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped)
      return;
    const { driver: n = kb, onPlay: i, startTime: r } = this.options;
    this.driver || (this.driver = n((s) => this.tick(s))), i && i();
    const o = this.driver.now();
    this.holdTime !== null ? this.startTime = o - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = o) : this.startTime = r ?? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    var n;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused", this.holdTime = (n = this.currentTime) !== null && n !== void 0 ? n : 0;
  }
  complete() {
    this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null;
  }
  finish() {
    this.teardown(), this.state = "finished";
    const { onComplete: n } = this.options;
    n && n();
  }
  cancel() {
    this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel();
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(n) {
    return this.startTime = 0, this.tick(n, !0);
  }
}
const Cb = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
  // or until we implement support for linear() easing.
  // "background-color"
]);
function Eb(e, n, i, { delay: r = 0, duration: o = 300, repeat: s = 0, repeatType: a = "loop", ease: l = "easeInOut", times: c } = {}) {
  const u = { [n]: i };
  c && (u.offset = c);
  const f = sm(l, o);
  return Array.isArray(f) && (u.easing = f), e.animate(u, {
    delay: r,
    duration: o,
    easing: Array.isArray(f) ? "linear" : f,
    fill: "both",
    iterations: s + 1,
    direction: a === "reverse" ? "alternate" : "normal"
  });
}
const Pb = /* @__PURE__ */ Wl(() => Object.hasOwnProperty.call(Element.prototype, "animate")), jo = 10, Tb = 2e4;
function Mb(e) {
  return ys(e.type) || e.type === "spring" || !om(e.ease);
}
function Ab(e, n) {
  const i = new wc({
    ...n,
    keyframes: e,
    repeat: 0,
    delay: 0,
    isGenerator: !0
  });
  let r = { done: !1, value: e[0] };
  const o = [];
  let s = 0;
  for (; !r.done && s < Tb; )
    r = i.sample(s), o.push(r.value), s += jo;
  return {
    times: void 0,
    keyframes: o,
    duration: s - jo,
    ease: "linear"
  };
}
const Hm = {
  anticipate: wm,
  backInOut: vm,
  circInOut: bm
};
function Ib(e) {
  return e in Hm;
}
class vd extends $m {
  constructor(n) {
    super(n);
    const { name: i, motionValue: r, element: o, keyframes: s } = this.options;
    this.resolver = new Lm(s, (a, l) => this.onKeyframesResolved(a, l), i, r, o), this.resolver.scheduleResolve();
  }
  initPlayback(n, i) {
    let { duration: r = 300, times: o, ease: s, type: a, motionValue: l, name: c, startTime: u } = this.options;
    if (!l.owner || !l.owner.current)
      return !1;
    if (typeof s == "string" && Oo() && Ib(s) && (s = Hm[s]), Mb(this.options)) {
      const { onComplete: h, onUpdate: p, motionValue: m, element: g, ...y } = this.options, v = Ab(n, y);
      n = v.keyframes, n.length === 1 && (n[1] = n[0]), r = v.duration, o = v.times, s = v.ease, a = "keyframes";
    }
    const f = Eb(l.owner.current, c, n, { ...this.options, duration: r, times: o, ease: s });
    return f.startTime = u ?? this.calcStartTime(), this.pendingTimeline ? (td(f, this.pendingTimeline), this.pendingTimeline = void 0) : f.onfinish = () => {
      const { onComplete: h } = this.options;
      l.set(ws(n, this.options, i)), h && h(), this.cancel(), this.resolveFinishedPromise();
    }, {
      animation: f,
      duration: r,
      times: o,
      type: a,
      ease: s,
      keyframes: n
    };
  }
  get duration() {
    const { resolved: n } = this;
    if (!n)
      return 0;
    const { duration: i } = n;
    return /* @__PURE__ */ Mt(i);
  }
  get time() {
    const { resolved: n } = this;
    if (!n)
      return 0;
    const { animation: i } = n;
    return /* @__PURE__ */ Mt(i.currentTime || 0);
  }
  set time(n) {
    const { resolved: i } = this;
    if (!i)
      return;
    const { animation: r } = i;
    r.currentTime = /* @__PURE__ */ Tt(n);
  }
  get speed() {
    const { resolved: n } = this;
    if (!n)
      return 1;
    const { animation: i } = n;
    return i.playbackRate;
  }
  set speed(n) {
    const { resolved: i } = this;
    if (!i)
      return;
    const { animation: r } = i;
    r.playbackRate = n;
  }
  get state() {
    const { resolved: n } = this;
    if (!n)
      return "idle";
    const { animation: i } = n;
    return i.playState;
  }
  get startTime() {
    const { resolved: n } = this;
    if (!n)
      return null;
    const { animation: i } = n;
    return i.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(n) {
    if (!this._resolved)
      this.pendingTimeline = n;
    else {
      const { resolved: i } = this;
      if (!i)
        return tt;
      const { animation: r } = i;
      td(r, n);
    }
    return tt;
  }
  play() {
    if (this.isStopped)
      return;
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: i } = n;
    i.playState === "finished" && this.updateFinishedPromise(), i.play();
  }
  pause() {
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: i } = n;
    i.pause();
  }
  stop() {
    if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle")
      return;
    this.resolveFinishedPromise(), this.updateFinishedPromise();
    const { resolved: n } = this;
    if (!n)
      return;
    const { animation: i, keyframes: r, duration: o, type: s, ease: a, times: l } = n;
    if (i.playState === "idle" || i.playState === "finished")
      return;
    if (this.time) {
      const { motionValue: u, onUpdate: f, onComplete: h, element: p, ...m } = this.options, g = new wc({
        ...m,
        keyframes: r,
        duration: o,
        type: s,
        ease: a,
        times: l,
        isGenerator: !0
      }), y = /* @__PURE__ */ Tt(this.time);
      u.setWithVelocity(g.sample(y - jo).value, g.sample(y).value, jo);
    }
    const { onStop: c } = this.options;
    c && c(), this.cancel();
  }
  complete() {
    const { resolved: n } = this;
    n && n.animation.finish();
  }
  cancel() {
    const { resolved: n } = this;
    n && n.animation.cancel();
  }
  static supports(n) {
    const { motionValue: i, name: r, repeatDelay: o, repeatType: s, damping: a, type: l } = n;
    if (!i || !i.owner || !(i.owner.current instanceof HTMLElement))
      return !1;
    const { onUpdate: c, transformTemplate: u } = i.owner.getProps();
    return Pb() && r && Cb.has(r) && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !c && !u && !o && s !== "mirror" && a !== 0 && l !== "inertia";
  }
}
const Db = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, Nb = (e) => ({
  type: "spring",
  stiffness: 550,
  damping: e === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Rb = {
  type: "keyframes",
  duration: 0.8
}, Lb = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, $b = (e, { keyframes: n }) => n.length > 2 ? Rb : Wn.has(e) ? e.startsWith("scale") ? Nb(n[1]) : Db : Lb;
function zb({ when: e, delay: n, delayChildren: i, staggerChildren: r, staggerDirection: o, repeat: s, repeatType: a, repeatDelay: l, from: c, elapsed: u, ...f }) {
  return !!Object.keys(f).length;
}
const xc = (e, n, i, r = {}, o, s) => (a) => {
  const l = oc(r, e) || {}, c = l.delay || r.delay || 0;
  let { elapsed: u = 0 } = r;
  u = u - /* @__PURE__ */ Tt(c);
  let f = {
    keyframes: Array.isArray(i) ? i : [null, i],
    ease: "easeOut",
    velocity: n.getVelocity(),
    ...l,
    delay: -u,
    onUpdate: (p) => {
      n.set(p), l.onUpdate && l.onUpdate(p);
    },
    onComplete: () => {
      a(), l.onComplete && l.onComplete();
    },
    name: e,
    motionValue: n,
    element: s ? void 0 : o
  };
  zb(l) || (f = {
    ...f,
    ...$b(e, f)
  }), f.duration && (f.duration = /* @__PURE__ */ Tt(f.duration)), f.repeatDelay && (f.repeatDelay = /* @__PURE__ */ Tt(f.repeatDelay)), f.from !== void 0 && (f.keyframes[0] = f.from);
  let h = !1;
  if ((f.type === !1 || f.duration === 0 && !f.repeatDelay) && (f.duration = 0, f.delay === 0 && (h = !0)), h && !s && n.get() !== void 0) {
    const p = ws(f.keyframes, l);
    if (p !== void 0)
      return fe.update(() => {
        f.onUpdate(p), f.onComplete();
      }), new im([]);
  }
  return !s && vd.supports(f) ? new vd(f) : new wc(f);
};
function Ob({ protectedKeys: e, needsAnimating: n }, i) {
  const r = e.hasOwnProperty(i) && n[i] !== !0;
  return n[i] = !1, r;
}
function bc(e, n, { delay: i = 0, transitionOverride: r, type: o } = {}) {
  var s;
  let { transition: a = e.getDefaultTransition(), transitionEnd: l, ...c } = n;
  r && (a = r);
  const u = [], f = o && e.animationState && e.animationState.getState()[o];
  for (const h in c) {
    const p = e.getValue(h, (s = e.latestValues[h]) !== null && s !== void 0 ? s : null), m = c[h];
    if (m === void 0 || f && Ob(f, h))
      continue;
    const g = {
      delay: i,
      ...oc(a || {}, h)
    };
    let y = !1;
    if (window.MotionHandoffAnimation) {
      const w = fm(e);
      if (w) {
        const x = window.MotionHandoffAnimation(w, h, fe);
        x !== null && (g.startTime = x, y = !0);
      }
    }
    Oa(e, h), p.start(xc(h, p, m, e.shouldReduceMotion && dm.has(h) ? { type: !1 } : g, e, y));
    const v = p.animation;
    v && u.push(v);
  }
  return l && Promise.all(u).then(() => {
    fe.update(() => {
      l && wx(e, l);
    });
  }), u;
}
function qa(e, n, i = {}) {
  var r;
  const o = Lr(e, n, i.type === "exit" ? (r = e.presenceContext) === null || r === void 0 ? void 0 : r.custom : void 0);
  let { transition: s = e.getDefaultTransition() || {} } = o || {};
  i.transitionOverride && (s = i.transitionOverride);
  const a = o ? () => Promise.all(bc(e, o, i)) : () => Promise.resolve(), l = e.variantChildren && e.variantChildren.size ? (u = 0) => {
    const { delayChildren: f = 0, staggerChildren: h, staggerDirection: p } = s;
    return Vb(e, n, f + u, h, p, i);
  } : () => Promise.resolve(), { when: c } = s;
  if (c) {
    const [u, f] = c === "beforeChildren" ? [a, l] : [l, a];
    return u().then(() => f());
  } else
    return Promise.all([a(), l(i.delay)]);
}
function Vb(e, n, i = 0, r = 0, o = 1, s) {
  const a = [], l = (e.variantChildren.size - 1) * r, c = o === 1 ? (u = 0) => u * r : (u = 0) => l - u * r;
  return Array.from(e.variantChildren).sort(Bb).forEach((u, f) => {
    u.notify("AnimationStart", n), a.push(qa(u, n, {
      ...s,
      delay: i + c(f)
    }).then(() => u.notify("AnimationComplete", n)));
  }), Promise.all(a);
}
function Bb(e, n) {
  return e.sortNodePosition(n);
}
function jb(e, n, i = {}) {
  e.notify("AnimationStart", n);
  let r;
  if (Array.isArray(n)) {
    const o = n.map((s) => qa(e, s, i));
    r = Promise.all(o);
  } else if (typeof n == "string")
    r = qa(e, n, i);
  else {
    const o = typeof n == "function" ? Lr(e, n, i.custom) : n;
    r = Promise.all(bc(e, o, i));
  }
  return r.then(() => {
    e.notify("AnimationComplete", n);
  });
}
function qm(e, n) {
  if (!Array.isArray(n))
    return !1;
  const i = n.length;
  if (i !== e.length)
    return !1;
  for (let r = 0; r < i; r++)
    if (n[r] !== e[r])
      return !1;
  return !0;
}
const Fb = Gl.length;
function Gm(e) {
  if (!e)
    return;
  if (!e.isControllingVariants) {
    const i = e.parent ? Gm(e.parent) || {} : {};
    return e.props.initial !== void 0 && (i.initial = e.props.initial), i;
  }
  const n = {};
  for (let i = 0; i < Fb; i++) {
    const r = Gl[i], o = e.props[r];
    (Dr(o) || o === !1) && (n[r] = o);
  }
  return n;
}
const Wb = [...ql].reverse(), Hb = ql.length;
function qb(e) {
  return (n) => Promise.all(n.map(({ animation: i, options: r }) => jb(e, i, r)));
}
function Gb(e) {
  let n = qb(e), i = wd(), r = !0;
  const o = (c) => (u, f) => {
    var h;
    const p = Lr(e, f, c === "exit" ? (h = e.presenceContext) === null || h === void 0 ? void 0 : h.custom : void 0);
    if (p) {
      const { transition: m, transitionEnd: g, ...y } = p;
      u = { ...u, ...y, ...g };
    }
    return u;
  };
  function s(c) {
    n = c(e);
  }
  function a(c) {
    const { props: u } = e, f = Gm(e.parent) || {}, h = [], p = /* @__PURE__ */ new Set();
    let m = {}, g = 1 / 0;
    for (let v = 0; v < Hb; v++) {
      const w = Wb[v], x = i[w], k = u[w] !== void 0 ? u[w] : f[w], _ = Dr(k), S = w === c ? x.isActive : null;
      S === !1 && (g = v);
      let P = k === f[w] && k !== u[w] && _;
      if (P && r && e.manuallyAnimateOnMount && (P = !1), x.protectedKeys = { ...m }, // If it isn't active and hasn't *just* been set as inactive
      !x.isActive && S === null || // If we didn't and don't have any defined prop for this animation type
      !k && !x.prevProp || // Or if the prop doesn't define an animation
      ms(k) || typeof k == "boolean")
        continue;
      const C = Ub(x.prevProp, k);
      let T = C || // If we're making this variant active, we want to always make it active
      w === c && x.isActive && !P && _ || // If we removed a higher-priority variant (i is in reverse order)
      v > g && _, M = !1;
      const D = Array.isArray(k) ? k : [k];
      let L = D.reduce(o(w), {});
      S === !1 && (L = {});
      const { prevResolvedValues: z = {} } = x, Q = {
        ...z,
        ...L
      }, ee = (G) => {
        T = !0, p.has(G) && (M = !0, p.delete(G)), x.needsAnimating[G] = !0;
        const te = e.getValue(G);
        te && (te.liveStyle = !1);
      };
      for (const G in Q) {
        const te = L[G], $e = z[G];
        if (m.hasOwnProperty(G))
          continue;
        let Me = !1;
        $a(te) && $a($e) ? Me = !qm(te, $e) : Me = te !== $e, Me ? te != null ? ee(G) : p.add(G) : te !== void 0 && p.has(G) ? ee(G) : x.protectedKeys[G] = !0;
      }
      x.prevProp = k, x.prevResolvedValues = L, x.isActive && (m = { ...m, ...L }), r && e.blockInitialAnimation && (T = !1), T && (!(P && C) || M) && h.push(...D.map((G) => ({
        animation: G,
        options: { type: w }
      })));
    }
    if (p.size) {
      const v = {};
      if (typeof u.initial != "boolean") {
        const w = Lr(e, Array.isArray(u.initial) ? u.initial[0] : u.initial);
        w && w.transition && (v.transition = w.transition);
      }
      p.forEach((w) => {
        const x = e.getBaseTarget(w), k = e.getValue(w);
        k && (k.liveStyle = !0), v[w] = x ?? null;
      }), h.push({ animation: v });
    }
    let y = !!h.length;
    return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (y = !1), r = !1, y ? n(h) : Promise.resolve();
  }
  function l(c, u) {
    var f;
    if (i[c].isActive === u)
      return Promise.resolve();
    (f = e.variantChildren) === null || f === void 0 || f.forEach((p) => {
      var m;
      return (m = p.animationState) === null || m === void 0 ? void 0 : m.setActive(c, u);
    }), i[c].isActive = u;
    const h = a(c);
    for (const p in i)
      i[p].protectedKeys = {};
    return h;
  }
  return {
    animateChanges: a,
    setActive: l,
    setAnimateFunction: s,
    getState: () => i,
    reset: () => {
      i = wd(), r = !0;
    }
  };
}
function Ub(e, n) {
  return typeof n == "string" ? n !== e : Array.isArray(n) ? !qm(n, e) : !1;
}
function dn(e = !1) {
  return {
    isActive: e,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function wd() {
  return {
    animate: dn(!0),
    whileInView: dn(),
    whileHover: dn(),
    whileTap: dn(),
    whileDrag: dn(),
    whileFocus: dn(),
    exit: dn()
  };
}
class ln {
  constructor(n) {
    this.isMounted = !1, this.node = n;
  }
  update() {
  }
}
class Yb extends ln {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(n) {
    super(n), n.animationState || (n.animationState = Gb(n));
  }
  updateAnimationControlsSubscription() {
    const { animate: n } = this.node.getProps();
    ms(n) && (this.unmountControls = n.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: n } = this.node.getProps(), { animate: i } = this.node.prevProps || {};
    n !== i && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var n;
    this.node.animationState.reset(), (n = this.unmountControls) === null || n === void 0 || n.call(this);
  }
}
let Xb = 0;
class Kb extends ln {
  constructor() {
    super(...arguments), this.id = Xb++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: n, onExitComplete: i } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || n === r)
      return;
    const o = this.node.animationState.setActive("exit", !n);
    i && !n && o.then(() => {
      i(this.id);
    });
  }
  mount() {
    const { register: n, onExitComplete: i } = this.node.presenceContext || {};
    i && i(this.id), n && (this.unmount = n(this.id));
  }
  unmount() {
  }
}
const Zb = {
  animation: {
    Feature: Yb
  },
  exit: {
    Feature: Kb
  }
};
function zr(e, n, i, r = { passive: !0 }) {
  return e.addEventListener(n, i, r), () => e.removeEventListener(n, i);
}
function eo(e) {
  return {
    point: {
      x: e.pageX,
      y: e.pageY
    }
  };
}
const Jb = (e) => (n) => lc(n) && e(n, eo(n));
function vr(e, n, i, r) {
  return zr(e, n, Jb(i), r);
}
const xd = (e, n) => Math.abs(e - n);
function Qb(e, n) {
  const i = xd(e.x, n.x), r = xd(e.y, n.y);
  return Math.sqrt(i ** 2 + r ** 2);
}
class Um {
  constructor(n, i, { transformPagePoint: r, contextWindow: o, dragSnapToOrigin: s = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const h = ia(this.lastMoveEventInfo, this.history), p = this.startEvent !== null, m = Qb(h.offset, { x: 0, y: 0 }) >= 3;
      if (!p && !m)
        return;
      const { point: g } = h, { timestamp: y } = Ne;
      this.history.push({ ...g, timestamp: y });
      const { onStart: v, onMove: w } = this.handlers;
      p || (v && v(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), w && w(this.lastMoveEvent, h);
    }, this.handlePointerMove = (h, p) => {
      this.lastMoveEvent = h, this.lastMoveEventInfo = na(p, this.transformPagePoint), fe.update(this.updatePoint, !0);
    }, this.handlePointerUp = (h, p) => {
      this.end();
      const { onEnd: m, onSessionEnd: g, resumeAnimation: y } = this.handlers;
      if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const v = ia(h.type === "pointercancel" ? this.lastMoveEventInfo : na(p, this.transformPagePoint), this.history);
      this.startEvent && m && m(h, v), g && g(h, v);
    }, !lc(n))
      return;
    this.dragSnapToOrigin = s, this.handlers = i, this.transformPagePoint = r, this.contextWindow = o || window;
    const a = eo(n), l = na(a, this.transformPagePoint), { point: c } = l, { timestamp: u } = Ne;
    this.history = [{ ...c, timestamp: u }];
    const { onSessionStart: f } = i;
    f && f(n, ia(l, this.history)), this.removeListeners = Qr(vr(this.contextWindow, "pointermove", this.handlePointerMove), vr(this.contextWindow, "pointerup", this.handlePointerUp), vr(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(n) {
    this.handlers = n;
  }
  end() {
    this.removeListeners && this.removeListeners(), tn(this.updatePoint);
  }
}
function na(e, n) {
  return n ? { point: n(e.point) } : e;
}
function bd(e, n) {
  return { x: e.x - n.x, y: e.y - n.y };
}
function ia({ point: e }, n) {
  return {
    point: e,
    delta: bd(e, Ym(n)),
    offset: bd(e, e2(n)),
    velocity: t2(n, 0.1)
  };
}
function e2(e) {
  return e[0];
}
function Ym(e) {
  return e[e.length - 1];
}
function t2(e, n) {
  if (e.length < 2)
    return { x: 0, y: 0 };
  let i = e.length - 1, r = null;
  const o = Ym(e);
  for (; i >= 0 && (r = e[i], !(o.timestamp - r.timestamp > /* @__PURE__ */ Tt(n))); )
    i--;
  if (!r)
    return { x: 0, y: 0 };
  const s = /* @__PURE__ */ Mt(o.timestamp - r.timestamp);
  if (s === 0)
    return { x: 0, y: 0 };
  const a = {
    x: (o.x - r.x) / s,
    y: (o.y - r.y) / s
  };
  return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a;
}
const Xm = 1e-4, n2 = 1 - Xm, i2 = 1 + Xm, Km = 0.01, r2 = 0 - Km, o2 = 0 + Km;
function qe(e) {
  return e.max - e.min;
}
function s2(e, n, i) {
  return Math.abs(e - n) <= i;
}
function kd(e, n, i, r = 0.5) {
  e.origin = r, e.originPoint = we(n.min, n.max, e.origin), e.scale = qe(i) / qe(n), e.translate = we(i.min, i.max, e.origin) - e.originPoint, (e.scale >= n2 && e.scale <= i2 || isNaN(e.scale)) && (e.scale = 1), (e.translate >= r2 && e.translate <= o2 || isNaN(e.translate)) && (e.translate = 0);
}
function wr(e, n, i, r) {
  kd(e.x, n.x, i.x, r ? r.originX : void 0), kd(e.y, n.y, i.y, r ? r.originY : void 0);
}
function Sd(e, n, i) {
  e.min = i.min + n.min, e.max = e.min + qe(n);
}
function a2(e, n, i) {
  Sd(e.x, n.x, i.x), Sd(e.y, n.y, i.y);
}
function _d(e, n, i) {
  e.min = n.min - i.min, e.max = e.min + qe(n);
}
function xr(e, n, i) {
  _d(e.x, n.x, i.x), _d(e.y, n.y, i.y);
}
function l2(e, { min: n, max: i }, r) {
  return n !== void 0 && e < n ? e = r ? we(n, e, r.min) : Math.max(e, n) : i !== void 0 && e > i && (e = r ? we(i, e, r.max) : Math.min(e, i)), e;
}
function Cd(e, n, i) {
  return {
    min: n !== void 0 ? e.min + n : void 0,
    max: i !== void 0 ? e.max + i - (e.max - e.min) : void 0
  };
}
function c2(e, { top: n, left: i, bottom: r, right: o }) {
  return {
    x: Cd(e.x, i, o),
    y: Cd(e.y, n, r)
  };
}
function Ed(e, n) {
  let i = n.min - e.min, r = n.max - e.max;
  return n.max - n.min < e.max - e.min && ([i, r] = [r, i]), { min: i, max: r };
}
function u2(e, n) {
  return {
    x: Ed(e.x, n.x),
    y: Ed(e.y, n.y)
  };
}
function d2(e, n) {
  let i = 0.5;
  const r = qe(e), o = qe(n);
  return o > r ? i = /* @__PURE__ */ In(n.min, n.max - r, e.min) : r > o && (i = /* @__PURE__ */ In(e.min, e.max - o, n.min)), qt(0, 1, i);
}
function h2(e, n) {
  const i = {};
  return n.min !== void 0 && (i.min = n.min - e.min), n.max !== void 0 && (i.max = n.max - e.min), i;
}
const Ga = 0.35;
function f2(e = Ga) {
  return e === !1 ? e = 0 : e === !0 && (e = Ga), {
    x: Pd(e, "left", "right"),
    y: Pd(e, "top", "bottom")
  };
}
function Pd(e, n, i) {
  return {
    min: Td(e, n),
    max: Td(e, i)
  };
}
function Td(e, n) {
  return typeof e == "number" ? e : e[n] || 0;
}
const Md = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), li = () => ({
  x: Md(),
  y: Md()
}), Ad = () => ({ min: 0, max: 0 }), Se = () => ({
  x: Ad(),
  y: Ad()
});
function st(e) {
  return [e("x"), e("y")];
}
function Zm({ top: e, left: n, right: i, bottom: r }) {
  return {
    x: { min: n, max: i },
    y: { min: e, max: r }
  };
}
function p2({ x: e, y: n }) {
  return { top: n.min, right: e.max, bottom: n.max, left: e.min };
}
function m2(e, n) {
  if (!n)
    return e;
  const i = n({ x: e.left, y: e.top }), r = n({ x: e.right, y: e.bottom });
  return {
    top: i.y,
    left: i.x,
    bottom: r.y,
    right: r.x
  };
}
function ra(e) {
  return e === void 0 || e === 1;
}
function Ua({ scale: e, scaleX: n, scaleY: i }) {
  return !ra(e) || !ra(n) || !ra(i);
}
function mn(e) {
  return Ua(e) || Jm(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY;
}
function Jm(e) {
  return Id(e.x) || Id(e.y);
}
function Id(e) {
  return e && e !== "0%";
}
function Fo(e, n, i) {
  const r = e - i, o = n * r;
  return i + o;
}
function Dd(e, n, i, r, o) {
  return o !== void 0 && (e = Fo(e, o, r)), Fo(e, i, r) + n;
}
function Ya(e, n = 0, i = 1, r, o) {
  e.min = Dd(e.min, n, i, r, o), e.max = Dd(e.max, n, i, r, o);
}
function Qm(e, { x: n, y: i }) {
  Ya(e.x, n.translate, n.scale, n.originPoint), Ya(e.y, i.translate, i.scale, i.originPoint);
}
const Nd = 0.999999999999, Rd = 1.0000000000001;
function g2(e, n, i, r = !1) {
  const o = i.length;
  if (!o)
    return;
  n.x = n.y = 1;
  let s, a;
  for (let l = 0; l < o; l++) {
    s = i[l], a = s.projectionDelta;
    const { visualElement: c } = s.options;
    c && c.props.style && c.props.style.display === "contents" || (r && s.options.layoutScroll && s.scroll && s !== s.root && ui(e, {
      x: -s.scroll.offset.x,
      y: -s.scroll.offset.y
    }), a && (n.x *= a.x.scale, n.y *= a.y.scale, Qm(e, a)), r && mn(s.latestValues) && ui(e, s.latestValues));
  }
  n.x < Rd && n.x > Nd && (n.x = 1), n.y < Rd && n.y > Nd && (n.y = 1);
}
function ci(e, n) {
  e.min = e.min + n, e.max = e.max + n;
}
function Ld(e, n, i, r, o = 0.5) {
  const s = we(e.min, e.max, o);
  Ya(e, n, i, s, r);
}
function ui(e, n) {
  Ld(e.x, n.x, n.scaleX, n.scale, n.originX), Ld(e.y, n.y, n.scaleY, n.scale, n.originY);
}
function eg(e, n) {
  return Zm(m2(e.getBoundingClientRect(), n));
}
function y2(e, n, i) {
  const r = eg(e, i), { scroll: o } = n;
  return o && (ci(r.x, o.offset.x), ci(r.y, o.offset.y)), r;
}
const tg = ({ current: e }) => e ? e.ownerDocument.defaultView : null, v2 = /* @__PURE__ */ new WeakMap();
class w2 {
  constructor(n) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = Se(), this.visualElement = n;
  }
  start(n, { snapToCursor: i = !1 } = {}) {
    const { presenceContext: r } = this.visualElement;
    if (r && r.isPresent === !1)
      return;
    const o = (f) => {
      const { dragSnapToOrigin: h } = this.getProps();
      h ? this.pauseAnimation() : this.stopAnimation(), i && this.snapToCursor(eo(f).point);
    }, s = (f, h) => {
      const { drag: p, dragPropagation: m, onDragStart: g } = this.getProps();
      if (p && !m && (this.openDragLock && this.openDragLock(), this.openDragLock = px(p), !this.openDragLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), st((v) => {
        let w = this.getAxisMotionValue(v).get() || 0;
        if (At.test(w)) {
          const { projection: x } = this.visualElement;
          if (x && x.layout) {
            const k = x.layout.layoutBox[v];
            k && (w = qe(k) * (parseFloat(w) / 100));
          }
        }
        this.originPoint[v] = w;
      }), g && fe.postRender(() => g(f, h)), Oa(this.visualElement, "transform");
      const { animationState: y } = this.visualElement;
      y && y.setActive("whileDrag", !0);
    }, a = (f, h) => {
      const { dragPropagation: p, dragDirectionLock: m, onDirectionLock: g, onDrag: y } = this.getProps();
      if (!p && !this.openDragLock)
        return;
      const { offset: v } = h;
      if (m && this.currentDirection === null) {
        this.currentDirection = x2(v), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", h.point, v), this.updateAxis("y", h.point, v), this.visualElement.render(), y && y(f, h);
    }, l = (f, h) => this.stop(f, h), c = () => st((f) => {
      var h;
      return this.getAnimationState(f) === "paused" && ((h = this.getAxisMotionValue(f).animation) === null || h === void 0 ? void 0 : h.play());
    }), { dragSnapToOrigin: u } = this.getProps();
    this.panSession = new Um(n, {
      onSessionStart: o,
      onStart: s,
      onMove: a,
      onSessionEnd: l,
      resumeAnimation: c
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: u,
      contextWindow: tg(this.visualElement)
    });
  }
  stop(n, i) {
    const r = this.isDragging;
    if (this.cancel(), !r)
      return;
    const { velocity: o } = i;
    this.startAnimation(o);
    const { onDragEnd: s } = this.getProps();
    s && fe.postRender(() => s(n, i));
  }
  cancel() {
    this.isDragging = !1;
    const { projection: n, animationState: i } = this.visualElement;
    n && (n.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation: r } = this.getProps();
    !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), i && i.setActive("whileDrag", !1);
  }
  updateAxis(n, i, r) {
    const { drag: o } = this.getProps();
    if (!r || !mo(n, o, this.currentDirection))
      return;
    const s = this.getAxisMotionValue(n);
    let a = this.originPoint[n] + r[n];
    this.constraints && this.constraints[n] && (a = l2(a, this.constraints[n], this.elastic[n])), s.set(a);
  }
  resolveConstraints() {
    var n;
    const { dragConstraints: i, dragElastic: r } = this.getProps(), o = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (n = this.visualElement.projection) === null || n === void 0 ? void 0 : n.layout, s = this.constraints;
    i && si(i) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : i && o ? this.constraints = c2(o.layoutBox, i) : this.constraints = !1, this.elastic = f2(r), s !== this.constraints && o && this.constraints && !this.hasMutatedConstraints && st((a) => {
      this.constraints !== !1 && this.getAxisMotionValue(a) && (this.constraints[a] = h2(o.layoutBox[a], this.constraints[a]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: n, onMeasureDragConstraints: i } = this.getProps();
    if (!n || !si(n))
      return !1;
    const r = n.current, { projection: o } = this.visualElement;
    if (!o || !o.layout)
      return !1;
    const s = y2(r, o.root, this.visualElement.getTransformPagePoint());
    let a = u2(o.layout.layoutBox, s);
    if (i) {
      const l = i(p2(a));
      this.hasMutatedConstraints = !!l, l && (a = Zm(l));
    }
    return a;
  }
  startAnimation(n) {
    const { drag: i, dragMomentum: r, dragElastic: o, dragTransition: s, dragSnapToOrigin: a, onDragTransitionEnd: l } = this.getProps(), c = this.constraints || {}, u = st((f) => {
      if (!mo(f, i, this.currentDirection))
        return;
      let h = c && c[f] || {};
      a && (h = { min: 0, max: 0 });
      const p = o ? 200 : 1e6, m = o ? 40 : 1e7, g = {
        type: "inertia",
        velocity: r ? n[f] : 0,
        bounceStiffness: p,
        bounceDamping: m,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...s,
        ...h
      };
      return this.startAxisValueAnimation(f, g);
    });
    return Promise.all(u).then(l);
  }
  startAxisValueAnimation(n, i) {
    const r = this.getAxisMotionValue(n);
    return Oa(this.visualElement, n), r.start(xc(n, r, 0, i, this.visualElement, !1));
  }
  stopAnimation() {
    st((n) => this.getAxisMotionValue(n).stop());
  }
  pauseAnimation() {
    st((n) => {
      var i;
      return (i = this.getAxisMotionValue(n).animation) === null || i === void 0 ? void 0 : i.pause();
    });
  }
  getAnimationState(n) {
    var i;
    return (i = this.getAxisMotionValue(n).animation) === null || i === void 0 ? void 0 : i.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(n) {
    const i = `_drag${n.toUpperCase()}`, r = this.visualElement.getProps(), o = r[i];
    return o || this.visualElement.getValue(n, (r.initial ? r.initial[n] : void 0) || 0);
  }
  snapToCursor(n) {
    st((i) => {
      const { drag: r } = this.getProps();
      if (!mo(i, r, this.currentDirection))
        return;
      const { projection: o } = this.visualElement, s = this.getAxisMotionValue(i);
      if (o && o.layout) {
        const { min: a, max: l } = o.layout.layoutBox[i];
        s.set(n[i] - we(a, l, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: n, dragConstraints: i } = this.getProps(), { projection: r } = this.visualElement;
    if (!si(i) || !r || !this.constraints)
      return;
    this.stopAnimation();
    const o = { x: 0, y: 0 };
    st((a) => {
      const l = this.getAxisMotionValue(a);
      if (l && this.constraints !== !1) {
        const c = l.get();
        o[a] = d2({ min: c, max: c }, this.constraints[a]);
      }
    });
    const { transformTemplate: s } = this.visualElement.getProps();
    this.visualElement.current.style.transform = s ? s({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), st((a) => {
      if (!mo(a, n, null))
        return;
      const l = this.getAxisMotionValue(a), { min: c, max: u } = this.constraints[a];
      l.set(we(c, u, o[a]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    v2.set(this.visualElement, this);
    const n = this.visualElement.current, i = vr(n, "pointerdown", (c) => {
      const { drag: u, dragListener: f = !0 } = this.getProps();
      u && f && this.start(c);
    }), r = () => {
      const { dragConstraints: c } = this.getProps();
      si(c) && c.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: o } = this.visualElement, s = o.addEventListener("measure", r);
    o && !o.layout && (o.root && o.root.updateScroll(), o.updateLayout()), fe.read(r);
    const a = zr(window, "resize", () => this.scalePositionWithinConstraints()), l = o.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: u }) => {
      this.isDragging && u && (st((f) => {
        const h = this.getAxisMotionValue(f);
        h && (this.originPoint[f] += c[f].translate, h.set(h.get() + c[f].translate));
      }), this.visualElement.render());
    });
    return () => {
      a(), i(), s(), l && l();
    };
  }
  getProps() {
    const n = this.visualElement.getProps(), { drag: i = !1, dragDirectionLock: r = !1, dragPropagation: o = !1, dragConstraints: s = !1, dragElastic: a = Ga, dragMomentum: l = !0 } = n;
    return {
      ...n,
      drag: i,
      dragDirectionLock: r,
      dragPropagation: o,
      dragConstraints: s,
      dragElastic: a,
      dragMomentum: l
    };
  }
}
function mo(e, n, i) {
  return (n === !0 || n === e) && (i === null || i === e);
}
function x2(e, n = 10) {
  let i = null;
  return Math.abs(e.y) > n ? i = "y" : Math.abs(e.x) > n && (i = "x"), i;
}
class b2 extends ln {
  constructor(n) {
    super(n), this.removeGroupControls = tt, this.removeListeners = tt, this.controls = new w2(n);
  }
  mount() {
    const { dragControls: n } = this.node.getProps();
    n && (this.removeGroupControls = n.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || tt;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const $d = (e) => (n, i) => {
  e && fe.postRender(() => e(n, i));
};
class k2 extends ln {
  constructor() {
    super(...arguments), this.removePointerDownListener = tt;
  }
  onPointerDown(n) {
    this.session = new Um(n, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: tg(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: n, onPanStart: i, onPan: r, onPanEnd: o } = this.node.getProps();
    return {
      onSessionStart: $d(n),
      onStart: $d(i),
      onMove: r,
      onEnd: (s, a) => {
        delete this.session, o && fe.postRender(() => o(s, a));
      }
    };
  }
  mount() {
    this.removePointerDownListener = vr(this.node.current, "pointerdown", (n) => this.onPointerDown(n));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
const Ao = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function zd(e, n) {
  return n.max === n.min ? 0 : e / (n.max - n.min) * 100;
}
const Ki = {
  correct: (e, n) => {
    if (!n.target)
      return e;
    if (typeof e == "string")
      if (F.test(e))
        e = parseFloat(e);
      else
        return e;
    const i = zd(e, n.target.x), r = zd(e, n.target.y);
    return `${i}% ${r}%`;
  }
}, S2 = {
  correct: (e, { treeScale: n, projectionDelta: i }) => {
    const r = e, o = nn.parse(e);
    if (o.length > 5)
      return r;
    const s = nn.createTransformer(e), a = typeof o[0] != "number" ? 1 : 0, l = i.x.scale * n.x, c = i.y.scale * n.y;
    o[0 + a] /= l, o[1 + a] /= c;
    const u = we(l, c, 0.5);
    return typeof o[2 + a] == "number" && (o[2 + a] /= u), typeof o[3 + a] == "number" && (o[3 + a] /= u), s(o);
  }
};
class _2 extends up {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: n, layoutGroup: i, switchLayoutGroup: r, layoutId: o } = this.props, { projection: s } = n;
    Dw(C2), s && (i.group && i.group.add(s), r && r.register && o && r.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), s.setOptions({
      ...s.options,
      onExitComplete: () => this.safeToRemove()
    })), Ao.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(n) {
    const { layoutDependency: i, visualElement: r, drag: o, isPresent: s } = this.props, a = r.projection;
    return a && (a.isPresent = s, o || n.layoutDependency !== i || i === void 0 ? a.willUpdate() : this.safeToRemove(), n.isPresent !== s && (s ? a.promote() : a.relegate() || fe.postRender(() => {
      const l = a.getStack();
      (!l || !l.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: n } = this.props.visualElement;
    n && (n.root.didUpdate(), Yl.postRender(() => {
      !n.currentAnimation && n.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: n, layoutGroup: i, switchLayoutGroup: r } = this.props, { projection: o } = n;
    o && (o.scheduleCheckAfterUnmount(), i && i.group && i.group.remove(o), r && r.deregister && r.deregister(o));
  }
  safeToRemove() {
    const { safeToRemove: n } = this.props;
    n && n();
  }
  render() {
    return null;
  }
}
function ng(e) {
  const [n, i] = $p(), r = oe(Ir);
  return d(_2, { ...e, layoutGroup: r, switchLayoutGroup: oe(Hp), isPresent: n, safeToRemove: i });
}
const C2 = {
  borderRadius: {
    ...Ki,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Ki,
  borderTopRightRadius: Ki,
  borderBottomLeftRadius: Ki,
  borderBottomRightRadius: Ki,
  boxShadow: S2
};
function ig(e, n, i) {
  const r = Ie(e) ? e : _i(e);
  return r.start(xc("", r, n, i)), r.animation;
}
function rg(e) {
  return e instanceof SVGElement && e.tagName !== "svg";
}
const E2 = (e, n) => e.depth - n.depth;
class P2 {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(n) {
    cc(this.children, n), this.isDirty = !0;
  }
  remove(n) {
    vs(this.children, n), this.isDirty = !0;
  }
  forEach(n) {
    this.isDirty && this.children.sort(E2), this.isDirty = !1, this.children.forEach(n);
  }
}
function T2(e, n) {
  const i = It.now(), r = ({ timestamp: o }) => {
    const s = o - i;
    s >= n && (tn(r), e(s - n));
  };
  return fe.read(r, !0), () => tn(r);
}
const og = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], M2 = og.length, Od = (e) => typeof e == "string" ? parseFloat(e) : e, Vd = (e) => typeof e == "number" || F.test(e);
function A2(e, n, i, r, o, s) {
  o ? (e.opacity = we(
    0,
    // TODO Reinstate this if only child
    i.opacity !== void 0 ? i.opacity : 1,
    I2(r)
  ), e.opacityExit = we(n.opacity !== void 0 ? n.opacity : 1, 0, D2(r))) : s && (e.opacity = we(n.opacity !== void 0 ? n.opacity : 1, i.opacity !== void 0 ? i.opacity : 1, r));
  for (let a = 0; a < M2; a++) {
    const l = `border${og[a]}Radius`;
    let c = Bd(n, l), u = Bd(i, l);
    if (c === void 0 && u === void 0)
      continue;
    c || (c = 0), u || (u = 0), c === 0 || u === 0 || Vd(c) === Vd(u) ? (e[l] = Math.max(we(Od(c), Od(u), r), 0), (At.test(u) || At.test(c)) && (e[l] += "%")) : e[l] = u;
  }
  (n.rotate || i.rotate) && (e.rotate = we(n.rotate || 0, i.rotate || 0, r));
}
function Bd(e, n) {
  return e[n] !== void 0 ? e[n] : e.borderRadius;
}
const I2 = /* @__PURE__ */ sg(0, 0.5, xm), D2 = /* @__PURE__ */ sg(0.5, 0.95, tt);
function sg(e, n, i) {
  return (r) => r < e ? 0 : r > n ? 1 : i(/* @__PURE__ */ In(e, n, r));
}
function jd(e, n) {
  e.min = n.min, e.max = n.max;
}
function ot(e, n) {
  jd(e.x, n.x), jd(e.y, n.y);
}
function Fd(e, n) {
  e.translate = n.translate, e.scale = n.scale, e.originPoint = n.originPoint, e.origin = n.origin;
}
function Wd(e, n, i, r, o) {
  return e -= n, e = Fo(e, 1 / i, r), o !== void 0 && (e = Fo(e, 1 / o, r)), e;
}
function N2(e, n = 0, i = 1, r = 0.5, o, s = e, a = e) {
  if (At.test(n) && (n = parseFloat(n), n = we(a.min, a.max, n / 100) - a.min), typeof n != "number")
    return;
  let l = we(s.min, s.max, r);
  e === s && (l -= n), e.min = Wd(e.min, n, i, l, o), e.max = Wd(e.max, n, i, l, o);
}
function Hd(e, n, [i, r, o], s, a) {
  N2(e, n[i], n[r], n[o], n.scale, s, a);
}
const R2 = ["x", "scaleX", "originX"], L2 = ["y", "scaleY", "originY"];
function qd(e, n, i, r) {
  Hd(e.x, n, R2, i ? i.x : void 0, r ? r.x : void 0), Hd(e.y, n, L2, i ? i.y : void 0, r ? r.y : void 0);
}
function Gd(e) {
  return e.translate === 0 && e.scale === 1;
}
function ag(e) {
  return Gd(e.x) && Gd(e.y);
}
function Ud(e, n) {
  return e.min === n.min && e.max === n.max;
}
function $2(e, n) {
  return Ud(e.x, n.x) && Ud(e.y, n.y);
}
function Yd(e, n) {
  return Math.round(e.min) === Math.round(n.min) && Math.round(e.max) === Math.round(n.max);
}
function lg(e, n) {
  return Yd(e.x, n.x) && Yd(e.y, n.y);
}
function Xd(e) {
  return qe(e.x) / qe(e.y);
}
function Kd(e, n) {
  return e.translate === n.translate && e.scale === n.scale && e.originPoint === n.originPoint;
}
class z2 {
  constructor() {
    this.members = [];
  }
  add(n) {
    cc(this.members, n), n.scheduleRender();
  }
  remove(n) {
    if (vs(this.members, n), n === this.prevLead && (this.prevLead = void 0), n === this.lead) {
      const i = this.members[this.members.length - 1];
      i && this.promote(i);
    }
  }
  relegate(n) {
    const i = this.members.findIndex((o) => n === o);
    if (i === 0)
      return !1;
    let r;
    for (let o = i; o >= 0; o--) {
      const s = this.members[o];
      if (s.isPresent !== !1) {
        r = s;
        break;
      }
    }
    return r ? (this.promote(r), !0) : !1;
  }
  promote(n, i) {
    const r = this.lead;
    if (n !== r && (this.prevLead = r, this.lead = n, n.show(), r)) {
      r.instance && r.scheduleRender(), n.scheduleRender(), n.resumeFrom = r, i && (n.resumeFrom.preserveOpacity = !0), r.snapshot && (n.snapshot = r.snapshot, n.snapshot.latestValues = r.animationValues || r.latestValues), n.root && n.root.isUpdating && (n.isLayoutDirty = !0);
      const { crossfade: o } = n.options;
      o === !1 && r.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((n) => {
      const { options: i, resumingFrom: r } = n;
      i.onExitComplete && i.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((n) => {
      n.instance && n.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function O2(e, n, i) {
  let r = "";
  const o = e.x.translate / n.x, s = e.y.translate / n.y, a = i?.z || 0;
  if ((o || s || a) && (r = `translate3d(${o}px, ${s}px, ${a}px) `), (n.x !== 1 || n.y !== 1) && (r += `scale(${1 / n.x}, ${1 / n.y}) `), i) {
    const { transformPerspective: u, rotate: f, rotateX: h, rotateY: p, skewX: m, skewY: g } = i;
    u && (r = `perspective(${u}px) ${r}`), f && (r += `rotate(${f}deg) `), h && (r += `rotateX(${h}deg) `), p && (r += `rotateY(${p}deg) `), m && (r += `skewX(${m}deg) `), g && (r += `skewY(${g}deg) `);
  }
  const l = e.x.scale * n.x, c = e.y.scale * n.y;
  return (l !== 1 || c !== 1) && (r += `scale(${l}, ${c})`), r || "none";
}
const oa = ["", "X", "Y", "Z"], V2 = { visibility: "hidden" }, Zd = 1e3;
let B2 = 0;
function sa(e, n, i, r) {
  const { latestValues: o } = n;
  o[e] && (i[e] = o[e], n.setStaticValue(e, 0), r && (r[e] = 0));
}
function cg(e) {
  if (e.hasCheckedOptimisedAppear = !0, e.root === e)
    return;
  const { visualElement: n } = e.options;
  if (!n)
    return;
  const i = fm(n);
  if (window.MotionHasOptimisedAnimation(i, "transform")) {
    const { layout: o, layoutId: s } = e.options;
    window.MotionCancelOptimisedAnimation(i, "transform", fe, !(o || s));
  }
  const { parent: r } = e;
  r && !r.hasCheckedOptimisedAppear && cg(r);
}
function ug({ attachResizeListener: e, defaultParent: n, measureScroll: i, checkIsScrollRoot: r, resetTransform: o }) {
  return class {
    constructor(a = {}, l = n?.()) {
      this.id = B2++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(W2), this.nodes.forEach(Y2), this.nodes.forEach(X2), this.nodes.forEach(H2);
      }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0;
      for (let c = 0; c < this.path.length; c++)
        this.path[c].shouldResetTransform = !0;
      this.root === this && (this.nodes = new P2());
    }
    addEventListener(a, l) {
      return this.eventHandlers.has(a) || this.eventHandlers.set(a, new uc()), this.eventHandlers.get(a).add(l);
    }
    notifyListeners(a, ...l) {
      const c = this.eventHandlers.get(a);
      c && c.notify(...l);
    }
    hasListeners(a) {
      return this.eventHandlers.has(a);
    }
    /**
     * Lifecycles
     */
    mount(a, l = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = rg(a), this.instance = a;
      const { layoutId: c, layout: u, visualElement: f } = this.options;
      if (f && !f.current && f.mount(a), this.root.nodes.add(this), this.parent && this.parent.children.add(this), l && (u || c) && (this.isLayoutDirty = !0), e) {
        let h;
        const p = () => this.root.updateBlockedByResize = !1;
        e(a, () => {
          this.root.updateBlockedByResize = !0, h && h(), h = T2(p, 250), Ao.hasAnimatedSinceResize && (Ao.hasAnimatedSinceResize = !1, this.nodes.forEach(Qd));
        });
      }
      c && this.root.registerSharedNode(c, this), this.options.animate !== !1 && f && (c || u) && this.addEventListener("didUpdate", ({ delta: h, hasLayoutChanged: p, hasRelativeLayoutChanged: m, layout: g }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const y = this.options.transition || f.getDefaultTransition() || ek, { onLayoutAnimationStart: v, onLayoutAnimationComplete: w } = f.getProps(), x = !this.targetLayout || !lg(this.targetLayout, g), k = !p && m;
        if (this.options.layoutRoot || this.resumeFrom || k || p && (x || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(h, k);
          const _ = {
            ...oc(y, "layout"),
            onPlay: v,
            onComplete: w
          };
          (f.shouldReduceMotion || this.options.layoutRoot) && (_.delay = 0, _.type = !1), this.startAnimation(_);
        } else
          p || Qd(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = g;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const a = this.getStack();
      a && a.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, tn(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(K2), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: a } = this.options;
      return a && a.getProps().transformTemplate;
    }
    willUpdate(a = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && cg(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let f = 0; f < this.path.length; f++) {
        const h = this.path[f];
        h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1);
      }
      const { layoutId: l, layout: c } = this.options;
      if (l === void 0 && !c)
        return;
      const u = this.getTransformTemplate();
      this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), a && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Jd);
        return;
      }
      this.isUpdating || this.nodes.forEach(G2), this.isUpdating = !1, this.nodes.forEach(U2), this.nodes.forEach(j2), this.nodes.forEach(F2), this.clearAllSnapshots();
      const l = It.now();
      Ne.delta = qt(0, 1e3 / 60, l - Ne.timestamp), Ne.timestamp = l, Ne.isProcessing = !0, Ks.update.process(Ne), Ks.preRender.process(Ne), Ks.render.process(Ne), Ne.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Yl.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(q2), this.sharedNodes.forEach(Z2);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, fe.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      fe.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !qe(this.snapshot.measuredBox.x) && !qe(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let c = 0; c < this.path.length; c++)
          this.path[c].updateScroll();
      const a = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = Se(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: l } = this.options;
      l && l.notify("LayoutMeasure", this.layout.layoutBox, a ? a.layoutBox : void 0);
    }
    updateScroll(a = "measure") {
      let l = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (l = !1), l) {
        const c = r(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: a,
          isRoot: c,
          offset: i(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : c
        };
      }
    }
    resetTransform() {
      if (!o)
        return;
      const a = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, l = this.projectionDelta && !ag(this.projectionDelta), c = this.getTransformTemplate(), u = c ? c(this.latestValues, "") : void 0, f = u !== this.prevTransformTemplateValue;
      a && (l || mn(this.latestValues) || f) && (o(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(a = !0) {
      const l = this.measurePageBox();
      let c = this.removeElementScroll(l);
      return a && (c = this.removeTransform(c)), tk(c), {
        animationId: this.root.animationId,
        measuredBox: l,
        layoutBox: c,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var a;
      const { visualElement: l } = this.options;
      if (!l)
        return Se();
      const c = l.measureViewportBox();
      if (!(((a = this.scroll) === null || a === void 0 ? void 0 : a.wasRoot) || this.path.some(nk))) {
        const { scroll: f } = this.root;
        f && (ci(c.x, f.offset.x), ci(c.y, f.offset.y));
      }
      return c;
    }
    removeElementScroll(a) {
      var l;
      const c = Se();
      if (ot(c, a), !((l = this.scroll) === null || l === void 0) && l.wasRoot)
        return c;
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u], { scroll: h, options: p } = f;
        f !== this.root && h && p.layoutScroll && (h.wasRoot && ot(c, a), ci(c.x, h.offset.x), ci(c.y, h.offset.y));
      }
      return c;
    }
    applyTransform(a, l = !1) {
      const c = Se();
      ot(c, a);
      for (let u = 0; u < this.path.length; u++) {
        const f = this.path[u];
        !l && f.options.layoutScroll && f.scroll && f !== f.root && ui(c, {
          x: -f.scroll.offset.x,
          y: -f.scroll.offset.y
        }), mn(f.latestValues) && ui(c, f.latestValues);
      }
      return mn(this.latestValues) && ui(c, this.latestValues), c;
    }
    removeTransform(a) {
      const l = Se();
      ot(l, a);
      for (let c = 0; c < this.path.length; c++) {
        const u = this.path[c];
        if (!u.instance || !mn(u.latestValues))
          continue;
        Ua(u.latestValues) && u.updateSnapshot();
        const f = Se(), h = u.measurePageBox();
        ot(f, h), qd(l, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, f);
      }
      return mn(this.latestValues) && qd(l, this.latestValues), l;
    }
    setTargetDelta(a) {
      this.targetDelta = a, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(a) {
      this.options = {
        ...this.options,
        ...a,
        crossfade: a.crossfade !== void 0 ? a.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== Ne.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(a = !1) {
      var l;
      const c = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = c.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = c.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = c.isSharedProjectionDirty);
      const u = !!this.resumingFrom || this !== c;
      if (!(a || u && this.isSharedProjectionDirty || this.isProjectionDirty || !((l = this.parent) === null || l === void 0) && l.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: h, layoutId: p } = this.options;
      if (!(!this.layout || !(h || p))) {
        if (this.resolvedRelativeTargetAt = Ne.timestamp, !this.targetDelta && !this.relativeTarget) {
          const m = this.getClosestProjectingParent();
          m && m.layout && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Se(), this.relativeTargetOrigin = Se(), xr(this.relativeTargetOrigin, this.layout.layoutBox, m.layout.layoutBox), ot(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = Se(), this.targetWithTransforms = Se()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), a2(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : ot(this.target, this.layout.layoutBox), Qm(this.target, this.targetDelta)) : ot(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
          this.attemptToResolveRelativeTarget = !1;
          const m = this.getClosestProjectingParent();
          m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = Se(), this.relativeTargetOrigin = Se(), xr(this.relativeTargetOrigin, this.target, m.target), ot(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Ua(this.parent.latestValues) || Jm(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var a;
      const l = this.getLead(), c = !!this.resumingFrom || this !== l;
      let u = !0;
      if ((this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty) && (u = !1), c && (this.isSharedProjectionDirty || this.isTransformDirty) && (u = !1), this.resolvedRelativeTargetAt === Ne.timestamp && (u = !1), u)
        return;
      const { layout: f, layoutId: h } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(f || h))
        return;
      ot(this.layoutCorrected, this.layout.layoutBox);
      const p = this.treeScale.x, m = this.treeScale.y;
      g2(this.layoutCorrected, this.treeScale, this.path, c), l.layout && !l.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (l.target = l.layout.layoutBox, l.targetWithTransforms = Se());
      const { target: g } = l;
      if (!g) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Fd(this.prevProjectionDelta.x, this.projectionDelta.x), Fd(this.prevProjectionDelta.y, this.projectionDelta.y)), wr(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== p || this.treeScale.y !== m || !Kd(this.projectionDelta.x, this.prevProjectionDelta.x) || !Kd(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(a = !0) {
      var l;
      if ((l = this.options.visualElement) === null || l === void 0 || l.scheduleRender(), a) {
        const c = this.getStack();
        c && c.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = li(), this.projectionDelta = li(), this.projectionDeltaWithTransform = li();
    }
    setAnimationOrigin(a, l = !1) {
      const c = this.snapshot, u = c ? c.latestValues : {}, f = { ...this.latestValues }, h = li();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !l;
      const p = Se(), m = c ? c.source : void 0, g = this.layout ? this.layout.source : void 0, y = m !== g, v = this.getStack(), w = !v || v.members.length <= 1, x = !!(y && !w && this.options.crossfade === !0 && !this.path.some(Q2));
      this.animationProgress = 0;
      let k;
      this.mixTargetDelta = (_) => {
        const S = _ / 1e3;
        eh(h.x, a.x, S), eh(h.y, a.y, S), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (xr(p, this.layout.layoutBox, this.relativeParent.layout.layoutBox), J2(this.relativeTarget, this.relativeTargetOrigin, p, S), k && $2(this.relativeTarget, k) && (this.isProjectionDirty = !1), k || (k = Se()), ot(k, this.relativeTarget)), y && (this.animationValues = f, A2(f, u, this.latestValues, S, x, w)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = S;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(a) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (tn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = fe.update(() => {
        Ao.hasAnimatedSinceResize = !0, this.currentAnimation = ig(0, Zd, {
          ...a,
          onUpdate: (l) => {
            this.mixTargetDelta(l), a.onUpdate && a.onUpdate(l);
          },
          onStop: () => {
          },
          onComplete: () => {
            a.onComplete && a.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const a = this.getStack();
      a && a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Zd), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const a = this.getLead();
      let { targetWithTransforms: l, target: c, layout: u, latestValues: f } = a;
      if (!(!l || !c || !u)) {
        if (this !== a && this.layout && u && dg(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
          c = this.target || Se();
          const h = qe(this.layout.layoutBox.x);
          c.x.min = a.target.x.min, c.x.max = c.x.min + h;
          const p = qe(this.layout.layoutBox.y);
          c.y.min = a.target.y.min, c.y.max = c.y.min + p;
        }
        ot(l, c), ui(l, f), wr(this.projectionDeltaWithTransform, this.layoutCorrected, l, f);
      }
    }
    registerSharedNode(a, l) {
      this.sharedNodes.has(a) || this.sharedNodes.set(a, new z2()), this.sharedNodes.get(a).add(l);
      const u = l.options.initialPromotionConfig;
      l.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(l) : void 0
      });
    }
    isLead() {
      const a = this.getStack();
      return a ? a.lead === this : !0;
    }
    getLead() {
      var a;
      const { layoutId: l } = this.options;
      return l ? ((a = this.getStack()) === null || a === void 0 ? void 0 : a.lead) || this : this;
    }
    getPrevLead() {
      var a;
      const { layoutId: l } = this.options;
      return l ? (a = this.getStack()) === null || a === void 0 ? void 0 : a.prevLead : void 0;
    }
    getStack() {
      const { layoutId: a } = this.options;
      if (a)
        return this.root.sharedNodes.get(a);
    }
    promote({ needsReset: a, transition: l, preserveFollowOpacity: c } = {}) {
      const u = this.getStack();
      u && u.promote(this, c), a && (this.projectionDelta = void 0, this.needsReset = !0), l && this.setOptions({ transition: l });
    }
    relegate() {
      const a = this.getStack();
      return a ? a.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: a } = this.options;
      if (!a)
        return;
      let l = !1;
      const { latestValues: c } = a;
      if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (l = !0), !l)
        return;
      const u = {};
      c.z && sa("z", a, u, this.animationValues);
      for (let f = 0; f < oa.length; f++)
        sa(`rotate${oa[f]}`, a, u, this.animationValues), sa(`skew${oa[f]}`, a, u, this.animationValues);
      a.render();
      for (const f in u)
        a.setStaticValue(f, u[f]), this.animationValues && (this.animationValues[f] = u[f]);
      a.scheduleRender();
    }
    getProjectionStyles(a) {
      var l, c;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return V2;
      const u = {
        visibility: ""
      }, f = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, u.opacity = "", u.pointerEvents = To(a?.pointerEvents) || "", u.transform = f ? f(this.latestValues, "") : "none", u;
      const h = this.getLead();
      if (!this.projectionDelta || !this.layout || !h.target) {
        const y = {};
        return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = To(a?.pointerEvents) || ""), this.hasProjected && !mn(this.latestValues) && (y.transform = f ? f({}, "") : "none", this.hasProjected = !1), y;
      }
      const p = h.animationValues || h.latestValues;
      this.applyTransformsToTarget(), u.transform = O2(this.projectionDeltaWithTransform, this.treeScale, p), f && (u.transform = f(p, u.transform));
      const { x: m, y: g } = this.projectionDelta;
      u.transformOrigin = `${m.origin * 100}% ${g.origin * 100}% 0`, h.animationValues ? u.opacity = h === this ? (c = (l = p.opacity) !== null && l !== void 0 ? l : this.latestValues.opacity) !== null && c !== void 0 ? c : 1 : this.preserveOpacity ? this.latestValues.opacity : p.opacityExit : u.opacity = h === this ? p.opacity !== void 0 ? p.opacity : "" : p.opacityExit !== void 0 ? p.opacityExit : 0;
      for (const y in Nr) {
        if (p[y] === void 0)
          continue;
        const { correct: v, applyTo: w, isCSSVariable: x } = Nr[y], k = u.transform === "none" ? p[y] : v(p[y], h);
        if (w) {
          const _ = w.length;
          for (let S = 0; S < _; S++)
            u[w[S]] = k;
        } else
          x ? this.options.visualElement.renderState.vars[y] = k : u[y] = k;
      }
      return this.options.layoutId && (u.pointerEvents = h === this ? To(a?.pointerEvents) || "" : "none"), u;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((a) => {
        var l;
        return (l = a.currentAnimation) === null || l === void 0 ? void 0 : l.stop();
      }), this.root.nodes.forEach(Jd), this.root.sharedNodes.clear();
    }
  };
}
function j2(e) {
  e.updateLayout();
}
function F2(e) {
  var n;
  const i = ((n = e.resumeFrom) === null || n === void 0 ? void 0 : n.snapshot) || e.snapshot;
  if (e.isLead() && e.layout && i && e.hasListeners("didUpdate")) {
    const { layoutBox: r, measuredBox: o } = e.layout, { animationType: s } = e.options, a = i.source !== e.layout.source;
    s === "size" ? st((h) => {
      const p = a ? i.measuredBox[h] : i.layoutBox[h], m = qe(p);
      p.min = r[h].min, p.max = p.min + m;
    }) : dg(s, i.layoutBox, r) && st((h) => {
      const p = a ? i.measuredBox[h] : i.layoutBox[h], m = qe(r[h]);
      p.max = p.min + m, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[h].max = e.relativeTarget[h].min + m);
    });
    const l = li();
    wr(l, r, i.layoutBox);
    const c = li();
    a ? wr(c, e.applyTransform(o, !0), i.measuredBox) : wr(c, r, i.layoutBox);
    const u = !ag(l);
    let f = !1;
    if (!e.resumeFrom) {
      const h = e.getClosestProjectingParent();
      if (h && !h.resumeFrom) {
        const { snapshot: p, layout: m } = h;
        if (p && m) {
          const g = Se();
          xr(g, i.layoutBox, p.layoutBox);
          const y = Se();
          xr(y, r, m.layoutBox), lg(g, y) || (f = !0), h.options.layoutRoot && (e.relativeTarget = y, e.relativeTargetOrigin = g, e.relativeParent = h);
        }
      }
    }
    e.notifyListeners("didUpdate", {
      layout: r,
      snapshot: i,
      delta: c,
      layoutDelta: l,
      hasLayoutChanged: u,
      hasRelativeLayoutChanged: f
    });
  } else if (e.isLead()) {
    const { onExitComplete: r } = e.options;
    r && r();
  }
  e.options.transition = void 0;
}
function W2(e) {
  e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty));
}
function H2(e) {
  e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1;
}
function q2(e) {
  e.clearSnapshot();
}
function Jd(e) {
  e.clearMeasurements();
}
function G2(e) {
  e.isLayoutDirty = !1;
}
function U2(e) {
  const { visualElement: n } = e.options;
  n && n.getProps().onBeforeLayoutMeasure && n.notify("BeforeLayoutMeasure"), e.resetTransform();
}
function Qd(e) {
  e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0;
}
function Y2(e) {
  e.resolveTargetDelta();
}
function X2(e) {
  e.calcProjection();
}
function K2(e) {
  e.resetSkewAndRotation();
}
function Z2(e) {
  e.removeLeadSnapshot();
}
function eh(e, n, i) {
  e.translate = we(n.translate, 0, i), e.scale = we(n.scale, 1, i), e.origin = n.origin, e.originPoint = n.originPoint;
}
function th(e, n, i, r) {
  e.min = we(n.min, i.min, r), e.max = we(n.max, i.max, r);
}
function J2(e, n, i, r) {
  th(e.x, n.x, i.x, r), th(e.y, n.y, i.y, r);
}
function Q2(e) {
  return e.animationValues && e.animationValues.opacityExit !== void 0;
}
const ek = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, nh = (e) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), ih = nh("applewebkit/") && !nh("chrome/") ? Math.round : tt;
function rh(e) {
  e.min = ih(e.min), e.max = ih(e.max);
}
function tk(e) {
  rh(e.x), rh(e.y);
}
function dg(e, n, i) {
  return e === "position" || e === "preserve-aspect" && !s2(Xd(n), Xd(i), 0.2);
}
function nk(e) {
  var n;
  return e !== e.root && ((n = e.scroll) === null || n === void 0 ? void 0 : n.wasRoot);
}
const ik = ug({
  attachResizeListener: (e, n) => zr(e, "resize", n),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), aa = {
  current: void 0
}, hg = ug({
  measureScroll: (e) => ({
    x: e.scrollLeft,
    y: e.scrollTop
  }),
  defaultParent: () => {
    if (!aa.current) {
      const e = new ik({});
      e.mount(window), e.setOptions({ layoutScroll: !0 }), aa.current = e;
    }
    return aa.current;
  },
  resetTransform: (e, n) => {
    e.style.transform = n !== void 0 ? n : "none";
  },
  checkIsScrollRoot: (e) => window.getComputedStyle(e).position === "fixed"
}), rk = {
  pan: {
    Feature: k2
  },
  drag: {
    Feature: b2,
    ProjectionNode: hg,
    MeasureLayout: ng
  }
};
function oh(e, n, i) {
  const { props: r } = e;
  e.animationState && r.whileHover && e.animationState.setActive("whileHover", i === "Start");
  const o = "onHover" + i, s = r[o];
  s && fe.postRender(() => s(n, eo(n)));
}
class ok extends ln {
  mount() {
    const { current: n } = this.node;
    n && (this.unmount = cx(n, (i, r) => (oh(this.node, r, "Start"), (o) => oh(this.node, o, "End"))));
  }
  unmount() {
  }
}
class sk extends ln {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let n = !1;
    try {
      n = this.node.current.matches(":focus-visible");
    } catch {
      n = !0;
    }
    !n || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Qr(zr(this.node.current, "focus", () => this.onFocus()), zr(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function sh(e, n, i) {
  const { props: r } = e;
  if (e.current instanceof HTMLButtonElement && e.current.disabled)
    return;
  e.animationState && r.whileTap && e.animationState.setActive("whileTap", i === "Start");
  const o = "onTap" + (i === "End" ? "" : i), s = r[o];
  s && fe.postRender(() => s(n, eo(n)));
}
class ak extends ln {
  mount() {
    const { current: n } = this.node;
    n && (this.unmount = fx(n, (i, r) => (sh(this.node, r, "Start"), (o, { success: s }) => sh(this.node, o, s ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const Xa = /* @__PURE__ */ new WeakMap(), la = /* @__PURE__ */ new WeakMap(), lk = (e) => {
  const n = Xa.get(e.target);
  n && n(e);
}, ck = (e) => {
  e.forEach(lk);
};
function uk({ root: e, ...n }) {
  const i = e || document;
  la.has(i) || la.set(i, {});
  const r = la.get(i), o = JSON.stringify(n);
  return r[o] || (r[o] = new IntersectionObserver(ck, { root: e, ...n })), r[o];
}
function dk(e, n, i) {
  const r = uk(n);
  return Xa.set(e, i), r.observe(e), () => {
    Xa.delete(e), r.unobserve(e);
  };
}
const hk = {
  some: 0,
  all: 1
};
class fk extends ln {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: n = {} } = this.node.getProps(), { root: i, margin: r, amount: o = "some", once: s } = n, a = {
      root: i ? i.current : void 0,
      rootMargin: r,
      threshold: typeof o == "number" ? o : hk[o]
    }, l = (c) => {
      const { isIntersecting: u } = c;
      if (this.isInView === u || (this.isInView = u, s && !u && this.hasEnteredView))
        return;
      u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u);
      const { onViewportEnter: f, onViewportLeave: h } = this.node.getProps(), p = u ? f : h;
      p && p(c);
    };
    return dk(this.node.current, a, l);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: n, prevProps: i } = this.node;
    ["amount", "margin", "root"].some(pk(n, i)) && this.startObserver();
  }
  unmount() {
  }
}
function pk({ viewport: e = {} }, { viewport: n = {} } = {}) {
  return (i) => e[i] !== n[i];
}
const mk = {
  inView: {
    Feature: fk
  },
  tap: {
    Feature: ak
  },
  focus: {
    Feature: sk
  },
  hover: {
    Feature: ok
  }
}, gk = {
  layout: {
    ProjectionNode: hg,
    MeasureLayout: ng
  }
}, Wo = { current: null }, kc = { current: !1 };
function fg() {
  if (kc.current = !0, !!jl)
    if (window.matchMedia) {
      const e = window.matchMedia("(prefers-reduced-motion)"), n = () => Wo.current = e.matches;
      e.addListener(n), n();
    } else
      Wo.current = !1;
}
const yk = [...Rm, Oe, nn], vk = (e) => yk.find(Nm(e)), Or = /* @__PURE__ */ new WeakMap();
function wk(e, n, i) {
  for (const r in n) {
    const o = n[r], s = i[r];
    if (Ie(o))
      e.addValue(r, o);
    else if (Ie(s))
      e.addValue(r, _i(o, { owner: e }));
    else if (s !== o)
      if (e.hasValue(r)) {
        const a = e.getValue(r);
        a.liveStyle === !0 ? a.jump(o) : a.hasAnimated || a.set(o);
      } else {
        const a = e.getStaticValue(r);
        e.addValue(r, _i(a !== void 0 ? a : o, { owner: e }));
      }
  }
  for (const r in i)
    n[r] === void 0 && e.removeValue(r);
  return n;
}
const ah = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
class pg {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(n, i, r) {
    return {};
  }
  constructor({ parent: n, props: i, presenceContext: r, reducedMotionConfig: o, blockInitialAnimation: s, visualState: a }, l = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = gc, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const m = It.now();
      this.renderScheduledAt < m && (this.renderScheduledAt = m, fe.render(this.render, !1, !0));
    };
    const { latestValues: c, renderState: u, onUpdate: f } = a;
    this.onUpdate = f, this.latestValues = c, this.baseTarget = { ...c }, this.initialValues = i.initial ? { ...c } : {}, this.renderState = u, this.parent = n, this.props = i, this.presenceContext = r, this.depth = n ? n.depth + 1 : 0, this.reducedMotionConfig = o, this.options = l, this.blockInitialAnimation = !!s, this.isControllingVariants = gs(i), this.isVariantNode = Fp(i), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(n && n.current);
    const { willChange: h, ...p } = this.scrapeMotionValuesFromProps(i, {}, this);
    for (const m in p) {
      const g = p[m];
      c[m] !== void 0 && Ie(g) && g.set(c[m], !1);
    }
  }
  mount(n) {
    this.current = n, Or.set(n, this), this.projection && !this.projection.instance && this.projection.mount(n), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, r) => this.bindToMotionValue(r, i)), kc.current || fg(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Wo.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount(), tn(this.notifyUpdate), tn(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const i = this.features[n];
      i && (i.unmount(), i.isMounted = !1);
    }
    this.current = null;
  }
  bindToMotionValue(n, i) {
    this.valueSubscriptions.has(n) && this.valueSubscriptions.get(n)();
    const r = Wn.has(n);
    r && this.onBindTransform && this.onBindTransform();
    const o = i.on("change", (l) => {
      this.latestValues[n] = l, this.props.onUpdate && fe.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0);
    }), s = i.on("renderRequest", this.scheduleRender);
    let a;
    window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, n, i)), this.valueSubscriptions.set(n, () => {
      o(), s(), a && a(), i.owner && i.stop();
    });
  }
  sortNodePosition(n) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== n.type ? 0 : this.sortInstanceNodePosition(this.current, n.current);
  }
  updateFeatures() {
    let n = "animation";
    for (n in Si) {
      const i = Si[n];
      if (!i)
        continue;
      const { isEnabled: r, Feature: o } = i;
      if (!this.features[n] && o && r(this.props) && (this.features[n] = new o(this)), this.features[n]) {
        const s = this.features[n];
        s.isMounted ? s.update() : (s.mount(), s.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : Se();
  }
  getStaticValue(n) {
    return this.latestValues[n];
  }
  setStaticValue(n, i) {
    this.latestValues[n] = i;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(n, i) {
    (n.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = n, this.prevPresenceContext = this.presenceContext, this.presenceContext = i;
    for (let r = 0; r < ah.length; r++) {
      const o = ah[r];
      this.propEventSubscriptions[o] && (this.propEventSubscriptions[o](), delete this.propEventSubscriptions[o]);
      const s = "on" + o, a = n[s];
      a && (this.propEventSubscriptions[o] = this.on(o, a));
    }
    this.prevMotionValues = wk(this, this.scrapeMotionValuesFromProps(n, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue(), this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(n) {
    return this.props.variants ? this.props.variants[n] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(n) {
    const i = this.getClosestVariantNode();
    if (i)
      return i.variantChildren && i.variantChildren.add(n), () => i.variantChildren.delete(n);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(n, i) {
    const r = this.values.get(n);
    i !== r && (r && this.removeValue(n), this.bindToMotionValue(n, i), this.values.set(n, i), this.latestValues[n] = i.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(n) {
    this.values.delete(n);
    const i = this.valueSubscriptions.get(n);
    i && (i(), this.valueSubscriptions.delete(n)), delete this.latestValues[n], this.removeValueFromRenderState(n, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(n) {
    return this.values.has(n);
  }
  getValue(n, i) {
    if (this.props.values && this.props.values[n])
      return this.props.values[n];
    let r = this.values.get(n);
    return r === void 0 && i !== void 0 && (r = _i(i === null ? void 0 : i, { owner: this }), this.addValue(n, r)), r;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(n, i) {
    var r;
    let o = this.latestValues[n] !== void 0 || !this.current ? this.latestValues[n] : (r = this.getBaseTargetFromProps(this.props, n)) !== null && r !== void 0 ? r : this.readValueFromInstance(this.current, n, this.options);
    return o != null && (typeof o == "string" && (Im(o) || km(o)) ? o = parseFloat(o) : !vk(o) && nn.test(i) && (o = Tm(n, i)), this.setBaseTarget(n, Ie(o) ? o.get() : o)), Ie(o) ? o.get() : o;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(n, i) {
    this.baseTarget[n] = i;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(n) {
    var i;
    const { initial: r } = this.props;
    let o;
    if (typeof r == "string" || typeof r == "object") {
      const a = ic(this.props, r, (i = this.presenceContext) === null || i === void 0 ? void 0 : i.custom);
      a && (o = a[n]);
    }
    if (r && o !== void 0)
      return o;
    const s = this.getBaseTargetFromProps(this.props, n);
    return s !== void 0 && !Ie(s) ? s : this.initialValues[n] !== void 0 && o === void 0 ? void 0 : this.baseTarget[n];
  }
  on(n, i) {
    return this.events[n] || (this.events[n] = new uc()), this.events[n].add(i);
  }
  notify(n, ...i) {
    this.events[n] && this.events[n].notify(...i);
  }
}
class mg extends pg {
  constructor() {
    super(...arguments), this.KeyframeResolver = Lm;
  }
  sortInstanceNodePosition(n, i) {
    return n.compareDocumentPosition(i) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(n, i) {
    return n.style ? n.style[i] : void 0;
  }
  removeValueFromRenderState(n, { vars: i, style: r }) {
    delete i[n], delete r[n];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: n } = this.props;
    Ie(n) && (this.childSubscription = n.on("change", (i) => {
      this.current && (this.current.textContent = `${i}`);
    }));
  }
}
function xk(e) {
  return window.getComputedStyle(e);
}
class gg extends mg {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = Qp;
  }
  readValueFromInstance(n, i) {
    if (Wn.has(i)) {
      const r = mc(i);
      return r && r.default || 0;
    } else {
      const r = xk(n), o = (Xl(i) ? r.getPropertyValue(i) : r[i]) || 0;
      return typeof o == "string" ? o.trim() : o;
    }
  }
  measureInstanceViewportBox(n, { transformPagePoint: i }) {
    return eg(n, i);
  }
  build(n, i, r) {
    Jl(n, i, r.transformTemplate);
  }
  scrapeMotionValuesFromProps(n, i, r) {
    return rc(n, i, r);
  }
}
class yg extends mg {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = Se, this.updateDimensions = () => {
      this.current && !this.renderState.dimensions && Jp(this.current, this.renderState);
    };
  }
  getBaseTargetFromProps(n, i) {
    return n[i];
  }
  readValueFromInstance(n, i) {
    if (Wn.has(i)) {
      const r = mc(i);
      return r && r.default || 0;
    }
    return i = em.has(i) ? i : Ul(i), n.getAttribute(i);
  }
  scrapeMotionValuesFromProps(n, i, r) {
    return nm(n, i, r);
  }
  onBindTransform() {
    this.current && !this.renderState.dimensions && fe.postRender(this.updateDimensions);
  }
  build(n, i, r) {
    tc(n, i, this.isSVGTag, r.transformTemplate);
  }
  renderInstance(n, i, r, o) {
    tm(n, i, r, o);
  }
  mount(n) {
    this.isSVGTag = nc(n.tagName), super.mount(n);
  }
}
const bk = (e, n) => ec(e) ? new yg(n) : new gg(n, {
  allowProjection: e !== Sl
}), kk = {
  renderer: bk,
  ...Zb,
  ...mk
}, Sk = {
  ...kk,
  ...rk,
  ...gk
};
function lh(e) {
  const n = Oi(() => _i(e)), { isStatic: i } = oe(bi);
  if (i) {
    const [, r] = ge(e);
    ie(() => n.on("change", r), []);
  }
  return n;
}
function _k() {
  !kc.current && fg();
  const [e] = ge(Wo.current);
  return e;
}
const Ck = (e, n, i) => {
  const r = n - e;
  return ((i - e) % r + r) % r + e;
};
function vg(e, n) {
  return jm(e) ? e[Ck(0, e.length, n)] : e;
}
function Sc(e) {
  return typeof e == "object" && !Array.isArray(e);
}
function wg(e, n, i, r) {
  return typeof e == "string" && Sc(n) ? lm(e, i, r) : e instanceof NodeList ? Array.from(e) : Array.isArray(e) ? e : [e];
}
function Ek(e, n, i) {
  return e * (n + 1);
}
function ch(e, n, i, r) {
  var o;
  return typeof n == "number" ? n : n.startsWith("-") || n.startsWith("+") ? Math.max(0, e + parseFloat(n)) : n === "<" ? i : (o = r.get(n)) !== null && o !== void 0 ? o : e;
}
function Pk(e, n, i) {
  for (let r = 0; r < e.length; r++) {
    const o = e[r];
    o.at > n && o.at < i && (vs(e, o), r--);
  }
}
function Tk(e, n, i, r, o, s) {
  Pk(e, o, s);
  for (let a = 0; a < n.length; a++)
    e.push({
      value: n[a],
      at: we(o, s, r[a]),
      easing: vg(i, a)
    });
}
function Mk(e, n) {
  for (let i = 0; i < e.length; i++)
    e[i] = e[i] / (n + 1);
}
function Ak(e, n) {
  return e.at === n.at ? e.value === null ? 1 : n.value === null ? -1 : 0 : e.at - n.at;
}
const Ik = "easeInOut";
function Dk(e, { defaultTransition: n = {}, ...i } = {}, r, o) {
  const s = n.duration || 0.3, a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = {}, u = /* @__PURE__ */ new Map();
  let f = 0, h = 0, p = 0;
  for (let m = 0; m < e.length; m++) {
    const g = e[m];
    if (typeof g == "string") {
      u.set(g, h);
      continue;
    } else if (!Array.isArray(g)) {
      u.set(g.name, ch(h, g.at, f, u));
      continue;
    }
    let [y, v, w = {}] = g;
    w.at !== void 0 && (h = ch(h, w.at, f, u));
    let x = 0;
    const k = (_, S, P, C = 0, T = 0) => {
      const M = Nk(_), { delay: D = 0, times: L = Wm(M), type: z = "keyframes", repeat: Q, repeatType: ee, repeatDelay: Z = 0, ...ae } = S;
      let { ease: G = n.ease || "easeOut", duration: te } = S;
      const $e = typeof D == "function" ? D(C, T) : D, Me = M.length, We = ys(z) ? z : o?.[z];
      if (Me <= 2 && We) {
        let R = 100;
        if (Me === 2 && $k(M)) {
          const W = M[1] - M[0];
          R = Math.abs(W);
        }
        const O = { ...ae };
        te !== void 0 && (O.duration = /* @__PURE__ */ Tt(te));
        const V = sx(O, R, We);
        G = V.ease, te = V.duration;
      }
      te ?? (te = s);
      const Ae = h + $e;
      L.length === 1 && L[0] === 0 && (L[1] = 1);
      const E = L.length - M.length;
      if (E > 0 && Fm(L, E), M.length === 1 && M.unshift(null), Q) {
        te = Ek(te, Q);
        const R = [...M], O = [...L];
        G = Array.isArray(G) ? [...G] : [G];
        const V = [...G];
        for (let W = 0; W < Q; W++) {
          M.push(...R);
          for (let ne = 0; ne < R.length; ne++)
            L.push(O[ne] + (W + 1)), G.push(ne === 0 ? "linear" : vg(V, ne - 1));
        }
        Mk(L, Q);
      }
      const N = Ae + te;
      Tk(P, M, G, L, Ae, N), x = Math.max($e + te, x), p = Math.max(N, p);
    };
    if (Ie(y)) {
      const _ = uh(y, l);
      k(v, w, dh("default", _));
    } else {
      const _ = wg(y, v, r, c), S = _.length;
      for (let P = 0; P < S; P++) {
        v = v, w = w;
        const C = _[P], T = uh(C, l);
        for (const M in v)
          k(v[M], Rk(w, M), dh(M, T), P, S);
      }
    }
    f = h, h += x;
  }
  return l.forEach((m, g) => {
    for (const y in m) {
      const v = m[y];
      v.sort(Ak);
      const w = [], x = [], k = [];
      for (let S = 0; S < v.length; S++) {
        const { at: P, value: C, easing: T } = v[S];
        w.push(C), x.push(/* @__PURE__ */ In(0, p, P)), k.push(T || "easeOut");
      }
      x[0] !== 0 && (x.unshift(0), w.unshift(w[0]), k.unshift(Ik)), x[x.length - 1] !== 1 && (x.push(1), w.push(null)), a.has(g) || a.set(g, {
        keyframes: {},
        transition: {}
      });
      const _ = a.get(g);
      _.keyframes[y] = w, _.transition[y] = {
        ...n,
        duration: p,
        ease: k,
        times: x,
        ...i
      };
    }
  }), a;
}
function uh(e, n) {
  return !n.has(e) && n.set(e, {}), n.get(e);
}
function dh(e, n) {
  return n[e] || (n[e] = []), n[e];
}
function Nk(e) {
  return Array.isArray(e) ? e : [e];
}
function Rk(e, n) {
  return e && e[n] ? {
    ...e,
    ...e[n]
  } : { ...e };
}
const Lk = (e) => typeof e == "number", $k = (e) => e.every(Lk);
function zk(e, n) {
  return e in n;
}
class Ok extends pg {
  constructor() {
    super(...arguments), this.type = "object";
  }
  readValueFromInstance(n, i) {
    if (zk(i, n)) {
      const r = n[i];
      if (typeof r == "string" || typeof r == "number")
        return r;
    }
  }
  getBaseTargetFromProps() {
  }
  removeValueFromRenderState(n, i) {
    delete i.output[n];
  }
  measureInstanceViewportBox() {
    return Se();
  }
  build(n, i) {
    Object.assign(n.output, i);
  }
  renderInstance(n, { output: i }) {
    Object.assign(n, i);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function Vk(e) {
  const n = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  }, i = rg(e) ? new yg(n) : new gg(n);
  i.mount(e), Or.set(e, i);
}
function Bk(e) {
  const n = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  }, i = new Ok(n);
  i.mount(e), Or.set(e, i);
}
function jk(e, n) {
  return Ie(e) || typeof e == "number" || typeof e == "string" && !Sc(n);
}
function xg(e, n, i, r) {
  const o = [];
  if (jk(e, n))
    o.push(ig(e, Sc(n) && n.default || n, i && (i.default || i)));
  else {
    const s = wg(e, n, r), a = s.length;
    for (let l = 0; l < a; l++) {
      const c = s[l], u = c instanceof Element ? Vk : Bk;
      Or.has(c) || u(c);
      const f = Or.get(c), h = { ...i };
      "delay" in h && typeof h.delay == "function" && (h.delay = h.delay(l, a)), o.push(...bc(f, { ...n, transition: h }, {}));
    }
  }
  return o;
}
function Fk(e, n, i) {
  const r = [];
  return Dk(e, n, i, { spring: vc }).forEach(({ keyframes: s, transition: a }, l) => {
    r.push(...xg(l, s, a));
  }), r;
}
function Wk(e) {
  return Array.isArray(e) && e.some(Array.isArray);
}
function Hk(e) {
  function n(i, r, o) {
    let s = [];
    return Wk(i) ? s = Fk(i, r, e) : s = xg(i, r, o, e), new im(s);
  }
  return n;
}
const qk = Hk();
class Gk {
  constructor() {
    this.componentControls = /* @__PURE__ */ new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(n) {
    return this.componentControls.add(n), () => this.componentControls.delete(n);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(n, i) {
    this.componentControls.forEach((r) => {
      r.start(n.nativeEvent || n, i);
    });
  }
}
const Uk = () => new Gk();
function Yk() {
  return Oi(Uk);
}
const Xk = ({ children: e }) => {
  const n = dp()?.();
  return /* @__PURE__ */ d(pw, { features: Sk, strict: !0, children: /* @__PURE__ */ d(yw, { ...n && { nonce: n }, children: e }) });
};
var xs = { done: !1, hasNext: !1 };
function ve(e, ...n) {
  let i = e, r = n.map((s) => "lazy" in s ? Kk(s) : void 0), o = 0;
  for (; o < n.length; ) {
    if (r[o] === void 0 || !Zk(i)) {
      let c = n[o];
      i = c(i), o += 1;
      continue;
    }
    let s = [];
    for (let c = o; c < n.length; c++) {
      let u = r[c];
      if (u === void 0 || (s.push(u), u.isSingle)) break;
    }
    let a = [];
    for (let c of i) if (bg(c, a, s)) break;
    let { isSingle: l } = s.at(-1);
    i = l ? a[0] : a, o += s.length;
  }
  return i;
}
function bg(e, n, i) {
  if (i.length === 0) return n.push(e), !1;
  let r = e, o = xs, s = !1;
  for (let [a, l] of i.entries()) {
    let { index: c, items: u } = l;
    if (u.push(r), o = l(r, c, u), l.index += 1, o.hasNext) {
      if (o.hasMany ?? !1) {
        for (let f of o.next) if (bg(f, n, i.slice(a + 1))) return !0;
        return s;
      }
      r = o.next;
    }
    if (!o.hasNext) break;
    o.done && (s = !0);
  }
  return o.hasNext && n.push(r), s;
}
function Kk(e) {
  let { lazy: n, lazyArgs: i } = e, r = n(...i);
  return Object.assign(r, { isSingle: n.single ?? !1, index: 0, items: [] });
}
function Zk(e) {
  return typeof e == "string" || typeof e == "object" && e !== null && Symbol.iterator in e;
}
function Jk(e, n) {
  let i = n.length - e.length;
  if (i === 1) {
    let [r, ...o] = n;
    return ve(r, { lazy: e, lazyArgs: o });
  }
  if (i === 0) {
    let r = { lazy: e, lazyArgs: n };
    return Object.assign((o) => ve(o, r), r);
  }
  throw new Error("Wrong number of arguments");
}
function Qk(e, n, i) {
  let r = (o) => e(o, ...n);
  return i === void 0 ? r : Object.assign(r, { lazy: i, lazyArgs: n });
}
function ue(e, n, i) {
  let r = e.length - n.length;
  if (r === 0) return e(...n);
  if (r === 1) return Qk(e, n, i);
  throw new Error("Wrong number of arguments");
}
function eS(...e) {
  return ue(Object.values, e);
}
function hh(...e) {
  return Jk(tS, e);
}
function tS() {
  let e = /* @__PURE__ */ new Set();
  return (n) => e.has(n) ? xs : (e.add(n), { done: !1, hasNext: !0, next: n });
}
function ut(...e) {
  return ue(nS, e);
}
var nS = (e, n) => e.length >= n, kg = { asc: (e, n) => e > n, desc: (e, n) => e < n };
function iS(e, n) {
  let [i, ...r] = n;
  if (!rS(i)) {
    let s = Ka(...r);
    return e(i, s);
  }
  let o = Ka(i, ...r);
  return (s) => e(s, o);
}
function Ka(e, n, ...i) {
  let r = typeof e == "function" ? e : e[0], o = typeof e == "function" ? "asc" : e[1], { [o]: s } = kg, a = n === void 0 ? void 0 : Ka(n, ...i);
  return (l, c) => {
    let u = r(l), f = r(c);
    return s(u, f) ? 1 : s(f, u) ? -1 : a?.(l, c) ?? 0;
  };
}
function rS(e) {
  if (fh(e)) return !0;
  if (typeof e != "object" || !Array.isArray(e)) return !1;
  let [n, i, ...r] = e;
  return fh(n) && typeof i == "string" && i in kg && r.length === 0;
}
var fh = (e) => typeof e == "function" && e.length === 1;
function oS(...e) {
  return ue(sS, e);
}
function sS(e, n) {
  let i = [];
  for (let [r, o] of e.entries()) {
    if (!n(o, r, e)) break;
    i.push(o);
  }
  return i;
}
function Sg(...e) {
  return ue(aS, e);
}
function aS(e, n) {
  return n(e), e;
}
function lS(...e) {
  return ue(cS, e);
}
function cS(e, n) {
  let i = [...e];
  return i.sort(n), i;
}
function Ho(...e) {
  return iS(uS, e);
}
var uS = (e, n) => [...e].sort(n);
function Ei(...e) {
  return ue(dS, e);
}
var dS = (e, n, i) => e.reduce(n, i);
function _g(...e) {
  return ue(hS, e);
}
function hS(e) {
  return [...e].reverse();
}
function fS(e) {
  return (n, i) => {
    if (i === 0) return e(n);
    if (!Number.isInteger(i)) throw new TypeError(`precision must be an integer: ${i.toString()}`);
    if (i > 15 || i < -15) throw new RangeError("precision must be between -15 and 15");
    if (Number.isNaN(n) || !Number.isFinite(n)) return e(n);
    if (i > 0) {
      let o = 10 ** i;
      return e(n * o) / o;
    }
    let r = 10 ** -i;
    return e(n / r) * r;
  };
}
function et(...e) {
  return ue(pS, e);
}
var pS = (e, n) => e[n];
function _c(...e) {
  return ue(mS, e);
}
var mS = (e, n) => {
  let i = [[], []];
  for (let [r, o] of e.entries()) n(o, r, e) ? i[0].push(o) : i[1].push(o);
  return i;
};
function Cc(...e) {
  return ue(gS, e);
}
function gS(e, n) {
  let i = {};
  for (let r of n) r in e && (i[r] = e[r]);
  return i;
}
function bs(...e) {
  return ue(yS, e);
}
function yS(e, n) {
  if (!ut(n, 1)) return { ...e };
  if (!ut(n, 2)) {
    let { [n[0]]: r, ...o } = e;
    return o;
  }
  let i = { ...e };
  for (let r of n) delete i[r];
  return i;
}
function Vr(...e) {
  return ue(vS, e);
}
var vS = (e) => e.length === 1 ? e[0] : void 0;
function ph(e) {
  if (typeof e != "object" || e === null) return !1;
  let n = Object.getPrototypeOf(e);
  return n === null || n === Object.prototype;
}
function Cg(...e) {
  return ue(Eg, e);
}
function Eg(e, n) {
  let i = { ...e, ...n };
  for (let r in n) {
    if (!(r in e)) continue;
    let { [r]: o } = e;
    if (!ph(o)) continue;
    let { [r]: s } = n;
    ph(s) && (i[r] = Eg(o, s));
  }
  return i;
}
function rn(e) {
  return !!e;
}
function Ec(...e) {
  return ue(Object.keys, e);
}
function yn(...e) {
  return ue(wS, e);
}
var wS = (e) => e.at(-1);
function Ce(...e) {
  return ue(xS, e, bS);
}
var xS = (e, n) => e.map(n), bS = (e) => (n, i, r) => ({ done: !1, hasNext: !0, next: e(n, i, r) });
function to(...e) {
  return ue(kS, e);
}
function kS(e, n) {
  let i = {};
  for (let [r, o] of e.entries()) {
    let [s, a] = n(o, r, e);
    i[s] = a;
  }
  return i;
}
function Pc(e) {
  return typeof e == "number" && !Number.isNaN(e);
}
function Tc(e) {
  return typeof e == "string";
}
function Mc(e) {
  return e === void 0 ? !0 : typeof e == "string" || Array.isArray(e) ? e.length === 0 : Object.keys(e).length === 0;
}
function SS(e) {
  return typeof e == "function";
}
function Pg(e) {
  return e !== null;
}
function qo(e) {
  return e != null;
}
function Ac(e) {
  return e == null;
}
function mh(e) {
  return Array.isArray(e);
}
function Ic(e) {
  return e !== void 0;
}
function Tg(...e) {
  return ue(_S, e);
}
var _S = (e, n) => {
  let i = {};
  for (let [r, o] of e.entries()) {
    let s = n(o, r, e);
    if (s !== void 0) {
      let { [s]: a } = i;
      a === void 0 && (a = [], i[s] = a), a.push(o);
    }
  }
  return i;
};
function CS(...e) {
  return ue(no, e);
}
function no(e, n) {
  if (e === n || Object.is(e, n)) return !0;
  if (typeof e != "object" || typeof n != "object" || e === null || n === null || Object.getPrototypeOf(e) !== Object.getPrototypeOf(n)) return !1;
  if (Array.isArray(e)) return ES(e, n);
  if (e instanceof Map) return PS(e, n);
  if (e instanceof Set) return TS(e, n);
  if (e instanceof Date) return e.getTime() === n.getTime();
  if (e instanceof RegExp) return e.toString() === n.toString();
  if (Object.keys(e).length !== Object.keys(n).length) return !1;
  for (let [i, r] of Object.entries(e)) if (!(i in n) || !no(r, n[i])) return !1;
  return !0;
}
function ES(e, n) {
  if (e.length !== n.length) return !1;
  for (let [i, r] of e.entries()) if (!no(r, n[i])) return !1;
  return !0;
}
function PS(e, n) {
  if (e.size !== n.size) return !1;
  for (let [i, r] of e.entries()) if (!n.has(i) || !no(r, n.get(i))) return !1;
  return !0;
}
function TS(e, n) {
  if (e.size !== n.size) return !1;
  let i = [...n];
  for (let r of e) {
    let o = !1;
    for (let [s, a] of i.entries()) if (no(r, a)) {
      o = !0, i.splice(s, 1);
      break;
    }
    if (!o) return !1;
  }
  return !0;
}
function MS(...e) {
  return ue(AS, e);
}
function AS(e, n) {
  for (let [i, r] of Object.entries(n)) if (!Object.hasOwn(e, i) || !CS(r, e[i])) return !1;
  return !0;
}
function IS(...e) {
  return ue(DS, e);
}
function DS(e, n) {
  let i = {};
  for (let [r, o] of e.entries()) {
    let s = n(o, r, e);
    i[s] = o;
  }
  return i;
}
function NS(...e) {
  return ue(RS, e, LS);
}
function RS(e, n) {
  return e.forEach(n), e;
}
var LS = (e) => (n, i, r) => (e(n, i, r), { done: !1, hasNext: !0, next: n });
function Mg(...e) {
  return ue($S, e);
}
function $S(e, n) {
  for (let [i, r] of Object.entries(e)) n(r, i, e);
  return e;
}
function Za(...e) {
  return ue(Object.entries, e);
}
function Gt(...e) {
  return ue(zS, e, OS);
}
var zS = (e, n) => e.filter(n), OS = (e) => (n, i, r) => e(n, i, r) ? { done: !1, hasNext: !0, next: n } : xs, Ag = (e) => Object.assign(e, { single: !0 });
function Dc(...e) {
  return ue(VS, e, Ag(BS));
}
var VS = (e, n) => e.find(n), BS = (e) => (n, i, r) => e(n, i, r) ? { done: !0, hasNext: !0, next: n } : xs;
function on(...e) {
  return ue(jS, e, Ag(FS));
}
var jS = ([e]) => e, FS = () => WS, WS = (e) => ({ hasNext: !0, next: e, done: !0 });
function Ig(...e) {
  return ue(HS, e);
}
var HS = (e, n) => [...e, ...n];
function qS(...e) {
  return ue(fS(Math.ceil), e);
}
function bn(...e) {
  return ue(GS, e);
}
var GS = (e, { min: n, max: i }) => n !== void 0 && e < n ? n : i !== void 0 && e > i ? i : e;
function Dn(e) {
  const n = J(e);
  return n.current = e, ce(() => Object.freeze({
    get current() {
      return n.current;
    }
  }), []);
}
function US(e) {
  const n = Dn(e);
  ie(
    () => () => {
      n.current();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
}
function ks(e, n, i, r = 0) {
  const o = J(), s = J(), a = J(e), l = J(), c = () => {
    o.current && (clearTimeout(o.current), o.current = void 0), s.current && (clearTimeout(s.current), s.current = void 0);
  };
  return US(c), ie(() => {
    a.current = e;
  }, n), ce(() => {
    const u = () => {
      if (c(), !l.current)
        return;
      const h = l.current;
      l.current = void 0, a.current.apply(h.this, h.args);
    }, f = function(...h) {
      o.current && clearTimeout(o.current), l.current = { args: h, this: this }, o.current = setTimeout(u, i), r > 0 && !s.current && (s.current = setTimeout(u, r));
    };
    return Object.defineProperties(f, {
      length: { value: e.length },
      name: { value: `${e.name || "anonymous"}__debounced__${i}` }
    }), f;
  }, [i, r, ...n]);
}
const YS = () => {
}, Dg = typeof globalThis < "u" && typeof navigator < "u" && typeof document < "u", XS = (e, n) => e === n, KS = (e, n) => {
  if (e === n)
    return !0;
  if (e.length !== n.length)
    return !1;
  for (const [i, r] of e.entries())
    if (r !== n[i])
      return !1;
  return !0;
};
function Ng(e, n, i = KS, r = ie, ...o) {
  const s = J();
  (s.current === void 0 || Dg && !i(s.current, n)) && (s.current = n), r(e, s.current, ...o);
}
function Nc(e, n, i, r = 0) {
  ie(ks(e, n, i, r), n);
}
const { valueOf: ZS, toString: JS } = Object.prototype, Io = (e, n) => {
  if (e === n)
    return !0;
  if (typeof e == "object" && typeof n == "object" && e && n) {
    if (e.constructor !== n.constructor)
      return !1;
    if (Array.isArray(e)) {
      const { length: o } = e;
      if (o !== n.length)
        return !1;
      for (let s = o; s-- !== 0; )
        if (!Io(e[s], n[s]))
          return !1;
      return !0;
    }
    if (e instanceof RegExp)
      return e.source === n.source && e.flags === n.flags;
    if (e instanceof Date)
      return e.getTime() === n.getTime();
    if (e instanceof Map && n instanceof Map) {
      if (e.size !== n.size)
        return !1;
      for (const o of e)
        if (!n.has(o[0]) || !Io(o[1], n.get(o[0])))
          return !1;
      return !0;
    }
    if (e instanceof Set && n instanceof Set) {
      if (e.size !== n.size)
        return !1;
      for (const o of e)
        if (!n.has(o))
          return !1;
      return !0;
    }
    if (e instanceof DataView && n instanceof DataView) {
      const { byteLength: o } = e;
      if (o !== n.byteLength)
        return !1;
      for (let s = o; s-- !== 0; )
        if (e.getUint8(s) !== n.getUint8(s))
          return !1;
      return !0;
    }
    if (e instanceof ArrayBuffer && n instanceof ArrayBuffer && (e = new Uint8Array(e), n = new Uint8Array(n)), ArrayBuffer.isView(e) && ArrayBuffer.isView(n)) {
      const { length: o } = e;
      if (o !== n.length)
        return !1;
      for (let s = o; s-- !== 0; )
        if (e[s] !== n[s])
          return !1;
      return !0;
    }
    if (e.valueOf !== ZS && typeof e.valueOf == "function" && typeof n.valueOf == "function")
      return e.valueOf() === n.valueOf();
    if (e.toString !== JS && typeof e.toString == "function" && typeof n.toString == "function")
      return e.toString() === n.toString();
    const i = Object.keys(e);
    let r;
    for (let o = i.length; o-- !== 0; )
      if (r = i[o], !((r === "_owner" || r === "__v" || r === "__o") && Object.hasOwn(e, "$$typeof")) && (!Object.hasOwn(n, r) || !Io(e[r], n[r])))
        return !1;
    return Object.keys(n).length === i.length;
  }
  return e !== e && n !== n;
};
function Rg() {
  const e = J(!0);
  return ie(() => {
    e.current = !1;
  }, []), e.current;
}
const QS = Dg ? as : ie;
function Lg(e, n) {
  const i = Rg();
  ie(i ? YS : e, n);
}
const e_ = (e) => {
  e && clearTimeout(e);
};
function Ja(e, n) {
  const i = Dn(e), r = Dn(n), o = J(null), s = dt(() => {
    e_(o.current);
  }, []), a = dt(() => {
    r.current !== void 0 && (s(), o.current = setTimeout(() => {
      i.current();
    }, r.current));
  }, []);
  return ie(() => (a(), s), [n]), [s, a];
}
const t_ = (e, n, i) => {
  const r = J();
  return (r.current === void 0 || !i(r.current, n)) && (r.current = n), ce(e, r.current);
};
function n_(e, n) {
  return t_(e, n, Io);
}
function i_(e, n = XS) {
  const [i, r] = ge(), o = J(e);
  return Lg(() => {
    n(o.current, e) || (r(o.current), o.current = e);
  }, [e]), i;
}
function $g(e, n) {
  const [i, r] = ge({
    status: "not-executed",
    error: void 0,
    result: n
  }), o = J(), s = J(), a = Dn({
    execute(...l) {
      s.current = l;
      const c = e(...l);
      return o.current = c, r((u) => ({ ...u, status: "loading" })), c.then(
        (u) => {
          c === o.current && r((f) => ({ ...f, status: "success", error: void 0, result: u }));
        },
        // eslint-disable-next-line @typescript-eslint/use-unknown-in-catch-callback-variable
        (u) => {
          c === o.current && r((f) => ({ ...f, status: "error", error: u }));
        }
      ), c;
    },
    reset() {
      r({
        status: "not-executed",
        error: void 0,
        result: n
      }), o.current = void 0, s.current = void 0;
    }
  });
  return [
    i,
    ce(
      () => ({
        reset() {
          a.current.reset();
        },
        execute: (...l) => a.current.execute(...l)
      }),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    ),
    { promise: o.current, lastArgs: s.current }
  ];
}
const Qa = [
  "onBurgerMenuClick",
  "onNavigateTo",
  "onOpenSource",
  "onCanvasClick",
  "onCanvasContextMenu",
  "onEdgeClick",
  "onEdgeContextMenu",
  "onNodeClick",
  "onNodeContextMenu",
  "onChange",
  "onCanvasDblClick"
], Rc = Le({
  ...to(Qa, (e) => [e, null]),
  handlersRef: {
    current: {}
  }
});
function r_({
  handlers: e,
  children: n
}) {
  const i = Dn(e), r = Qa.map((s) => SS(e[s])), o = ce(() => ({
    ...to(Qa, (s) => i.current[s] ? [s, (...a) => i.current[s]?.(...a)] : [s, null]),
    handlersRef: i
  }), [i, ...r]);
  return /* @__PURE__ */ d(Rc.Provider, { value: o, children: n });
}
function ji() {
  return oe(Rc);
}
function o_() {
  return oe(Rc).handlersRef;
}
var s_ = Object.getOwnPropertyNames, a_ = Object.getOwnPropertySymbols, l_ = Object.prototype.hasOwnProperty;
function gh(e, n) {
  return function(r, o, s) {
    return e(r, o, s) && n(r, o, s);
  };
}
function go(e) {
  return function(i, r, o) {
    if (!i || !r || typeof i != "object" || typeof r != "object")
      return e(i, r, o);
    var s = o.cache, a = s.get(i), l = s.get(r);
    if (a && l)
      return a === r && l === i;
    s.set(i, r), s.set(r, i);
    var c = e(i, r, o);
    return s.delete(i), s.delete(r), c;
  };
}
function yh(e) {
  return s_(e).concat(a_(e));
}
var c_ = Object.hasOwn || function(e, n) {
  return l_.call(e, n);
};
function Hn(e, n) {
  return e === n || !e && !n && e !== e && n !== n;
}
var u_ = "__v", d_ = "__o", h_ = "_owner", vh = Object.getOwnPropertyDescriptor, wh = Object.keys;
function f_(e, n, i) {
  var r = e.length;
  if (n.length !== r)
    return !1;
  for (; r-- > 0; )
    if (!i.equals(e[r], n[r], r, r, e, n, i))
      return !1;
  return !0;
}
function p_(e, n) {
  return Hn(e.getTime(), n.getTime());
}
function m_(e, n) {
  return e.name === n.name && e.message === n.message && e.cause === n.cause && e.stack === n.stack;
}
function g_(e, n) {
  return e === n;
}
function xh(e, n, i) {
  var r = e.size;
  if (r !== n.size)
    return !1;
  if (!r)
    return !0;
  for (var o = new Array(r), s = e.entries(), a, l, c = 0; (a = s.next()) && !a.done; ) {
    for (var u = n.entries(), f = !1, h = 0; (l = u.next()) && !l.done; ) {
      if (o[h]) {
        h++;
        continue;
      }
      var p = a.value, m = l.value;
      if (i.equals(p[0], m[0], c, h, e, n, i) && i.equals(p[1], m[1], p[0], m[0], e, n, i)) {
        f = o[h] = !0;
        break;
      }
      h++;
    }
    if (!f)
      return !1;
    c++;
  }
  return !0;
}
var y_ = Hn;
function v_(e, n, i) {
  var r = wh(e), o = r.length;
  if (wh(n).length !== o)
    return !1;
  for (; o-- > 0; )
    if (!zg(e, n, i, r[o]))
      return !1;
  return !0;
}
function Zi(e, n, i) {
  var r = yh(e), o = r.length;
  if (yh(n).length !== o)
    return !1;
  for (var s, a, l; o-- > 0; )
    if (s = r[o], !zg(e, n, i, s) || (a = vh(e, s), l = vh(n, s), (a || l) && (!a || !l || a.configurable !== l.configurable || a.enumerable !== l.enumerable || a.writable !== l.writable)))
      return !1;
  return !0;
}
function w_(e, n) {
  return Hn(e.valueOf(), n.valueOf());
}
function x_(e, n) {
  return e.source === n.source && e.flags === n.flags;
}
function bh(e, n, i) {
  var r = e.size;
  if (r !== n.size)
    return !1;
  if (!r)
    return !0;
  for (var o = new Array(r), s = e.values(), a, l; (a = s.next()) && !a.done; ) {
    for (var c = n.values(), u = !1, f = 0; (l = c.next()) && !l.done; ) {
      if (!o[f] && i.equals(a.value, l.value, a.value, l.value, e, n, i)) {
        u = o[f] = !0;
        break;
      }
      f++;
    }
    if (!u)
      return !1;
  }
  return !0;
}
function b_(e, n) {
  var i = e.length;
  if (n.length !== i)
    return !1;
  for (; i-- > 0; )
    if (e[i] !== n[i])
      return !1;
  return !0;
}
function k_(e, n) {
  return e.hostname === n.hostname && e.pathname === n.pathname && e.protocol === n.protocol && e.port === n.port && e.hash === n.hash && e.username === n.username && e.password === n.password;
}
function zg(e, n, i, r) {
  return (r === h_ || r === d_ || r === u_) && (e.$$typeof || n.$$typeof) ? !0 : c_(n, r) && i.equals(e[r], n[r], r, r, e, n, i);
}
var S_ = "[object Arguments]", __ = "[object Boolean]", C_ = "[object Date]", E_ = "[object Error]", P_ = "[object Map]", T_ = "[object Number]", M_ = "[object Object]", A_ = "[object RegExp]", I_ = "[object Set]", D_ = "[object String]", N_ = "[object URL]", R_ = Array.isArray, kh = typeof ArrayBuffer == "function" && ArrayBuffer.isView ? ArrayBuffer.isView : null, Sh = Object.assign, L_ = Object.prototype.toString.call.bind(Object.prototype.toString);
function $_(e) {
  var n = e.areArraysEqual, i = e.areDatesEqual, r = e.areErrorsEqual, o = e.areFunctionsEqual, s = e.areMapsEqual, a = e.areNumbersEqual, l = e.areObjectsEqual, c = e.arePrimitiveWrappersEqual, u = e.areRegExpsEqual, f = e.areSetsEqual, h = e.areTypedArraysEqual, p = e.areUrlsEqual;
  return function(g, y, v) {
    if (g === y)
      return !0;
    if (g == null || y == null)
      return !1;
    var w = typeof g;
    if (w !== typeof y)
      return !1;
    if (w !== "object")
      return w === "number" ? a(g, y, v) : w === "function" ? o(g, y, v) : !1;
    var x = g.constructor;
    if (x !== y.constructor)
      return !1;
    if (x === Object)
      return l(g, y, v);
    if (R_(g))
      return n(g, y, v);
    if (kh != null && kh(g))
      return h(g, y, v);
    if (x === Date)
      return i(g, y, v);
    if (x === RegExp)
      return u(g, y, v);
    if (x === Map)
      return s(g, y, v);
    if (x === Set)
      return f(g, y, v);
    var k = L_(g);
    return k === C_ ? i(g, y, v) : k === A_ ? u(g, y, v) : k === P_ ? s(g, y, v) : k === I_ ? f(g, y, v) : k === M_ ? typeof g.then != "function" && typeof y.then != "function" && l(g, y, v) : k === N_ ? p(g, y, v) : k === E_ ? r(g, y, v) : k === S_ ? l(g, y, v) : k === __ || k === T_ || k === D_ ? c(g, y, v) : !1;
  };
}
function z_(e) {
  var n = e.circular, i = e.createCustomConfig, r = e.strict, o = {
    areArraysEqual: r ? Zi : f_,
    areDatesEqual: p_,
    areErrorsEqual: m_,
    areFunctionsEqual: g_,
    areMapsEqual: r ? gh(xh, Zi) : xh,
    areNumbersEqual: y_,
    areObjectsEqual: r ? Zi : v_,
    arePrimitiveWrappersEqual: w_,
    areRegExpsEqual: x_,
    areSetsEqual: r ? gh(bh, Zi) : bh,
    areTypedArraysEqual: r ? Zi : b_,
    areUrlsEqual: k_
  };
  if (i && (o = Sh({}, o, i(o))), n) {
    var s = go(o.areArraysEqual), a = go(o.areMapsEqual), l = go(o.areObjectsEqual), c = go(o.areSetsEqual);
    o = Sh({}, o, {
      areArraysEqual: s,
      areMapsEqual: a,
      areObjectsEqual: l,
      areSetsEqual: c
    });
  }
  return o;
}
function O_(e) {
  return function(n, i, r, o, s, a, l) {
    return e(n, i, l);
  };
}
function V_(e) {
  var n = e.circular, i = e.comparator, r = e.createState, o = e.equals, s = e.strict;
  if (r)
    return function(c, u) {
      var f = r(), h = f.cache, p = h === void 0 ? n ? /* @__PURE__ */ new WeakMap() : void 0 : h, m = f.meta;
      return i(c, u, {
        cache: p,
        equals: o,
        meta: m,
        strict: s
      });
    };
  if (n)
    return function(c, u) {
      return i(c, u, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals: o,
        meta: void 0,
        strict: s
      });
    };
  var a = {
    cache: void 0,
    equals: o,
    meta: void 0,
    strict: s
  };
  return function(c, u) {
    return i(c, u, a);
  };
}
var Y = cn();
cn({ strict: !0 });
cn({ circular: !0 });
cn({
  circular: !0,
  strict: !0
});
var Ze = cn({
  createInternalComparator: function() {
    return Hn;
  }
});
cn({
  strict: !0,
  createInternalComparator: function() {
    return Hn;
  }
});
cn({
  circular: !0,
  createInternalComparator: function() {
    return Hn;
  }
});
cn({
  circular: !0,
  createInternalComparator: function() {
    return Hn;
  },
  strict: !0
});
function cn(e) {
  e === void 0 && (e = {});
  var n = e.circular, i = n === void 0 ? !1 : n, r = e.createInternalComparator, o = e.createState, s = e.strict, a = s === void 0 ? !1 : s, l = z_(e), c = $_(l), u = r ? r(c) : O_(c);
  return V_({ circular: i, comparator: c, createState: o, equals: u, strict: a });
}
const B_ = () => {
}, Og = (e, n) => {
  if (e === n)
    return !0;
  if (e.length !== n.length)
    return !1;
  for (const [i, r] of e.entries())
    if (!Ze(r, n[i]))
      return !1;
  return !0;
};
function Nn(e, n, i, r) {
  const o = Rg();
  Ng(
    o ? B_ : e,
    n,
    Og,
    r
  );
}
const j_ = [
  "Controls",
  "ReadOnly",
  "FocusMode",
  "NavigateTo",
  "ElementDetails",
  "RelationshipDetails",
  "RelationshipBrowser",
  "Search",
  "NavigationButtons",
  "Notations",
  "DynamicViewWalkthrough",
  "EdgeEditing",
  "ViewTitle",
  "FitView",
  /**
   * LikeC4Model is available in context
   */
  "LikeC4Model",
  /**
   * Running in VSCode
   */
  "Vscode"
], Vg = to(
  j_,
  (e) => [`enable${e}`, !1]
), Go = Le(Vg), F_ = (e) => {
  let {
    enableReadOnly: n,
    enableLikeC4Model: i,
    enableElementDetails: r,
    enableRelationshipDetails: o,
    enableRelationshipBrowser: s,
    enableSearch: a,
    enableEdgeEditing: l,
    ...c
  } = e;
  return i || (r = !1, o = !1, s = !1, a = !1), n && (l = !1), {
    enableReadOnly: n,
    enableLikeC4Model: i,
    enableElementDetails: r,
    enableRelationshipDetails: o,
    enableRelationshipBrowser: s,
    enableSearch: a,
    enableEdgeEditing: l,
    ...c
  };
};
function Pi({
  children: e,
  features: n,
  overrides: i
}) {
  const r = oe(Go), [o, s] = ge(r);
  return Ng(
    () => {
      s(F_({
        ...r,
        ...n,
        ...i
      }));
    },
    [r, n, i],
    Og
  ), /* @__PURE__ */ d(Go.Provider, { value: o, children: e });
}
Pi.Overlays = ({ children: e }) => /* @__PURE__ */ d(
  Pi,
  {
    overrides: {
      enableControls: !1,
      enableReadOnly: !0,
      enableEdgeEditing: !1
    },
    children: e
  }
);
function Fe(...e) {
  return Cc(oe(Go), Ce(e, (n) => `enable${n}`));
}
function Lc() {
  return oe(Go);
}
function $c({
  feature: e,
  children: n,
  and: i = !0
}) {
  return Fe(e)[`enable${e}`] === !0 && i ? /* @__PURE__ */ d(H, { children: n }) : null;
}
function yo({
  feature: e,
  children: n
}) {
  return Fe(e)[`enable${e}`] !== !0 ? /* @__PURE__ */ d(H, { children: n }) : null;
}
function Bg({ children: e }) {
  if (!oe(Dv))
    throw new Error("LikeC4Diagram must be a child of MantineProvider");
  return /* @__PURE__ */ d(H, { children: e });
}
Bg.displayName = "EnsureMantine";
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var W_ = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
const B = (e, n, i, r) => {
  const o = an(
    ({ color: s = "currentColor", size: a = 24, stroke: l = 2, title: c, className: u, children: f, ...h }, p) => pi(
      "svg",
      {
        ref: p,
        ...W_[e],
        width: a,
        height: a,
        className: ["tabler-icon", `tabler-icon-${n}`, u].join(" "),
        ...e === "filled" ? {
          fill: s
        } : {
          strokeWidth: l,
          stroke: s
        },
        ...h
      },
      [
        c && pi("title", { key: "svg-title" }, c),
        ...r.map(([m, g]) => pi(m, g)),
        ...Array.isArray(f) ? f : [f]
      ]
    )
  );
  return o.displayName = `${i}`, o;
};
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var zc = B("outline", "alert-triangle", "IconAlertTriangle", [["path", { d: "M12 9v4", key: "svg-0" }], ["path", { d: "M10.363 3.591l-8.106 13.534a1.914 1.914 0 0 0 1.636 2.871h16.214a1.914 1.914 0 0 0 1.636 -2.87l-8.106 -13.536a1.914 1.914 0 0 0 -3.274 0z", key: "svg-1" }], ["path", { d: "M12 16h.01", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var H_ = B("outline", "arrow-down-right", "IconArrowDownRight", [["path", { d: "M7 7l10 10", key: "svg-0" }], ["path", { d: "M17 8l0 9l-9 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var q_ = B("outline", "arrow-left", "IconArrowLeft", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M5 12l6 6", key: "svg-1" }], ["path", { d: "M5 12l6 -6", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Br = B("outline", "arrow-right", "IconArrowRight", [["path", { d: "M5 12l14 0", key: "svg-0" }], ["path", { d: "M13 18l6 -6", key: "svg-1" }], ["path", { d: "M13 6l6 6", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var G_ = B("outline", "browser", "IconBrowser", [["path", { d: "M4 8h16", key: "svg-0" }], ["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-1" }], ["path", { d: "M8 4v4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Ss = B("outline", "check", "IconCheck", [["path", { d: "M5 12l5 5l10 -10", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var U_ = B("outline", "chevron-down", "IconChevronDown", [["path", { d: "M6 9l6 6l6 -6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Oc = B("outline", "chevron-left", "IconChevronLeft", [["path", { d: "M15 6l-6 6l6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var io = B("outline", "chevron-right", "IconChevronRight", [["path", { d: "M9 6l6 6l-6 6", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Vc = B("outline", "copy", "IconCopy", [["path", { d: "M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z", key: "svg-0" }], ["path", { d: "M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var _h = B("outline", "cylinder", "IconCylinder", [["path", { d: "M12 6m-7 0a7 3 0 1 0 14 0a7 3 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M5 6v12c0 1.657 3.134 3 7 3s7 -1.343 7 -3v-12", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Y_ = B("outline", "device-mobile", "IconDeviceMobile", [["path", { d: "M6 5a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v14a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2v-14z", key: "svg-0" }], ["path", { d: "M11 4h2", key: "svg-1" }], ["path", { d: "M12 17v.01", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Bc = B("outline", "external-link", "IconExternalLink", [["path", { d: "M12 6h-6a2 2 0 0 0 -2 2v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-6", key: "svg-0" }], ["path", { d: "M11 13l9 -9", key: "svg-1" }], ["path", { d: "M15 4h5v5", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var X_ = B("outline", "file-code", "IconFileCode", [["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-0" }], ["path", { d: "M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z", key: "svg-1" }], ["path", { d: "M10 13l-1 2l1 2", key: "svg-2" }], ["path", { d: "M14 13l1 2l-1 2", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var ro = B("outline", "file-symlink", "IconFileSymlink", [["path", { d: "M4 21v-4a3 3 0 0 1 3 -3h5", key: "svg-0" }], ["path", { d: "M9 17l3 -3l-3 -3", key: "svg-1" }], ["path", { d: "M14 3v4a1 1 0 0 0 1 1h4", key: "svg-2" }], ["path", { d: "M5 11v-6a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2h-9.5", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var K_ = B("outline", "focus-centered", "IconFocusCentered", [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-1" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-2" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-3" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Z_ = B("outline", "folder-open", "IconFolderOpen", [["path", { d: "M5 19l2.757 -7.351a1 1 0 0 1 .936 -.649h12.307a1 1 0 0 1 .986 1.164l-.996 5.211a2 2 0 0 1 -1.964 1.625h-14.026a2 2 0 0 1 -2 -2v-11a2 2 0 0 1 2 -2h4l3 3h7a2 2 0 0 1 2 2v2", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var J_ = B("outline", "help-circle", "IconHelpCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 16v.01", key: "svg-1" }], ["path", { d: "M12 13a2 2 0 0 0 .914 -3.782a1.98 1.98 0 0 0 -2.414 .483", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var jg = B("outline", "id", "IconId", [["path", { d: "M3 4m0 3a3 3 0 0 1 3 -3h12a3 3 0 0 1 3 3v10a3 3 0 0 1 -3 3h-12a3 3 0 0 1 -3 -3z", key: "svg-0" }], ["path", { d: "M9 10m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M15 8l2 0", key: "svg-2" }], ["path", { d: "M15 12l2 0", key: "svg-3" }], ["path", { d: "M7 16l10 0", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var _s = B("outline", "info-circle", "IconInfoCircle", [["path", { d: "M3 12a9 9 0 1 0 18 0a9 9 0 0 0 -18 0", key: "svg-0" }], ["path", { d: "M12 9h.01", key: "svg-1" }], ["path", { d: "M11 12h1v4h1", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Q_ = B("outline", "layout-align-bottom", "IconLayoutAlignBottom", [["path", { d: "M4 20l16 0", key: "svg-0" }], ["path", { d: "M9 4m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var eC = B("outline", "layout-align-center", "IconLayoutAlignCenter", [["path", { d: "M12 4l0 5", key: "svg-0" }], ["path", { d: "M12 15l0 5", key: "svg-1" }], ["path", { d: "M6 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var tC = B("outline", "layout-align-left", "IconLayoutAlignLeft", [["path", { d: "M4 4l0 16", key: "svg-0" }], ["path", { d: "M8 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var nC = B("outline", "layout-align-middle", "IconLayoutAlignMiddle", [["path", { d: "M4 12l5 0", key: "svg-0" }], ["path", { d: "M15 12l5 0", key: "svg-1" }], ["path", { d: "M9 6m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var iC = B("outline", "layout-align-right", "IconLayoutAlignRight", [["path", { d: "M20 4l0 16", key: "svg-0" }], ["path", { d: "M4 9m0 2a2 2 0 0 1 2 -2h8a2 2 0 0 1 2 2v2a2 2 0 0 1 -2 2h-8a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var rC = B("outline", "layout-align-top", "IconLayoutAlignTop", [["path", { d: "M4 4l16 0", key: "svg-0" }], ["path", { d: "M9 8m0 2a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v8a2 2 0 0 1 -2 2h-2a2 2 0 0 1 -2 -2z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Ch = B("outline", "layout-board-split", "IconLayoutBoardSplit", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M4 12h8", key: "svg-1" }], ["path", { d: "M12 15h8", key: "svg-2" }], ["path", { d: "M12 9h8", key: "svg-3" }], ["path", { d: "M12 4v16", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var oC = B("outline", "layout-collage", "IconLayoutCollage", [["path", { d: "M4 4m0 2a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v12a2 2 0 0 1 -2 2h-12a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M10 4l4 16", key: "svg-1" }], ["path", { d: "M12 12l-8 2", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Fg = B("outline", "layout-dashboard", "IconLayoutDashboard", [["path", { d: "M5 4h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-0" }], ["path", { d: "M5 16h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-1" }], ["path", { d: "M15 12h4a1 1 0 0 1 1 1v6a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1", key: "svg-2" }], ["path", { d: "M15 4h4a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1v-2a1 1 0 0 1 1 -1", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var sC = B("outline", "lock-open-2", "IconLockOpen2", [["path", { d: "M3 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2z", key: "svg-0" }], ["path", { d: "M9 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M13 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var aC = B("outline", "lock", "IconLock", [["path", { d: "M5 13a2 2 0 0 1 2 -2h10a2 2 0 0 1 2 2v6a2 2 0 0 1 -2 2h-10a2 2 0 0 1 -2 -2v-6z", key: "svg-0" }], ["path", { d: "M11 16a1 1 0 1 0 2 0a1 1 0 0 0 -2 0", key: "svg-1" }], ["path", { d: "M8 11v-4a4 4 0 1 1 8 0v4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var lC = B("outline", "menu-2", "IconMenu2", [["path", { d: "M4 6l16 0", key: "svg-0" }], ["path", { d: "M4 12l16 0", key: "svg-1" }], ["path", { d: "M4 18l16 0", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var cC = B("outline", "menu", "IconMenu", [["path", { d: "M4 8l16 0", key: "svg-0" }], ["path", { d: "M4 16l16 0", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var uC = B("outline", "moon-stars", "IconMoonStars", [["path", { d: "M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z", key: "svg-0" }], ["path", { d: "M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2", key: "svg-1" }], ["path", { d: "M19 11h2m-1 -1v2", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var dC = B("outline", "rectangular-prism", "IconRectangularPrism", [["path", { d: "M21 14.008v-5.018a1.98 1.98 0 0 0 -1 -1.717l-4 -2.008a2.016 2.016 0 0 0 -2 0l-10 5.008c-.619 .355 -1 1.01 -1 1.718v5.018c0 .709 .381 1.363 1 1.717l4 2.008a2.016 2.016 0 0 0 2 0l10 -5.008c.619 -.355 1 -1.01 1 -1.718z", key: "svg-0" }], ["path", { d: "M9 21v-7.5", key: "svg-1" }], ["path", { d: "M9 13.5l11.5 -5.5", key: "svg-2" }], ["path", { d: "M3.5 11l5.5 2.5", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var hC = B("outline", "reorder", "IconReorder", [["path", { d: "M3 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-0" }], ["path", { d: "M10 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-1" }], ["path", { d: "M17 15m0 1a1 1 0 0 1 1 -1h2a1 1 0 0 1 1 1v2a1 1 0 0 1 -1 1h-2a1 1 0 0 1 -1 -1z", key: "svg-2" }], ["path", { d: "M5 11v-3a3 3 0 0 1 3 -3h8a3 3 0 0 1 3 3v3", key: "svg-3" }], ["path", { d: "M16.5 8.5l2.5 2.5l2.5 -2.5", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var fC = B("outline", "route-off", "IconRouteOff", [["path", { d: "M6 19m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-0" }], ["path", { d: "M18 5m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0", key: "svg-1" }], ["path", { d: "M12 19h4.5c.71 0 1.372 -.212 1.924 -.576m1.545 -2.459a3.5 3.5 0 0 0 -3.469 -3.965h-.499m-4 0h-3.501a3.5 3.5 0 0 1 -2.477 -5.972m2.477 -1.028h3.5", key: "svg-2" }], ["path", { d: "M3 3l18 18", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Wg = B("outline", "search", "IconSearch", [["path", { d: "M10 10m-7 0a7 7 0 1 0 14 0a7 7 0 1 0 -14 0", key: "svg-0" }], ["path", { d: "M21 21l-6 -6", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var jc = B("outline", "selector", "IconSelector", [["path", { d: "M8 9l4 -4l4 4", key: "svg-0" }], ["path", { d: "M16 15l-4 4l-4 -4", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var pC = B("outline", "share", "IconShare", [["path", { d: "M6 12m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-0" }], ["path", { d: "M18 6m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-1" }], ["path", { d: "M18 18m-3 0a3 3 0 1 0 6 0a3 3 0 1 0 -6 0", key: "svg-2" }], ["path", { d: "M8.7 10.7l6.6 -3.4", key: "svg-3" }], ["path", { d: "M8.7 13.3l6.6 3.4", key: "svg-4" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Fc = B("outline", "stack-2", "IconStack2", [["path", { d: "M12 4l-8 4l8 4l8 -4l-8 -4", key: "svg-0" }], ["path", { d: "M4 12l8 4l8 -4", key: "svg-1" }], ["path", { d: "M4 16l8 4l8 -4", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var mC = B("outline", "sun", "IconSun", [["path", { d: "M12 12m-4 0a4 4 0 1 0 8 0a4 4 0 1 0 -8 0", key: "svg-0" }], ["path", { d: "M3 12h1m8 -9v1m8 8h1m-9 8v1m-6.4 -15.4l.7 .7m12.1 -.7l-.7 .7m0 11.4l.7 .7m-12.1 -.7l-.7 .7", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var gC = B("outline", "target", "IconTarget", [["path", { d: "M12 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0", key: "svg-0" }], ["path", { d: "M12 12m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0", key: "svg-1" }], ["path", { d: "M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0", key: "svg-2" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Cs = B("outline", "transform", "IconTransform", [["path", { d: "M3 6a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-0" }], ["path", { d: "M21 11v-3a2 2 0 0 0 -2 -2h-6l3 3m0 -6l-3 3", key: "svg-1" }], ["path", { d: "M3 13v3a2 2 0 0 0 2 2h6l-3 -3m0 6l3 -3", key: "svg-2" }], ["path", { d: "M15 18a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-3" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var yC = B("outline", "user", "IconUser", [["path", { d: "M8 7a4 4 0 1 0 8 0a4 4 0 0 0 -8 0", key: "svg-0" }], ["path", { d: "M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var oo = B("outline", "x", "IconX", [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var kt = B("outline", "zoom-scan", "IconZoomScan", [["path", { d: "M4 8v-2a2 2 0 0 1 2 -2h2", key: "svg-0" }], ["path", { d: "M4 16v2a2 2 0 0 0 2 2h2", key: "svg-1" }], ["path", { d: "M16 4h2a2 2 0 0 1 2 2v2", key: "svg-2" }], ["path", { d: "M16 20h2a2 2 0 0 0 2 -2v-2", key: "svg-3" }], ["path", { d: "M8 11a3 3 0 1 0 6 0a3 3 0 0 0 -6 0", key: "svg-4" }], ["path", { d: "M16 16l-2.5 -2.5", key: "svg-5" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var vC = B("filled", "folder-filled", "IconFolderFilled", [["path", { d: "M9 3a1 1 0 0 1 .608 .206l.1 .087l2.706 2.707h6.586a3 3 0 0 1 2.995 2.824l.005 .176v8a3 3 0 0 1 -2.824 2.995l-.176 .005h-14a3 3 0 0 1 -2.995 -2.824l-.005 -.176v-11a3 3 0 0 1 2.824 -2.995l.176 -.005h4z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var wC = B("filled", "player-play-filled", "IconPlayerPlayFilled", [["path", { d: "M6 4v16a1 1 0 0 0 1.524 .852l13 -8a1 1 0 0 0 0 -1.704l-13 -8a1 1 0 0 0 -1.524 .852z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var xC = B("filled", "player-skip-back-filled", "IconPlayerSkipBackFilled", [["path", { d: "M19.496 4.136l-12 7a1 1 0 0 0 0 1.728l12 7a1 1 0 0 0 1.504 -.864v-14a1 1 0 0 0 -1.504 -.864z", key: "svg-0" }], ["path", { d: "M4 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var bC = B("filled", "player-skip-forward-filled", "IconPlayerSkipForwardFilled", [["path", { d: "M3 5v14a1 1 0 0 0 1.504 .864l12 -7a1 1 0 0 0 0 -1.728l-12 -7a1 1 0 0 0 -1.504 .864z", key: "svg-0" }], ["path", { d: "M20 4a1 1 0 0 1 .993 .883l.007 .117v14a1 1 0 0 1 -1.993 .117l-.007 -.117v-14a1 1 0 0 1 1 -1z", key: "svg-1" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var kC = B("filled", "player-stop-filled", "IconPlayerStopFilled", [["path", { d: "M17 4h-10a3 3 0 0 0 -3 3v10a3 3 0 0 0 3 3h10a3 3 0 0 0 3 -3v-10a3 3 0 0 0 -3 -3z", key: "svg-0" }]]);
/**
 * @license @tabler/icons-react v3.29.0 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var Hg = B("filled", "star-filled", "IconStarFilled", [["path", { d: "M8.243 7.34l-6.38 .925l-.113 .023a1 1 0 0 0 -.44 1.684l4.622 4.499l-1.09 6.355l-.013 .11a1 1 0 0 0 1.464 .944l5.706 -3l5.693 3l.1 .046a1 1 0 0 0 1.352 -1.1l-1.091 -6.355l4.624 -4.5l.078 -.085a1 1 0 0 0 -.633 -1.62l-6.38 -.926l-2.852 -5.78a1 1 0 0 0 -1.794 0l-2.853 5.78z", key: "svg-0" }]]);
const qg = Le(null), SC = qg.Provider;
function Es({
  element: e,
  className: n
}) {
  const i = oe(qg);
  if (!e || !e.icon || e.icon === "none")
    return null;
  let r;
  return e.icon.startsWith("http://") || e.icon.startsWith("https://") ? r = /* @__PURE__ */ d("img", { src: e.icon, alt: e.title }) : i && (r = /* @__PURE__ */ d(i, { node: e })), r ? /* @__PURE__ */ d(
    "div",
    {
      className: j(
        n,
        "likec4-element-icon"
      ),
      "data-likec4-icon": e.icon,
      children: r
    }
  ) : null;
}
const _C = {
  browser: G_,
  cylinder: _h,
  mobile: Y_,
  person: yC,
  queue: hC,
  rectangle: dC,
  storage: _h
};
function CC({
  element: e,
  className: n
}) {
  const i = Es({
    element: e,
    className: n
  });
  if (i)
    return i;
  const r = _C[e.shape];
  return /* @__PURE__ */ d(
    "div",
    {
      className: j(
        n,
        "likec4-shape-icon"
      ),
      children: /* @__PURE__ */ d(r, {})
    }
  );
}
var EC = "likec4-diagram-root";
const Gg = Le(Ev());
function PC({
  className: e,
  children: n
}) {
  const i = J(null);
  return /* @__PURE__ */ d(A, { className: j(EC, e), ref: i, children: /* @__PURE__ */ d(Gg.Provider, { value: i, children: n }) });
}
function TC() {
  return oe(Gg).current;
}
var el = { safariAnimationHook: "var(--likec4-safari-animation-hook)", default: { font: "var(--likec4-default-font-family)" }, likec4: { font: "var(--likec4-font-family)", background: { color: "var(--likec4-background-color)", pattern: { color: "var(--likec4-background-pattern-color)" } } }, compound: { font: "var(--likec4-compound-font-family)", titleColor: "var(--likec4-compound-title-color)" }, element: { font: "var(--likec4-element-font-family)", fill: "var(--likec4-element-fill)", stroke: "var(--likec4-element-stroke)", hiContrast: "var(--likec4-element-hiContrast)", loContrast: "var(--likec4-element-loContrast)" }, relation: { lineColor: "var(--likec4-relation-lineColor)", labelColor: "var(--likec4-relation-labelColor)", labelBgColor: "var(--likec4-relation-labelBg)" }, optionsPanel: { top: "var(--likec4-options-webview-top)", right: "var(--likec4-options-webview-right)" }, navigationPanel: { top: "var(--likec4-navigation-webview-top)", left: "var(--likec4-navigation-webview-left)" } };
const MC = Nv({});
function AC(e, n) {
  const i = [
    ...Za(n.elements).map(([r, o]) => `${Eh(el.element[r])}: ${o};`),
    ...Za(n.relationships).map(([r, o]) => `${Eh(el.relation[r])}: ${o};`)
  ].join(`
`);
  return `:where([data-likec4-color=${e}]) {
  ${i}
}`;
}
function Eh(e) {
  const n = e.indexOf(",");
  return e.substring(4, n == -1 ? e.length - 1 : n);
}
const Ug = nt(({ customColors: e }) => {
  const n = Za(e).map(([r, o]) => AC(r, o)).join(`
`), i = dp()?.();
  return /* @__PURE__ */ d(H, { children: /* @__PURE__ */ d("style", { type: "text/css", dangerouslySetInnerHTML: { __html: n }, nonce: i }) });
}, Y);
Ug.displayName = "LikeC4CustomColors";
const Ht = {
  Compound: 2,
  Edge: 4,
  Element: 6,
  Max: 8
}, Rn = 0.1, IC = 2;
function DC(e) {
  const {
    view: n,
    nodesSelectable: i
  } = e;
  n.__;
  const r = [], o = [], s = /* @__PURE__ */ new Map(), a = Ip.from(n.nodes.reduce(
    (h, p) => (s.set(p.id, p), p.parent || h.push({ node: p, parent: null }), h),
    []
  ));
  let l = (h) => !0;
  if (e.where)
    try {
      const h = L1(e.where);
      l = (p) => h({
        ...Cc(p, ["tags", "kind"]),
        ..."source" in p ? { source: u(p.source) } : p,
        ..."target" in p ? { target: u(p.target) } : p
      });
    } catch (h) {
      console.error("Error in where filter:", h);
    }
  const c = "", u = (h) => xe(s.get(h), `Node not found: ${h}`);
  let f;
  for (; f = a.dequeue(); ) {
    const { node: h, parent: p } = f, m = ut(h.children, 1) || h.kind == cr.Group;
    if (m)
      for (const P of h.children)
        a.enqueue({ node: u(P), parent: h });
    const g = {
      x: h.position[0],
      y: h.position[1]
    };
    p && (g.x -= p.position[0], g.y -= p.position[1]);
    const v = {
      id: c + h.id,
      selectable: i && h.kind !== cr.Group,
      focusable: i && !m,
      deletable: !1,
      position: g,
      zIndex: m ? Ht.Compound : Ht.Element,
      style: {
        width: h.width,
        height: h.height
      },
      initialWidth: h.width,
      initialHeight: h.height,
      hidden: h.kind !== cr.Group && !l(h),
      ...p && {
        parentId: c + p.id
      }
    }, w = {
      id: h.id,
      title: h.title,
      color: h.color,
      shape: h.shape,
      style: h.style,
      depth: h.depth ?? 0,
      icon: h.icon ?? "none",
      position: h.position
    }, x = {
      id: h.id,
      title: h.title,
      technology: h.technology,
      description: h.description,
      height: h.height,
      width: h.width,
      level: h.level,
      color: h.color,
      shape: h.shape,
      style: h.style,
      icon: h.icon ?? null,
      position: h.position,
      isMultiple: h.style?.multiple ?? !1
    };
    if (h.kind === cr.Group) {
      r.push({
        ...v,
        type: "view-group",
        data: {
          isViewGroup: !0,
          ...w
        },
        dragHandle: ".likec4-compound-title"
      });
      continue;
    }
    const k = ct.modelRef(h), _ = ct.deploymentRef(h);
    if (!k && !_)
      throw console.error("Invalid node", h), new Error("Element should have either modelRef or deploymentRef");
    const S = { navigateTo: h.navigateTo ?? null };
    switch (!0) {
      case (m && !!_): {
        r.push(
          {
            ...v,
            type: "compound-deployment",
            data: {
              ...w,
              ...S,
              deploymentFqn: _,
              modelFqn: k
            }
          }
        );
        break;
      }
      case m: {
        me(!!k, "ModelRef expected"), r.push(
          {
            ...v,
            type: "compound-element",
            data: {
              ...w,
              ...S,
              modelFqn: k
            },
            dragHandle: ".likec4-compound-title"
          }
        );
        break;
      }
      case !!_: {
        r.push(
          {
            ...v,
            type: "deployment",
            data: {
              ...x,
              ...S,
              deploymentFqn: _,
              modelFqn: k
            }
          }
        );
        break;
      }
      default:
        me(!!k, "ModelRef expected"), r.push(
          {
            ...v,
            type: "element",
            data: {
              ...x,
              ...S,
              modelFqn: k
            }
          }
        );
    }
  }
  for (const h of n.edges) {
    const p = h.source, m = h.target, g = c + h.id;
    if (!ut(h.points, 2)) {
      console.error("edge should have at least 2 points", h);
      continue;
    }
    o.push({
      id: g,
      type: "relationship",
      source: c + p,
      target: c + m,
      zIndex: Ht.Edge,
      selectable: i,
      hidden: !l(h),
      deletable: !1,
      data: {
        id: h.id,
        label: h.label,
        technology: h.technology,
        notes: h.notes,
        navigateTo: h.navigateTo,
        controlPoints: h.controlPoints ?? null,
        labelBBox: h.labelBBox ?? null,
        labelXY: h.labelBBox ? { x: h.labelBBox.x, y: h.labelBBox.y } : null,
        points: h.points,
        color: h.color ?? "gray",
        line: h.line ?? "dashed",
        dir: h.dir ?? "forward",
        head: h.head ?? "normal",
        tail: h.tail ?? "none"
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes: r,
    xyedges: o
  };
}
function NC({
  view: {
    id: e,
    nodes: n,
    edges: i,
    __: r = "element"
  },
  ...o
}) {
  return n_(() => DC({
    view: {
      id: e,
      nodes: n,
      edges: i,
      __: r
    },
    ...o
  }), [e, r, n, i, o]);
}
function Fi() {
  const e = TC();
  return ce(() => e ? { portalProps: { target: e }, withinPortal: !0 } : { withinPortal: !1 }, [e]);
}
const RC = Pp;
function Wc(e, n) {
  return Ll(
    q(e),
    Ze
  );
}
const Yg = ds, Ph = S1, LC = (e) => e.transform[2] < 0.2;
function Xg() {
  return Ll(LC);
}
var $C = "_17jps3v0", zC = "_17jps3v2", OC = "_17jps3v3", qn = "_17jps3v4";
const { abs: Ji, cos: $t, sin: Xn, acos: VC, atan2: Qi, sqrt: Xt, pow: at } = Math;
function er(e) {
  return e < 0 ? -at(-e, 1 / 3) : at(e, 1 / 3);
}
const Kg = Math.PI, vo = 2 * Kg, Kt = Kg / 2, BC = 1e-6, ca = Number.MAX_SAFE_INTEGER || 9007199254740991, ua = Number.MIN_SAFE_INTEGER || -9007199254740991, jC = { x: 0, y: 0, z: 0 }, I = {
  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))
  Tvalues: [
    -0.06405689286260563,
    0.06405689286260563,
    -0.1911188674736163,
    0.1911188674736163,
    -0.3150426796961634,
    0.3150426796961634,
    -0.4337935076260451,
    0.4337935076260451,
    -0.5454214713888396,
    0.5454214713888396,
    -0.6480936519369755,
    0.6480936519369755,
    -0.7401241915785544,
    0.7401241915785544,
    -0.820001985973903,
    0.820001985973903,
    -0.8864155270044011,
    0.8864155270044011,
    -0.9382745520027328,
    0.9382745520027328,
    -0.9747285559713095,
    0.9747285559713095,
    -0.9951872199970213,
    0.9951872199970213
  ],
  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)
  Cvalues: [
    0.12793819534675216,
    0.12793819534675216,
    0.1258374563468283,
    0.1258374563468283,
    0.12167047292780339,
    0.12167047292780339,
    0.1155056680537256,
    0.1155056680537256,
    0.10744427011596563,
    0.10744427011596563,
    0.09761865210411388,
    0.09761865210411388,
    0.08619016153195327,
    0.08619016153195327,
    0.0733464814110803,
    0.0733464814110803,
    0.05929858491543678,
    0.05929858491543678,
    0.04427743881741981,
    0.04427743881741981,
    0.028531388628933663,
    0.028531388628933663,
    0.0123412297999872,
    0.0123412297999872
  ],
  arcfn: function(e, n) {
    const i = n(e);
    let r = i.x * i.x + i.y * i.y;
    return typeof i.z < "u" && (r += i.z * i.z), Xt(r);
  },
  compute: function(e, n, i) {
    if (e === 0)
      return n[0].t = 0, n[0];
    const r = n.length - 1;
    if (e === 1)
      return n[r].t = 1, n[r];
    const o = 1 - e;
    let s = n;
    if (r === 0)
      return n[0].t = e, n[0];
    if (r === 1) {
      const l = {
        x: o * s[0].x + e * s[1].x,
        y: o * s[0].y + e * s[1].y,
        t: e
      };
      return i && (l.z = o * s[0].z + e * s[1].z), l;
    }
    if (r < 4) {
      let l = o * o, c = e * e, u, f, h, p = 0;
      r === 2 ? (s = [s[0], s[1], s[2], jC], u = l, f = o * e * 2, h = c) : r === 3 && (u = l * o, f = l * e * 3, h = o * c * 3, p = e * c);
      const m = {
        x: u * s[0].x + f * s[1].x + h * s[2].x + p * s[3].x,
        y: u * s[0].y + f * s[1].y + h * s[2].y + p * s[3].y,
        t: e
      };
      return i && (m.z = u * s[0].z + f * s[1].z + h * s[2].z + p * s[3].z), m;
    }
    const a = JSON.parse(JSON.stringify(n));
    for (; a.length > 1; ) {
      for (let l = 0; l < a.length - 1; l++)
        a[l] = {
          x: a[l].x + (a[l + 1].x - a[l].x) * e,
          y: a[l].y + (a[l + 1].y - a[l].y) * e
        }, typeof a[l].z < "u" && (a[l].z = a[l].z + (a[l + 1].z - a[l].z) * e);
      a.splice(a.length - 1, 1);
    }
    return a[0].t = e, a[0];
  },
  computeWithRatios: function(e, n, i, r) {
    const o = 1 - e, s = i, a = n;
    let l = s[0], c = s[1], u = s[2], f = s[3], h;
    if (l *= o, c *= e, a.length === 2)
      return h = l + c, {
        x: (l * a[0].x + c * a[1].x) / h,
        y: (l * a[0].y + c * a[1].y) / h,
        z: r ? (l * a[0].z + c * a[1].z) / h : !1,
        t: e
      };
    if (l *= o, c *= 2 * o, u *= e * e, a.length === 3)
      return h = l + c + u, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y) / h,
        z: r ? (l * a[0].z + c * a[1].z + u * a[2].z) / h : !1,
        t: e
      };
    if (l *= o, c *= 1.5 * o, u *= 3 * o, f *= e * e * e, a.length === 4)
      return h = l + c + u + f, {
        x: (l * a[0].x + c * a[1].x + u * a[2].x + f * a[3].x) / h,
        y: (l * a[0].y + c * a[1].y + u * a[2].y + f * a[3].y) / h,
        z: r ? (l * a[0].z + c * a[1].z + u * a[2].z + f * a[3].z) / h : !1,
        t: e
      };
  },
  derive: function(e, n) {
    const i = [];
    for (let r = e, o = r.length, s = o - 1; o > 1; o--, s--) {
      const a = [];
      for (let l = 0, c; l < s; l++)
        c = {
          x: s * (r[l + 1].x - r[l].x),
          y: s * (r[l + 1].y - r[l].y)
        }, n && (c.z = s * (r[l + 1].z - r[l].z)), a.push(c);
      i.push(a), r = a;
    }
    return i;
  },
  between: function(e, n, i) {
    return n <= e && e <= i || I.approximately(e, n) || I.approximately(e, i);
  },
  approximately: function(e, n, i) {
    return Ji(e - n) <= (i || BC);
  },
  length: function(e) {
    const i = I.Tvalues.length;
    let r = 0;
    for (let o = 0, s; o < i; o++)
      s = 0.5 * I.Tvalues[o] + 0.5, r += I.Cvalues[o] * I.arcfn(s, e);
    return 0.5 * r;
  },
  map: function(e, n, i, r, o) {
    const s = i - n, a = o - r, l = e - n, c = l / s;
    return r + a * c;
  },
  lerp: function(e, n, i) {
    const r = {
      x: n.x + e * (i.x - n.x),
      y: n.y + e * (i.y - n.y)
    };
    return n.z !== void 0 && i.z !== void 0 && (r.z = n.z + e * (i.z - n.z)), r;
  },
  pointToString: function(e) {
    let n = e.x + "/" + e.y;
    return typeof e.z < "u" && (n += "/" + e.z), n;
  },
  pointsToString: function(e) {
    return "[" + e.map(I.pointToString).join(", ") + "]";
  },
  copy: function(e) {
    return JSON.parse(JSON.stringify(e));
  },
  angle: function(e, n, i) {
    const r = n.x - e.x, o = n.y - e.y, s = i.x - e.x, a = i.y - e.y, l = r * a - o * s, c = r * s + o * a;
    return Qi(l, c);
  },
  // round as string, to avoid rounding errors
  round: function(e, n) {
    const i = "" + e, r = i.indexOf(".");
    return parseFloat(i.substring(0, r + 1 + n));
  },
  dist: function(e, n) {
    const i = e.x - n.x, r = e.y - n.y;
    return Xt(i * i + r * r);
  },
  closest: function(e, n) {
    let i = at(2, 63), r, o;
    return e.forEach(function(s, a) {
      o = I.dist(n, s), o < i && (i = o, r = a);
    }), { mdist: i, mpos: r };
  },
  abcratio: function(e, n) {
    if (n !== 2 && n !== 3)
      return !1;
    if (typeof e > "u")
      e = 0.5;
    else if (e === 0 || e === 1)
      return e;
    const i = at(e, n) + at(1 - e, n), r = i - 1;
    return Ji(r / i);
  },
  projectionratio: function(e, n) {
    if (n !== 2 && n !== 3)
      return !1;
    if (typeof e > "u")
      e = 0.5;
    else if (e === 0 || e === 1)
      return e;
    const i = at(1 - e, n), r = at(e, n) + i;
    return i / r;
  },
  lli8: function(e, n, i, r, o, s, a, l) {
    const c = (e * r - n * i) * (o - a) - (e - i) * (o * l - s * a), u = (e * r - n * i) * (s - l) - (n - r) * (o * l - s * a), f = (e - i) * (s - l) - (n - r) * (o - a);
    return f == 0 ? !1 : { x: c / f, y: u / f };
  },
  lli4: function(e, n, i, r) {
    const o = e.x, s = e.y, a = n.x, l = n.y, c = i.x, u = i.y, f = r.x, h = r.y;
    return I.lli8(o, s, a, l, c, u, f, h);
  },
  lli: function(e, n) {
    return I.lli4(e, e.c, n, n.c);
  },
  makeline: function(e, n) {
    return new ye(
      e.x,
      e.y,
      (e.x + n.x) / 2,
      (e.y + n.y) / 2,
      n.x,
      n.y
    );
  },
  findbbox: function(e) {
    let n = ca, i = ca, r = ua, o = ua;
    return e.forEach(function(s) {
      const a = s.bbox();
      n > a.x.min && (n = a.x.min), i > a.y.min && (i = a.y.min), r < a.x.max && (r = a.x.max), o < a.y.max && (o = a.y.max);
    }), {
      x: { min: n, mid: (n + r) / 2, max: r, size: r - n },
      y: { min: i, mid: (i + o) / 2, max: o, size: o - i }
    };
  },
  shapeintersections: function(e, n, i, r, o) {
    if (!I.bboxoverlap(n, r)) return [];
    const s = [], a = [e.startcap, e.forward, e.back, e.endcap], l = [i.startcap, i.forward, i.back, i.endcap];
    return a.forEach(function(c) {
      c.virtual || l.forEach(function(u) {
        if (u.virtual) return;
        const f = c.intersects(u, o);
        f.length > 0 && (f.c1 = c, f.c2 = u, f.s1 = e, f.s2 = i, s.push(f));
      });
    }), s;
  },
  makeshape: function(e, n, i) {
    const r = n.points.length, o = e.points.length, s = I.makeline(n.points[r - 1], e.points[0]), a = I.makeline(e.points[o - 1], n.points[0]), l = {
      startcap: s,
      forward: e,
      back: n,
      endcap: a,
      bbox: I.findbbox([s, e, n, a])
    };
    return l.intersections = function(c) {
      return I.shapeintersections(
        l,
        l.bbox,
        c,
        c.bbox,
        i
      );
    }, l;
  },
  getminmax: function(e, n, i) {
    if (!i) return { min: 0, max: 0 };
    let r = ca, o = ua, s, a;
    i.indexOf(0) === -1 && (i = [0].concat(i)), i.indexOf(1) === -1 && i.push(1);
    for (let l = 0, c = i.length; l < c; l++)
      s = i[l], a = e.get(s), a[n] < r && (r = a[n]), a[n] > o && (o = a[n]);
    return { min: r, mid: (r + o) / 2, max: o, size: o - r };
  },
  align: function(e, n) {
    const i = n.p1.x, r = n.p1.y, o = -Qi(n.p2.y - r, n.p2.x - i), s = function(a) {
      return {
        x: (a.x - i) * $t(o) - (a.y - r) * Xn(o),
        y: (a.x - i) * Xn(o) + (a.y - r) * $t(o)
      };
    };
    return e.map(s);
  },
  roots: function(e, n) {
    n = n || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };
    const i = e.length - 1, r = I.align(e, n), o = function(C) {
      return 0 <= C && C <= 1;
    };
    if (i === 2) {
      const C = r[0].y, T = r[1].y, M = r[2].y, D = C - 2 * T + M;
      if (D !== 0) {
        const L = -Xt(T * T - C * M), z = -C + T, Q = -(L + z) / D, ee = -(-L + z) / D;
        return [Q, ee].filter(o);
      } else if (T !== M && D === 0)
        return [(2 * T - M) / (2 * T - 2 * M)].filter(o);
      return [];
    }
    const s = r[0].y, a = r[1].y, l = r[2].y, c = r[3].y;
    let u = -s + 3 * a - 3 * l + c, f = 3 * s - 6 * a + 3 * l, h = -3 * s + 3 * a, p = s;
    if (I.approximately(u, 0)) {
      if (I.approximately(f, 0))
        return I.approximately(h, 0) ? [] : [-p / h].filter(o);
      const C = Xt(h * h - 4 * f * p), T = 2 * f;
      return [(C - h) / T, (-h - C) / T].filter(o);
    }
    f /= u, h /= u, p /= u;
    const m = (3 * h - f * f) / 3, g = m / 3, y = (2 * f * f * f - 9 * f * h + 27 * p) / 27, v = y / 2, w = v * v + g * g * g;
    let x, k, _, S, P;
    if (w < 0) {
      const C = -m / 3, T = C * C * C, M = Xt(T), D = -y / (2 * M), L = D < -1 ? -1 : D > 1 ? 1 : D, z = VC(L), Q = er(M), ee = 2 * Q;
      return _ = ee * $t(z / 3) - f / 3, S = ee * $t((z + vo) / 3) - f / 3, P = ee * $t((z + 2 * vo) / 3) - f / 3, [_, S, P].filter(o);
    } else {
      if (w === 0)
        return x = v < 0 ? er(-v) : -er(v), _ = 2 * x - f / 3, S = -x - f / 3, [_, S].filter(o);
      {
        const C = Xt(w);
        return x = er(-v + C), k = er(v + C), [x - k - f / 3].filter(o);
      }
    }
  },
  droots: function(e) {
    if (e.length === 3) {
      const n = e[0], i = e[1], r = e[2], o = n - 2 * i + r;
      if (o !== 0) {
        const s = -Xt(i * i - n * r), a = -n + i, l = -(s + a) / o, c = -(-s + a) / o;
        return [l, c];
      } else if (i !== r && o === 0)
        return [(2 * i - r) / (2 * (i - r))];
      return [];
    }
    if (e.length === 2) {
      const n = e[0], i = e[1];
      return n !== i ? [n / (n - i)] : [];
    }
    return [];
  },
  curvature: function(e, n, i, r, o) {
    let s, a, l, c, u = 0, f = 0;
    const h = I.compute(e, n), p = I.compute(e, i), m = h.x * h.x + h.y * h.y;
    if (r ? (s = Xt(
      at(h.y * p.z - p.y * h.z, 2) + at(h.z * p.x - p.z * h.x, 2) + at(h.x * p.y - p.x * h.y, 2)
    ), a = at(m + h.z * h.z, 3 / 2)) : (s = h.x * p.y - h.y * p.x, a = at(m, 3 / 2)), s === 0 || a === 0)
      return { k: 0, r: 0 };
    if (u = s / a, f = a / s, !o) {
      const g = I.curvature(e - 1e-3, n, i, r, !0).k, y = I.curvature(e + 1e-3, n, i, r, !0).k;
      c = (y - u + (u - g)) / 2, l = (Ji(y - u) + Ji(u - g)) / 2;
    }
    return { k: u, r: f, dk: c, adk: l };
  },
  inflections: function(e) {
    if (e.length < 4) return [];
    const n = I.align(e, { p1: e[0], p2: e.slice(-1)[0] }), i = n[2].x * n[1].y, r = n[3].x * n[1].y, o = n[1].x * n[2].y, s = n[3].x * n[2].y, a = 18 * (-3 * i + 2 * r + 3 * o - s), l = 18 * (3 * i - r - 3 * o), c = 18 * (o - i);
    if (I.approximately(a, 0)) {
      if (!I.approximately(l, 0)) {
        let p = -c / l;
        if (0 <= p && p <= 1) return [p];
      }
      return [];
    }
    const u = 2 * a;
    if (I.approximately(u, 0)) return [];
    const f = l * l - 4 * a * c;
    if (f < 0) return [];
    const h = Math.sqrt(f);
    return [(h - l) / u, -(l + h) / u].filter(function(p) {
      return 0 <= p && p <= 1;
    });
  },
  bboxoverlap: function(e, n) {
    const i = ["x", "y"], r = i.length;
    for (let o = 0, s, a, l, c; o < r; o++)
      if (s = i[o], a = e[s].mid, l = n[s].mid, c = (e[s].size + n[s].size) / 2, Ji(a - l) >= c) return !1;
    return !0;
  },
  expandbox: function(e, n) {
    n.x.min < e.x.min && (e.x.min = n.x.min), n.y.min < e.y.min && (e.y.min = n.y.min), n.z && n.z.min < e.z.min && (e.z.min = n.z.min), n.x.max > e.x.max && (e.x.max = n.x.max), n.y.max > e.y.max && (e.y.max = n.y.max), n.z && n.z.max > e.z.max && (e.z.max = n.z.max), e.x.mid = (e.x.min + e.x.max) / 2, e.y.mid = (e.y.min + e.y.max) / 2, e.z && (e.z.mid = (e.z.min + e.z.max) / 2), e.x.size = e.x.max - e.x.min, e.y.size = e.y.max - e.y.min, e.z && (e.z.size = e.z.max - e.z.min);
  },
  pairiteration: function(e, n, i) {
    const r = e.bbox(), o = n.bbox(), s = 1e5, a = i || 0.5;
    if (r.x.size + r.y.size < a && o.x.size + o.y.size < a)
      return [
        (s * (e._t1 + e._t2) / 2 | 0) / s + "/" + (s * (n._t1 + n._t2) / 2 | 0) / s
      ];
    let l = e.split(0.5), c = n.split(0.5), u = [
      { left: l.left, right: c.left },
      { left: l.left, right: c.right },
      { left: l.right, right: c.right },
      { left: l.right, right: c.left }
    ];
    u = u.filter(function(h) {
      return I.bboxoverlap(h.left.bbox(), h.right.bbox());
    });
    let f = [];
    return u.length === 0 || (u.forEach(function(h) {
      f = f.concat(
        I.pairiteration(h.left, h.right, a)
      );
    }), f = f.filter(function(h, p) {
      return f.indexOf(h) === p;
    })), f;
  },
  getccenter: function(e, n, i) {
    const r = n.x - e.x, o = n.y - e.y, s = i.x - n.x, a = i.y - n.y, l = r * $t(Kt) - o * Xn(Kt), c = r * Xn(Kt) + o * $t(Kt), u = s * $t(Kt) - a * Xn(Kt), f = s * Xn(Kt) + a * $t(Kt), h = (e.x + n.x) / 2, p = (e.y + n.y) / 2, m = (n.x + i.x) / 2, g = (n.y + i.y) / 2, y = h + l, v = p + c, w = m + u, x = g + f, k = I.lli8(h, p, y, v, m, g, w, x), _ = I.dist(k, e);
    let S = Qi(e.y - k.y, e.x - k.x), P = Qi(n.y - k.y, n.x - k.x), C = Qi(i.y - k.y, i.x - k.x), T;
    return S < C ? ((S > P || P > C) && (S += vo), S > C && (T = C, C = S, S = T)) : C < P && P < S ? (T = C, C = S, S = T) : C += vo, k.s = S, k.e = C, k.r = _, k;
  },
  numberSort: function(e, n) {
    return e - n;
  }
};
class br {
  constructor(n) {
    this.curves = [], this._3d = !1, n && (this.curves = n, this._3d = this.curves[0]._3d);
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return "[" + this.curves.map(function(n) {
      return I.pointsToString(n.points);
    }).join(", ") + "]";
  }
  addCurve(n) {
    this.curves.push(n), this._3d = this._3d || n._3d;
  }
  length() {
    return this.curves.map(function(n) {
      return n.length();
    }).reduce(function(n, i) {
      return n + i;
    });
  }
  curve(n) {
    return this.curves[n];
  }
  bbox() {
    const n = this.curves;
    for (var i = n[0].bbox(), r = 1; r < n.length; r++)
      I.expandbox(i, n[r].bbox());
    return i;
  }
  offset(n) {
    const i = [];
    return this.curves.forEach(function(r) {
      i.push(...r.offset(n));
    }), new br(i);
  }
}
const { abs: tr, min: Th, max: Mh, cos: FC, sin: WC, acos: HC, sqrt: nr } = Math, qC = Math.PI;
class ye {
  constructor(n) {
    let i = n && n.forEach ? n : Array.from(arguments).slice(), r = !1;
    if (typeof i[0] == "object") {
      r = i.length;
      const m = [];
      i.forEach(function(g) {
        ["x", "y", "z"].forEach(function(y) {
          typeof g[y] < "u" && m.push(g[y]);
        });
      }), i = m;
    }
    let o = !1;
    const s = i.length;
    if (r) {
      if (r > 4) {
        if (arguments.length !== 1)
          throw new Error(
            "Only new Bezier(point[]) is accepted for 4th and higher order curves"
          );
        o = !0;
      }
    } else if (s !== 6 && s !== 8 && s !== 9 && s !== 12 && arguments.length !== 1)
      throw new Error(
        "Only new Bezier(point[]) is accepted for 4th and higher order curves"
      );
    const a = this._3d = !o && (s === 9 || s === 12) || n && n[0] && typeof n[0].z < "u", l = this.points = [];
    for (let m = 0, g = a ? 3 : 2; m < s; m += g) {
      var c = {
        x: i[m],
        y: i[m + 1]
      };
      a && (c.z = i[m + 2]), l.push(c);
    }
    const u = this.order = l.length - 1, f = this.dims = ["x", "y"];
    a && f.push("z"), this.dimlen = f.length;
    const h = I.align(l, { p1: l[0], p2: l[u] }), p = I.dist(l[0], l[u]);
    this._linear = h.reduce((m, g) => m + tr(g.y), 0) < p / 50, this._lut = [], this._t1 = 0, this._t2 = 1, this.update();
  }
  static quadraticFromPoints(n, i, r, o) {
    if (typeof o > "u" && (o = 0.5), o === 0)
      return new ye(i, i, r);
    if (o === 1)
      return new ye(n, i, i);
    const s = ye.getABC(2, n, i, r, o);
    return new ye(n, s.A, r);
  }
  static cubicFromPoints(n, i, r, o, s) {
    typeof o > "u" && (o = 0.5);
    const a = ye.getABC(3, n, i, r, o);
    typeof s > "u" && (s = I.dist(i, a.C));
    const l = s * (1 - o) / o, c = I.dist(n, r), u = (r.x - n.x) / c, f = (r.y - n.y) / c, h = s * u, p = s * f, m = l * u, g = l * f, y = { x: i.x - h, y: i.y - p }, v = { x: i.x + m, y: i.y + g }, w = a.A, x = { x: w.x + (y.x - w.x) / (1 - o), y: w.y + (y.y - w.y) / (1 - o) }, k = { x: w.x + (v.x - w.x) / o, y: w.y + (v.y - w.y) / o }, _ = { x: n.x + (x.x - n.x) / o, y: n.y + (x.y - n.y) / o }, S = {
      x: r.x + (k.x - r.x) / (1 - o),
      y: r.y + (k.y - r.y) / (1 - o)
    };
    return new ye(n, _, S, r);
  }
  static getUtils() {
    return I;
  }
  getUtils() {
    return ye.getUtils();
  }
  static get PolyBezier() {
    return br;
  }
  valueOf() {
    return this.toString();
  }
  toString() {
    return I.pointsToString(this.points);
  }
  toSVG() {
    if (this._3d) return !1;
    const n = this.points, i = n[0].x, r = n[0].y, o = ["M", i, r, this.order === 2 ? "Q" : "C"];
    for (let s = 1, a = n.length; s < a; s++)
      o.push(n[s].x), o.push(n[s].y);
    return o.join(" ");
  }
  setRatios(n) {
    if (n.length !== this.points.length)
      throw new Error("incorrect number of ratio values");
    this.ratios = n, this._lut = [];
  }
  verify() {
    const n = this.coordDigest();
    n !== this._print && (this._print = n, this.update());
  }
  coordDigest() {
    return this.points.map(function(n, i) {
      return "" + i + n.x + n.y + (n.z ? n.z : 0);
    }).join("");
  }
  update() {
    this._lut = [], this.dpoints = I.derive(this.points, this._3d), this.computedirection();
  }
  computedirection() {
    const n = this.points, i = I.angle(n[0], n[this.order], n[1]);
    this.clockwise = i > 0;
  }
  length() {
    return I.length(this.derivative.bind(this));
  }
  static getABC(n = 2, i, r, o, s = 0.5) {
    const a = I.projectionratio(s, n), l = 1 - a, c = {
      x: a * i.x + l * o.x,
      y: a * i.y + l * o.y
    }, u = I.abcratio(s, n);
    return { A: {
      x: r.x + (r.x - c.x) / u,
      y: r.y + (r.y - c.y) / u
    }, B: r, C: c, S: i, E: o };
  }
  getABC(n, i) {
    i = i || this.get(n);
    let r = this.points[0], o = this.points[this.order];
    return ye.getABC(this.order, r, i, o, n);
  }
  getLUT(n) {
    if (this.verify(), n = n || 100, this._lut.length === n + 1)
      return this._lut;
    this._lut = [], n++, this._lut = [];
    for (let i = 0, r, o; i < n; i++)
      o = i / (n - 1), r = this.compute(o), r.t = o, this._lut.push(r);
    return this._lut;
  }
  on(n, i) {
    i = i || 5;
    const r = this.getLUT(), o = [];
    for (let s = 0, a, l = 0; s < r.length; s++)
      a = r[s], I.dist(a, n) < i && (o.push(a), l += s / r.length);
    return o.length ? t /= o.length : !1;
  }
  project(n) {
    const i = this.getLUT(), r = i.length - 1, o = I.closest(i, n), s = o.mpos, a = (s - 1) / r, l = (s + 1) / r, c = 0.1 / r;
    let u = o.mdist, f = a, h = f, p;
    u += 1;
    for (let m; f < l + c; f += c)
      p = this.compute(f), m = I.dist(n, p), m < u && (u = m, h = f);
    return h = h < 0 ? 0 : h > 1 ? 1 : h, p = this.compute(h), p.t = h, p.d = u, p;
  }
  get(n) {
    return this.compute(n);
  }
  point(n) {
    return this.points[n];
  }
  compute(n) {
    return this.ratios ? I.computeWithRatios(n, this.points, this.ratios, this._3d) : I.compute(n, this.points, this._3d, this.ratios);
  }
  raise() {
    const n = this.points, i = [n[0]], r = n.length;
    for (let o = 1, s, a; o < r; o++)
      s = n[o], a = n[o - 1], i[o] = {
        x: (r - o) / r * s.x + o / r * a.x,
        y: (r - o) / r * s.y + o / r * a.y
      };
    return i[r] = n[r - 1], new ye(i);
  }
  derivative(n) {
    return I.compute(n, this.dpoints[0], this._3d);
  }
  dderivative(n) {
    return I.compute(n, this.dpoints[1], this._3d);
  }
  align() {
    let n = this.points;
    return new ye(I.align(n, { p1: n[0], p2: n[n.length - 1] }));
  }
  curvature(n) {
    return I.curvature(n, this.dpoints[0], this.dpoints[1], this._3d);
  }
  inflections() {
    return I.inflections(this.points);
  }
  normal(n) {
    return this._3d ? this.__normal3(n) : this.__normal2(n);
  }
  __normal2(n) {
    const i = this.derivative(n), r = nr(i.x * i.x + i.y * i.y);
    return { t: n, x: -i.y / r, y: i.x / r };
  }
  __normal3(n) {
    const i = this.derivative(n), r = this.derivative(n + 0.01), o = nr(i.x * i.x + i.y * i.y + i.z * i.z), s = nr(r.x * r.x + r.y * r.y + r.z * r.z);
    i.x /= o, i.y /= o, i.z /= o, r.x /= s, r.y /= s, r.z /= s;
    const a = {
      x: r.y * i.z - r.z * i.y,
      y: r.z * i.x - r.x * i.z,
      z: r.x * i.y - r.y * i.x
    }, l = nr(a.x * a.x + a.y * a.y + a.z * a.z);
    a.x /= l, a.y /= l, a.z /= l;
    const c = [
      a.x * a.x,
      a.x * a.y - a.z,
      a.x * a.z + a.y,
      a.x * a.y + a.z,
      a.y * a.y,
      a.y * a.z - a.x,
      a.x * a.z - a.y,
      a.y * a.z + a.x,
      a.z * a.z
    ];
    return {
      t: n,
      x: c[0] * i.x + c[1] * i.y + c[2] * i.z,
      y: c[3] * i.x + c[4] * i.y + c[5] * i.z,
      z: c[6] * i.x + c[7] * i.y + c[8] * i.z
    };
  }
  hull(n) {
    let i = this.points, r = [], o = [], s = 0;
    for (o[s++] = i[0], o[s++] = i[1], o[s++] = i[2], this.order === 3 && (o[s++] = i[3]); i.length > 1; ) {
      r = [];
      for (let a = 0, l, c = i.length - 1; a < c; a++)
        l = I.lerp(n, i[a], i[a + 1]), o[s++] = l, r.push(l);
      i = r;
    }
    return o;
  }
  split(n, i) {
    if (n === 0 && i)
      return this.split(i).left;
    if (i === 1)
      return this.split(n).right;
    const r = this.hull(n), o = {
      left: this.order === 2 ? new ye([r[0], r[3], r[5]]) : new ye([r[0], r[4], r[7], r[9]]),
      right: this.order === 2 ? new ye([r[5], r[4], r[2]]) : new ye([r[9], r[8], r[6], r[3]]),
      span: r
    };
    return o.left._t1 = I.map(0, 0, 1, this._t1, this._t2), o.left._t2 = I.map(n, 0, 1, this._t1, this._t2), o.right._t1 = I.map(n, 0, 1, this._t1, this._t2), o.right._t2 = I.map(1, 0, 1, this._t1, this._t2), i ? (i = I.map(i, n, 1, 0, 1), o.right.split(i).left) : o;
  }
  extrema() {
    const n = {};
    let i = [];
    return this.dims.forEach(
      function(r) {
        let o = function(a) {
          return a[r];
        }, s = this.dpoints[0].map(o);
        n[r] = I.droots(s), this.order === 3 && (s = this.dpoints[1].map(o), n[r] = n[r].concat(I.droots(s))), n[r] = n[r].filter(function(a) {
          return a >= 0 && a <= 1;
        }), i = i.concat(n[r].sort(I.numberSort));
      }.bind(this)
    ), n.values = i.sort(I.numberSort).filter(function(r, o) {
      return i.indexOf(r) === o;
    }), n;
  }
  bbox() {
    const n = this.extrema(), i = {};
    return this.dims.forEach(
      function(r) {
        i[r] = I.getminmax(this, r, n[r]);
      }.bind(this)
    ), i;
  }
  overlaps(n) {
    const i = this.bbox(), r = n.bbox();
    return I.bboxoverlap(i, r);
  }
  offset(n, i) {
    if (typeof i < "u") {
      const r = this.get(n), o = this.normal(n), s = {
        c: r,
        n: o,
        x: r.x + o.x * i,
        y: r.y + o.y * i
      };
      return this._3d && (s.z = r.z + o.z * i), s;
    }
    if (this._linear) {
      const r = this.normal(0), o = this.points.map(function(s) {
        const a = {
          x: s.x + n * r.x,
          y: s.y + n * r.y
        };
        return s.z && r.z && (a.z = s.z + n * r.z), a;
      });
      return [new ye(o)];
    }
    return this.reduce().map(function(r) {
      return r._linear ? r.offset(n)[0] : r.scale(n);
    });
  }
  simple() {
    if (this.order === 3) {
      const o = I.angle(this.points[0], this.points[3], this.points[1]), s = I.angle(this.points[0], this.points[3], this.points[2]);
      if (o > 0 && s < 0 || o < 0 && s > 0) return !1;
    }
    const n = this.normal(0), i = this.normal(1);
    let r = n.x * i.x + n.y * i.y;
    return this._3d && (r += n.z * i.z), tr(HC(r)) < qC / 3;
  }
  reduce() {
    let n, i = 0, r = 0, o = 0.01, s, a = [], l = [], c = this.extrema().values;
    for (c.indexOf(0) === -1 && (c = [0].concat(c)), c.indexOf(1) === -1 && c.push(1), i = c[0], n = 1; n < c.length; n++)
      r = c[n], s = this.split(i, r), s._t1 = i, s._t2 = r, a.push(s), i = r;
    return a.forEach(function(u) {
      for (i = 0, r = 0; r <= 1; )
        for (r = i + o; r <= 1 + o; r += o)
          if (s = u.split(i, r), !s.simple()) {
            if (r -= o, tr(i - r) < o)
              return [];
            s = u.split(i, r), s._t1 = I.map(i, 0, 1, u._t1, u._t2), s._t2 = I.map(r, 0, 1, u._t1, u._t2), l.push(s), i = r;
            break;
          }
      i < 1 && (s = u.split(i, 1), s._t1 = I.map(i, 0, 1, u._t1, u._t2), s._t2 = u._t2, l.push(s));
    }), l;
  }
  translate(n, i, r) {
    r = typeof r == "number" ? r : i;
    const o = this.order;
    let s = this.points.map((a, l) => (1 - l / o) * i + l / o * r);
    return new ye(
      this.points.map((a, l) => ({
        x: a.x + n.x * s[l],
        y: a.y + n.y * s[l]
      }))
    );
  }
  scale(n) {
    const i = this.order;
    let r = !1;
    if (typeof n == "function" && (r = n), r && i === 2)
      return this.raise().scale(r);
    const o = this.clockwise, s = this.points;
    if (this._linear)
      return this.translate(
        this.normal(0),
        r ? r(0) : n,
        r ? r(1) : n
      );
    const a = r ? r(0) : n, l = r ? r(1) : n, c = [this.offset(0, 10), this.offset(1, 10)], u = [], f = I.lli4(c[0], c[0].c, c[1], c[1].c);
    if (!f)
      throw new Error("cannot scale this curve. Try reducing it first.");
    return [0, 1].forEach(function(h) {
      const p = u[h * i] = I.copy(s[h * i]);
      p.x += (h ? l : a) * c[h].n.x, p.y += (h ? l : a) * c[h].n.y;
    }), r ? ([0, 1].forEach(function(h) {
      if (!(i === 2 && h)) {
        var p = s[h + 1], m = {
          x: p.x - f.x,
          y: p.y - f.y
        }, g = r ? r((h + 1) / i) : n;
        r && !o && (g = -g);
        var y = nr(m.x * m.x + m.y * m.y);
        m.x /= y, m.y /= y, u[h + 1] = {
          x: p.x + g * m.x,
          y: p.y + g * m.y
        };
      }
    }), new ye(u)) : ([0, 1].forEach((h) => {
      if (i === 2 && h) return;
      const p = u[h * i], m = this.derivative(h), g = { x: p.x + m.x, y: p.y + m.y };
      u[h + 1] = I.lli4(p, g, f, s[h + 1]);
    }), new ye(u));
  }
  outline(n, i, r, o) {
    if (i = i === void 0 ? n : i, this._linear) {
      const S = this.normal(0), P = this.points[0], C = this.points[this.points.length - 1];
      let T, M, D;
      r === void 0 && (r = n, o = i), T = { x: P.x + S.x * n, y: P.y + S.y * n }, D = { x: C.x + S.x * r, y: C.y + S.y * r }, M = { x: (T.x + D.x) / 2, y: (T.y + D.y) / 2 };
      const L = [T, M, D];
      T = { x: P.x - S.x * i, y: P.y - S.y * i }, D = { x: C.x - S.x * o, y: C.y - S.y * o }, M = { x: (T.x + D.x) / 2, y: (T.y + D.y) / 2 };
      const z = [D, M, T], Q = I.makeline(z[2], L[0]), ee = I.makeline(L[2], z[0]), Z = [Q, new ye(L), ee, new ye(z)];
      return new br(Z);
    }
    const s = this.reduce(), a = s.length, l = [];
    let c = [], u, f = 0, h = this.length();
    const p = typeof r < "u" && typeof o < "u";
    function m(S, P, C, T, M) {
      return function(D) {
        const L = T / C, z = (T + M) / C, Q = P - S;
        return I.map(D, 0, 1, S + L * Q, S + z * Q);
      };
    }
    s.forEach(function(S) {
      const P = S.length();
      p ? (l.push(
        S.scale(m(n, r, h, f, P))
      ), c.push(
        S.scale(m(-i, -o, h, f, P))
      )) : (l.push(S.scale(n)), c.push(S.scale(-i))), f += P;
    }), c = c.map(function(S) {
      return u = S.points, u[3] ? S.points = [u[3], u[2], u[1], u[0]] : S.points = [u[2], u[1], u[0]], S;
    }).reverse();
    const g = l[0].points[0], y = l[a - 1].points[l[a - 1].points.length - 1], v = c[a - 1].points[c[a - 1].points.length - 1], w = c[0].points[0], x = I.makeline(v, g), k = I.makeline(y, w), _ = [x].concat(l).concat([k]).concat(c);
    return new br(_);
  }
  outlineshapes(n, i, r) {
    i = i || n;
    const o = this.outline(n, i).curves, s = [];
    for (let a = 1, l = o.length; a < l / 2; a++) {
      const c = I.makeshape(
        o[a],
        o[l - a],
        r
      );
      c.startcap.virtual = a > 1, c.endcap.virtual = a < l / 2 - 1, s.push(c);
    }
    return s;
  }
  intersects(n, i) {
    return n ? n.p1 && n.p2 ? this.lineIntersects(n) : (n instanceof ye && (n = n.reduce()), this.curveintersects(
      this.reduce(),
      n,
      i
    )) : this.selfintersects(i);
  }
  lineIntersects(n) {
    const i = Th(n.p1.x, n.p2.x), r = Th(n.p1.y, n.p2.y), o = Mh(n.p1.x, n.p2.x), s = Mh(n.p1.y, n.p2.y);
    return I.roots(this.points, n).filter((a) => {
      var l = this.get(a);
      return I.between(l.x, i, o) && I.between(l.y, r, s);
    });
  }
  selfintersects(n) {
    const i = this.reduce(), r = i.length - 2, o = [];
    for (let s = 0, a, l, c; s < r; s++)
      l = i.slice(s, s + 1), c = i.slice(s + 2), a = this.curveintersects(l, c, n), o.push(...a);
    return o;
  }
  curveintersects(n, i, r) {
    const o = [];
    n.forEach(function(a) {
      i.forEach(function(l) {
        a.overlaps(l) && o.push({ left: a, right: l });
      });
    });
    let s = [];
    return o.forEach(function(a) {
      const l = I.pairiteration(
        a.left,
        a.right,
        r
      );
      l.length > 0 && (s = s.concat(l));
    }), s;
  }
  arcs(n) {
    return n = n || 0.5, this._iterate(n, []);
  }
  _error(n, i, r, o) {
    const s = (o - r) / 4, a = this.get(r + s), l = this.get(o - s), c = I.dist(n, i), u = I.dist(n, a), f = I.dist(n, l);
    return tr(u - c) + tr(f - c);
  }
  _iterate(n, i) {
    let r = 0, o = 1, s;
    do {
      s = 0, o = 1;
      let a = this.get(r), l, c, u, f, h = !1, p = !1, m, g = o, y = 1;
      do
        if (p = h, f = u, g = (r + o) / 2, l = this.get(g), c = this.get(o), u = I.getccenter(a, l, c), u.interval = {
          start: r,
          end: o
        }, h = this._error(u, a, r, o) <= n, m = p && !h, m || (y = o), h) {
          if (o >= 1) {
            if (u.interval.end = y = 1, f = u, o > 1) {
              let w = {
                x: u.x + u.r * FC(u.e),
                y: u.y + u.r * WC(u.e)
              };
              u.e += I.angle({ x: u.x, y: u.y }, w, this.get(1));
            }
            break;
          }
          o = o + (o - r) / 2;
        } else
          o = g;
      while (!m && s++ < 100);
      if (s >= 100)
        break;
      f = f || u, i.push(f), r = y;
    } while (o < 1);
    return i;
  }
}
function Zg(e) {
  return e === null ? 0.01 : Math.round(e * 100) / 100;
}
function Jg(e) {
  let [n, ...i] = e.points;
  me(n, "start should be defined");
  const r = [
    // start
  ];
  for (; Dp(i, 3); ) {
    const [o, s, a, ...l] = i, c = new ye(n[0], n[1], o[0], o[1], s[0], s[1], a[0], a[1]), u = c.inflections();
    u.length === 0 && u.push(0.5), u.forEach((f) => {
      const { x: h, y: p } = c.get(f);
      r.push({
        x: Math.round(h),
        y: Math.round(p)
      });
    }), i = l, n = a;
  }
  return me(i.length === 0, "all points should be consumed"), r;
}
const Ah = (e, n) => Math.abs(e - n) < 3.1;
function hr(e, n) {
  const [i, r] = mh(e) ? e : [e.x, e.y], [o, s] = mh(n) ? n : [n.x, n.y];
  return Ah(i, o) && Ah(r, s);
}
function Ee(e) {
  return e.stopPropagation();
}
function GC(e) {
  const { width: n, height: i } = Ut(e);
  return {
    x: e.internals.positionAbsolute.x + n / 2,
    y: e.internals.positionAbsolute.y + i / 2
  };
}
function UC(e) {
  let [n, ...i] = e;
  me(n, "start should be defined");
  let r = `M ${n[0]},${n[1]}`;
  for (; Dp(i, 3); ) {
    const [o, s, a, ...l] = i;
    r = r + ` C ${o[0]},${o[1]} ${s[0]},${s[1]} ${a[0]},${a[1]}`, i = l;
  }
  return me(i.length === 0, "all points should be consumed"), r;
}
function YC(e) {
  switch (e) {
    case "dots":
      return Xs.Dots;
    case "lines":
      return Xs.Lines;
    case "cross":
      return Xs.Cross;
    default:
      Pt(e);
  }
}
function XC({ background: e }) {
  return typeof e == "string" ? /* @__PURE__ */ d(Vu, { variant: YC(e), size: 2, gap: 20 }) : /* @__PURE__ */ d(Vu, { ...e });
}
var Ke;
((e) => {
  const n = (l, c) => l.data.dimmed === c ? l : {
    ...l,
    data: {
      ...l.data,
      dimmed: c
    }
  };
  function i(l, c) {
    return c !== void 0 ? n(l, c) : (u) => n(u, l);
  }
  e.setDimmed = i;
  const r = (l, c) => l.data.hovered === c ? l : {
    ...l,
    data: {
      ...l.data,
      hovered: c
    }
  };
  function o(l, c) {
    return c !== void 0 ? r(l, c) : (u) => r(u, l);
  }
  e.setHovered = o;
  function s(l, c) {
    return MS(l.data, c) ? l : {
      ...l,
      data: {
        ...l.data,
        ...c
      }
    };
  }
  function a(l, c) {
    return c !== void 0 ? s(l, c) : (u) => s(u, l);
  }
  e.setData = a;
})(Ke || (Ke = {}));
const Hc = ({
  nodes: e,
  edges: n,
  onEdgesChange: i,
  onNodesChange: r,
  className: o,
  pannable: s = !0,
  zoomable: a = !0,
  nodesSelectable: l = !0,
  nodesDraggable: c = !1,
  background: u = "dots",
  children: f,
  colorMode: h = "system",
  fitViewPadding: p = 0,
  fitView: m = !0,
  zoomOnDoubleClick: g = !1,
  onViewportResize: y,
  ...v
}) => {
  const w = u !== "transparent" && u !== "solid", x = Xg();
  return /* @__PURE__ */ b(
    _1,
    {
      colorMode: h,
      nodes: e,
      edges: n,
      className: j(
        $C,
        s !== !0 && zC,
        u === "transparent" && OC,
        o
      ),
      "data-likec4-zoom-small": x,
      zoomOnPinch: a,
      zoomOnScroll: !s && a,
      ...!a && {
        zoomActivationKeyCode: null
      },
      zoomOnDoubleClick: g,
      maxZoom: a ? IC : 1,
      minZoom: a ? Rn : 1,
      fitView: m,
      fitViewOptions: ce(() => ({
        minZoom: Rn,
        maxZoom: 1,
        padding: p,
        includeHiddenNodes: !1
      }), [p]),
      preventScrolling: a || s,
      defaultMarkerColor: "var(--xy-edge-stroke)",
      noDragClassName: "nodrag",
      noPanClassName: "nopan",
      panOnScroll: s,
      panOnDrag: s,
      ...!s && {
        selectionKeyCode: null
      },
      elementsSelectable: l,
      nodesFocusable: c || l,
      edgesFocusable: !1,
      nodesDraggable: c,
      nodeDragThreshold: 4,
      nodeClickDistance: 1.9,
      paneClickDistance: 1.9,
      elevateNodesOnSelect: !1,
      selectNodesOnDrag: !1,
      onNodesChange: r,
      onEdgesChange: i,
      onNodeMouseEnter: q((k, _) => {
        r([{
          id: _.id,
          type: "replace",
          item: Ke.setHovered(_, !0)
        }]);
      }),
      onNodeMouseLeave: q((k, _) => {
        r([{
          id: _.id,
          type: "replace",
          item: Ke.setHovered(_, !1)
        }]);
      }),
      onEdgeMouseEnter: q((k, _) => {
        i([{
          id: _.id,
          type: "replace",
          item: Ke.setHovered(_, !0)
        }]);
      }),
      onEdgeMouseLeave: q((k, _) => {
        i([{
          id: _.id,
          type: "replace",
          item: Ke.setHovered(_, !1)
        }]);
      }),
      onNodeDoubleClick: Ee,
      onEdgeDoubleClick: Ee,
      ...v,
      children: [
        w && /* @__PURE__ */ d(XC, { background: u }),
        /* @__PURE__ */ d(KC, { onViewportResize: y }),
        f
      ]
    }
  );
}, KC = ({
  onViewportResize: e
}) => {
  const n = ds();
  return C1({
    onEnd: ({ x: i, y: r, zoom: o }) => {
      const s = Math.round(i), a = Math.round(r);
      (i !== s || r !== a) && n.setState({ transform: [s, a, o] });
    }
  }), /* @__PURE__ */ d(H, { children: e && /* @__PURE__ */ d(JC, { onViewportResize: e }) });
}, ZC = ({ width: e, height: n }) => ({ width: e, height: n }), JC = ({
  onViewportResize: e
}) => {
  const { width: n, height: i } = Ll(ZC);
  return Nn(e, [n, i]), /* @__PURE__ */ d(H, {});
};
function QC() {
  if (typeof globalThis < "u")
    return globalThis;
  if (typeof self < "u")
    return self;
  if (typeof window < "u")
    return window;
  if (typeof global < "u")
    return global;
}
function eE() {
  const e = QC();
  if (e.__xstate__)
    return e.__xstate__;
}
const tE = (e) => {
  if (typeof window > "u")
    return;
  const n = eE();
  n && n.register(e);
};
class Ih {
  constructor(n) {
    this._process = n, this._active = !1, this._current = null, this._last = null;
  }
  start() {
    this._active = !0, this.flush();
  }
  clear() {
    this._current && (this._current.next = null, this._last = this._current);
  }
  enqueue(n) {
    const i = {
      value: n,
      next: null
    };
    if (this._current) {
      this._last.next = i, this._last = i;
      return;
    }
    this._current = i, this._last = i, this._active && this.flush();
  }
  flush() {
    for (; this._current; ) {
      const n = this._current;
      this._process(n.value), this._current = n.next;
    }
    this._last = null;
  }
}
const Qg = ".", nE = "", ey = "", iE = "#", rE = "*", ty = "xstate.init", oE = "xstate.error", jr = "xstate.stop";
function sE(e, n) {
  return {
    type: `xstate.after.${e}.${n}`
  };
}
function tl(e, n) {
  return {
    type: `xstate.done.state.${e}`,
    output: n
  };
}
function aE(e, n) {
  return {
    type: `xstate.done.actor.${e}`,
    output: n,
    actorId: e
  };
}
function ny(e, n) {
  return {
    type: `xstate.error.actor.${e}`,
    error: n,
    actorId: e
  };
}
function iy(e) {
  return {
    type: ty,
    input: e
  };
}
function zt(e) {
  setTimeout(() => {
    throw e;
  });
}
const lE = typeof Symbol == "function" && Symbol.observable || "@@observable";
function ry(e, n) {
  const i = Dh(e), r = Dh(n);
  return typeof r == "string" ? typeof i == "string" ? r === i : !1 : typeof i == "string" ? i in r : Object.keys(i).every((o) => o in r ? ry(i[o], r[o]) : !1);
}
function qc(e) {
  if (sy(e))
    return e;
  const n = [];
  let i = "";
  for (let r = 0; r < e.length; r++) {
    switch (e.charCodeAt(r)) {
      case 92:
        i += e[r + 1], r++;
        continue;
      case 46:
        n.push(i), i = "";
        continue;
    }
    i += e[r];
  }
  return n.push(i), n;
}
function Dh(e) {
  if (HE(e))
    return e.value;
  if (typeof e != "string")
    return e;
  const n = qc(e);
  return cE(n);
}
function cE(e) {
  if (e.length === 1)
    return e[0];
  const n = {};
  let i = n;
  for (let r = 0; r < e.length - 1; r++)
    if (r === e.length - 2)
      i[e[r]] = e[r + 1];
    else {
      const o = i;
      i = {}, o[e[r]] = i;
    }
  return n;
}
function Nh(e, n) {
  const i = {}, r = Object.keys(e);
  for (let o = 0; o < r.length; o++) {
    const s = r[o];
    i[s] = n(e[s], s, e, o);
  }
  return i;
}
function oy(e) {
  return sy(e) ? e : [e];
}
function Wt(e) {
  return e === void 0 ? [] : oy(e);
}
function nl(e, n, i, r) {
  return typeof e == "function" ? e({
    context: n,
    event: i,
    self: r
  }) : e;
}
function sy(e) {
  return Array.isArray(e);
}
function uE(e) {
  return e.type.startsWith("xstate.error.actor");
}
function ri(e) {
  return oy(e).map((n) => typeof n > "u" || typeof n == "string" ? {
    target: n
  } : n);
}
function ay(e) {
  if (!(e === void 0 || e === nE))
    return Wt(e);
}
function Uo(e, n, i) {
  const r = typeof e == "object", o = r ? e : void 0;
  return {
    next: (r ? e.next : e)?.bind(o),
    error: (r ? e.error : n)?.bind(o),
    complete: (r ? e.complete : i)?.bind(o)
  };
}
function Rh(e, n) {
  return `${n}.${e}`;
}
function Gc(e, n) {
  const i = n.match(/^xstate\.invoke\.(\d+)\.(.*)/);
  if (!i)
    return e.implementations.actors[n];
  const [, r, o] = i, a = e.getStateNodeById(o).config.invoke;
  return (Array.isArray(a) ? a[r] : a).src;
}
function Lh(e, n) {
  return `${e.sessionId}.${n}`;
}
let dE = 0;
function hE(e, n) {
  const i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new WeakMap(), s = /* @__PURE__ */ new Set(), a = {}, {
    clock: l,
    logger: c
  } = n, u = {
    schedule: (p, m, g, y, v = Math.random().toString(36).slice(2)) => {
      const w = {
        source: p,
        target: m,
        event: g,
        delay: y,
        id: v,
        startedAt: Date.now()
      }, x = Lh(p, v);
      h._snapshot._scheduledEvents[x] = w;
      const k = l.setTimeout(() => {
        delete a[x], delete h._snapshot._scheduledEvents[x], h._relay(p, m, g);
      }, y);
      a[x] = k;
    },
    cancel: (p, m) => {
      const g = Lh(p, m), y = a[g];
      delete a[g], delete h._snapshot._scheduledEvents[g], y !== void 0 && l.clearTimeout(y);
    },
    cancelAll: (p) => {
      for (const m in h._snapshot._scheduledEvents) {
        const g = h._snapshot._scheduledEvents[m];
        g.source === p && u.cancel(p, g.id);
      }
    }
  }, f = (p) => {
    if (!s.size)
      return;
    const m = {
      ...p,
      rootId: e.sessionId
    };
    s.forEach((g) => g.next?.(m));
  }, h = {
    _snapshot: {
      _scheduledEvents: (n?.snapshot && n.snapshot.scheduler) ?? {}
    },
    _bookId: () => `x:${dE++}`,
    _register: (p, m) => (i.set(p, m), p),
    _unregister: (p) => {
      i.delete(p.sessionId);
      const m = o.get(p);
      m !== void 0 && (r.delete(m), o.delete(p));
    },
    get: (p) => r.get(p),
    _set: (p, m) => {
      const g = r.get(p);
      if (g && g !== m)
        throw new Error(`Actor with system ID '${p}' already exists.`);
      r.set(p, m), o.set(m, p);
    },
    inspect: (p) => {
      const m = Uo(p);
      return s.add(m), {
        unsubscribe() {
          s.delete(m);
        }
      };
    },
    _sendInspectionEvent: f,
    _relay: (p, m, g) => {
      h._sendInspectionEvent({
        type: "@xstate.event",
        sourceRef: p,
        actorRef: m,
        event: g
      }), m._send(g);
    },
    scheduler: u,
    getSnapshot: () => ({
      _scheduledEvents: {
        ...h._snapshot._scheduledEvents
      }
    }),
    start: () => {
      const p = h._snapshot._scheduledEvents;
      h._snapshot._scheduledEvents = {};
      for (const m in p) {
        const {
          source: g,
          target: y,
          event: v,
          delay: w,
          id: x
        } = p[m];
        u.schedule(g, y, v, w, x);
      }
    },
    _clock: l,
    _logger: c
  };
  return h;
}
let da = !1;
const Uc = 1;
let Ue = /* @__PURE__ */ function(e) {
  return e[e.NotStarted = 0] = "NotStarted", e[e.Running = 1] = "Running", e[e.Stopped = 2] = "Stopped", e;
}({});
const fE = {
  clock: {
    setTimeout: (e, n) => setTimeout(e, n),
    clearTimeout: (e) => clearTimeout(e)
  },
  logger: console.log.bind(console),
  devTools: !1
};
class pE {
  /**
   * Creates a new actor instance for the given logic with the provided options,
   * if any.
   *
   * @param logic The logic to create an actor from
   * @param options Actor options
   */
  constructor(n, i) {
    this.logic = n, this._snapshot = void 0, this.clock = void 0, this.options = void 0, this.id = void 0, this.mailbox = new Ih(this._process.bind(this)), this.observers = /* @__PURE__ */ new Set(), this.eventListeners = /* @__PURE__ */ new Map(), this.logger = void 0, this._processingStatus = Ue.NotStarted, this._parent = void 0, this._syncSnapshot = void 0, this.ref = void 0, this._actorScope = void 0, this._systemId = void 0, this.sessionId = void 0, this.system = void 0, this._doneEvent = void 0, this.src = void 0, this._deferred = [];
    const r = {
      ...fE,
      ...i
    }, {
      clock: o,
      logger: s,
      parent: a,
      syncSnapshot: l,
      id: c,
      systemId: u,
      inspect: f
    } = r;
    this.system = a ? a.system : hE(this, {
      clock: o,
      logger: s
    }), f && !a && this.system.inspect(Uo(f)), this.sessionId = this.system._bookId(), this.id = c ?? this.sessionId, this.logger = i?.logger ?? this.system._logger, this.clock = i?.clock ?? this.system._clock, this._parent = a, this._syncSnapshot = l, this.options = r, this.src = r.src ?? n, this.ref = this, this._actorScope = {
      self: this,
      id: this.id,
      sessionId: this.sessionId,
      logger: this.logger,
      defer: (h) => {
        this._deferred.push(h);
      },
      system: this.system,
      stopChild: (h) => {
        if (h._parent !== this)
          throw new Error(`Cannot stop child actor ${h.id} of ${this.id} because it is not a child`);
        h._stop();
      },
      emit: (h) => {
        const p = this.eventListeners.get(h.type), m = this.eventListeners.get("*");
        if (!p && !m)
          return;
        const g = [...p ? p.values() : [], ...m ? m.values() : []];
        for (const y of g)
          y(h);
      },
      actionExecutor: (h) => {
        const p = () => {
          if (this._actorScope.system._sendInspectionEvent({
            type: "@xstate.action",
            actorRef: this,
            action: {
              type: h.type,
              params: h.params
            }
          }), !h.exec)
            return;
          const m = da;
          try {
            da = !0, h.exec(h.info, h.params);
          } finally {
            da = m;
          }
        };
        this._processingStatus === Ue.Running ? p() : this._deferred.push(p);
      }
    }, this.send = this.send.bind(this), this.system._sendInspectionEvent({
      type: "@xstate.actor",
      actorRef: this
    }), u && (this._systemId = u, this.system._set(u, this)), this._initState(i?.snapshot ?? i?.state), u && this._snapshot.status !== "active" && this.system._unregister(this);
  }
  _initState(n) {
    try {
      this._snapshot = n ? this.logic.restoreSnapshot ? this.logic.restoreSnapshot(n, this._actorScope) : n : this.logic.getInitialSnapshot(this._actorScope, this.options?.input);
    } catch (i) {
      this._snapshot = {
        status: "error",
        output: void 0,
        error: i
      };
    }
  }
  update(n, i) {
    this._snapshot = n;
    let r;
    for (; r = this._deferred.shift(); )
      try {
        r();
      } catch (o) {
        this._deferred.length = 0, this._snapshot = {
          ...n,
          status: "error",
          error: o
        };
      }
    switch (this._snapshot.status) {
      case "active":
        for (const o of this.observers)
          try {
            o.next?.(n);
          } catch (s) {
            zt(s);
          }
        break;
      case "done":
        for (const o of this.observers)
          try {
            o.next?.(n);
          } catch (s) {
            zt(s);
          }
        this._stopProcedure(), this._complete(), this._doneEvent = aE(this.id, this._snapshot.output), this._parent && this.system._relay(this, this._parent, this._doneEvent);
        break;
      case "error":
        this._error(this._snapshot.error);
        break;
    }
    this.system._sendInspectionEvent({
      type: "@xstate.snapshot",
      actorRef: this,
      event: i,
      snapshot: n
    });
  }
  /**
   * Subscribe an observer to an actors snapshot values.
   *
   * @remarks
   * The observer will receive the actors snapshot value when it is emitted.
   * The observer can be:
   *
   * - A plain function that receives the latest snapshot, or
   * - An observer object whose `.next(snapshot)` method receives the latest
   *   snapshot
   *
   * @example
   *
   * ```ts
   * // Observer as a plain function
   * const subscription = actor.subscribe((snapshot) => {
   *   console.log(snapshot);
   * });
   * ```
   *
   * @example
   *
   * ```ts
   * // Observer as an object
   * const subscription = actor.subscribe({
   *   next(snapshot) {
   *     console.log(snapshot);
   *   },
   *   error(err) {
   *     // ...
   *   },
   *   complete() {
   *     // ...
   *   }
   * });
   * ```
   *
   * The return value of `actor.subscribe(observer)` is a subscription object
   * that has an `.unsubscribe()` method. You can call
   * `subscription.unsubscribe()` to unsubscribe the observer:
   *
   * @example
   *
   * ```ts
   * const subscription = actor.subscribe((snapshot) => {
   *   // ...
   * });
   *
   * // Unsubscribe the observer
   * subscription.unsubscribe();
   * ```
   *
   * When the actor is stopped, all of its observers will automatically be
   * unsubscribed.
   *
   * @param observer - Either a plain function that receives the latest
   *   snapshot, or an observer object whose `.next(snapshot)` method receives
   *   the latest snapshot
   */
  subscribe(n, i, r) {
    const o = Uo(n, i, r);
    if (this._processingStatus !== Ue.Stopped)
      this.observers.add(o);
    else
      switch (this._snapshot.status) {
        case "done":
          try {
            o.complete?.();
          } catch (s) {
            zt(s);
          }
          break;
        case "error": {
          const s = this._snapshot.error;
          if (!o.error)
            zt(s);
          else
            try {
              o.error(s);
            } catch (a) {
              zt(a);
            }
          break;
        }
      }
    return {
      unsubscribe: () => {
        this.observers.delete(o);
      }
    };
  }
  on(n, i) {
    let r = this.eventListeners.get(n);
    r || (r = /* @__PURE__ */ new Set(), this.eventListeners.set(n, r));
    const o = i.bind(void 0);
    return r.add(o), {
      unsubscribe: () => {
        r.delete(o);
      }
    };
  }
  /** Starts the Actor from the initial state */
  start() {
    if (this._processingStatus === Ue.Running)
      return this;
    this._syncSnapshot && this.subscribe({
      next: (r) => {
        r.status === "active" && this.system._relay(this, this._parent, {
          type: `xstate.snapshot.${this.id}`,
          snapshot: r
        });
      },
      error: () => {
      }
    }), this.system._register(this.sessionId, this), this._systemId && this.system._set(this._systemId, this), this._processingStatus = Ue.Running;
    const n = iy(this.options.input);
    switch (this.system._sendInspectionEvent({
      type: "@xstate.event",
      sourceRef: this._parent,
      actorRef: this,
      event: n
    }), this._snapshot.status) {
      case "done":
        return this.update(this._snapshot, n), this;
      case "error":
        return this._error(this._snapshot.error), this;
    }
    if (this._parent || this.system.start(), this.logic.start)
      try {
        this.logic.start(this._snapshot, this._actorScope);
      } catch (r) {
        return this._snapshot = {
          ...this._snapshot,
          status: "error",
          error: r
        }, this._error(r), this;
      }
    return this.update(this._snapshot, n), this.options.devTools && this.attachDevTools(), this.mailbox.start(), this;
  }
  _process(n) {
    let i, r;
    try {
      i = this.logic.transition(this._snapshot, n, this._actorScope);
    } catch (o) {
      r = {
        err: o
      };
    }
    if (r) {
      const {
        err: o
      } = r;
      this._snapshot = {
        ...this._snapshot,
        status: "error",
        error: o
      }, this._error(o);
      return;
    }
    this.update(i, n), n.type === jr && (this._stopProcedure(), this._complete());
  }
  _stop() {
    return this._processingStatus === Ue.Stopped ? this : (this.mailbox.clear(), this._processingStatus === Ue.NotStarted ? (this._processingStatus = Ue.Stopped, this) : (this.mailbox.enqueue({
      type: jr
    }), this));
  }
  /** Stops the Actor and unsubscribe all listeners. */
  stop() {
    if (this._parent)
      throw new Error("A non-root actor cannot be stopped directly.");
    return this._stop();
  }
  _complete() {
    for (const n of this.observers)
      try {
        n.complete?.();
      } catch (i) {
        zt(i);
      }
    this.observers.clear();
  }
  _reportError(n) {
    if (!this.observers.size) {
      this._parent || zt(n);
      return;
    }
    let i = !1;
    for (const r of this.observers) {
      const o = r.error;
      i ||= !o;
      try {
        o?.(n);
      } catch (s) {
        zt(s);
      }
    }
    this.observers.clear(), i && zt(n);
  }
  _error(n) {
    this._stopProcedure(), this._reportError(n), this._parent && this.system._relay(this, this._parent, ny(this.id, n));
  }
  // TODO: atm children don't belong entirely to the actor so
  // in a way - it's not even super aware of them
  // so we can't stop them from here but we really should!
  // right now, they are being stopped within the machine's transition
  // but that could throw and leave us with "orphaned" active actors
  _stopProcedure() {
    return this._processingStatus !== Ue.Running ? this : (this.system.scheduler.cancelAll(this), this.mailbox.clear(), this.mailbox = new Ih(this._process.bind(this)), this._processingStatus = Ue.Stopped, this.system._unregister(this), this);
  }
  /** @internal */
  _send(n) {
    this._processingStatus !== Ue.Stopped && this.mailbox.enqueue(n);
  }
  /**
   * Sends an event to the running Actor to trigger a transition.
   *
   * @param event The event to send
   */
  send(n) {
    this.system._relay(void 0, this, n);
  }
  attachDevTools() {
    const {
      devTools: n
    } = this.options;
    n && (typeof n == "function" ? n : tE)(this);
  }
  toJSON() {
    return {
      xstate$$type: Uc,
      id: this.id
    };
  }
  /**
   * Obtain the internal state of the actor, which can be persisted.
   *
   * @remarks
   * The internal state can be persisted from any actor, not only machines.
   *
   * Note that the persisted state is not the same as the snapshot from
   * {@link Actor.getSnapshot}. Persisted state represents the internal state of
   * the actor, while snapshots represent the actor's last emitted value.
   *
   * Can be restored with {@link ActorOptions.state}
   * @see https://stately.ai/docs/persistence
   */
  getPersistedSnapshot(n) {
    return this.logic.getPersistedSnapshot(this._snapshot, n);
  }
  [lE]() {
    return this;
  }
  /**
   * Read an actors snapshot synchronously.
   *
   * @remarks
   * The snapshot represent an actor's last emitted value.
   *
   * When an actor receives an event, its internal state may change. An actor
   * may emit a snapshot when a state transition occurs.
   *
   * Note that some actors, such as callback actors generated with
   * `fromCallback`, will not emit snapshots.
   * @see {@link Actor.subscribe} to subscribe to an actors snapshot values.
   * @see {@link Actor.getPersistedSnapshot} to persist the internal state of an actor (which is more than just a snapshot).
   */
  getSnapshot() {
    return this._snapshot;
  }
}
function Ti(e, ...[n]) {
  return new pE(e, n);
}
function mE(e, n, i, r, {
  sendId: o
}) {
  const s = typeof o == "function" ? o(i, r) : o;
  return [n, {
    sendId: s
  }, void 0];
}
function gE(e, n) {
  e.defer(() => {
    e.system.scheduler.cancel(e.self, n.sendId);
  });
}
function so(e) {
  function n(i, r) {
  }
  return n.type = "xstate.cancel", n.sendId = e, n.resolve = mE, n.execute = gE, n;
}
function yE(e, n, i, r, {
  id: o,
  systemId: s,
  src: a,
  input: l,
  syncSnapshot: c
}) {
  const u = typeof a == "string" ? Gc(n.machine, a) : a, f = typeof o == "function" ? o(i) : o;
  let h, p;
  return u && (p = typeof l == "function" ? l({
    context: n.context,
    event: i.event,
    self: e.self
  }) : l, h = Ti(u, {
    id: f,
    src: a,
    parent: e.self,
    syncSnapshot: c,
    systemId: s,
    input: p
  })), [Ln(n, {
    children: {
      ...n.children,
      [f]: h
    }
  }), {
    id: o,
    systemId: s,
    actorRef: h,
    src: a,
    input: p
  }, void 0];
}
function vE(e, {
  actorRef: n
}) {
  n && e.defer(() => {
    n._processingStatus !== Ue.Stopped && n.start();
  });
}
function ao(...[e, {
  id: n,
  systemId: i,
  input: r,
  syncSnapshot: o = !1
} = {}]) {
  function s(a, l) {
  }
  return s.type = "xstate.spawnChild", s.id = n, s.systemId = i, s.src = e, s.input = r, s.syncSnapshot = o, s.resolve = yE, s.execute = vE, s;
}
function wE(e, n, i, r, {
  actorRef: o
}) {
  const s = typeof o == "function" ? o(i, r) : o, a = typeof s == "string" ? n.children[s] : s;
  let l = n.children;
  return a && (l = {
    ...l
  }, delete l[a.id]), [Ln(n, {
    children: l
  }), a, void 0];
}
function xE(e, n) {
  if (n) {
    if (e.system._unregister(n), n._processingStatus !== Ue.Running) {
      e.stopChild(n);
      return;
    }
    e.defer(() => {
      e.stopChild(n);
    });
  }
}
function Wi(e) {
  function n(i, r) {
  }
  return n.type = "xstate.stopChild", n.actorRef = e, n.resolve = wE, n.execute = xE, n;
}
function bE(e, {
  context: n,
  event: i
}, {
  guards: r
}) {
  return r.every((o) => Hi(o, n, i, e));
}
function kE(e) {
  function n(i, r) {
    return !1;
  }
  return n.check = bE, n.guards = e, n;
}
function SE(e, {
  context: n,
  event: i
}, {
  guards: r
}) {
  return r.some((o) => Hi(o, n, i, e));
}
function _E(e) {
  function n(i, r) {
    return !1;
  }
  return n.check = SE, n.guards = e, n;
}
function Hi(e, n, i, r) {
  const {
    machine: o
  } = r, s = typeof e == "function", a = s ? e : o.implementations.guards[typeof e == "string" ? e : e.type];
  if (!s && !a)
    throw new Error(`Guard '${typeof e == "string" ? e : e.type}' is not implemented.'.`);
  if (typeof a != "function")
    return Hi(a, n, i, r);
  const l = {
    context: n,
    event: i
  }, c = s || typeof e == "string" ? void 0 : "params" in e ? typeof e.params == "function" ? e.params({
    context: n,
    event: i
  }) : e.params : void 0;
  return "check" in a ? a.check(
    r,
    l,
    a
    // this holds all params
  ) : a(l, c);
}
const Yc = (e) => e.type === "atomic" || e.type === "final";
function Mi(e) {
  return Object.values(e.states).filter((n) => n.type !== "history");
}
function lo(e, n) {
  const i = [];
  if (n === e)
    return i;
  let r = e.parent;
  for (; r && r !== n; )
    i.push(r), r = r.parent;
  return i;
}
function Yo(e) {
  const n = new Set(e), i = cy(n);
  for (const r of n)
    if (r.type === "compound" && (!i.get(r) || !i.get(r).length))
      $h(r).forEach((o) => n.add(o));
    else if (r.type === "parallel") {
      for (const o of Mi(r))
        if (o.type !== "history" && !n.has(o)) {
          const s = $h(o);
          for (const a of s)
            n.add(a);
        }
    }
  for (const r of n) {
    let o = r.parent;
    for (; o; )
      n.add(o), o = o.parent;
  }
  return n;
}
function ly(e, n) {
  const i = n.get(e);
  if (!i)
    return {};
  if (e.type === "compound") {
    const o = i[0];
    if (o) {
      if (Yc(o))
        return o.key;
    } else
      return {};
  }
  const r = {};
  for (const o of i)
    r[o.key] = ly(o, n);
  return r;
}
function cy(e) {
  const n = /* @__PURE__ */ new Map();
  for (const i of e)
    n.has(i) || n.set(i, []), i.parent && (n.has(i.parent) || n.set(i.parent, []), n.get(i.parent).push(i));
  return n;
}
function uy(e, n) {
  const i = Yo(n);
  return ly(e, cy(i));
}
function Xc(e, n) {
  return n.type === "compound" ? Mi(n).some((i) => i.type === "final" && e.has(i)) : n.type === "parallel" ? Mi(n).every((i) => Xc(e, i)) : n.type === "final";
}
const Ps = (e) => e[0] === iE;
function CE(e, n) {
  return e.transitions.get(n) || [...e.transitions.keys()].filter((r) => {
    if (r === rE)
      return !0;
    if (!r.endsWith(".*"))
      return !1;
    const o = r.split("."), s = n.split(".");
    for (let a = 0; a < o.length; a++) {
      const l = o[a], c = s[a];
      if (l === "*")
        return a === o.length - 1;
      if (l !== c)
        return !1;
    }
    return !0;
  }).sort((r, o) => o.length - r.length).flatMap((r) => e.transitions.get(r));
}
function EE(e) {
  const n = e.config.after;
  if (!n)
    return [];
  const i = (o) => {
    const s = sE(o, e.id), a = s.type;
    return e.entry.push(Be(s, {
      id: a,
      delay: o
    })), e.exit.push(so(a)), a;
  };
  return Object.keys(n).flatMap((o) => {
    const s = n[o], a = typeof s == "string" ? {
      target: s
    } : s, l = Number.isNaN(+o) ? o : +o, c = i(l);
    return Wt(a).map((u) => ({
      ...u,
      event: c,
      delay: l
    }));
  }).map((o) => {
    const {
      delay: s
    } = o;
    return {
      ...vn(e, o.event, o),
      delay: s
    };
  });
}
function vn(e, n, i) {
  const r = ay(i.target), o = i.reenter ?? !1, s = ME(e, r), a = {
    ...i,
    actions: Wt(i.actions),
    guard: i.guard,
    target: s,
    source: e,
    reenter: o,
    eventType: n,
    toJSON: () => ({
      ...a,
      source: `#${e.id}`,
      target: s ? s.map((l) => `#${l.id}`) : void 0
    })
  };
  return a;
}
function PE(e) {
  const n = /* @__PURE__ */ new Map();
  if (e.config.on)
    for (const i of Object.keys(e.config.on)) {
      if (i === ey)
        throw new Error('Null events ("") cannot be specified as a transition key. Use `always: { ... }` instead.');
      const r = e.config.on[i];
      n.set(i, ri(r).map((o) => vn(e, i, o)));
    }
  if (e.config.onDone) {
    const i = `xstate.done.state.${e.id}`;
    n.set(i, ri(e.config.onDone).map((r) => vn(e, i, r)));
  }
  for (const i of e.invoke) {
    if (i.onDone) {
      const r = `xstate.done.actor.${i.id}`;
      n.set(r, ri(i.onDone).map((o) => vn(e, r, o)));
    }
    if (i.onError) {
      const r = `xstate.error.actor.${i.id}`;
      n.set(r, ri(i.onError).map((o) => vn(e, r, o)));
    }
    if (i.onSnapshot) {
      const r = `xstate.snapshot.${i.id}`;
      n.set(r, ri(i.onSnapshot).map((o) => vn(e, r, o)));
    }
  }
  for (const i of e.after) {
    let r = n.get(i.eventType);
    r || (r = [], n.set(i.eventType, r)), r.push(i);
  }
  return n;
}
function TE(e, n) {
  const i = typeof n == "string" ? e.states[n] : n ? e.states[n.target] : void 0;
  if (!i && n)
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions, @typescript-eslint/no-base-to-string
      `Initial state node "${n}" not found on parent state node #${e.id}`
    );
  const r = {
    source: e,
    actions: !n || typeof n == "string" ? [] : Wt(n.actions),
    eventType: null,
    reenter: !1,
    target: i ? [i] : [],
    toJSON: () => ({
      ...r,
      source: `#${e.id}`,
      target: i ? [`#${i.id}`] : []
    })
  };
  return r;
}
function ME(e, n) {
  if (n !== void 0)
    return n.map((i) => {
      if (typeof i != "string")
        return i;
      if (Ps(i))
        return e.machine.getStateNodeById(i);
      const r = i[0] === Qg;
      if (r && !e.parent)
        return Xo(e, i.slice(1));
      const o = r ? e.key + i : i;
      if (e.parent)
        try {
          return Xo(e.parent, o);
        } catch (s) {
          throw new Error(`Invalid transition definition for state node '${e.id}':
${s.message}`);
        }
      else
        throw new Error(`Invalid target: "${i}" is not a valid target from the root node. Did you mean ".${i}"?`);
    });
}
function dy(e) {
  const n = ay(e.config.target);
  return n ? {
    target: n.map((i) => typeof i == "string" ? Xo(e.parent, i) : i)
  } : e.parent.initial;
}
function kn(e) {
  return e.type === "history";
}
function $h(e) {
  const n = hy(e);
  for (const i of n)
    for (const r of lo(i, e))
      n.add(r);
  return n;
}
function hy(e) {
  const n = /* @__PURE__ */ new Set();
  function i(r) {
    if (!n.has(r)) {
      if (n.add(r), r.type === "compound")
        i(r.initial.target[0]);
      else if (r.type === "parallel")
        for (const o of Mi(r))
          i(o);
    }
  }
  return i(e), n;
}
function Ai(e, n) {
  if (Ps(n))
    return e.machine.getStateNodeById(n);
  if (!e.states)
    throw new Error(`Unable to retrieve child state '${n}' from '${e.id}'; no child states exist.`);
  const i = e.states[n];
  if (!i)
    throw new Error(`Child state '${n}' does not exist on '${e.id}'`);
  return i;
}
function Xo(e, n) {
  if (typeof n == "string" && Ps(n))
    try {
      return e.machine.getStateNodeById(n);
    } catch {
    }
  const i = qc(n).slice();
  let r = e;
  for (; i.length; ) {
    const o = i.shift();
    if (!o.length)
      break;
    r = Ai(r, o);
  }
  return r;
}
function Ko(e, n) {
  if (typeof n == "string") {
    const o = e.states[n];
    if (!o)
      throw new Error(`State '${n}' does not exist on '${e.id}'`);
    return [e, o];
  }
  const i = Object.keys(n), r = i.map((o) => Ai(e, o)).filter(Boolean);
  return [e.machine.root, e].concat(r, i.reduce((o, s) => {
    const a = Ai(e, s);
    if (!a)
      return o;
    const l = Ko(a, n[s]);
    return o.concat(l);
  }, []));
}
function AE(e, n, i, r) {
  const s = Ai(e, n).next(i, r);
  return !s || !s.length ? e.next(i, r) : s;
}
function IE(e, n, i, r) {
  const o = Object.keys(n), s = Ai(e, o[0]), a = Kc(s, n[o[0]], i, r);
  return !a || !a.length ? e.next(i, r) : a;
}
function DE(e, n, i, r) {
  const o = [];
  for (const s of Object.keys(n)) {
    const a = n[s];
    if (!a)
      continue;
    const l = Ai(e, s), c = Kc(l, a, i, r);
    c && o.push(...c);
  }
  return o.length ? o : e.next(i, r);
}
function Kc(e, n, i, r) {
  return typeof n == "string" ? AE(e, n, i, r) : Object.keys(n).length === 1 ? IE(e, n, i, r) : DE(e, n, i, r);
}
function NE(e) {
  return Object.keys(e.states).map((n) => e.states[n]).filter((n) => n.type === "history");
}
function sn(e, n) {
  let i = e;
  for (; i.parent && i.parent !== n; )
    i = i.parent;
  return i.parent === n;
}
function RE(e, n) {
  const i = new Set(e), r = new Set(n);
  for (const o of i)
    if (r.has(o))
      return !0;
  for (const o of r)
    if (i.has(o))
      return !0;
  return !1;
}
function fy(e, n, i) {
  const r = /* @__PURE__ */ new Set();
  for (const o of e) {
    let s = !1;
    const a = /* @__PURE__ */ new Set();
    for (const l of r)
      if (RE(il([o], n, i), il([l], n, i)))
        if (sn(o.source, l.source))
          a.add(l);
        else {
          s = !0;
          break;
        }
    if (!s) {
      for (const l of a)
        r.delete(l);
      r.add(o);
    }
  }
  return Array.from(r);
}
function LE(e) {
  const [n, ...i] = e;
  for (const r of lo(n, void 0))
    if (i.every((o) => sn(o, r)))
      return r;
}
function Zc(e, n) {
  if (!e.target)
    return [];
  const i = /* @__PURE__ */ new Set();
  for (const r of e.target)
    if (kn(r))
      if (n[r.id])
        for (const o of n[r.id])
          i.add(o);
      else
        for (const o of Zc(dy(r), n))
          i.add(o);
    else
      i.add(r);
  return [...i];
}
function py(e, n) {
  const i = Zc(e, n);
  if (!i)
    return;
  if (!e.reenter && i.every((o) => o === e.source || sn(o, e.source)))
    return e.source;
  const r = LE(i.concat(e.source));
  if (r)
    return r;
  if (!e.reenter)
    return e.source.machine.root;
}
function il(e, n, i) {
  const r = /* @__PURE__ */ new Set();
  for (const o of e)
    if (o.target?.length) {
      const s = py(o, i);
      o.reenter && o.source === s && r.add(s);
      for (const a of n)
        sn(a, s) && r.add(a);
    }
  return [...r];
}
function $E(e, n) {
  if (e.length !== n.size)
    return !1;
  for (const i of e)
    if (!n.has(i))
      return !1;
  return !0;
}
function rl(e, n, i, r, o, s) {
  if (!e.length)
    return n;
  const a = new Set(n._nodes);
  let l = n.historyValue;
  const c = fy(e, a, l);
  let u = n;
  o || ([u, l] = BE(u, r, i, c, a, l, s, i.actionExecutor)), u = Ii(u, r, i, c.flatMap((h) => h.actions), s, void 0), u = OE(u, r, i, c, a, s, l, o);
  const f = [...a];
  u.status === "done" && (u = Ii(u, r, i, f.sort((h, p) => p.order - h.order).flatMap((h) => h.exit), s, void 0));
  try {
    return l === n.historyValue && $E(n._nodes, a) ? u : Ln(u, {
      _nodes: f,
      historyValue: l
    });
  } catch (h) {
    throw h;
  }
}
function zE(e, n, i, r, o) {
  if (r.output === void 0)
    return;
  const s = tl(o.id, o.output !== void 0 && o.parent ? nl(o.output, e.context, n, i.self) : void 0);
  return nl(r.output, e.context, s, i.self);
}
function OE(e, n, i, r, o, s, a, l) {
  let c = e;
  const u = /* @__PURE__ */ new Set(), f = /* @__PURE__ */ new Set();
  VE(r, a, f, u), l && f.add(e.machine.root);
  const h = /* @__PURE__ */ new Set();
  for (const p of [...u].sort((m, g) => m.order - g.order)) {
    o.add(p);
    const m = [];
    m.push(...p.entry);
    for (const g of p.invoke)
      m.push(ao(g.src, {
        ...g,
        syncSnapshot: !!g.onSnapshot
      }));
    if (f.has(p)) {
      const g = p.initial.actions;
      m.push(...g);
    }
    if (c = Ii(c, n, i, m, s, p.invoke.map((g) => g.id)), p.type === "final") {
      const g = p.parent;
      let y = g?.type === "parallel" ? g : g?.parent, v = y || p;
      for (g?.type === "compound" && s.push(tl(g.id, p.output !== void 0 ? nl(p.output, c.context, n, i.self) : void 0)); y?.type === "parallel" && !h.has(y) && Xc(o, y); )
        h.add(y), s.push(tl(y.id)), v = y, y = y.parent;
      if (y)
        continue;
      c = Ln(c, {
        status: "done",
        output: zE(c, n, i, c.machine.root, v)
      });
    }
  }
  return c;
}
function VE(e, n, i, r) {
  for (const o of e) {
    const s = py(o, n);
    for (const l of o.target || [])
      !kn(l) && // if the target is different than the source then it will *definitely* be entered
      (o.source !== l || // we know that the domain can't lie within the source
      // if it's different than the source then it's outside of it and it means that the target has to be entered as well
      o.source !== s || // reentering transitions always enter the target, even if it's the source itself
      o.reenter) && (r.add(l), i.add(l)), di(l, n, i, r);
    const a = Zc(o, n);
    for (const l of a) {
      const c = lo(l, s);
      s?.type === "parallel" && c.push(s), my(r, n, i, c, !o.source.parent && o.reenter ? void 0 : s);
    }
  }
}
function di(e, n, i, r) {
  if (kn(e))
    if (n[e.id]) {
      const o = n[e.id];
      for (const s of o)
        r.add(s), di(s, n, i, r);
      for (const s of o)
        ha(s, e.parent, r, n, i);
    } else {
      const o = dy(e);
      for (const s of o.target)
        r.add(s), o === e.parent?.initial && i.add(e.parent), di(s, n, i, r);
      for (const s of o.target)
        ha(s, e.parent, r, n, i);
    }
  else if (e.type === "compound") {
    const [o] = e.initial.target;
    kn(o) || (r.add(o), i.add(o)), di(o, n, i, r), ha(o, e, r, n, i);
  } else if (e.type === "parallel")
    for (const o of Mi(e).filter((s) => !kn(s)))
      [...r].some((s) => sn(s, o)) || (kn(o) || (r.add(o), i.add(o)), di(o, n, i, r));
}
function my(e, n, i, r, o) {
  for (const s of r)
    if ((!o || sn(s, o)) && e.add(s), s.type === "parallel")
      for (const a of Mi(s).filter((l) => !kn(l)))
        [...e].some((l) => sn(l, a)) || (e.add(a), di(a, n, i, e));
}
function ha(e, n, i, r, o) {
  my(i, r, o, lo(e, n));
}
function BE(e, n, i, r, o, s, a, l) {
  let c = e;
  const u = il(r, o, s);
  u.sort((h, p) => p.order - h.order);
  let f;
  for (const h of u)
    for (const p of NE(h)) {
      let m;
      p.history === "deep" ? m = (g) => Yc(g) && sn(g, h) : m = (g) => g.parent === h, f ??= {
        ...s
      }, f[p.id] = Array.from(o).filter(m);
    }
  for (const h of u)
    c = Ii(c, n, i, [...h.exit, ...h.invoke.map((p) => Wi(p.id))], a, void 0), o.delete(h);
  return [c, f || s];
}
function jE(e, n) {
  return e.implementations.actions[n];
}
function gy(e, n, i, r, o, s) {
  const {
    machine: a
  } = e;
  let l = e;
  for (const c of r) {
    const u = typeof c == "function", f = u ? c : (
      // the existing type of `.actions` assumes non-nullable `TExpressionAction`
      // it's fine to cast this here to get a common type and lack of errors in the rest of the code
      // our logic below makes sure that we call those 2 "variants" correctly
      jE(a, typeof c == "string" ? c : c.type)
    ), h = {
      context: l.context,
      event: n,
      self: i.self,
      system: i.system
    }, p = u || typeof c == "string" ? void 0 : "params" in c ? typeof c.params == "function" ? c.params({
      context: l.context,
      event: n
    }) : c.params : void 0;
    if (!f || !("resolve" in f)) {
      i.actionExecutor({
        type: typeof c == "string" ? c : typeof c == "object" ? c.type : c.name || "(anonymous)",
        info: h,
        params: p,
        exec: f
      });
      continue;
    }
    const m = f, [g, y, v] = m.resolve(
      i,
      l,
      h,
      p,
      f,
      // this holds all params
      o
    );
    l = g, "retryResolve" in m && s?.push([m, y]), "execute" in m && i.actionExecutor({
      type: m.type,
      info: h,
      params: y,
      exec: m.execute.bind(null, i, y)
    }), v && (l = gy(l, n, i, v, o, s));
  }
  return l;
}
function Ii(e, n, i, r, o, s) {
  const a = s ? [] : void 0, l = gy(e, n, i, r, {
    internalQueue: o,
    deferredActorIds: s
  }, a);
  return a?.forEach(([c, u]) => {
    c.retryResolve(i, l, u);
  }), l;
}
function fa(e, n, i, r) {
  let o = e;
  const s = [];
  function a(u, f, h) {
    i.system._sendInspectionEvent({
      type: "@xstate.microstep",
      actorRef: i.self,
      event: f,
      snapshot: u,
      _transitions: h
    }), s.push(u);
  }
  if (n.type === jr)
    return o = Ln(zh(o, n, i), {
      status: "stopped"
    }), a(o, n, []), {
      snapshot: o,
      microstates: s
    };
  let l = n;
  if (l.type !== ty) {
    const u = l, f = uE(u), h = Oh(u, o);
    if (f && !h.length)
      return o = Ln(e, {
        status: "error",
        error: u.error
      }), a(o, u, []), {
        snapshot: o,
        microstates: s
      };
    o = rl(
      h,
      e,
      i,
      l,
      !1,
      // isInitial
      r
    ), a(o, u, h);
  }
  let c = !0;
  for (; o.status === "active"; ) {
    let u = c ? FE(o, l) : [];
    const f = u.length ? o : void 0;
    if (!u.length) {
      if (!r.length)
        break;
      l = r.shift(), u = Oh(l, o);
    }
    o = rl(u, o, i, l, !1, r), c = o !== f, a(o, l, u);
  }
  return o.status !== "active" && zh(o, l, i), {
    snapshot: o,
    microstates: s
  };
}
function zh(e, n, i) {
  return Ii(e, n, i, Object.values(e.children).map((r) => Wi(r)), [], void 0);
}
function Oh(e, n) {
  return n.machine.getTransitionData(n, e);
}
function FE(e, n) {
  const i = /* @__PURE__ */ new Set(), r = e._nodes.filter(Yc);
  for (const o of r)
    e: for (const s of [o].concat(lo(o, void 0)))
      if (s.always) {
        for (const a of s.always)
          if (a.guard === void 0 || Hi(a.guard, e.context, n, e)) {
            i.add(a);
            break e;
          }
      }
  return fy(Array.from(i), new Set(e._nodes), e.historyValue);
}
function WE(e, n) {
  const i = Yo(Ko(e, n));
  return uy(e, [...i]);
}
function HE(e) {
  return !!e && typeof e == "object" && "machine" in e && "value" in e;
}
const qE = function(n) {
  return ry(n, this.value);
}, GE = function(n) {
  return this.tags.has(n);
}, UE = function(n) {
  const i = this.machine.getTransitionData(this, n);
  return !!i?.length && // Check that at least one transition is not forbidden
  i.some((r) => r.target !== void 0 || r.actions.length);
}, YE = function() {
  const {
    _nodes: n,
    tags: i,
    machine: r,
    getMeta: o,
    toJSON: s,
    can: a,
    hasTag: l,
    matches: c,
    ...u
  } = this;
  return {
    ...u,
    tags: Array.from(i)
  };
}, XE = function() {
  return this._nodes.reduce((n, i) => (i.meta !== void 0 && (n[i.id] = i.meta), n), {});
};
function Do(e, n) {
  return {
    status: e.status,
    output: e.output,
    error: e.error,
    machine: n,
    context: e.context,
    _nodes: e._nodes,
    value: uy(n.root, e._nodes),
    tags: new Set(e._nodes.flatMap((i) => i.tags)),
    children: e.children,
    historyValue: e.historyValue || {},
    matches: qE,
    hasTag: GE,
    can: UE,
    getMeta: XE,
    toJSON: YE
  };
}
function Ln(e, n = {}) {
  return Do({
    ...e,
    ...n
  }, e.machine);
}
function KE(e, n) {
  const {
    _nodes: i,
    tags: r,
    machine: o,
    children: s,
    context: a,
    can: l,
    hasTag: c,
    matches: u,
    getMeta: f,
    toJSON: h,
    ...p
  } = e, m = {};
  for (const y in s) {
    const v = s[y];
    m[y] = {
      snapshot: v.getPersistedSnapshot(n),
      src: v.src,
      systemId: v._systemId,
      syncSnapshot: v._syncSnapshot
    };
  }
  return {
    ...p,
    context: yy(a),
    children: m
  };
}
function yy(e) {
  let n;
  for (const i in e) {
    const r = e[i];
    if (r && typeof r == "object")
      if ("sessionId" in r && "send" in r && "ref" in r)
        n ??= Array.isArray(e) ? e.slice() : {
          ...e
        }, n[i] = {
          xstate$$type: Uc,
          id: r.id
        };
      else {
        const o = yy(r);
        o !== r && (n ??= Array.isArray(e) ? e.slice() : {
          ...e
        }, n[i] = o);
      }
  }
  return n ?? e;
}
function ZE(e, n, i, r, {
  event: o,
  id: s,
  delay: a
}, {
  internalQueue: l
}) {
  const c = n.machine.implementations.delays;
  if (typeof o == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with raise; use raise({ type: "${o}" }) instead`
    );
  const u = typeof o == "function" ? o(i, r) : o;
  let f;
  if (typeof a == "string") {
    const h = c && c[a];
    f = typeof h == "function" ? h(i, r) : h;
  } else
    f = typeof a == "function" ? a(i, r) : a;
  return typeof f != "number" && l.push(u), [n, {
    event: u,
    id: s,
    delay: f
  }, void 0];
}
function JE(e, n) {
  const {
    event: i,
    delay: r,
    id: o
  } = n;
  if (typeof r == "number") {
    e.defer(() => {
      const s = e.self;
      e.system.scheduler.schedule(s, s, i, r, o);
    });
    return;
  }
}
function Be(e, n) {
  function i(r, o) {
  }
  return i.type = "xstate.raise", i.event = e, i.id = n?.id, i.delay = n?.delay, i.resolve = ZE, i.execute = JE, i;
}
const Vh = /* @__PURE__ */ new WeakMap();
function vy(e) {
  return {
    config: e,
    start: (i, r) => {
      const {
        self: o,
        system: s,
        emit: a
      } = r, l = {
        receivers: void 0,
        dispose: void 0
      };
      Vh.set(o, l), l.dispose = e({
        input: i.input,
        system: s,
        self: o,
        sendBack: (c) => {
          o.getSnapshot().status !== "stopped" && o._parent && s._relay(o, o._parent, c);
        },
        receive: (c) => {
          l.receivers ??= /* @__PURE__ */ new Set(), l.receivers.add(c);
        },
        emit: a
      });
    },
    transition: (i, r, o) => {
      const s = Vh.get(o.self);
      return r.type === jr ? (i = {
        ...i,
        status: "stopped",
        error: void 0
      }, s.dispose?.(), i) : (s.receivers?.forEach((a) => a(r)), i);
    },
    getInitialSnapshot: (i, r) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input: r
    }),
    getPersistedSnapshot: (i) => i,
    restoreSnapshot: (i) => i
  };
}
const Bh = "xstate.promise.resolve", jh = "xstate.promise.reject", wo = /* @__PURE__ */ new WeakMap();
function QE(e) {
  return {
    config: e,
    transition: (i, r, o) => {
      if (i.status !== "active")
        return i;
      switch (r.type) {
        case Bh: {
          const s = r.data;
          return {
            ...i,
            status: "done",
            output: s,
            input: void 0
          };
        }
        case jh:
          return {
            ...i,
            status: "error",
            error: r.data,
            input: void 0
          };
        case jr:
          return wo.get(o.self)?.abort(), {
            ...i,
            status: "stopped",
            input: void 0
          };
        default:
          return i;
      }
    },
    start: (i, {
      self: r,
      system: o,
      emit: s
    }) => {
      if (i.status !== "active")
        return;
      const a = new AbortController();
      wo.set(r, a), Promise.resolve(e({
        input: i.input,
        system: o,
        self: r,
        signal: a.signal,
        emit: s
      })).then((c) => {
        r.getSnapshot().status === "active" && (wo.delete(r), o._relay(r, r, {
          type: Bh,
          data: c
        }));
      }, (c) => {
        r.getSnapshot().status === "active" && (wo.delete(r), o._relay(r, r, {
          type: jh,
          data: c
        }));
      });
    },
    getInitialSnapshot: (i, r) => ({
      status: "active",
      output: void 0,
      error: void 0,
      input: r
    }),
    getPersistedSnapshot: (i) => i,
    restoreSnapshot: (i) => i
  };
}
function eP(e, {
  machine: n,
  context: i
}, r, o) {
  const s = (a, l) => {
    if (typeof a == "string") {
      const c = Gc(n, a);
      if (!c)
        throw new Error(`Actor logic '${a}' not implemented in machine '${n.id}'`);
      const u = Ti(c, {
        id: l?.id,
        parent: e.self,
        syncSnapshot: l?.syncSnapshot,
        input: typeof l?.input == "function" ? l.input({
          context: i,
          event: r,
          self: e.self
        }) : l?.input,
        src: a,
        systemId: l?.systemId
      });
      return o[u.id] = u, u;
    } else
      return Ti(a, {
        id: l?.id,
        parent: e.self,
        syncSnapshot: l?.syncSnapshot,
        input: l?.input,
        src: a,
        systemId: l?.systemId
      });
  };
  return (a, l) => {
    const c = s(a, l);
    return o[c.id] = c, e.defer(() => {
      c._processingStatus !== Ue.Stopped && c.start();
    }), c;
  };
}
function tP(e, n, i, r, {
  assignment: o
}) {
  if (!n.context)
    throw new Error("Cannot assign to undefined `context`. Ensure that `context` is defined in the machine config.");
  const s = {}, a = {
    context: n.context,
    event: i.event,
    spawn: eP(e, n, i.event, s),
    self: e.self,
    system: e.system
  };
  let l = {};
  if (typeof o == "function")
    l = o(a, r);
  else
    for (const u of Object.keys(o)) {
      const f = o[u];
      l[u] = typeof f == "function" ? f(a, r) : f;
    }
  const c = Object.assign({}, n.context, l);
  return [Ln(n, {
    context: c,
    children: Object.keys(s).length ? {
      ...n.children,
      ...s
    } : n.children
  }), void 0, void 0];
}
function U(e) {
  function n(i, r) {
  }
  return n.type = "xstate.assign", n.assignment = e, n.resolve = tP, n;
}
function nP(e, n, i, r, {
  event: o
}) {
  const s = typeof o == "function" ? o(i, r) : o;
  return [n, {
    event: s
  }, void 0];
}
function iP(e, {
  event: n
}) {
  e.defer(() => e.emit(n));
}
function rP(e) {
  function n(i, r) {
  }
  return n.type = "xstate.emit", n.event = e, n.resolve = nP, n.execute = iP, n;
}
let ol = /* @__PURE__ */ function(e) {
  return e.Parent = "#_parent", e.Internal = "#_internal", e;
}({});
function oP(e, n, i, r, {
  to: o,
  event: s,
  id: a,
  delay: l
}, c) {
  const u = n.machine.implementations.delays;
  if (typeof s == "string")
    throw new Error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `Only event objects may be used with sendTo; use sendTo({ type: "${s}" }) instead`
    );
  const f = typeof s == "function" ? s(i, r) : s;
  let h;
  if (typeof l == "string") {
    const g = u && u[l];
    h = typeof g == "function" ? g(i, r) : g;
  } else
    h = typeof l == "function" ? l(i, r) : l;
  const p = typeof o == "function" ? o(i, r) : o;
  let m;
  if (typeof p == "string") {
    if (p === ol.Parent ? m = e.self._parent : p === ol.Internal ? m = e.self : p.startsWith("#_") ? m = n.children[p.slice(2)] : m = c.deferredActorIds?.includes(p) ? p : n.children[p], !m)
      throw new Error(`Unable to send event to actor '${p}' from machine '${n.machine.id}'.`);
  } else
    m = p || e.self;
  return [n, {
    to: m,
    targetId: typeof p == "string" ? p : void 0,
    event: f,
    id: a,
    delay: h
  }, void 0];
}
function sP(e, n, i) {
  typeof i.to == "string" && (i.to = n.children[i.to]);
}
function aP(e, n) {
  e.defer(() => {
    const {
      to: i,
      event: r,
      delay: o,
      id: s
    } = n;
    if (typeof o == "number") {
      e.system.scheduler.schedule(e.self, i, r, o, s);
      return;
    }
    e.system._relay(
      e.self,
      // at this point, in a deferred task, it should already be mutated by retryResolveSendTo
      // if it initially started as a string
      i,
      r.type === oE ? ny(e.self.id, r.data) : r
    );
  });
}
function Sn(e, n, i) {
  function r(o, s) {
  }
  return r.type = "xstate.sendTo", r.to = e, r.event = n, r.id = i?.id, r.delay = i?.delay, r.resolve = oP, r.retryResolve = sP, r.execute = aP, r;
}
function lP(e, n) {
  return Sn(ol.Parent, e, n);
}
function cP(e, n, i, r, {
  collect: o
}) {
  const s = [], a = function(c) {
    s.push(c);
  };
  return a.assign = (...l) => {
    s.push(U(...l));
  }, a.cancel = (...l) => {
    s.push(so(...l));
  }, a.raise = (...l) => {
    s.push(Be(...l));
  }, a.sendTo = (...l) => {
    s.push(Sn(...l));
  }, a.sendParent = (...l) => {
    s.push(lP(...l));
  }, a.spawnChild = (...l) => {
    s.push(ao(...l));
  }, a.stopChild = (...l) => {
    s.push(Wi(...l));
  }, a.emit = (...l) => {
    s.push(rP(...l));
  }, o({
    context: i.context,
    event: i.event,
    enqueue: a,
    check: (l) => Hi(l, n.context, i.event, n),
    self: e.self,
    system: e.system
  }, r), [n, void 0, s];
}
function Te(e) {
  function n(i, r) {
  }
  return n.type = "xstate.enqueueActions", n.collect = e, n.resolve = cP, n;
}
function je(e, n) {
  const i = Wt(n);
  if (!i.includes(e.type)) {
    const r = i.length === 1 ? `type "${i[0]}"` : `one of types "${i.join('", "')}"`;
    throw new Error(`Expected event ${JSON.stringify(e)} to have ${r}`);
  }
}
const Fh = /* @__PURE__ */ new WeakMap();
function Kn(e, n, i) {
  let r = Fh.get(e);
  return r ? n in r || (r[n] = i()) : (r = {
    [n]: i()
  }, Fh.set(e, r)), r[n];
}
const uP = {}, ir = (e) => typeof e == "string" ? {
  type: e
} : typeof e == "function" ? "resolve" in e ? {
  type: e.type
} : {
  type: e.name
} : e;
class Jc {
  constructor(n, i) {
    if (this.config = n, this.key = void 0, this.id = void 0, this.type = void 0, this.path = void 0, this.states = void 0, this.history = void 0, this.entry = void 0, this.exit = void 0, this.parent = void 0, this.machine = void 0, this.meta = void 0, this.output = void 0, this.order = -1, this.description = void 0, this.tags = [], this.transitions = void 0, this.always = void 0, this.parent = i._parent, this.key = i._key, this.machine = i._machine, this.path = this.parent ? this.parent.path.concat(this.key) : [], this.id = this.config.id || [this.machine.id, ...this.path].join(Qg), this.type = this.config.type || (this.config.states && Object.keys(this.config.states).length ? "compound" : this.config.history ? "history" : "atomic"), this.description = this.config.description, this.order = this.machine.idMap.size, this.machine.idMap.set(this.id, this), this.states = this.config.states ? Nh(this.config.states, (r, o) => new Jc(r, {
      _parent: this,
      _key: o,
      _machine: this.machine
    })) : uP, this.type === "compound" && !this.config.initial)
      throw new Error(`No initial state specified for compound state node "#${this.id}". Try adding { initial: "${Object.keys(this.states)[0]}" } to the state config.`);
    this.history = this.config.history === !0 ? "shallow" : this.config.history || !1, this.entry = Wt(this.config.entry).slice(), this.exit = Wt(this.config.exit).slice(), this.meta = this.config.meta, this.output = this.type === "final" || !this.parent ? this.config.output : void 0, this.tags = Wt(n.tags).slice();
  }
  /** @internal */
  _initialize() {
    this.transitions = PE(this), this.config.always && (this.always = ri(this.config.always).map((n) => vn(this, ey, n))), Object.keys(this.states).forEach((n) => {
      this.states[n]._initialize();
    });
  }
  /** The well-structured state node definition. */
  get definition() {
    return {
      id: this.id,
      key: this.key,
      version: this.machine.version,
      type: this.type,
      initial: this.initial ? {
        target: this.initial.target,
        source: this,
        actions: this.initial.actions.map(ir),
        eventType: null,
        reenter: !1,
        toJSON: () => ({
          target: this.initial.target.map((n) => `#${n.id}`),
          source: `#${this.id}`,
          actions: this.initial.actions.map(ir),
          eventType: null
        })
      } : void 0,
      history: this.history,
      states: Nh(this.states, (n) => n.definition),
      on: this.on,
      transitions: [...this.transitions.values()].flat().map((n) => ({
        ...n,
        actions: n.actions.map(ir)
      })),
      entry: this.entry.map(ir),
      exit: this.exit.map(ir),
      meta: this.meta,
      order: this.order || -1,
      output: this.output,
      invoke: this.invoke,
      description: this.description,
      tags: this.tags
    };
  }
  /** @internal */
  toJSON() {
    return this.definition;
  }
  /** The logic invoked as actors by this state node. */
  get invoke() {
    return Kn(this, "invoke", () => Wt(this.config.invoke).map((n, i) => {
      const {
        src: r,
        systemId: o
      } = n, s = n.id ?? Rh(this.id, i), a = typeof r == "string" ? r : `xstate.invoke.${Rh(this.id, i)}`;
      return {
        ...n,
        src: a,
        id: s,
        systemId: o,
        toJSON() {
          const {
            onDone: l,
            onError: c,
            ...u
          } = n;
          return {
            ...u,
            type: "xstate.invoke",
            src: a,
            id: s
          };
        }
      };
    }));
  }
  /** The mapping of events to transitions. */
  get on() {
    return Kn(this, "on", () => [...this.transitions].flatMap(([i, r]) => r.map((o) => [i, o])).reduce((i, [r, o]) => (i[r] = i[r] || [], i[r].push(o), i), {}));
  }
  get after() {
    return Kn(this, "delayedTransitions", () => EE(this));
  }
  get initial() {
    return Kn(this, "initial", () => TE(this, this.config.initial));
  }
  /** @internal */
  next(n, i) {
    const r = i.type, o = [];
    let s;
    const a = Kn(this, `candidates-${r}`, () => CE(this, r));
    for (const l of a) {
      const {
        guard: c
      } = l, u = n.context;
      let f = !1;
      try {
        f = !c || Hi(c, u, i, n);
      } catch (h) {
        const p = typeof c == "string" ? c : typeof c == "object" ? c.type : void 0;
        throw new Error(`Unable to evaluate guard ${p ? `'${p}' ` : ""}in transition for event '${r}' in state node '${this.id}':
${h.message}`);
      }
      if (f) {
        o.push(...l.actions), s = l;
        break;
      }
    }
    return s ? [s] : void 0;
  }
  /** All the event types accepted by this state node and its descendants. */
  get events() {
    return Kn(this, "events", () => {
      const {
        states: n
      } = this, i = new Set(this.ownEvents);
      if (n)
        for (const r of Object.keys(n)) {
          const o = n[r];
          if (o.states)
            for (const s of o.events)
              i.add(`${s}`);
        }
      return Array.from(i);
    });
  }
  /**
   * All the events that have transitions directly from this state node.
   *
   * Excludes any inert events.
   */
  get ownEvents() {
    const n = new Set([...this.transitions.keys()].filter((i) => this.transitions.get(i).some((r) => !(!r.target && !r.actions.length && !r.reenter))));
    return Array.from(n);
  }
}
const dP = "#";
class Qc {
  constructor(n, i) {
    this.config = n, this.version = void 0, this.schemas = void 0, this.implementations = void 0, this.__xstatenode = !0, this.idMap = /* @__PURE__ */ new Map(), this.root = void 0, this.id = void 0, this.states = void 0, this.events = void 0, this.id = n.id || "(machine)", this.implementations = {
      actors: i?.actors ?? {},
      actions: i?.actions ?? {},
      delays: i?.delays ?? {},
      guards: i?.guards ?? {}
    }, this.version = this.config.version, this.schemas = this.config.schemas, this.transition = this.transition.bind(this), this.getInitialSnapshot = this.getInitialSnapshot.bind(this), this.getPersistedSnapshot = this.getPersistedSnapshot.bind(this), this.restoreSnapshot = this.restoreSnapshot.bind(this), this.start = this.start.bind(this), this.root = new Jc(n, {
      _key: this.id,
      _machine: this
    }), this.root._initialize(), this.states = this.root.states, this.events = this.root.events;
  }
  /**
   * Clones this state machine with the provided implementations and merges the
   * `context` (if provided).
   *
   * @param implementations Options (`actions`, `guards`, `actors`, `delays`,
   *   `context`) to recursively merge with the existing options.
   * @returns A new `StateMachine` instance with the provided implementations.
   */
  provide(n) {
    const {
      actions: i,
      guards: r,
      actors: o,
      delays: s
    } = this.implementations;
    return new Qc(this.config, {
      actions: {
        ...i,
        ...n.actions
      },
      guards: {
        ...r,
        ...n.guards
      },
      actors: {
        ...o,
        ...n.actors
      },
      delays: {
        ...s,
        ...n.delays
      }
    });
  }
  resolveState(n) {
    const i = WE(this.root, n.value), r = Yo(Ko(this.root, i));
    return Do({
      _nodes: [...r],
      context: n.context || {},
      children: {},
      status: Xc(r, this.root) ? "done" : n.status || "active",
      output: n.output,
      error: n.error,
      historyValue: n.historyValue
    }, this);
  }
  /**
   * Determines the next snapshot given the current `snapshot` and received
   * `event`. Calculates a full macrostep from all microsteps.
   *
   * @param snapshot The current snapshot
   * @param event The received event
   */
  transition(n, i, r) {
    return fa(n, i, r, []).snapshot;
  }
  /**
   * Determines the next state given the current `state` and `event`. Calculates
   * a microstep.
   *
   * @param state The current state
   * @param event The received event
   */
  microstep(n, i, r) {
    return fa(n, i, r, []).microstates;
  }
  getTransitionData(n, i) {
    return Kc(this.root, n.value, n, i) || [];
  }
  /**
   * The initial state _before_ evaluating any microsteps. This "pre-initial"
   * state is provided to initial actions executed in the initial state.
   */
  getPreInitialState(n, i, r) {
    const {
      context: o
    } = this.config, s = Do({
      context: typeof o != "function" && o ? o : {},
      _nodes: [this.root],
      children: {},
      status: "active"
    }, this);
    return typeof o == "function" ? Ii(s, i, n, [U(({
      spawn: l,
      event: c,
      self: u
    }) => o({
      spawn: l,
      input: c.input,
      self: u
    }))], r, void 0) : s;
  }
  /**
   * Returns the initial `State` instance, with reference to `self` as an
   * `ActorRef`.
   */
  getInitialSnapshot(n, i) {
    const r = iy(i), o = [], s = this.getPreInitialState(n, r, o), a = rl([{
      target: [...hy(this.root)],
      source: this.root,
      reenter: !0,
      actions: [],
      eventType: null,
      toJSON: null
      // TODO: fix
    }], s, n, r, !0, o), {
      snapshot: l
    } = fa(a, r, n, o);
    return l;
  }
  start(n) {
    Object.values(n.children).forEach((i) => {
      i.getSnapshot().status === "active" && i.start();
    });
  }
  getStateNodeById(n) {
    const i = qc(n), r = i.slice(1), o = Ps(i[0]) ? i[0].slice(dP.length) : i[0], s = this.idMap.get(o);
    if (!s)
      throw new Error(`Child state node '#${o}' does not exist on machine '${this.id}'`);
    return Xo(s, r);
  }
  get definition() {
    return this.root.definition;
  }
  toJSON() {
    return this.definition;
  }
  getPersistedSnapshot(n, i) {
    return KE(n, i);
  }
  restoreSnapshot(n, i) {
    const r = {}, o = n.children;
    Object.keys(o).forEach((c) => {
      const u = o[c], f = u.snapshot, h = u.src, p = typeof h == "string" ? Gc(this, h) : h;
      if (!p)
        return;
      const m = Ti(p, {
        id: c,
        parent: i.self,
        syncSnapshot: u.syncSnapshot,
        snapshot: f,
        src: h,
        systemId: u.systemId
      });
      r[c] = m;
    });
    const s = Do({
      ...n,
      children: r,
      _nodes: Array.from(Yo(Ko(this.root, n.value)))
    }, this), a = /* @__PURE__ */ new Set();
    function l(c, u) {
      if (!a.has(c)) {
        a.add(c);
        for (const f in c) {
          const h = c[f];
          if (h && typeof h == "object") {
            if ("xstate$$type" in h && h.xstate$$type === Uc) {
              c[f] = u[h.id];
              continue;
            }
            l(h, u);
          }
        }
      }
    }
    return l(s.context, r), s;
  }
}
function hP(e, n) {
  return new Qc(e, n);
}
function qi({
  schemas: e,
  actors: n,
  actions: i,
  guards: r,
  delays: o
}) {
  return {
    createMachine: (s) => hP({
      ...s,
      schemas: e
    }, {
      actors: n,
      actions: i,
      guards: r,
      delays: o
    })
  };
}
const wy = (e, n) => {
  n(e);
  const i = e.getSnapshot().children;
  i && Object.values(i).forEach((r) => {
    wy(r, n);
  });
};
function fP(e) {
  const n = [];
  wy(e, (r) => {
    n.push([r, r.getSnapshot()]), r.observers = /* @__PURE__ */ new Set();
  });
  const i = e.system.getSnapshot?.();
  e.stop(), e.system._snapshot = i, n.forEach(([r, o]) => {
    r._processingStatus = 0, r._snapshot = o;
  });
}
function pP(e, ...[n]) {
  let [[i, r], o] = ge(() => {
    const s = Ti(e, n);
    return [e.config, s];
  });
  if (e.config !== i) {
    const s = Ti(e, {
      ...n,
      snapshot: r.getPersistedSnapshot({
        __unsafeAllowInlineActors: !0
      })
    });
    o([e.config, s]), r = s;
  }
  return Rv(() => {
    r.logic.implementations = e.implementations;
  }), r;
}
function mP(e, ...[n, i]) {
  const r = pP(e, n);
  return ie(() => {
    if (!i)
      return;
    const o = r.subscribe(Uo(i));
    return () => {
      o.unsubscribe();
    };
  }, [i]), ie(() => (r.start(), () => {
    fP(r);
  }), [r]), r;
}
function gP(e, n) {
  return e === n;
}
function Gn(e, n, i = gP) {
  const r = dt((a) => {
    if (!e)
      return () => {
      };
    const {
      unsubscribe: l
    } = e.subscribe(a);
    return l;
  }, [e]), o = dt(() => e?.getSnapshot(), [e]);
  return E1.useSyncExternalStoreWithSelector(r, o, o, n, i);
}
function rr(e) {
  return {
    get overlaysActorRef() {
      return e.get("overlays") ?? null;
    },
    get diagramActorRef() {
      return e.get("diagram") ?? null;
    }
  };
}
function Zo(e, n) {
  return e.view.nodes.find((i) => i.id === n) ?? null;
}
function xy(e, n) {
  return e.view.edges.find((i) => i.id === n) ?? null;
}
function or(e) {
  const n = /* @__PURE__ */ new Map(), i = e.context.xynodes.reduce((r, o) => {
    let s = o.position;
    if (o.parentId) {
      const c = n.get(o.parentId) ?? { x: 0, y: 0 };
      s = {
        x: s.x + c.x,
        y: s.y + c.y
      };
    }
    if (n.set(o.id, s), o.hidden || o.data.dimmed)
      return r;
    const a = o.measured?.width ?? o.width ?? o.initialWidth, l = o.measured?.height ?? o.height ?? o.initialHeight;
    return {
      minX: Math.min(r.minX, s.x),
      minY: Math.min(r.minY, s.y),
      maxX: Math.max(r.maxX, s.x + a),
      maxY: Math.max(r.maxY, s.y + l)
    };
  }, {
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0
  });
  return i.minX === 1 / 0 ? {
    bounds: e.context.view.bounds
  } : {
    duration: 350,
    bounds: {
      x: i.minX - 10,
      y: i.minY - 10,
      width: i.maxX - i.minX + 20,
      height: i.maxY - i.minY + 20
    }
  };
}
const eu = Le(null);
eu.displayName = "DiagramActorSafeContext";
const by = () => {
  const e = Pv(eu);
  if (e === null)
    throw new Error("DiagramActorRef is not provided");
  return e;
};
function de() {
  const e = by(), [, n] = _l();
  return ce(() => ({
    send: e.send,
    navigateTo: (i, r) => {
      n(() => {
        e.send({
          type: "navigate.to",
          viewId: i,
          ...r && { fromNode: r }
        });
      });
    },
    navigate: (i) => {
      n(() => {
        e.send({ type: `navigate.${i}` });
      });
    },
    fitDiagram: (i = 350) => {
      n(() => {
        e.send({ type: "fitDiagram", duration: i });
      });
    },
    openRelationshipsBrowser: (i) => {
      n(() => {
        e.send({ type: "open.relationshipsBrowser", fqn: i });
      });
    },
    openSource: (i) => {
      e.send({ type: "open.source", ...i });
    },
    openElementDetails: (i, r) => {
      n(() => {
        e.send({ type: "open.elementDetails", fqn: i, fromNode: r });
      });
    },
    openRelationshipDetails: (i) => {
      n(() => {
        e.send({ type: "open.relationshipDetails", edgeId: i });
      });
    },
    updateNodeData: (i, r) => {
      e.send({ type: "update.nodeData", nodeId: i, data: r });
    },
    updateEdgeData: (i, r) => {
      e.send({
        type: "update.edgeData",
        edgeId: i,
        // @ts-expect-error TODO: fix this
        data: r
      });
    },
    scheduleSaveManualLayout: () => {
      e.send({ type: "saveManualLayout.schedule" });
    },
    /**
     * @returns true if there was pending request to save layout
     */
    cancelSaveManualLayout: () => {
      const i = e.getSnapshot().children.syncLayout?.getSnapshot().value;
      return e.send({ type: "saveManualLayout.cancel" }), i === "pending" || i === "paused";
    },
    align: (i) => {
      e.send({ type: "layout.align", mode: i });
    },
    resetEdgeControlPoints: () => {
      e.send({ type: "layout.resetEdgeControlPoints" });
    },
    focusNode: (i) => {
      e.send({ type: "focus.node", nodeId: i });
    },
    /**
     * @warning Do not use in render phase
     */
    get currentView() {
      return e.getSnapshot().context.view;
    },
    /**
     * @warning Do not use in render phase
     */
    getSnapshot: () => e.getSnapshot(),
    /**
     * @warning Do not use in render phase
     */
    getContext: () => e.getSnapshot().context,
    /**
     * @warning Do not use in render phase
     */
    findDiagramNode: (i) => Zo(e.getSnapshot().context, i),
    /**
     * @warning Do not use in render phase
     */
    findDiagramEdge: (i) => xy(e.getSnapshot().context, i),
    startWalkthrough: () => {
      e.send({ type: "walkthrough.start" });
    },
    walkthroughStep: (i = "next") => {
      e.send({ type: "walkthrough.step", direction: i });
    },
    stopWalkthrough: () => {
      e.send({ type: "walkthrough.end" });
    },
    toggleFeature: (i, r) => {
      e.send({ type: "toggle.feature", feature: i, ...r !== void 0 && { forceValue: r } });
    }
  }), [e]);
}
function ky(e, n = Ze) {
  const i = by();
  return Gn(i, q(e), n);
}
function pt(e, n = Ze) {
  return ky(q((i) => e(i.context)), n);
}
function Zn(e) {
  return function() {
    return e;
  };
}
const Wh = 1e-12, sl = Math.PI, al = 2 * sl, gn = 1e-6, yP = al - gn;
function Sy(e) {
  this._ += e[0];
  for (let n = 1, i = e.length; n < i; ++n)
    this._ += arguments[n] + e[n];
}
function vP(e) {
  let n = Math.floor(e);
  if (!(n >= 0)) throw new Error(`invalid digits: ${e}`);
  if (n > 15) return Sy;
  const i = 10 ** n;
  return function(r) {
    this._ += r[0];
    for (let o = 1, s = r.length; o < s; ++o)
      this._ += Math.round(arguments[o] * i) / i + r[o];
  };
}
class wP {
  constructor(n) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "", this._append = n == null ? Sy : vP(n);
  }
  moveTo(n, i) {
    this._append`M${this._x0 = this._x1 = +n},${this._y0 = this._y1 = +i}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._append`Z`);
  }
  lineTo(n, i) {
    this._append`L${this._x1 = +n},${this._y1 = +i}`;
  }
  quadraticCurveTo(n, i, r, o) {
    this._append`Q${+n},${+i},${this._x1 = +r},${this._y1 = +o}`;
  }
  bezierCurveTo(n, i, r, o, s, a) {
    this._append`C${+n},${+i},${+r},${+o},${this._x1 = +s},${this._y1 = +a}`;
  }
  arcTo(n, i, r, o, s) {
    if (n = +n, i = +i, r = +r, o = +o, s = +s, s < 0) throw new Error(`negative radius: ${s}`);
    let a = this._x1, l = this._y1, c = r - n, u = o - i, f = a - n, h = l - i, p = f * f + h * h;
    if (this._x1 === null)
      this._append`M${this._x1 = n},${this._y1 = i}`;
    else if (p > gn) if (!(Math.abs(h * c - u * f) > gn) || !s)
      this._append`L${this._x1 = n},${this._y1 = i}`;
    else {
      let m = r - a, g = o - l, y = c * c + u * u, v = m * m + g * g, w = Math.sqrt(y), x = Math.sqrt(p), k = s * Math.tan((sl - Math.acos((y + p - v) / (2 * w * x))) / 2), _ = k / x, S = k / w;
      Math.abs(_ - 1) > gn && this._append`L${n + _ * f},${i + _ * h}`, this._append`A${s},${s},0,0,${+(h * m > f * g)},${this._x1 = n + S * c},${this._y1 = i + S * u}`;
    }
  }
  arc(n, i, r, o, s, a) {
    if (n = +n, i = +i, r = +r, a = !!a, r < 0) throw new Error(`negative radius: ${r}`);
    let l = r * Math.cos(o), c = r * Math.sin(o), u = n + l, f = i + c, h = 1 ^ a, p = a ? o - s : s - o;
    this._x1 === null ? this._append`M${u},${f}` : (Math.abs(this._x1 - u) > gn || Math.abs(this._y1 - f) > gn) && this._append`L${u},${f}`, r && (p < 0 && (p = p % al + al), p > yP ? this._append`A${r},${r},0,1,${h},${n - l},${i - c}A${r},${r},0,1,${h},${this._x1 = u},${this._y1 = f}` : p > gn && this._append`A${r},${r},0,${+(p >= sl)},${h},${this._x1 = n + r * Math.cos(s)},${this._y1 = i + r * Math.sin(s)}`);
  }
  rect(n, i, r, o) {
    this._append`M${this._x0 = this._x1 = +n},${this._y0 = this._y1 = +i}h${r = +r}v${+o}h${-r}Z`;
  }
  toString() {
    return this._;
  }
}
function xP(e) {
  let n = 3;
  return e.digits = function(i) {
    if (!arguments.length) return n;
    if (i == null)
      n = null;
    else {
      const r = Math.floor(i);
      if (!(r >= 0)) throw new RangeError(`invalid digits: ${i}`);
      n = r;
    }
    return e;
  }, () => new wP(n);
}
function bP(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function _y(e) {
  this._context = e;
}
_y.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, n) {
    switch (e = +e, n = +n, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, n) : this._context.moveTo(e, n);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(e, n);
        break;
    }
  }
};
function kP(e) {
  return new _y(e);
}
function SP(e) {
  return e[0];
}
function _P(e) {
  return e[1];
}
function CP(e, n) {
  var i = Zn(!0), r = null, o = kP, s = null, a = xP(l);
  e = typeof e == "function" ? e : e === void 0 ? SP : Zn(e), n = typeof n == "function" ? n : n === void 0 ? _P : Zn(n);
  function l(c) {
    var u, f = (c = bP(c)).length, h, p = !1, m;
    for (r == null && (s = o(m = a())), u = 0; u <= f; ++u)
      !(u < f && i(h = c[u], u, c)) === p && ((p = !p) ? s.lineStart() : s.lineEnd()), p && s.point(+e(h, u, c), +n(h, u, c));
    if (m) return s = null, m + "" || null;
  }
  return l.x = function(c) {
    return arguments.length ? (e = typeof c == "function" ? c : Zn(+c), l) : e;
  }, l.y = function(c) {
    return arguments.length ? (n = typeof c == "function" ? c : Zn(+c), l) : n;
  }, l.defined = function(c) {
    return arguments.length ? (i = typeof c == "function" ? c : Zn(!!c), l) : i;
  }, l.curve = function(c) {
    return arguments.length ? (o = c, r != null && (s = o(r)), l) : o;
  }, l.context = function(c) {
    return arguments.length ? (c == null ? r = s = null : s = o(r = c), l) : r;
  }, l;
}
function ll(e, n, i) {
  e._context.bezierCurveTo(
    e._x1 + e._k * (e._x2 - e._x0),
    e._y1 + e._k * (e._y2 - e._y0),
    e._x2 + e._k * (e._x1 - n),
    e._y2 + e._k * (e._y1 - i),
    e._x2,
    e._y2
  );
}
function tu(e, n) {
  this._context = e, this._k = (1 - n) / 6;
}
tu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        ll(this, this._x1, this._y1);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, n) {
    switch (e = +e, n = +n, this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, n) : this._context.moveTo(e, n);
        break;
      case 1:
        this._point = 2, this._x1 = e, this._y1 = n;
        break;
      case 2:
        this._point = 3;
      default:
        ll(this, e, n);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
  }
};
(function e(n) {
  function i(r) {
    return new tu(r, n);
  }
  return i.tension = function(r) {
    return e(+r);
  }, i;
})(0);
function nu(e, n) {
  this._context = e, this._k = (1 - n) / 6;
}
nu.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, n) {
    switch (e = +e, n = +n, this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        ll(this, e, n);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
  }
};
(function e(n) {
  function i(r) {
    return new nu(r, n);
  }
  return i.tension = function(r) {
    return e(+r);
  }, i;
})(0);
function Cy(e, n, i) {
  var r = e._x1, o = e._y1, s = e._x2, a = e._y2;
  if (e._l01_a > Wh) {
    var l = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a, c = 3 * e._l01_a * (e._l01_a + e._l12_a);
    r = (r * l - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / c, o = (o * l - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / c;
  }
  if (e._l23_a > Wh) {
    var u = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a, f = 3 * e._l23_a * (e._l23_a + e._l12_a);
    s = (s * u + e._x1 * e._l23_2a - n * e._l12_2a) / f, a = (a * u + e._y1 * e._l23_2a - i * e._l12_2a) / f;
  }
  e._context.bezierCurveTo(r, o, s, a, e._x2, e._y2);
}
function Ey(e, n) {
  this._context = e, this._alpha = n;
}
Ey.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    (this._line || this._line !== 0 && this._point === 1) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, n) {
    if (e = +e, n = +n, this._point) {
      var i = this._x2 - e, r = this._y2 - n;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(i * i + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this._context.lineTo(e, n) : this._context.moveTo(e, n);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        Cy(this, e, n);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
  }
};
(function e(n) {
  function i(r) {
    return n ? new Ey(r, n) : new tu(r, 0);
  }
  return i.alpha = function(r) {
    return e(+r);
  }, i;
})(0.5);
function Py(e, n) {
  this._context = e, this._alpha = n;
}
Py.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    (this._line || this._line !== 0 && this._point === 3) && this._context.closePath(), this._line = 1 - this._line;
  },
  point: function(e, n) {
    if (e = +e, n = +n, this._point) {
      var i = this._x2 - e, r = this._y2 - n;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(i * i + r * r, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        Cy(this, e, n);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = e, this._y0 = this._y1, this._y1 = this._y2, this._y2 = n;
  }
};
const EP = function e(n) {
  function i(r) {
    return n ? new Py(r, n) : new nu(r, 0);
  }
  return i.alpha = function(r) {
    return e(+r);
  }, i;
}(0.5);
var PP = "rh5b6f0", TP = "rh5b6f1", MP = "rh5b6f2";
function AP({
  data: {
    hovered: e = !1
  },
  icon: n,
  onClick: i
}) {
  return /* @__PURE__ */ d(A, { className: j(PP, qn, "compound-action"), children: /* @__PURE__ */ d(
    A,
    {
      className: j("nodrag nopan", TP),
      component: re.div,
      initial: !1,
      animate: {
        scale: e ? 1.2 : 1,
        x: e ? -1 : 0
        // y: isHovered ? -1 : 0,
      },
      whileHover: {
        scale: 1.35,
        x: -1
        // y: 1,
      },
      whileTap: { scale: 1 },
      children: /* @__PURE__ */ d(
        se,
        {
          className: MP,
          size: "md",
          radius: "md",
          onClick: i,
          onDoubleClick: Ee,
          children: n ?? /* @__PURE__ */ d(kt, { stroke: 2 })
        }
      )
    }
  ) });
}
var IP = "xad3aj0", DP = "xad3aj2", NP = "xad3aj3";
function RP({
  data: {
    hovered: e = !1
  },
  icon: n,
  onClick: i
}) {
  return /* @__PURE__ */ d(A, { className: j(IP, qn, "details-button"), onClick: Ee, children: /* @__PURE__ */ d(
    A,
    {
      component: re.div,
      className: j("nodrag nopan", NP),
      initial: !1,
      style: {
        originX: 0.45,
        originY: 0.55
      },
      animate: e ? {
        scale: 1.2
      } : {
        scale: 1
      },
      whileHover: {
        scale: 1.42
      },
      whileTap: { scale: 1.15 },
      children: /* @__PURE__ */ d(
        se,
        {
          className: DP,
          size: "md",
          radius: "md",
          onClick: i,
          onDoubleClick: Ee,
          children: n ?? /* @__PURE__ */ d(jg, { stroke: 1.8, style: { width: "75%" } })
        }
      )
    }
  ) });
}
function LP(e) {
  var n = e.match(/^var\((.*)\)$/);
  return n ? n[1] : e;
}
function iu(e, n) {
  var i = {};
  {
    var r = e;
    for (var o in r) {
      var s = r[o];
      s != null && (i[LP(o)] = s);
    }
  }
  return Object.defineProperty(i, "toString", {
    value: function() {
      return Object.keys(this).map((l) => "".concat(l, ":").concat(this[l])).join(";");
    },
    writable: !1
  }), i;
}
var $P = "var(--_13c5o1v0)", zP = "var(--_13c5o1v2)", OP = "_13c5o1v5", VP = "_13c5o1v6", BP = "_13c5o1v7", jP = "_13c5o1vb";
const yi = Cl(
  an(({
    nodeProps: {
      data: {
        hovered: e = !1,
        dimmed: n = !1,
        style: i,
        ...r
      }
    },
    children: o,
    ...s
  }, a) => {
    const l = Pc(i.opacity) && i.opacity < 100;
    let c = bn((i.opacity ?? 100) / 100, {
      min: 0,
      max: 1
    });
    l && e && (c = Math.min(c + 0.11, 1));
    const u = 40, f = bn(u - c * u, {
      min: 0,
      max: u
    });
    return /* @__PURE__ */ b(
      A,
      {
        ref: a,
        component: re.div,
        className: j([
          OP,
          "likec4-compound-node"
        ]),
        initial: !1,
        "data-hovered": e,
        "data-likec4-color": r.color,
        "data-compound-depth": r.depth ?? 1,
        "data-compound-transparent": l,
        "data-likec4-dimmed": n,
        "data-likec4-shape": r.shape,
        style: iu({
          [$P]: c.toFixed(2),
          [zP]: `${f}%`
        }),
        ...s,
        children: [
          /* @__PURE__ */ d("svg", { className: jP, children: /* @__PURE__ */ d(
            "rect",
            {
              x: 0,
              y: 0,
              width: "100%",
              height: "100%",
              rx: 6
            }
          ) }),
          /* @__PURE__ */ d("div", { className: VP }),
          l && i.border !== "none" && /* @__PURE__ */ d(
            "div",
            {
              className: BP,
              style: {
                borderStyle: i.border ?? "dashed"
              }
            }
          ),
          o
        ]
      }
    );
  })
);
yi.displayName = "CompoundNodeContainer";
var FP = "_84irvm0", WP = "_84irvm1", HP = "_84irvm2";
function kr({ id: e, data: n }) {
  const i = Es({
    element: {
      id: e,
      title: n.title,
      icon: n.icon
    },
    className: HP
  });
  return /* @__PURE__ */ b(
    A,
    {
      className: j(
        FP,
        "likec4-compound-title"
      ),
      children: [
        i,
        /* @__PURE__ */ d($, { className: WP, truncate: "end", children: n.title })
      ]
    }
  );
}
const xo = (e, n) => Math.abs(e - n) < 2.5, qP = (e, n) => e.id === n.id && Y(e.source, n.source) && Y(e.sourceHandleId ?? null, n.sourceHandleId ?? null) && Y(e.target, n.target) && Y(e.targetHandleId ?? null, n.targetHandleId ?? null) && Y(e.selected ?? !1, n.selected ?? !1) && Y(e.sourcePosition, n.sourcePosition) && Y(e.targetPosition, n.targetPosition) && xo(e.sourceX, n.sourceX) && xo(e.sourceY, n.sourceY) && xo(e.targetX, n.targetX) && xo(e.targetY, n.targetY) && Y(e.data, n.data) && Y(e.style, n.style);
function ru(e) {
  return nt(e, qP);
}
const GP = (e, n) => e.id === n.id && Y(e.selected ?? !1, n.selected ?? !1) && Y(e.dragging ?? !1, n.dragging ?? !1) && Y(e.width ?? 0, n.width ?? 0) && Y(e.height ?? 0, n.height ?? 0) && Y(e.zIndex, n.zIndex) && Y(e.positionAbsoluteX, n.positionAbsoluteX) && Y(e.positionAbsoluteY, n.positionAbsoluteY) && Y(e.data, n.data);
function Ct(e) {
  return nt(e, GP);
}
var UP = "_1upu9wi2", YP = "_1upu9wi1", XP = "_15w4wzo0", KP = "var(--_15w4wzo3)", ZP = "_15w4wzo4", JP = "_15w4wzo5", QP = "_15w4wzo6", eT = "_15w4wzo7", tT = "_15w4wzo8", nT = "_15w4wzob";
function ou({ icon: e, onClick: n }) {
  return /* @__PURE__ */ d(
    se,
    {
      className: j("nodrag nopan", nT),
      size: "sm",
      radius: "sm",
      onPointerDownCapture: Ee,
      onClick: n,
      role: "button",
      onDoubleClick: Ee,
      children: e ?? /* @__PURE__ */ d(kt, {})
    }
  );
}
var iT = "_1upu9wi1", rT = "_1upu9wi2", oT = "_1upu9wi3", sT = "_1upu9wi4", aT = "_1upu9wi6";
function su({
  className: e,
  data: {
    hovered: n = !1,
    active: i = !1,
    dimmed: r = !1,
    ...o
  },
  children: s
}) {
  return /* @__PURE__ */ d(
    "g",
    {
      className: j(
        iT,
        r && rT,
        e
      ),
      "data-likec4-color": o.color ?? "gray",
      "data-edge-dir": o.dir ?? "forward",
      "data-edge-active": i,
      "data-edge-animated": i,
      "data-edge-hovered": n,
      "data-edge-dimmed": r,
      children: s
    }
  );
}
const Hh = (e) => {
  if (e !== void 0)
    return Pc(e) ? `${e}px` : e;
}, Ts = Cl(
  an(({
    edgeProps: {
      id: e,
      data: {
        technology: n,
        hovered: i = !1,
        active: r = !1,
        dimmed: o = !1,
        labelBBox: s,
        ...a
      }
    },
    labelPosition: l,
    className: c,
    style: u,
    children: f,
    ...h
  }, p) => {
    const m = Xg(), g = Np(e) ? $1(e) : null;
    let y = Ht.Edge;
    (i || r) && (y = Ht.Element + 1);
    let v = l?.x ?? s?.x, w = l?.y ?? s?.y;
    if (v === void 0 || w === void 0 || m)
      return null;
    const x = l?.translate;
    return /* @__PURE__ */ d(P1, { children: /* @__PURE__ */ d(
      A,
      {
        className: j(
          "nodrag nopan",
          YP,
          ZP,
          !!o && UP,
          c
        ),
        "data-likec4-color": a.color ?? "gray",
        "data-edge-active": r,
        "data-edge-animated": r,
        "data-edge-hovered": i,
        "data-edge-dimmed": o,
        style: {
          top: Hh(w),
          left: Hh(v),
          // ...assignInlineVars({
          //   [css.varLabelX]: toCssVarValue(labelX),
          //   [css.varLabelY]: toCssVarValue(labelY),
          // }),
          ...x && iu({
            [KP]: x
          }),
          ...s && {
            maxWidth: s.width + 18
          },
          zIndex: y,
          ...u
        },
        children: /* @__PURE__ */ b(A, { ref: p, className: JP, ...h, children: [
          g !== null && /* @__PURE__ */ d(A, { className: XP, children: g }),
          /* @__PURE__ */ b(A, { className: QP, children: [
            rn(a.label) && /* @__PURE__ */ d($, { component: "div", className: eT, lineClamp: 5, children: a.label }),
            rn(n) && /* @__PURE__ */ d($, { component: "div", className: tT, children: "[ " + n + " ]" }),
            f
          ] })
        ] })
      }
    ) });
  })
);
Ts.displayName = "EdgeLabel";
const lT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "-4 -4 14 16",
    refX: 5,
    refY: 4,
    markerWidth: "7",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...e,
    children: /* @__PURE__ */ d(
      "path",
      {
        d: "M0,0 L7,4 L0,8 L4,4 Z",
        stroke: "context-stroke",
        fill: "context-stroke",
        strokeDasharray: 0,
        strokeWidth: 1,
        strokeLinecap: "round"
      }
    )
  }
), cT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...e,
    children: /* @__PURE__ */ d(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        fill: "context-stroke",
        strokeWidth: 0
      }
    )
  }
), uT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "-1 -1 12 12",
    refX: 8,
    refY: 4,
    markerWidth: "8",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...e,
    children: /* @__PURE__ */ d(
      "path",
      {
        d: "M 8 0 L 0 4 L 8 8 M 8 4 L 0 4",
        fill: "none",
        strokeWidth: 1
      }
    )
  }
), dT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "-1 -1 12 10",
    refX: 4,
    refY: 3,
    markerWidth: "8",
    markerHeight: "6",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...e,
    children: /* @__PURE__ */ d(
      "path",
      {
        d: "M 0 0 L 8 3 L 0 6 L 1 3 z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinejoin: "miter",
        strokeLinecap: "square"
      }
    )
  }
), hT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 5,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...e,
    children: /* @__PURE__ */ d(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        fill: "context-stroke",
        strokeWidth: 0,
        strokeLinecap: "round"
      }
    )
  }
), fT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "-4 -4 16 14",
    refX: 6,
    refY: 4,
    markerWidth: "10",
    markerHeight: "8",
    preserveAspectRatio: "xMaxYMid meet",
    orient: "auto-start-reverse",
    ...e,
    children: /* @__PURE__ */ d(
      "path",
      {
        d: "M5,0 L10,4 L5,8 L0,4 Z",
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        strokeWidth: 1.25,
        strokeLinecap: "round"
      }
    )
  }
), pT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...e,
    children: /* @__PURE__ */ d(
      "circle",
      {
        strokeWidth: 0,
        fill: "context-stroke",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), mT = (e) => /* @__PURE__ */ d(
  "marker",
  {
    viewBox: "0 0 10 10",
    refX: 4,
    refY: 4,
    markerWidth: "6",
    markerHeight: "6",
    ...e,
    children: /* @__PURE__ */ d(
      "circle",
      {
        strokeWidth: 1.25,
        stroke: "context-stroke",
        fill: "var(--likec4-background-color)",
        cx: 4,
        cy: 4,
        r: 3
      }
    )
  }
), qh = {
  Arrow: cT,
  Crow: uT,
  OArrow: dT,
  Open: lT,
  Diamond: hT,
  ODiamond: fT,
  Dot: pT,
  ODot: mT
};
function Gh(e) {
  if (!(!e || e === "none"))
    switch (e) {
      case "normal":
        return "Arrow";
      case "crow":
        return "Crow";
      case "onormal":
        return "OArrow";
      case "diamond":
        return "Diamond";
      case "odiamond":
        return "ODiamond";
      case "open":
      case "vee":
        return "Open";
      case "dot":
        return "Dot";
      case "odot":
        return "ODot";
      default:
        Pt(e);
    }
}
const au = an(({
  id: e,
  data: {
    line: n,
    dir: i,
    tail: r,
    head: o
  },
  strokeWidth: s,
  svgPath: a,
  style: l,
  interactionWidth: c,
  onEdgePointerDown: u
}, f) => {
  let h = Gh(r), p = Gh(o ?? "normal");
  i === "back" && ([h, p] = [p, h]);
  const m = h ? qh[h] : null, g = p ? qh[p] : null, y = n === "dotted", v = y || n === "dashed";
  let w;
  return y ? w = "1,8" : v && (w = "8,10"), /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(
      "path",
      {
        className: j("react-flow__edge-interaction"),
        d: a,
        fill: "none",
        stroke: "transparent",
        strokeWidth: c ?? 10
      }
    ),
    /* @__PURE__ */ b("g", { className: sT, onPointerDown: u, children: [
      /* @__PURE__ */ b("defs", { children: [
        m && /* @__PURE__ */ d(m, { id: "start" + e }),
        g && /* @__PURE__ */ d(g, { id: "end" + e })
      ] }),
      /* @__PURE__ */ d(
        "path",
        {
          className: j("react-flow__edge-path", oT),
          d: a,
          style: l,
          strokeLinecap: "round"
        }
      ),
      /* @__PURE__ */ d(
        "path",
        {
          ref: f,
          className: j("react-flow__edge-path", aT),
          d: a,
          style: l,
          strokeWidth: s,
          strokeLinecap: "round",
          strokeDasharray: w,
          markerStart: m ? `url(#start${e})` : void 0,
          markerEnd: g ? `url(#end${e})` : void 0
        }
      )
    ] })
  ] });
});
var gT = "_1q8w4uv0", yT = "_1q8w4uv1", vT = "_1q8w4uv2";
function Ms({
  id: e,
  selected: n = !1,
  data: {
    hovered: i = !1
  },
  buttons: r
}) {
  return r.length ? /* @__PURE__ */ d(A, { className: j(gT, qn), children: /* @__PURE__ */ d(
    A,
    {
      component: re.div,
      layoutRoot: !0,
      initial: !1,
      style: {
        originY: 0,
        gap: "6px"
      },
      animate: {
        opacity: i || n ? 1 : 0.75,
        scale: i ? 1.1 : n ? 0.9 : 0.8,
        y: i || n ? 6 : 0
      },
      "data-hovered": i,
      className: j("nodrag nopan", yT),
      children: r.map((o, s) => /* @__PURE__ */ d(
        re.div,
        {
          initial: !1,
          whileTap: { scale: 1 },
          whileHover: {
            scale: 1.35
          },
          children: /* @__PURE__ */ d(
            se,
            {
              className: vT,
              size: "md",
              radius: "md",
              onClick: o.onClick,
              onDoubleClick: Ee,
              children: o.icon
            }
          )
        },
        `action-button-${e}-${o.key ?? s}`
      ))
    }
  ) }) : null;
}
var wT = "_8g2jws0", xT = "_8g2jws1", bT = "_8g2jws2";
function lu({
  selected: e = !1,
  data: {
    hovered: n = !1
  },
  icon: i,
  onClick: r
}) {
  return /* @__PURE__ */ d(A, { className: j(wT, qn, "details-button"), children: /* @__PURE__ */ d(
    A,
    {
      className: j("nodrag nopan", xT),
      component: re.div,
      initial: !1,
      style: {
        originX: 0.45,
        originY: 0.55
      },
      animate: n || e ? {
        scale: 1.2,
        opacity: 0.7
      } : {
        scale: 1,
        opacity: 0.5
      },
      whileHover: {
        scale: 1.4,
        opacity: 1
      },
      whileTap: { scale: 1.15 },
      children: /* @__PURE__ */ d(
        se,
        {
          className: bT,
          size: "md",
          radius: "md",
          onClick: r,
          onDoubleClick: Ee,
          children: i ?? /* @__PURE__ */ d(jg, { stroke: 1.8, style: { width: "75%" } })
        }
      )
    }
  ) });
}
var kT = "_8sjr7a1";
function Ty({
  size: e,
  padding: n,
  textSize: i
}) {
  return !e && i && (e = i), !i && e && (i = e), !n && e && (n = e), e ??= z1, i ??= O1, n ??= V1, {
    size: e,
    padding: n,
    textSize: i
  };
}
const Fr = Cl(
  an(({
    nodeProps: {
      selected: e = !1,
      selectable: n = !1,
      data: {
        hovered: i = !1,
        dimmed: r = !1,
        ...o
      }
    },
    children: s,
    ...a
  }, l) => {
    let c = 1;
    switch (!0) {
      case i:
        c = 1.05;
        break;
      case e:
        c = 1.02;
        break;
    }
    const {
      size: u,
      padding: f,
      textSize: h
    } = Ty(o.style);
    return /* @__PURE__ */ d(
      A,
      {
        component: re.div,
        ref: l,
        className: j([
          kT,
          "likec4-element-node"
        ]),
        initial: !1,
        ...n && {
          animate: {
            scale: c
          },
          whileTap: { scale: 0.98 }
        },
        "data-hovered": i,
        "data-likec4-color": o.color,
        "data-likec4-shape": o.shape,
        "data-likec4-shape-size": u,
        "data-likec4-padding": f,
        "data-likec4-text-size": h,
        "data-likec4-dimmed": r,
        ...a,
        children: s
      }
    );
  })
);
Fr.displayName = "ElementNodeContainer";
var ST = "_1lwlbrx2", Uh = "_1lwlbrx3", sr = "_1lwlbrx5", _T = "_1lwlbrx8 _1lwlbrx7", CT = "_1lwlbrx9 _1lwlbrx7";
function My(e, n, i = 0.065) {
  const r = Math.round(e / 2), o = r, s = Zg(i * r), a = n - 2 * s;
  return {
    path: `  M ${e},${s}
        a ${o},${s} 0,0,0 ${-e} 0
        l 0,${a}
        a ${o},${s} 0,0,0 ${e} 0
        l 0,${-a}
        z
        `.replace(/\s+/g, " ").trim(),
    ry: s,
    rx: o
  };
}
function Ay(e, n, i = 0.185) {
  const r = n, s = Math.round(r / 2), a = Zg(r / 2 * i), l = e - 2 * a;
  return {
    path: `
    M ${a},0
    a ${a},${s} 0,0,0 0 ${r}
    l ${l},0
    a ${a},${s} 0,0,0 0 ${-r}
    z`.replace(/\s+/g, " ").trim(),
    ry: s,
    rx: a
  };
}
const hn = {
  width: 115,
  height: 120,
  path: "M57.9197 0C10.9124 0 33.5766 54.75 33.5766 54.75C38.6131 62.25 45.3285 60.75 45.3285 66C45.3285 70.5 39.4526 72 33.5766 72.75C24.3431 72.75 15.9489 71.25 7.55474 84.75C2.51825 93 0 120 0 120H115C115 120 112.482 93 108.285 84.75C99.8905 70.5 91.4963 72.75 82.2628 72C76.3869 71.25 70.5109 69.75 70.5109 65.25C70.5109 60.75 77.2263 62.25 82.2628 54C82.2628 54.75 104.927 0 57.9197 0V0Z"
};
function Yh({ shape: e, w: n, h: i }) {
  switch (e) {
    case "mobile":
      return /* @__PURE__ */ b(H, { children: [
        /* @__PURE__ */ d(
          "rect",
          {
            width: n,
            height: i,
            rx: 6,
            className: sr,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ b("g", { className: Uh, strokeWidth: 0, children: [
          /* @__PURE__ */ d("circle", { cx: 17, cy: i / 2, r: 12 }),
          /* @__PURE__ */ d("rect", { x: 33, y: 12, width: n - 44, height: i - 24, rx: 5 })
        ] })
      ] });
    case "browser":
      return /* @__PURE__ */ b(H, { children: [
        /* @__PURE__ */ d(
          "rect",
          {
            width: n,
            height: i,
            rx: 6,
            className: sr,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ b("g", { className: Uh, strokeWidth: 0, children: [
          /* @__PURE__ */ d("circle", { cx: 16, cy: 17, r: 7 }),
          /* @__PURE__ */ d("circle", { cx: 36, cy: 17, r: 7 }),
          /* @__PURE__ */ d("circle", { cx: 56, cy: 17, r: 7 }),
          /* @__PURE__ */ d("rect", { x: 70, y: 8, width: n - 80, height: 17, rx: 4 }),
          /* @__PURE__ */ d("rect", { x: 10, y: 32, width: n - 20, height: i - 42, rx: 4 })
        ] })
      ] });
    case "person":
      return /* @__PURE__ */ b(H, { children: [
        /* @__PURE__ */ d(
          "rect",
          {
            width: n,
            height: i,
            rx: 6,
            strokeWidth: 0
          }
        ),
        /* @__PURE__ */ d(
          "svg",
          {
            x: n - hn.width - 6,
            y: i - hn.height,
            width: hn.width,
            height: hn.height,
            viewBox: `0 0 ${hn.width} ${hn.height}`,
            className: sr,
            children: /* @__PURE__ */ d(
              "path",
              {
                strokeWidth: 0,
                d: hn.path
              }
            )
          }
        )
      ] });
    case "queue": {
      const { path: r, rx: o, ry: s } = Ay(n, i);
      return /* @__PURE__ */ b(H, { children: [
        /* @__PURE__ */ d("path", { d: r, strokeWidth: 2 }),
        /* @__PURE__ */ d("ellipse", { cx: o, cy: s, ry: s - 0.75, rx: o, className: sr, strokeWidth: 2 })
      ] });
    }
    case "storage":
    case "cylinder": {
      const { path: r, rx: o, ry: s } = My(n, i);
      return /* @__PURE__ */ b(H, { children: [
        /* @__PURE__ */ d("path", { d: r, strokeWidth: 2 }),
        /* @__PURE__ */ d("ellipse", { cx: o, cy: s, ry: s, rx: o - 0.75, className: sr, strokeWidth: 2 })
      ] });
    }
    case "rectangle":
      return /* @__PURE__ */ d(
        "rect",
        {
          width: n,
          height: i,
          rx: 6,
          strokeWidth: 0
        }
      );
    default:
      return Pt(e);
  }
}
function Wr({ data: e, width: n, height: i, isMultiple: r = !1, withSelectedIndicator: o = !0 }) {
  let s = n && n > 10 ? n : e.width, a = i && i > 10 ? i : e.height;
  return /* @__PURE__ */ b(H, { children: [
    r && /* @__PURE__ */ d("svg", { className: j(_T, qn), viewBox: `0 0 ${s} ${a}`, children: /* @__PURE__ */ d(Yh, { shape: e.shape, w: s, h: a }) }),
    /* @__PURE__ */ b("svg", { className: CT, viewBox: `0 0 ${s} ${a}`, children: [
      o && /* @__PURE__ */ d(ET, { shape: e.shape, w: s, h: a }),
      /* @__PURE__ */ d(Yh, { shape: e.shape, w: s, h: a })
    ] })
  ] });
}
function ET({ shape: e, w: n, h: i }) {
  let r;
  switch (e) {
    case "queue":
      r = /* @__PURE__ */ d("path", { d: Ay(n, i).path });
      break;
    case "storage":
    case "cylinder": {
      r = /* @__PURE__ */ d("path", { d: My(n, i).path });
      break;
    }
    default: {
      r = /* @__PURE__ */ d(
        "rect",
        {
          x: -1,
          y: -1,
          width: n + 2,
          height: i + 2,
          rx: 6
        }
      );
      break;
    }
  }
  return /* @__PURE__ */ d("g", { className: j(ST, qn), children: r });
}
var PT = "jk2gm30", TT = "jk2gm32", MT = "jk2gm33", AT = "jk2gm34", IT = "jk2gm35", DT = "jk2gm36", NT = "jk2gm37", RT = "var(--likec4-icon-size)";
function Jo({ id: e, data: n, iconSize: i }) {
  const r = Es({
    element: {
      id: e,
      title: n.title,
      icon: n.icon
    },
    className: NT
  }), o = Ty(n.style).size, a = o === "sm" || o === "xs";
  return /* @__PURE__ */ b(
    A,
    {
      className: j(
        IT,
        rn(r) && PT,
        "likec4-element"
      ),
      style: {
        ...Pc(i) && iu({
          [RT]: `${i}px`
        })
      },
      children: [
        r,
        /* @__PURE__ */ b(A, { className: j(DT, "likec4-element-main-props"), children: [
          /* @__PURE__ */ d(
            $,
            {
              component: "h3",
              className: j(TT, "likec4-element-title"),
              lineClamp: a ? 2 : 3,
              children: n.title
            }
          ),
          n.technology && /* @__PURE__ */ d(
            $,
            {
              component: "div",
              className: j(AT, qn, "likec4-element-technology"),
              children: n.technology
            }
          ),
          n.description && /* @__PURE__ */ d(
            $,
            {
              component: "div",
              className: j(MT, "likec4-element-description"),
              lineClamp: a ? 3 : 5,
              children: n.description
            }
          )
        ] })
      ]
    }
  );
}
const Xh = {
  top: "50%",
  left: "50%",
  visibility: "hidden"
}, ar = () => /* @__PURE__ */ b(H, { children: [
  /* @__PURE__ */ d(Nt, { type: "target", position: Rt.Top, style: Xh }),
  /* @__PURE__ */ d(Nt, { type: "source", position: Rt.Bottom, style: Xh })
] });
class Xe {
  constructor(n, i) {
    this.x = n, this.y = i;
  }
  static create(n) {
    return new Xe(n.x, n.y);
  }
  static add(n, i) {
    return { x: n.x + i.x, y: n.y + i.y };
  }
  static sub(n, i) {
    return { x: n.x - i.x, y: n.y - i.y };
  }
  static mul(n, i) {
    return { x: n.x * i, y: n.y * i };
  }
  static dot(n, i) {
    return n.x * i.x + n.y * i.y;
  }
  static cross(n, i) {
    return new Xe(n.y * i.x - n.x * i.y, n.x * i.y - n.y * i.x);
  }
  static setLength(n, i) {
    return En(n).setLength(i);
  }
  add(n) {
    return new Xe(this.x + n.x, this.y + n.y);
  }
  sub(n) {
    return new Xe(this.x - n.x, this.y - n.y);
  }
  mul(n) {
    return new Xe(this.x * n, this.y * n);
  }
  dot(n) {
    return this.x * n.x + this.y * n.y;
  }
  cross(n) {
    return new Xe(this.y * n.x - this.x * n.y, this.x * n.y - this.y * n.x);
  }
  abs() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  setLength(n) {
    return this.mul(n / this.abs());
  }
}
function En(e) {
  return Xe.create(e);
}
var LT = "zcezy90", $T = "zcezy91", zT = "_1e4yniu0", OT = "_1e4yniu1";
const VT = ({ notes: e, children: n }) => {
  const {
    isActive: i,
    isParallel: r,
    hasNext: o,
    hasPrevious: s
  } = pt((f) => ({
    isActive: Pg(f.activeWalkthrough),
    isParallel: rn(f.activeWalkthrough?.parallelPrefix),
    hasNext: f.xyedges.findIndex((h) => h.id === f.activeWalkthrough?.stepId) < f.xyedges.length - 1,
    hasPrevious: f.xyedges.findIndex((h) => h.id === f.activeWalkthrough?.stepId) > 0
  })), a = de(), [l, c] = ge(!1), u = Fi();
  return Nc(
    () => {
      c(!0);
    },
    [],
    300
  ), /* @__PURE__ */ b(
    Ri,
    {
      shadow: "xs",
      offset: 16,
      opened: l,
      closeOnClickOutside: !1,
      ...u,
      children: [
        /* @__PURE__ */ d(Li, { children: n }),
        /* @__PURE__ */ b(
          $i,
          {
            component: be,
            p: "xs",
            onPointerDownCapture: Ee,
            onClick: Ee,
            onDoubleClick: Ee,
            children: [
              /* @__PURE__ */ d(jn, { miw: 180, maw: 450, mah: 350, type: "scroll", mx: "auto", mt: 2, children: /* @__PURE__ */ d($, { component: "div", className: OT, p: 4, children: e }) }),
              /* @__PURE__ */ d(
                hp,
                {
                  size: "xs",
                  className: zT,
                  onClick: () => c(!1)
                }
              ),
              (s || o) && /* @__PURE__ */ b(K, { gap: 0, justify: s ? "flex-start" : "flex-end", children: [
                s && /* @__PURE__ */ d(
                  le,
                  {
                    variant: "subtle",
                    radius: "xs",
                    size: "compact-xs",
                    onClick: () => a.walkthroughStep("previous"),
                    children: "back"
                  }
                ),
                o && /* @__PURE__ */ d(
                  le,
                  {
                    variant: "subtle",
                    radius: "xs",
                    size: "compact-xs",
                    onClick: () => a.walkthroughStep("next"),
                    children: "next"
                  }
                )
              ] })
            ]
          }
        )
      ]
    }
  );
};
var BT = "_1klecxu0", jT = "_1klecxu1", FT = "_1klecxu2";
function cu({
  value: e,
  size: n = "md"
}) {
  const i = n === "md", r = new URL(e.url, window.location.href).toString();
  return /* @__PURE__ */ d(_r, { value: r, children: ({ copied: o, copy: s }) => /* @__PURE__ */ b(
    fp,
    {
      href: r,
      target: "_blank",
      underline: "never",
      className: BT,
      "data-size": n,
      onClick: Ee,
      children: [
        /* @__PURE__ */ d(
          se,
          {
            className: jT,
            tabIndex: -1,
            size: i ? 24 : 20,
            variant: o ? "light" : "subtle",
            color: o ? "teal" : "gray",
            onClick: (a) => {
              a.stopPropagation(), a.preventDefault(), s();
            },
            children: o ? /* @__PURE__ */ d(Ss, {}) : /* @__PURE__ */ d(Vc, { style: { width: "65%", opacity: 0.65 } })
          }
        ),
        /* @__PURE__ */ b(A, { className: FT, children: [
          /* @__PURE__ */ d(
            $,
            {
              component: "div",
              fz: i ? "xs" : 11,
              truncate: !0,
              lh: i ? 1.3 : 1.2,
              fw: e.title ? 500 : 400,
              children: e.title || r
            }
          ),
          e.title && /* @__PURE__ */ d($, { component: "div", fz: i ? 10 : 9, c: "dimmed", lh: i ? 1.2 : 1.1, truncate: !0, children: r })
        ] })
      ]
    }
  ) });
}
const Iy = Le(null);
function it(e, n) {
  const i = oe(Iy);
  if (Tc(n) && qo(i) && i.type !== n)
    throw new Error(`Invalid LikeC4ModelContext, expected "${n}" but got "${i.type}" in context`);
  if (Ic(e) && e === !0 && !i)
    throw new Error("No LikeC4Model found in context");
  return i;
}
const Hr = (e, n) => Ol(e.label, n.label);
function cl(e) {
  return {
    label: e.title,
    value: e.id,
    children: [...e.children()].map(cl).sort(Hr)
  };
}
function WT(e) {
  const n = it(!0);
  return ce(() => e ? [...n.view(e).roots()].map(cl).sort(Hr) : [...n.roots()].map(cl).sort(Hr), [n, e ?? null]);
}
var HT = "_1keswys0", qT = "_1keswys1", Kh = "_1keswys2", GT = "_1keswys3";
const Sr = (e) => e.stopPropagation(), Zh = vt.withProps({
  color: "gray",
  fz: "xs",
  openDelay: 300,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function UT({
  edgeId: e,
  source: n,
  target: i,
  disabled: r = !1,
  children: o
}) {
  const { diagramEdge: s, sourceNode: a, targetNode: l } = pt((y) => ({
    diagramEdge: xy(y, e),
    sourceNode: Zo(y, n),
    targetNode: Zo(y, i)
  })), c = it(!0), u = de(), f = Fi(), h = dt((y) => {
    y.stopPropagation(), u.openRelationshipDetails(e);
  }, [e]);
  if (!s || !a || !l)
    return /* @__PURE__ */ d(H, { children: o });
  const [p, m] = ve(
    s.relations,
    Ce((y) => {
      try {
        return c.relationship(y);
      } catch (v) {
        return console.error(
          `View is cached and likec4model missing relationship ${y} from ${a.id} -> ${l.id}`,
          v
        ), null;
      }
    }),
    Gt(rn),
    _c((y) => y.source.id === a.id && y.target.id === l.id)
  ), g = (y, v) => /* @__PURE__ */ b(Sl, { children: [
    v > 0 && /* @__PURE__ */ d(Ru, { opacity: 0.65 }),
    /* @__PURE__ */ d(
      _t,
      {
        onClick: h,
        component: YT,
        relationship: y,
        sourceNode: a,
        targetNode: l,
        edge: s
      }
    )
  ] }, y.id);
  return p.length + m.length === 0 ? /* @__PURE__ */ d(H, { children: o }) : /* @__PURE__ */ b(
    wn,
    {
      trigger: "click-hover",
      openDelay: 300,
      closeDelay: 450,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      keepMounted: !1,
      closeOnItemClick: !1,
      disabled: r,
      position: "bottom-start",
      middlewares: { size: { padding: 8 } },
      ...f,
      children: [
        /* @__PURE__ */ d(El, { children: o }),
        /* @__PURE__ */ b(
          Pl,
          {
            className: HT,
            onPointerDownCapture: Sr,
            onPointerDown: Sr,
            onClick: Sr,
            children: [
              p.length > 0 && /* @__PURE__ */ b(H, { children: [
                /* @__PURE__ */ d(Na, { children: "direct relationships" }),
                p.map(g)
              ] }),
              m.length > 0 && /* @__PURE__ */ b(H, { children: [
                p.length > 0 && /* @__PURE__ */ d(Ru, {}),
                /* @__PURE__ */ d(Na, { children: "resolved from nested" }),
                m.map(g)
              ] }),
              /* @__PURE__ */ d(A, { pos: "absolute", top: 5, right: 6, children: /* @__PURE__ */ d(
                se,
                {
                  size: 24,
                  variant: "subtle",
                  onClick: h,
                  children: /* @__PURE__ */ d(_s, { style: { width: "70%" } })
                }
              ) })
            ]
          }
        )
      ]
    }
  );
}
const YT = an(({
  className: e,
  relationship: n,
  edge: i,
  sourceNode: r,
  targetNode: o,
  ...s
}, a) => {
  const l = de(), { enableNavigateTo: c } = Fe("NavigateTo"), { onOpenSource: u } = ji(), f = l.currentView.id, h = Jh(n, n.source.id, r), p = Jh(n, n.target.id, o), m = c && n.navigateTo?.id !== f ? n.navigateTo?.id : void 0, g = n.links;
  return /* @__PURE__ */ b(be, { ref: a, className: j(qT, e), ...s, children: [
    /* @__PURE__ */ b(K, { gap: 4, children: [
      /* @__PURE__ */ d($, { component: "div", className: Kh, "data-likec4-color": r.color, children: h }),
      /* @__PURE__ */ d(Br, { stroke: 2.5, size: 11 }),
      /* @__PURE__ */ d($, { component: "div", className: Kh, "data-likec4-color": o.color, children: p }),
      (m || !!u) && /* @__PURE__ */ b(pp, { openDelay: 100, children: [
        /* @__PURE__ */ d(Ro, { w: "xs" }),
        m && /* @__PURE__ */ d(Zh, { label: "Open dynamic view", children: /* @__PURE__ */ d(
          se,
          {
            className: j("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: Sr,
            onClick: (y) => {
              y.stopPropagation(), l.navigateTo(m);
            },
            role: "button",
            children: /* @__PURE__ */ d(kt, { size: "80%", stroke: 2 })
          }
        ) }),
        /* @__PURE__ */ d($c, { feature: "Vscode", children: /* @__PURE__ */ d(Zh, { label: "Open source", children: /* @__PURE__ */ d(
          se,
          {
            className: j("nodrag nopan"),
            size: "sm",
            radius: "sm",
            variant: "default",
            onPointerDownCapture: Sr,
            onClick: (y) => {
              y.stopPropagation(), l.openSource({ relation: n.id });
            },
            role: "button",
            children: /* @__PURE__ */ d(ro, { size: "80%", stroke: 2 })
          }
        ) }) })
      ] })
    ] }),
    /* @__PURE__ */ d(A, { className: GT, children: n.title || "untitled" }),
    n.description && /* @__PURE__ */ d($, { size: "xs", c: "dimmed", children: n.description }),
    g.length > 0 && /* @__PURE__ */ d(
      be,
      {
        gap: 3,
        justify: "stretch",
        align: "stretch",
        children: g.map((y) => /* @__PURE__ */ d(cu, { size: "sm", value: y }, y.url))
      }
    )
  ] });
});
function Jh(e, n, i) {
  const r = e.isDeploymentRelation() ? i.id : ct.modelRef(i) || "";
  return Vl(r) + n.slice(r.length);
}
function XT(e) {
  const { width: n, height: i } = Ut(e), { x: r, y: o } = e.internals.positionAbsolute;
  return {
    x: r + n / 2,
    y: o + i / 2
  };
}
function bo(e, n, i = 0) {
  const r = XT(e), { width: o, height: s } = Ut(e), a = new Xe(n.x, n.y).sub(r), l = (i + (o || 0) / 2) / a.x, c = (i + (s || 0) / 2) / a.y, u = Math.min(Math.abs(l), Math.abs(c));
  return En(a).mul(u).add(r);
}
const KT = CP().curve(EP).x((e) => e.x).y((e) => e.y), ZT = ru((e) => {
  const [n, i] = ge(!1), r = Yg(), o = RC(), s = de(), { enableNavigateTo: a, enableEdgeEditing: l, enableRelationshipDetails: c } = Fe(
    "NavigateTo",
    "EdgeEditing",
    "RelationshipDetails"
  ), {
    id: u,
    source: f,
    sourceX: h,
    sourceY: p,
    target: m,
    targetX: g,
    targetY: y,
    data: {
      id: v,
      navigateTo: w,
      points: x,
      active: k = !1,
      dimmed: _ = !1,
      labelBBox: S,
      labelXY: P,
      ...C
    }
  } = e, T = xe(Ph(f), `source node ${f} not found`), M = xe(Ph(m), `target node ${m} not found`), D = rn(C.controlPoints) || !hr(T.internals.positionAbsolute, T.data.position) || !hr(M.internals.positionAbsolute, M.data.position);
  let L = C.controlPoints ?? Jg(e.data), z;
  if (D) {
    const E = { x: h, y: p }, N = { x: g, y }, R = 6, O = C.dir === "back" ? [
      N,
      bo(M, on(L) ?? E, R),
      ...L,
      bo(T, yn(L) ?? N, R),
      E
    ] : [
      E,
      bo(T, on(L) ?? N, R),
      ...L,
      bo(M, yn(L) ?? E, R),
      N
    ];
    z = xe(KT(O));
  } else
    z = UC(x);
  let Q = S?.x ?? 0, ee = S?.y ?? 0;
  const [Z, ae] = ge({
    x: P?.x ?? Q,
    y: P?.y ?? ee
  }), G = J(null);
  ie(() => {
    const E = G.current;
    if (!E) return;
    const N = E.getPointAtLength(E.getTotalLength() * 0.5), R = {
      x: Math.round(N.x),
      y: Math.round(N.y)
    };
    ae((O) => hr(O, R) ? O : R);
  }, [z]), Nc(
    () => {
      !S || S.x === Z.x && S.y === Z.y || o.updateEdgeData(u, {
        labelXY: {
          x: Z.x,
          y: Z.y
        }
      });
    },
    [Z],
    50,
    300
  ), (D || n) && (Q = Z.x, ee = Z.y);
  const te = (E, N, R) => {
    const { addSelectedEdges: O } = r.getState();
    O([u]);
    const V = s.cancelSaveManualLayout();
    N.stopPropagation();
    let W = !1, ne = { x: N.clientX, y: N.clientY };
    const pe = (ke) => {
      const he = {
        x: ke.clientX,
        y: ke.clientY
      };
      if (!hr(ne, he)) {
        i(!0), W = !0, ne = he;
        const { x: ze, y: rt } = o.screenToFlowPosition(ne, { snapToGrid: !1 });
        o.updateEdgeData(u, (Lt) => {
          const Yt = (Lt.data.controlPoints ?? L).slice();
          return Yt[E] = {
            x: Math.round(ze),
            y: Math.round(rt)
          }, {
            controlPoints: Yt
          };
        });
      }
      ke.stopPropagation();
    }, He = (ke) => {
      R.removeEventListener("pointermove", pe, {
        capture: !0
      }), W && ke.stopPropagation(), (W || V) && s.scheduleSaveManualLayout(), i(!1);
    };
    R.addEventListener("pointermove", pe, {
      capture: !0
    }), R.addEventListener("pointerup", He, {
      once: !0,
      capture: !0
    });
  }, $e = (E, N, R) => {
    if (L.length <= 1)
      return;
    const O = (V) => {
      const W = L.slice();
      W.splice(E, 1), V.stopPropagation(), setTimeout(() => {
        o.updateEdgeData(u, { controlPoints: W }), s.scheduleSaveManualLayout();
      }, 10), R.removeEventListener("pointerup", O, {
        capture: !0
      }), V.stopPropagation();
    };
    R.addEventListener("pointerup", O, {
      once: !0,
      capture: !0
    }), N.stopPropagation();
  }, Me = (E, N) => {
    const { domNode: R } = r.getState();
    if (!(!R || N.pointerType !== "mouse"))
      switch (N.button) {
        case 0:
          te(E, N, R);
          break;
        case 2:
          $e(E, N, R);
          break;
      }
  }, We = (E) => {
    const { domNode: N } = r.getState();
    !N || E.pointerType !== "mouse" || E.button === 2 && (o.updateEdgeData(u, (R) => {
      const O = [
        new Xe(h, p),
        ...L.map(En) || [],
        new Xe(g, y)
      ];
      let V = { x: E.clientX, y: E.clientY };
      const W = En(o.screenToFlowPosition(V, { snapToGrid: !1 }));
      let ne = 0, pe = 1 / 0;
      for (let ke = 0; ke < O.length - 1; ke++) {
        const he = O[ke], ze = O[ke + 1], rt = ze.sub(he), Lt = W.sub(he), Yt = W.sub(ze);
        if (rt.dot(Lt) * rt.dot(Yt) < 0) {
          const De = Math.abs(rt.cross(Lt).abs() / rt.abs());
          De < pe && (pe = De, ne = ke);
        }
      }
      const He = R.data.controlPoints?.slice() || [];
      return He.splice(ne, 0, W), { controlPoints: He };
    }), s.scheduleSaveManualLayout(), E.stopPropagation());
  };
  let Ae;
  if (!n) {
    const E = e.data.notes;
    E && Np(e.id) && s.getContext().activeWalkthrough?.stepId === e.id ? Ae = (N) => /* @__PURE__ */ d(VT, { notes: E, children: /* @__PURE__ */ d("div", { ...N }) }) : c && (Ae = (N) => /* @__PURE__ */ d(
      UT,
      {
        disabled: !!_,
        source: f,
        target: m,
        edgeId: v,
        children: /* @__PURE__ */ d("div", { ...N })
      }
    ));
  }
  return /* @__PURE__ */ b(su, { ...e, className: j(n && $T), children: [
    /* @__PURE__ */ d(au, { ...e, svgPath: z, ref: G, onEdgePointerDown: We }),
    l && /* @__PURE__ */ d(
      "g",
      {
        onContextMenu: (E) => {
          E.preventDefault(), E.stopPropagation();
        },
        children: L.map((E, N) => /* @__PURE__ */ d(
          "circle",
          {
            onPointerDown: (R) => Me(N, R),
            className: LT,
            cx: E.x,
            cy: E.y,
            r: 3
          },
          N
        ))
      }
    ),
    /* @__PURE__ */ d(
      Ts,
      {
        edgeProps: e,
        labelPosition: {
          x: Q,
          y: ee,
          translate: D ? "translate(-50%, 0)" : void 0
        },
        ...Ae && { renderRoot: Ae },
        children: !n && a && w && /* @__PURE__ */ d(
          ou,
          {
            ...e,
            onClick: (E) => {
              E.stopPropagation(), s.navigateTo(w);
            }
          }
        )
      }
    )
  ] });
}), Qh = (e) => {
  const { enableNavigateTo: n } = Fe("NavigateTo"), i = de(), { navigateTo: r } = e.data;
  return r && n ? /* @__PURE__ */ d(
    AP,
    {
      onClick: (o) => {
        o.stopPropagation(), i.navigateTo(r, e.id);
      },
      ...e
    }
  ) : null;
}, JT = (e) => {
  const { enableNavigateTo: n, enableRelationshipBrowser: i } = Fe("RelationshipBrowser", "NavigateTo"), r = de(), o = [], { navigateTo: s, modelFqn: a } = e.data;
  return s && n && o.push({
    key: "navigate",
    icon: /* @__PURE__ */ d(kt, {}),
    onClick: (l) => {
      l.stopPropagation(), r.navigateTo(s, e.id);
    }
  }), i && o.push({
    key: "relationships",
    icon: /* @__PURE__ */ d(Cs, {}),
    onClick: (l) => {
      l.stopPropagation(), r.openRelationshipsBrowser(a);
    }
  }), /* @__PURE__ */ d(
    Ms,
    {
      buttons: o,
      ...e
    }
  );
}, QT = (e) => {
  const { enableNavigateTo: n, enableRelationshipBrowser: i } = Fe("NavigateTo", "RelationshipBrowser"), r = de(), o = [], { navigateTo: s, modelFqn: a } = e.data;
  return s && n && o.push({
    key: "navigate",
    icon: /* @__PURE__ */ d(kt, {}),
    onClick: (l) => {
      l.stopPropagation(), r.navigateTo(s, e.id);
    }
  }), i && a && o.push({
    key: "relationships",
    icon: /* @__PURE__ */ d(Cs, {}),
    onClick: (l) => {
      l.stopPropagation(), r.openRelationshipsBrowser(a);
    }
  }), /* @__PURE__ */ d(Ms, { buttons: o, ...e });
}, {
  primary: eM,
  secondary: tM,
  muted: nM,
  ...iM
} = Bl.elements, rM = [
  { key: "primary", value: eM.fill },
  { key: "secondary", value: tM.fill },
  { key: "muted", value: nM.fill }
], oM = Ec(iM).map((e) => ({
  key: e,
  value: Bl.elements[e].fill
})), Dy = vt.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4,
  withinPortal: !1
});
function As(e, n) {
  const { onChange: i } = ji(), r = de(), [o, s] = ge(null), a = q((c) => {
    if (c === null) {
      me(o, "originalColor is null"), s(null), r.updateNodeData(n.id, {
        color: o
      });
      return;
    }
    s((u) => u ?? n.data.color), r.updateNodeData(n.id, {
      color: c
    });
  }), l = q((c) => {
    i?.({
      change: {
        op: "change-element-style",
        style: c,
        targets: [e]
      }
    });
    const { shape: u, color: f, ...h } = c;
    r.updateNodeData(n.id, {
      ...u && { shape: u },
      ...f && { color: f },
      style: h
    });
  });
  return {
    elementColor: o ?? n.data.color,
    onColorPreview: a,
    onChange: l
  };
}
function Is({ fqn: e }) {
  const n = de();
  return /* @__PURE__ */ d(Dy, { label: "Browse relationships", children: /* @__PURE__ */ d(
    se,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (i) => {
        i.stopPropagation(), n.openRelationshipsBrowser(e);
      },
      children: /* @__PURE__ */ d(
        Cs,
        {
          stroke: 2,
          style: {
            width: "72%",
            height: "72%"
          }
        }
      )
    }
  ) });
}
function Ds(e) {
  const { onOpenSource: n } = ji();
  return n ? /* @__PURE__ */ d(Dy, { label: "Open source", children: /* @__PURE__ */ d(
    se,
    {
      size: "sm",
      variant: "subtle",
      color: "gray",
      onClick: (i) => {
        i.stopPropagation(), e.elementId ? n?.({
          element: e.elementId
        }) : e.deploymentId && n?.({
          deployment: e.deploymentId
        });
      },
      children: /* @__PURE__ */ d(ro, { stroke: 1.8, style: { width: "70%" } })
    }
  ) }) : null;
}
function Ns({
  elementColor: e,
  elementOpacity: n,
  onColorPreview: i,
  isOpacityEditable: r = !1,
  onChange: o,
  ...s
}) {
  return /* @__PURE__ */ b(
    Ri,
    {
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      position: "right-end",
      offset: 2,
      withinPortal: !1,
      ...s,
      children: [
        /* @__PURE__ */ d(Li, { children: /* @__PURE__ */ d(le, { variant: "subtle", color: "gray", size: "compact-xs", px: 3, children: /* @__PURE__ */ d(
          Ra,
          {
            color: Bl.elements[e]?.fill,
            size: 14,
            withShadow: !0,
            style: { color: "#fff", cursor: "pointer" }
          }
        ) }) }),
        /* @__PURE__ */ b($i, { p: "xs", children: [
          /* @__PURE__ */ d(
            sM,
            {
              elementColor: e,
              onColorPreview: i,
              onChange: (a) => o({ color: a })
            }
          ),
          r && /* @__PURE__ */ b(H, { children: [
            /* @__PURE__ */ d(Ro, { h: "xs" }),
            /* @__PURE__ */ d(Tl, { label: "opacity", labelPosition: "left" }),
            /* @__PURE__ */ d(Ro, { h: "xs" }),
            /* @__PURE__ */ d(
              aM,
              {
                elementOpacity: n,
                onOpacityChange: (a) => {
                  o({ opacity: a });
                }
              }
            )
          ] })
        ] })
      ]
    }
  );
}
function sM({
  elementColor: e,
  onColorPreview: n,
  onChange: i
}) {
  const r = (o) => (s) => {
    s.stopPropagation(), n(null), e !== o && i(o);
  };
  return /* @__PURE__ */ d(be, { gap: 2, onMouseLeave: () => n(null), children: /* @__PURE__ */ b(pp, { openDelay: 1e3, closeDelay: 300, children: [
    /* @__PURE__ */ d(Cr, { maw: 120, gap: "6", justify: "flex-start", align: "flex-start", direction: "row", wrap: "wrap", children: rM.map(({ key: o, value: s }) => /* @__PURE__ */ d(
      vt,
      {
        label: o,
        fz: "xs",
        color: "dark",
        offset: 2,
        withinPortal: !1,
        transitionProps: { duration: 140, transition: "slide-up" },
        children: /* @__PURE__ */ d(
          Ra,
          {
            color: s,
            size: 18,
            withShadow: !0,
            onMouseEnter: () => n(o),
            onClick: r(o),
            style: { color: "#fff", cursor: "pointer" },
            children: e === o && /* @__PURE__ */ d(Lu, { style: { width: Re(10), height: Re(10) } })
          }
        )
      },
      o
    )) }),
    /* @__PURE__ */ d(
      Cr,
      {
        mt: "sm",
        maw: 110,
        gap: "6",
        justify: "flex-start",
        align: "flex-start",
        direction: "row",
        wrap: "wrap",
        children: oM.map(({ key: o, value: s }) => /* @__PURE__ */ d(
          vt,
          {
            label: o,
            fz: "xs",
            color: "dark",
            offset: 2,
            transitionProps: { duration: 140, transition: "slide-up" },
            children: /* @__PURE__ */ d(
              Ra,
              {
                color: s,
                size: 18,
                onMouseEnter: () => n(o),
                onClick: r(o),
                style: { color: "#fff", cursor: "pointer" },
                children: e === o && /* @__PURE__ */ d(Lu, { style: { width: Re(10), height: Re(10) } })
              }
            )
          },
          o
        ))
      }
    )
  ] }) });
}
function aM({
  elementOpacity: e = 100,
  onOpacityChange: n
}) {
  const [i, r] = ge(e);
  return Lg(() => {
    r(e);
  }, [e]), /* @__PURE__ */ d(
    Lv,
    {
      size: "sm",
      color: "dark",
      value: i,
      onChange: r,
      onChangeEnd: n
    }
  );
}
var lM = "_18e06ay0";
const cM = () => pt((e) => e.xynodes.filter((n) => n.selected).length);
function Rs({ title: e, children: n, nodeProps: i, ...r }) {
  const o = cM(), {
    selected: s = !1,
    dragging: a = !1,
    data: {
      hovered: l = !1
    }
  } = i, c = l && o === 0 || s && o === 1;
  let u = 150;
  c ? s ? u = 100 : u = 1e3 : o > 0 && (u = 50);
  const [f] = mp(c, u);
  return /* @__PURE__ */ d(
    T1,
    {
      isVisible: !a && f,
      offset: 4,
      ...r,
      children: /* @__PURE__ */ d(
        ls,
        {
          className: j("nodrag", "nopan"),
          px: 5,
          pb: 8,
          pt: 4,
          radius: "sm",
          shadow: "xl",
          onDoubleClickCapture: Ee,
          onPointerDown: Ee,
          onClick: Ee,
          onDoubleClick: Ee,
          withBorder: !0,
          children: /* @__PURE__ */ b(be, { gap: 6, children: [
            /* @__PURE__ */ d(A, { pl: 2, children: /* @__PURE__ */ d($, { c: "dimmed", className: lM, children: e }) }),
            /* @__PURE__ */ d(K, { gap: 4, children: n })
          ] })
        }
      )
    }
  );
}
function uM(e) {
  const { enableVscode: n, enableRelationshipBrowser: i } = Fe("RelationshipBrowser", "Vscode"), {
    data: {
      style: r,
      modelFqn: o
    }
  } = e, { elementColor: s, onColorPreview: a, onChange: l } = As(o, e);
  return /* @__PURE__ */ b(
    Rs,
    {
      nodeProps: e,
      title: o,
      align: "start",
      children: [
        /* @__PURE__ */ d(
          Ns,
          {
            elementColor: s,
            onColorPreview: a,
            isOpacityEditable: !0,
            elementOpacity: r?.opacity,
            onChange: l,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ d(
          Ny,
          {
            elementBorderStyle: r?.border,
            onChange: l
          }
        ),
        n && /* @__PURE__ */ d(Ds, { elementId: o }),
        i && /* @__PURE__ */ d(Is, { fqn: o })
      ]
    }
  );
}
function dM(e) {
  const { enableVscode: n, enableRelationshipBrowser: i } = Fe("RelationshipBrowser", "Vscode"), {
    data: {
      deploymentFqn: r,
      style: o,
      modelFqn: s
    }
  } = e, { elementColor: a, onColorPreview: l, onChange: c } = As(r, e);
  return /* @__PURE__ */ b(
    Rs,
    {
      nodeProps: e,
      title: r,
      align: "start",
      children: [
        /* @__PURE__ */ d(
          Ns,
          {
            elementColor: a,
            onColorPreview: l,
            isOpacityEditable: !0,
            elementOpacity: o?.opacity,
            onChange: c,
            position: "left-start"
          }
        ),
        /* @__PURE__ */ d(
          Ny,
          {
            elementBorderStyle: o?.border,
            onChange: c
          }
        ),
        n && /* @__PURE__ */ d(Ds, { deploymentId: r }),
        i && s && /* @__PURE__ */ d(Is, { fqn: s })
      ]
    }
  );
}
function Ny({
  elementBorderStyle: e = "dashed",
  onChange: n
}) {
  const [i, r] = ge(e);
  return ie(() => {
    r(e);
  }, [e]), /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d(
    gp,
    {
      size: "xs",
      fullWidth: !0,
      withItemsBorders: !1,
      value: i,
      onChange: (o) => {
        const s = o;
        r(s), n({ border: s });
      },
      styles: {
        label: {
          paddingTop: 2,
          paddingBottom: 2
        }
      },
      data: [
        { label: "Solid", value: "solid" },
        { label: "Dashed", value: "dashed" },
        { label: "Dotted", value: "dotted" },
        { label: "None", value: "none" }
      ]
    }
  ) });
}
function hM(e) {
  const { enableVscode: n, enableRelationshipBrowser: i } = Fe("RelationshipBrowser", "Vscode"), {
    data: {
      shape: r,
      modelFqn: o
    }
  } = e, { elementColor: s, onColorPreview: a, onChange: l } = As(o, e);
  return /* @__PURE__ */ b(
    Rs,
    {
      nodeProps: e,
      title: o,
      align: "start",
      children: [
        /* @__PURE__ */ d(
          Ry,
          {
            elementShape: r,
            onChange: l
          }
        ),
        /* @__PURE__ */ d(
          Ns,
          {
            elementColor: s,
            onColorPreview: a,
            onChange: l,
            position: "right-end"
          }
        ),
        n && /* @__PURE__ */ d(Ds, { elementId: o }),
        i && /* @__PURE__ */ d(Is, { fqn: o })
      ]
    }
  );
}
function fM(e) {
  const { enableVscode: n, enableRelationshipBrowser: i } = Fe("RelationshipBrowser", "Vscode"), {
    data: {
      shape: r,
      deploymentFqn: o,
      modelFqn: s
    }
  } = e, { elementColor: a, onColorPreview: l, onChange: c } = As(o, e);
  return /* @__PURE__ */ b(
    Rs,
    {
      nodeProps: e,
      title: o,
      align: "start",
      children: [
        /* @__PURE__ */ d(
          Ry,
          {
            elementShape: r,
            onChange: c
          }
        ),
        /* @__PURE__ */ d(
          Ns,
          {
            elementColor: a,
            onColorPreview: l,
            onChange: c,
            position: "right-end"
          }
        ),
        n && /* @__PURE__ */ d(Ds, { deploymentId: o }),
        i && s && /* @__PURE__ */ d(Is, { fqn: s })
      ]
    }
  );
}
function Ry({
  elementShape: e,
  onChange: n
}) {
  return /* @__PURE__ */ b(
    wn,
    {
      openDelay: 300,
      closeDelay: 450,
      floatingStrategy: "fixed",
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      closeOnEscape: !0,
      closeOnItemClick: !1,
      position: "top-start",
      offset: 2,
      styles: {
        item: {
          padding: "calc(var(--mantine-spacing-xs) / 1.5) var(--mantine-spacing-xs)"
        }
      },
      withinPortal: !1,
      children: [
        /* @__PURE__ */ d(El, { children: /* @__PURE__ */ d(
          le,
          {
            variant: "light",
            color: "gray",
            size: "compact-xs",
            rightSection: /* @__PURE__ */ d(jc, { size: 12 }),
            children: e
          }
        ) }),
        /* @__PURE__ */ d(
          Pl,
          {
            onDoubleClick: Ee,
            onClick: Ee,
            children: B1.map((i) => /* @__PURE__ */ d(
              _t,
              {
                fz: 12,
                fw: 500,
                value: i,
                rightSection: e === i ? /* @__PURE__ */ d(Ss, { size: 12 }) : void 0,
                onClick: (r) => {
                  r.stopPropagation(), n({ shape: i });
                },
                children: i
              },
              i
            ))
          }
        )
      ]
    }
  );
}
const ef = ({ fqn: e, ...n }) => {
  const { enableElementDetails: i } = Fe("ElementDetails"), r = de();
  return i ? /* @__PURE__ */ d(
    lu,
    {
      ...n,
      onClick: (o) => {
        o.stopPropagation(), r.openElementDetails(e, n.id);
      }
    }
  ) : null;
}, pM = {
  element: Ct((e) => /* @__PURE__ */ b(Fr, { nodeProps: e, children: [
    /* @__PURE__ */ d(Wr, { ...e, isMultiple: e.data.isMultiple }),
    /* @__PURE__ */ d(Jo, { ...e }),
    /* @__PURE__ */ d(JT, { ...e }),
    /* @__PURE__ */ d(
      ef,
      {
        fqn: e.data.modelFqn,
        ...e
      }
    ),
    /* @__PURE__ */ d(yo, { feature: "ReadOnly", children: /* @__PURE__ */ d(hM, { ...e }) }),
    /* @__PURE__ */ d(ar, {})
  ] })),
  deployment: Ct((e) => /* @__PURE__ */ b(Fr, { nodeProps: e, children: [
    /* @__PURE__ */ d(Wr, { ...e, isMultiple: e.data.isMultiple }),
    /* @__PURE__ */ d(Jo, { ...e }),
    /* @__PURE__ */ d(QT, { ...e }),
    !!e.data.modelFqn && /* @__PURE__ */ d(
      ef,
      {
        fqn: e.data.modelFqn,
        ...e
      }
    ),
    /* @__PURE__ */ d(yo, { feature: "ReadOnly", children: /* @__PURE__ */ d(fM, { ...e }) }),
    /* @__PURE__ */ d(ar, {})
  ] })),
  "compound-element": Ct((e) => {
    const n = de();
    return /* @__PURE__ */ b(yi, { nodeProps: e, children: [
      /* @__PURE__ */ d(kr, { ...e }),
      /* @__PURE__ */ d(Qh, { ...e }),
      /* @__PURE__ */ d($c, { feature: "ElementDetails", children: /* @__PURE__ */ d(
        RP,
        {
          ...e,
          onClick: (i) => {
            i.stopPropagation(), n.openElementDetails(e.data.modelFqn, e.id);
          }
        }
      ) }),
      /* @__PURE__ */ d(yo, { feature: "ReadOnly", children: /* @__PURE__ */ d(uM, { ...e }) }),
      /* @__PURE__ */ d(ar, {})
    ] });
  }),
  "compound-deployment": Ct((e) => /* @__PURE__ */ b(yi, { nodeProps: e, children: [
    /* @__PURE__ */ d(kr, { ...e }),
    /* @__PURE__ */ d(Qh, { ...e }),
    /* @__PURE__ */ d(yo, { feature: "ReadOnly", children: /* @__PURE__ */ d(dM, { ...e }) }),
    /* @__PURE__ */ d(ar, {})
  ] })),
  "view-group": Ct((e) => /* @__PURE__ */ b(yi, { nodeProps: e, children: [
    /* @__PURE__ */ d(kr, { ...e }),
    /* @__PURE__ */ d(ar, {})
  ] }))
}, mM = {
  relationship: ZT
}, gM = Le(null), pa = {
  didCatch: !1,
  error: null
};
class Ly extends up {
  constructor(n) {
    super(n), this.resetErrorBoundary = this.resetErrorBoundary.bind(this), this.state = pa;
  }
  static getDerivedStateFromError(n) {
    return {
      didCatch: !0,
      error: n
    };
  }
  resetErrorBoundary() {
    const {
      error: n
    } = this.state;
    if (n !== null) {
      for (var i, r, o = arguments.length, s = new Array(o), a = 0; a < o; a++)
        s[a] = arguments[a];
      (i = (r = this.props).onReset) === null || i === void 0 || i.call(r, {
        args: s,
        reason: "imperative-api"
      }), this.setState(pa);
    }
  }
  componentDidCatch(n, i) {
    var r, o;
    (r = (o = this.props).onError) === null || r === void 0 || r.call(o, n, i);
  }
  componentDidUpdate(n, i) {
    const {
      didCatch: r
    } = this.state, {
      resetKeys: o
    } = this.props;
    if (r && i.error !== null && yM(n.resetKeys, o)) {
      var s, a;
      (s = (a = this.props).onReset) === null || s === void 0 || s.call(a, {
        next: o,
        prev: n.resetKeys,
        reason: "keys"
      }), this.setState(pa);
    }
  }
  render() {
    const {
      children: n,
      fallbackRender: i,
      FallbackComponent: r,
      fallback: o
    } = this.props, {
      didCatch: s,
      error: a
    } = this.state;
    let l = n;
    if (s) {
      const c = {
        error: a,
        resetErrorBoundary: this.resetErrorBoundary
      };
      if (typeof i == "function")
        l = i(c);
      else if (r)
        l = pi(r, c);
      else if (o !== void 0)
        l = o;
      else
        throw a;
    }
    return pi(gM.Provider, {
      value: {
        didCatch: s,
        error: a,
        resetErrorBoundary: this.resetErrorBoundary
      }
    }, l);
  }
}
function yM() {
  let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [], n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  return e.length !== n.length || e.some((i, r) => !Object.is(i, n[r]));
}
const uu = Le(null);
uu.displayName = "ElementDetailsActorContext";
const vM = () => {
  const e = oe(uu);
  if (e === null)
    throw new Error("ElementDetailsActorRef is not provided");
  return e;
};
var wM = "_129pgl12", xM = "_129pgl13", bM = "_129pgl14", kM = "_129pgl15", SM = "_129pgl16", _M = "_129pgl19", CM = "_129pgl1a", EM = "_129pgl1b", PM = "_129pgl1c", TM = "_129pgl1d", MM = "_129pgl1e", AM = "_129pgl1f", IM = "_129pgl1g", DM = "_129pgl1h", NM = "_12fg5ip0", RM = "_12fg5ip1", LM = "_12fg5ip3 _12fg5ip2", $M = "_12fg5ip4 _12fg5ip2";
const zM = ({
  node: e
}) => /* @__PURE__ */ b(K, { className: LM, gap: 6, align: "baseline", wrap: "nowrap", children: [
  /* @__PURE__ */ b($, { component: "div", fz: 11, c: "dimmed", children: [
    e.kind,
    ":"
  ] }),
  /* @__PURE__ */ d($, { component: "div", fz: "sm", fw: "500", children: e.title })
] }), OM = ({
  instance: e
}) => {
  const n = de(), i = n.currentView.id, r = [...e.views()];
  return /* @__PURE__ */ b(K, { className: $M, gap: 4, children: [
    /* @__PURE__ */ d(wt, { color: "gray", variant: "transparent", size: "xs", flex: 0, children: /* @__PURE__ */ d(gC, { stroke: 1.2 }) }),
    /* @__PURE__ */ d($, { component: "div", fz: "sm", fw: "500", flex: "1 1 100%", children: e.title }),
    /* @__PURE__ */ b(A, { onClick: Ee, pos: "relative", "data-no-transform": !0, flex: 0, children: [
      r.length === 0 && /* @__PURE__ */ d(le, { size: "compact-xs", variant: "transparent", color: "gray", disabled: !0, children: "no views" }),
      r.length > 0 && /* @__PURE__ */ b(
        wn,
        {
          shadow: "md",
          withinPortal: !1,
          position: "bottom-start",
          offset: 0,
          closeOnClickOutside: !0,
          clickOutsideEvents: ["pointerdown", "mousedown", "click"],
          closeOnEscape: !0,
          trapFocus: !0,
          children: [
            /* @__PURE__ */ d(wn.Target, { children: /* @__PURE__ */ b(le, { size: "compact-xs", variant: "subtle", color: "gray", children: [
              r.length,
              " view",
              r.length > 1 ? "s" : ""
            ] }) }),
            /* @__PURE__ */ d(wn.Dropdown, { children: r.map((o) => /* @__PURE__ */ d(
              wn.Item,
              {
                px: "xs",
                py: 4,
                disabled: o.id === i,
                leftSection: /* @__PURE__ */ d(wt, { size: "sm", variant: "transparent", color: "gray", children: /* @__PURE__ */ d(kt, { stroke: 1.8, opacity: 0.65 }) }),
                styles: {
                  itemSection: {
                    marginInlineEnd: Re(8)
                  }
                },
                onClick: (s) => {
                  s.stopPropagation(), n.navigateTo(o.id);
                },
                children: o.title
              },
              o.id
            )) })
          ]
        }
      )
    ] })
  ] });
}, VM = nt(({ elementFqn: e }) => {
  const n = it(!0).element(e), i = [...n.deployments()], r = Xr({
    multiple: !1
  }), o = ce(() => {
    let s = [], a = /* @__PURE__ */ new Map();
    for (const l of n.deployments()) {
      let c = {
        label: /* @__PURE__ */ d(OM, { instance: l }),
        value: l.id,
        type: "instance",
        children: []
      };
      a.set(l.id, c);
      let u = l.parent;
      for (; u; ) {
        let f = a.get(u.id);
        if (f) {
          f.children.push(c);
          break;
        }
        f = {
          label: /* @__PURE__ */ d(zM, { node: u }),
          value: u.id,
          type: "node",
          children: [c]
        }, a.set(u.id, f), c = f, u = u.parent;
      }
      !u && !s.includes(c) && s.push(c);
    }
    return s;
  }, [n]);
  return ie(() => {
    r.expandAllNodes();
  }, [o]), i.length === 0 ? /* @__PURE__ */ d(Er, { variant: "light", color: "gray", icon: /* @__PURE__ */ d(_s, {}), children: "This element does not have any deployments" }) : (
    // <Box></Box>
    /* @__PURE__ */ d(
      Kr,
      {
        levelOffset: "sm",
        allowRangeSelection: !1,
        classNames: {
          node: NM,
          label: RM
        },
        styles: {
          root: {
            position: "relative",
            width: "min-content",
            minWidth: 300
          }
        },
        data: o,
        tree: r,
        renderNode: ({ node: s, selected: a, elementProps: l, hasChildren: c }) => /* @__PURE__ */ d(
          A,
          {
            ...l,
            style: {
              ...!c && {
                marginBottom: Re(4)
              }
            },
            children: c ? /* @__PURE__ */ d(
              le,
              {
                fullWidth: !0,
                color: "gray",
                variant: a ? "transparent" : "subtle",
                size: "xs",
                justify: "flex-start",
                styles: {
                  root: {
                    position: "unset",
                    paddingInlineStart: Re(16)
                  }
                },
                children: s.label
              }
            ) : s.label
          }
        )
      }
    )
  );
});
var BM = "\0", fn = "\0", tf = "";
let jM = class {
  _isDirected = !0;
  _isMultigraph = !1;
  _isCompound = !1;
  // Label for the graph itself
  _label;
  // Defaults to be set when creating a new node
  _defaultNodeLabelFn = () => {
  };
  // Defaults to be set when creating a new edge
  _defaultEdgeLabelFn = () => {
  };
  // v -> label
  _nodes = {};
  // v -> edgeObj
  _in = {};
  // u -> v -> Number
  _preds = {};
  // v -> edgeObj
  _out = {};
  // v -> w -> Number
  _sucs = {};
  // e -> edgeObj
  _edgeObjs = {};
  // e -> label
  _edgeLabels = {};
  /* Number of nodes in the graph. Should only be changed by the implementation. */
  _nodeCount = 0;
  /* Number of edges in the graph. Should only be changed by the implementation. */
  _edgeCount = 0;
  _parent;
  _children;
  constructor(n) {
    n && (this._isDirected = Object.hasOwn(n, "directed") ? n.directed : !0, this._isMultigraph = Object.hasOwn(n, "multigraph") ? n.multigraph : !1, this._isCompound = Object.hasOwn(n, "compound") ? n.compound : !1), this._isCompound && (this._parent = {}, this._children = {}, this._children[fn] = {});
  }
  /* === Graph functions ========= */
  /**
   * Whether graph was created with 'directed' flag set to true or not.
   */
  isDirected() {
    return this._isDirected;
  }
  /**
   * Whether graph was created with 'multigraph' flag set to true or not.
   */
  isMultigraph() {
    return this._isMultigraph;
  }
  /**
   * Whether graph was created with 'compound' flag set to true or not.
   */
  isCompound() {
    return this._isCompound;
  }
  /**
   * Sets the label of the graph.
   */
  setGraph(n) {
    return this._label = n, this;
  }
  /**
   * Gets the graph label.
   */
  graph() {
    return this._label;
  }
  /* === Node functions ========== */
  /**
   * Sets the default node label. If newDefault is a function, it will be
   * invoked ach time when setting a label for a node. Otherwise, this label
   * will be assigned as default label in case if no label was specified while
   * setting a node.
   * Complexity: O(1).
   */
  setDefaultNodeLabel(n) {
    return this._defaultNodeLabelFn = n, typeof n != "function" && (this._defaultNodeLabelFn = () => n), this;
  }
  /**
   * Gets the number of nodes in the graph.
   * Complexity: O(1).
   */
  nodeCount() {
    return this._nodeCount;
  }
  /**
   * Gets all nodes of the graph. Note, the in case of compound graph subnodes are
   * not included in list.
   * Complexity: O(1).
   */
  nodes() {
    return Object.keys(this._nodes);
  }
  /**
   * Gets list of nodes without in-edges.
   * Complexity: O(|V|).
   */
  sources() {
    var n = this;
    return this.nodes().filter((i) => Object.keys(n._in[i]).length === 0);
  }
  /**
   * Gets list of nodes without out-edges.
   * Complexity: O(|V|).
   */
  sinks() {
    var n = this;
    return this.nodes().filter((i) => Object.keys(n._out[i]).length === 0);
  }
  /**
   * Invokes setNode method for each node in names list.
   * Complexity: O(|names|).
   */
  setNodes(n, i) {
    var r = arguments, o = this;
    return n.forEach(function(s) {
      r.length > 1 ? o.setNode(s, i) : o.setNode(s);
    }), this;
  }
  /**
   * Creates or updates the value for the node v in the graph. If label is supplied
   * it is set as the value for the node. If label is not supplied and the node was
   * created by this call then the default node label will be assigned.
   * Complexity: O(1).
   */
  setNode(n, i) {
    return Object.hasOwn(this._nodes, n) ? (arguments.length > 1 && (this._nodes[n] = i), this) : (this._nodes[n] = arguments.length > 1 ? i : this._defaultNodeLabelFn(n), this._isCompound && (this._parent[n] = fn, this._children[n] = {}, this._children[fn][n] = !0), this._in[n] = {}, this._preds[n] = {}, this._out[n] = {}, this._sucs[n] = {}, ++this._nodeCount, this);
  }
  /**
   * Gets the label of node with specified name.
   * Complexity: O(|V|).
   */
  node(n) {
    return this._nodes[n];
  }
  /**
   * Detects whether graph has a node with specified name or not.
   */
  hasNode(n) {
    return Object.hasOwn(this._nodes, n);
  }
  /**
   * Remove the node with the name from the graph or do nothing if the node is not in
   * the graph. If the node was removed this function also removes any incident
   * edges.
   * Complexity: O(1).
   */
  removeNode(n) {
    var i = this;
    if (Object.hasOwn(this._nodes, n)) {
      var r = (o) => i.removeEdge(i._edgeObjs[o]);
      delete this._nodes[n], this._isCompound && (this._removeFromParentsChildList(n), delete this._parent[n], this.children(n).forEach(function(o) {
        i.setParent(o);
      }), delete this._children[n]), Object.keys(this._in[n]).forEach(r), delete this._in[n], delete this._preds[n], Object.keys(this._out[n]).forEach(r), delete this._out[n], delete this._sucs[n], --this._nodeCount;
    }
    return this;
  }
  /**
   * Sets node p as a parent for node v if it is defined, or removes the
   * parent for v if p is undefined. Method throws an exception in case of
   * invoking it in context of noncompound graph.
   * Average-case complexity: O(1).
   */
  setParent(n, i) {
    if (!this._isCompound)
      throw new Error("Cannot set parent in a non-compound graph");
    if (i === void 0)
      i = fn;
    else {
      i += "";
      for (var r = i; r !== void 0; r = this.parent(r))
        if (r === n)
          throw new Error("Setting " + i + " as parent of " + n + " would create a cycle");
      this.setNode(i);
    }
    return this.setNode(n), this._removeFromParentsChildList(n), this._parent[n] = i, this._children[i][n] = !0, this;
  }
  _removeFromParentsChildList(n) {
    delete this._children[this._parent[n]][n];
  }
  /**
   * Gets parent node for node v.
   * Complexity: O(1).
   */
  parent(n) {
    if (this._isCompound) {
      var i = this._parent[n];
      if (i !== fn)
        return i;
    }
  }
  /**
   * Gets list of direct children of node v.
   * Complexity: O(1).
   */
  children(n = fn) {
    if (this._isCompound) {
      var i = this._children[n];
      if (i)
        return Object.keys(i);
    } else {
      if (n === fn)
        return this.nodes();
      if (this.hasNode(n))
        return [];
    }
  }
  /**
   * Return all nodes that are predecessors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  predecessors(n) {
    var i = this._preds[n];
    if (i)
      return Object.keys(i);
  }
  /**
   * Return all nodes that are successors of the specified node or undefined if node v is not in
   * the graph. Behavior is undefined for undirected graphs - use neighbors instead.
   * Complexity: O(|V|).
   */
  successors(n) {
    var i = this._sucs[n];
    if (i)
      return Object.keys(i);
  }
  /**
   * Return all nodes that are predecessors or successors of the specified node or undefined if
   * node v is not in the graph.
   * Complexity: O(|V|).
   */
  neighbors(n) {
    var i = this.predecessors(n);
    if (i) {
      const o = new Set(i);
      for (var r of this.successors(n))
        o.add(r);
      return Array.from(o.values());
    }
  }
  isLeaf(n) {
    var i;
    return this.isDirected() ? i = this.successors(n) : i = this.neighbors(n), i.length === 0;
  }
  /**
   * Creates new graph with nodes filtered via filter. Edges incident to rejected node
   * are also removed. In case of compound graph, if parent is rejected by filter,
   * than all its children are rejected too.
   * Average-case complexity: O(|E|+|V|).
   */
  filterNodes(n) {
    var i = new this.constructor({
      directed: this._isDirected,
      multigraph: this._isMultigraph,
      compound: this._isCompound
    });
    i.setGraph(this.graph());
    var r = this;
    Object.entries(this._nodes).forEach(function([a, l]) {
      n(a) && i.setNode(a, l);
    }), Object.values(this._edgeObjs).forEach(function(a) {
      i.hasNode(a.v) && i.hasNode(a.w) && i.setEdge(a, r.edge(a));
    });
    var o = {};
    function s(a) {
      var l = r.parent(a);
      return l === void 0 || i.hasNode(l) ? (o[a] = l, l) : l in o ? o[l] : s(l);
    }
    return this._isCompound && i.nodes().forEach((a) => i.setParent(a, s(a))), i;
  }
  /* === Edge functions ========== */
  /**
   * Sets the default edge label or factory function. This label will be
   * assigned as default label in case if no label was specified while setting
   * an edge or this function will be invoked each time when setting an edge
   * with no label specified and returned value * will be used as a label for edge.
   * Complexity: O(1).
   */
  setDefaultEdgeLabel(n) {
    return this._defaultEdgeLabelFn = n, typeof n != "function" && (this._defaultEdgeLabelFn = () => n), this;
  }
  /**
   * Gets the number of edges in the graph.
   * Complexity: O(1).
   */
  edgeCount() {
    return this._edgeCount;
  }
  /**
   * Gets edges of the graph. In case of compound graph subgraphs are not considered.
   * Complexity: O(|E|).
   */
  edges() {
    return Object.values(this._edgeObjs);
  }
  /**
   * Establish an edges path over the nodes in nodes list. If some edge is already
   * exists, it will update its label, otherwise it will create an edge between pair
   * of nodes with label provided or default label if no label provided.
   * Complexity: O(|nodes|).
   */
  setPath(n, i) {
    var r = this, o = arguments;
    return n.reduce(function(s, a) {
      return o.length > 1 ? r.setEdge(s, a, i) : r.setEdge(s, a), a;
    }), this;
  }
  /**
   * Creates or updates the label for the edge (v, w) with the optionally supplied
   * name. If label is supplied it is set as the value for the edge. If label is not
   * supplied and the edge was created by this call then the default edge label will
   * be assigned. The name parameter is only useful with multigraphs.
   */
  setEdge() {
    var n, i, r, o, s = !1, a = arguments[0];
    typeof a == "object" && a !== null && "v" in a ? (n = a.v, i = a.w, r = a.name, arguments.length === 2 && (o = arguments[1], s = !0)) : (n = a, i = arguments[1], r = arguments[3], arguments.length > 2 && (o = arguments[2], s = !0)), n = "" + n, i = "" + i, r !== void 0 && (r = "" + r);
    var l = fr(this._isDirected, n, i, r);
    if (Object.hasOwn(this._edgeLabels, l))
      return s && (this._edgeLabels[l] = o), this;
    if (r !== void 0 && !this._isMultigraph)
      throw new Error("Cannot set a named edge when isMultigraph = false");
    this.setNode(n), this.setNode(i), this._edgeLabels[l] = s ? o : this._defaultEdgeLabelFn(n, i, r);
    var c = FM(this._isDirected, n, i, r);
    return n = c.v, i = c.w, Object.freeze(c), this._edgeObjs[l] = c, nf(this._preds[i], n), nf(this._sucs[n], i), this._in[i][l] = c, this._out[n][l] = c, this._edgeCount++, this;
  }
  /**
   * Gets the label for the specified edge.
   * Complexity: O(1).
   */
  edge(n, i, r) {
    var o = arguments.length === 1 ? ma(this._isDirected, arguments[0]) : fr(this._isDirected, n, i, r);
    return this._edgeLabels[o];
  }
  /**
   * Gets the label for the specified edge and converts it to an object.
   * Complexity: O(1)
   */
  edgeAsObj() {
    const n = this.edge(...arguments);
    return typeof n != "object" ? { label: n } : n;
  }
  /**
   * Detects whether the graph contains specified edge or not. No subgraphs are considered.
   * Complexity: O(1).
   */
  hasEdge(n, i, r) {
    var o = arguments.length === 1 ? ma(this._isDirected, arguments[0]) : fr(this._isDirected, n, i, r);
    return Object.hasOwn(this._edgeLabels, o);
  }
  /**
   * Removes the specified edge from the graph. No subgraphs are considered.
   * Complexity: O(1).
   */
  removeEdge(n, i, r) {
    var o = arguments.length === 1 ? ma(this._isDirected, arguments[0]) : fr(this._isDirected, n, i, r), s = this._edgeObjs[o];
    return s && (n = s.v, i = s.w, delete this._edgeLabels[o], delete this._edgeObjs[o], rf(this._preds[i], n), rf(this._sucs[n], i), delete this._in[i][o], delete this._out[n][o], this._edgeCount--), this;
  }
  /**
   * Return all edges that point to the node v. Optionally filters those edges down to just those
   * coming from node u. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  inEdges(n, i) {
    var r = this._in[n];
    if (r) {
      var o = Object.values(r);
      return i ? o.filter((s) => s.v === i) : o;
    }
  }
  /**
   * Return all edges that are pointed at by node v. Optionally filters those edges down to just
   * those point to w. Behavior is undefined for undirected graphs - use nodeEdges instead.
   * Complexity: O(|E|).
   */
  outEdges(n, i) {
    var r = this._out[n];
    if (r) {
      var o = Object.values(r);
      return i ? o.filter((s) => s.w === i) : o;
    }
  }
  /**
   * Returns all edges to or from node v regardless of direction. Optionally filters those edges
   * down to just those between nodes v and w regardless of direction.
   * Complexity: O(|E|).
   */
  nodeEdges(n, i) {
    var r = this.inEdges(n, i);
    if (r)
      return r.concat(this.outEdges(n, i));
  }
};
function nf(e, n) {
  e[n] ? e[n]++ : e[n] = 1;
}
function rf(e, n) {
  --e[n] || delete e[n];
}
function fr(e, n, i, r) {
  var o = "" + n, s = "" + i;
  if (!e && o > s) {
    var a = o;
    o = s, s = a;
  }
  return o + tf + s + tf + (r === void 0 ? BM : r);
}
function FM(e, n, i, r) {
  var o = "" + n, s = "" + i;
  if (!e && o > s) {
    var a = o;
    o = s, s = a;
  }
  var l = { v: o, w: s };
  return r && (l.name = r), l;
}
function ma(e, n) {
  return fr(e, n.v, n.w, n.name);
}
var du = jM, WM = "2.2.4", HM = {
  Graph: du,
  version: WM
}, qM = du, GM = {
  write: UM,
  read: KM
};
function UM(e) {
  var n = {
    options: {
      directed: e.isDirected(),
      multigraph: e.isMultigraph(),
      compound: e.isCompound()
    },
    nodes: YM(e),
    edges: XM(e)
  };
  return e.graph() !== void 0 && (n.value = structuredClone(e.graph())), n;
}
function YM(e) {
  return e.nodes().map(function(n) {
    var i = e.node(n), r = e.parent(n), o = { v: n };
    return i !== void 0 && (o.value = i), r !== void 0 && (o.parent = r), o;
  });
}
function XM(e) {
  return e.edges().map(function(n) {
    var i = e.edge(n), r = { v: n.v, w: n.w };
    return n.name !== void 0 && (r.name = n.name), i !== void 0 && (r.value = i), r;
  });
}
function KM(e) {
  var n = new qM(e.options).setGraph(e.value);
  return e.nodes.forEach(function(i) {
    n.setNode(i.v, i.value), i.parent && n.setParent(i.v, i.parent);
  }), e.edges.forEach(function(i) {
    n.setEdge({ v: i.v, w: i.w, name: i.name }, i.value);
  }), n;
}
var ZM = JM;
function JM(e) {
  var n = {}, i = [], r;
  function o(s) {
    Object.hasOwn(n, s) || (n[s] = !0, r.push(s), e.successors(s).forEach(o), e.predecessors(s).forEach(o));
  }
  return e.nodes().forEach(function(s) {
    r = [], o(s), r.length && i.push(r);
  }), i;
}
let QM = class {
  _arr = [];
  _keyIndices = {};
  /**
   * Returns the number of elements in the queue. Takes `O(1)` time.
   */
  size() {
    return this._arr.length;
  }
  /**
   * Returns the keys that are in the queue. Takes `O(n)` time.
   */
  keys() {
    return this._arr.map(function(n) {
      return n.key;
    });
  }
  /**
   * Returns `true` if **key** is in the queue and `false` if not.
   */
  has(n) {
    return Object.hasOwn(this._keyIndices, n);
  }
  /**
   * Returns the priority for **key**. If **key** is not present in the queue
   * then this function returns `undefined`. Takes `O(1)` time.
   *
   * @param {Object} key
   */
  priority(n) {
    var i = this._keyIndices[n];
    if (i !== void 0)
      return this._arr[i].priority;
  }
  /**
   * Returns the key for the minimum element in this queue. If the queue is
   * empty this function throws an Error. Takes `O(1)` time.
   */
  min() {
    if (this.size() === 0)
      throw new Error("Queue underflow");
    return this._arr[0].key;
  }
  /**
   * Inserts a new key into the priority queue. If the key already exists in
   * the queue this function returns `false`; otherwise it will return `true`.
   * Takes `O(n)` time.
   *
   * @param {Object} key the key to add
   * @param {Number} priority the initial priority for the key
   */
  add(n, i) {
    var r = this._keyIndices;
    if (n = String(n), !Object.hasOwn(r, n)) {
      var o = this._arr, s = o.length;
      return r[n] = s, o.push({ key: n, priority: i }), this._decrease(s), !0;
    }
    return !1;
  }
  /**
   * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
   */
  removeMin() {
    this._swap(0, this._arr.length - 1);
    var n = this._arr.pop();
    return delete this._keyIndices[n.key], this._heapify(0), n.key;
  }
  /**
   * Decreases the priority for **key** to **priority**. If the new priority is
   * greater than the previous priority, this function will throw an Error.
   *
   * @param {Object} key the key for which to raise priority
   * @param {Number} priority the new priority for the key
   */
  decrease(n, i) {
    var r = this._keyIndices[n];
    if (i > this._arr[r].priority)
      throw new Error("New priority is greater than current priority. Key: " + n + " Old: " + this._arr[r].priority + " New: " + i);
    this._arr[r].priority = i, this._decrease(r);
  }
  _heapify(n) {
    var i = this._arr, r = 2 * n, o = r + 1, s = n;
    r < i.length && (s = i[r].priority < i[s].priority ? r : s, o < i.length && (s = i[o].priority < i[s].priority ? o : s), s !== n && (this._swap(n, s), this._heapify(s)));
  }
  _decrease(n) {
    for (var i = this._arr, r = i[n].priority, o; n !== 0 && (o = n >> 1, !(i[o].priority < r)); )
      this._swap(n, o), n = o;
  }
  _swap(n, i) {
    var r = this._arr, o = this._keyIndices, s = r[n], a = r[i];
    r[n] = a, r[i] = s, o[a.key] = n, o[s.key] = i;
  }
};
var $y = QM, eA = $y, zy = nA, tA = () => 1;
function nA(e, n, i, r) {
  return iA(
    e,
    String(n),
    i || tA,
    r || function(o) {
      return e.outEdges(o);
    }
  );
}
function iA(e, n, i, r) {
  var o = {}, s = new eA(), a, l, c = function(u) {
    var f = u.v !== a ? u.v : u.w, h = o[f], p = i(u), m = l.distance + p;
    if (p < 0)
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + u + " Weight: " + p);
    m < h.distance && (h.distance = m, h.predecessor = a, s.decrease(f, m));
  };
  for (e.nodes().forEach(function(u) {
    var f = u === n ? 0 : Number.POSITIVE_INFINITY;
    o[u] = { distance: f }, s.add(u, f);
  }); s.size() > 0 && (a = s.removeMin(), l = o[a], l.distance !== Number.POSITIVE_INFINITY); )
    r(a).forEach(c);
  return o;
}
var rA = zy, oA = sA;
function sA(e, n, i) {
  return e.nodes().reduce(function(r, o) {
    return r[o] = rA(e, o, n, i), r;
  }, {});
}
var Oy = aA;
function aA(e) {
  var n = 0, i = [], r = {}, o = [];
  function s(a) {
    var l = r[a] = {
      onStack: !0,
      lowlink: n,
      index: n++
    };
    if (i.push(a), e.successors(a).forEach(function(f) {
      Object.hasOwn(r, f) ? r[f].onStack && (l.lowlink = Math.min(l.lowlink, r[f].index)) : (s(f), l.lowlink = Math.min(l.lowlink, r[f].lowlink));
    }), l.lowlink === l.index) {
      var c = [], u;
      do
        u = i.pop(), r[u].onStack = !1, c.push(u);
      while (a !== u);
      o.push(c);
    }
  }
  return e.nodes().forEach(function(a) {
    Object.hasOwn(r, a) || s(a);
  }), o;
}
var lA = Oy, cA = uA;
function uA(e) {
  return lA(e).filter(function(n) {
    return n.length > 1 || n.length === 1 && e.hasEdge(n[0], n[0]);
  });
}
var dA = fA, hA = () => 1;
function fA(e, n, i) {
  return pA(
    e,
    n || hA,
    i || function(r) {
      return e.outEdges(r);
    }
  );
}
function pA(e, n, i) {
  var r = {}, o = e.nodes();
  return o.forEach(function(s) {
    r[s] = {}, r[s][s] = { distance: 0 }, o.forEach(function(a) {
      s !== a && (r[s][a] = { distance: Number.POSITIVE_INFINITY });
    }), i(s).forEach(function(a) {
      var l = a.v === s ? a.w : a.v, c = n(a);
      r[s][l] = { distance: c, predecessor: s };
    });
  }), o.forEach(function(s) {
    var a = r[s];
    o.forEach(function(l) {
      var c = r[l];
      o.forEach(function(u) {
        var f = c[s], h = a[u], p = c[u], m = f.distance + h.distance;
        m < p.distance && (p.distance = m, p.predecessor = h.predecessor);
      });
    });
  }), r;
}
function Vy(e) {
  var n = {}, i = {}, r = [];
  function o(s) {
    if (Object.hasOwn(i, s))
      throw new ul();
    Object.hasOwn(n, s) || (i[s] = !0, n[s] = !0, e.predecessors(s).forEach(o), delete i[s], r.push(s));
  }
  if (e.sinks().forEach(o), Object.keys(n).length !== e.nodeCount())
    throw new ul();
  return r;
}
class ul extends Error {
  constructor() {
    super(...arguments);
  }
}
var By = Vy;
Vy.CycleException = ul;
var of = By, mA = gA;
function gA(e) {
  try {
    of(e);
  } catch (n) {
    if (n instanceof of.CycleException)
      return !1;
    throw n;
  }
  return !0;
}
var jy = yA;
function yA(e, n, i) {
  Array.isArray(n) || (n = [n]);
  var r = e.isDirected() ? (l) => e.successors(l) : (l) => e.neighbors(l), o = i === "post" ? vA : wA, s = [], a = {};
  return n.forEach((l) => {
    if (!e.hasNode(l))
      throw new Error("Graph does not have node: " + l);
    o(l, r, a, s);
  }), s;
}
function vA(e, n, i, r) {
  for (var o = [[e, !1]]; o.length > 0; ) {
    var s = o.pop();
    s[1] ? r.push(s[0]) : Object.hasOwn(i, s[0]) || (i[s[0]] = !0, o.push([s[0], !0]), Fy(n(s[0]), (a) => o.push([a, !1])));
  }
}
function wA(e, n, i, r) {
  for (var o = [e]; o.length > 0; ) {
    var s = o.pop();
    Object.hasOwn(i, s) || (i[s] = !0, r.push(s), Fy(n(s), (a) => o.push(a)));
  }
}
function Fy(e, n) {
  for (var i = e.length; i--; )
    n(e[i], i, e);
  return e;
}
var xA = jy, bA = kA;
function kA(e, n) {
  return xA(e, n, "post");
}
var SA = jy, _A = CA;
function CA(e, n) {
  return SA(e, n, "pre");
}
var EA = du, PA = $y, TA = MA;
function MA(e, n) {
  var i = new EA(), r = {}, o = new PA(), s;
  function a(c) {
    var u = c.v === s ? c.w : c.v, f = o.priority(u);
    if (f !== void 0) {
      var h = n(c);
      h < f && (r[u] = s, o.decrease(u, h));
    }
  }
  if (e.nodeCount() === 0)
    return i;
  e.nodes().forEach(function(c) {
    o.add(c, Number.POSITIVE_INFINITY), i.setNode(c);
  }), o.decrease(e.nodes()[0], 0);
  for (var l = !1; o.size() > 0; ) {
    if (s = o.removeMin(), Object.hasOwn(r, s))
      i.setEdge(s, r[s]);
    else {
      if (l)
        throw new Error("Input graph is not connected: " + e);
      l = !0;
    }
    e.nodeEdges(s).forEach(a);
  }
  return i;
}
var AA = {
  components: ZM,
  dijkstra: zy,
  dijkstraAll: oA,
  findCycles: cA,
  floydWarshall: dA,
  isAcyclic: mA,
  postorder: bA,
  preorder: _A,
  prim: TA,
  tarjan: Oy,
  topsort: By
}, sf = HM, St = {
  Graph: sf.Graph,
  json: GM,
  alg: AA,
  version: sf.version
};
let IA = class {
  constructor() {
    let n = {};
    n._next = n._prev = n, this._sentinel = n;
  }
  dequeue() {
    let n = this._sentinel, i = n._prev;
    if (i !== n)
      return af(i), i;
  }
  enqueue(n) {
    let i = this._sentinel;
    n._prev && n._next && af(n), n._next = i._next, i._next._prev = n, i._next = n, n._prev = i;
  }
  toString() {
    let n = [], i = this._sentinel, r = i._prev;
    for (; r !== i; )
      n.push(JSON.stringify(r, DA)), r = r._prev;
    return "[" + n.join(", ") + "]";
  }
};
function af(e) {
  e._prev._next = e._next, e._next._prev = e._prev, delete e._next, delete e._prev;
}
function DA(e, n) {
  if (e !== "_next" && e !== "_prev")
    return n;
}
var NA = IA;
let RA = St.Graph, LA = NA;
var $A = OA;
let zA = () => 1;
function OA(e, n) {
  if (e.nodeCount() <= 1)
    return [];
  let i = BA(e, n || zA);
  return VA(i.graph, i.buckets, i.zeroIdx).flatMap((o) => e.outEdges(o.v, o.w));
}
function VA(e, n, i) {
  let r = [], o = n[n.length - 1], s = n[0], a;
  for (; e.nodeCount(); ) {
    for (; a = s.dequeue(); )
      ga(e, n, i, a);
    for (; a = o.dequeue(); )
      ga(e, n, i, a);
    if (e.nodeCount()) {
      for (let l = n.length - 2; l > 0; --l)
        if (a = n[l].dequeue(), a) {
          r = r.concat(ga(e, n, i, a, !0));
          break;
        }
    }
  }
  return r;
}
function ga(e, n, i, r, o) {
  let s = o ? [] : void 0;
  return e.inEdges(r.v).forEach((a) => {
    let l = e.edge(a), c = e.node(a.v);
    o && s.push({ v: a.v, w: a.w }), c.out -= l, dl(n, i, c);
  }), e.outEdges(r.v).forEach((a) => {
    let l = e.edge(a), c = a.w, u = e.node(c);
    u.in -= l, dl(n, i, u);
  }), e.removeNode(r.v), s;
}
function BA(e, n) {
  let i = new RA(), r = 0, o = 0;
  e.nodes().forEach((l) => {
    i.setNode(l, { v: l, in: 0, out: 0 });
  }), e.edges().forEach((l) => {
    let c = i.edge(l.v, l.w) || 0, u = n(l), f = c + u;
    i.setEdge(l.v, l.w, f), o = Math.max(o, i.node(l.v).out += u), r = Math.max(r, i.node(l.w).in += u);
  });
  let s = jA(o + r + 3).map(() => new LA()), a = r + 1;
  return i.nodes().forEach((l) => {
    dl(s, a, i.node(l));
  }), { graph: i, buckets: s, zeroIdx: a };
}
function dl(e, n, i) {
  i.out ? i.in ? e[i.out - i.in + n].enqueue(i) : e[e.length - 1].enqueue(i) : e[0].enqueue(i);
}
function jA(e) {
  const n = [];
  for (let i = 0; i < e; i++)
    n.push(i);
  return n;
}
let Wy = St.Graph;
var Pe = {
  addBorderNode: KA,
  addDummyNode: Hy,
  applyWithChunking: Ls,
  asNonCompoundGraph: WA,
  buildLayerMatrix: UA,
  intersectRect: GA,
  mapValues: iI,
  maxRank: Gy,
  normalizeRanks: YA,
  notime: eI,
  partition: JA,
  pick: nI,
  predecessorWeights: qA,
  range: Yy,
  removeEmptyRanks: XA,
  simplify: FA,
  successorWeights: HA,
  time: QA,
  uniqueId: Uy,
  zipObject: hu
};
function Hy(e, n, i, r) {
  let o;
  do
    o = Uy(r);
  while (e.hasNode(o));
  return i.dummy = n, e.setNode(o, i), o;
}
function FA(e) {
  let n = new Wy().setGraph(e.graph());
  return e.nodes().forEach((i) => n.setNode(i, e.node(i))), e.edges().forEach((i) => {
    let r = n.edge(i.v, i.w) || { weight: 0, minlen: 1 }, o = e.edge(i);
    n.setEdge(i.v, i.w, {
      weight: r.weight + o.weight,
      minlen: Math.max(r.minlen, o.minlen)
    });
  }), n;
}
function WA(e) {
  let n = new Wy({ multigraph: e.isMultigraph() }).setGraph(e.graph());
  return e.nodes().forEach((i) => {
    e.children(i).length || n.setNode(i, e.node(i));
  }), e.edges().forEach((i) => {
    n.setEdge(i, e.edge(i));
  }), n;
}
function HA(e) {
  let n = e.nodes().map((i) => {
    let r = {};
    return e.outEdges(i).forEach((o) => {
      r[o.w] = (r[o.w] || 0) + e.edge(o).weight;
    }), r;
  });
  return hu(e.nodes(), n);
}
function qA(e) {
  let n = e.nodes().map((i) => {
    let r = {};
    return e.inEdges(i).forEach((o) => {
      r[o.v] = (r[o.v] || 0) + e.edge(o).weight;
    }), r;
  });
  return hu(e.nodes(), n);
}
function GA(e, n) {
  let i = e.x, r = e.y, o = n.x - i, s = n.y - r, a = e.width / 2, l = e.height / 2;
  if (!o && !s)
    throw new Error("Not possible to find intersection inside of the rectangle");
  let c, u;
  return Math.abs(s) * a > Math.abs(o) * l ? (s < 0 && (l = -l), c = l * o / s, u = l) : (o < 0 && (a = -a), c = a, u = a * s / o), { x: i + c, y: r + u };
}
function UA(e) {
  let n = Yy(Gy(e) + 1).map(() => []);
  return e.nodes().forEach((i) => {
    let r = e.node(i), o = r.rank;
    o !== void 0 && (n[o][r.order] = i);
  }), n;
}
function YA(e) {
  let n = e.nodes().map((r) => {
    let o = e.node(r).rank;
    return o === void 0 ? Number.MAX_VALUE : o;
  }), i = Ls(Math.min, n);
  e.nodes().forEach((r) => {
    let o = e.node(r);
    Object.hasOwn(o, "rank") && (o.rank -= i);
  });
}
function XA(e) {
  let n = e.nodes().map((a) => e.node(a).rank), i = Ls(Math.min, n), r = [];
  e.nodes().forEach((a) => {
    let l = e.node(a).rank - i;
    r[l] || (r[l] = []), r[l].push(a);
  });
  let o = 0, s = e.graph().nodeRankFactor;
  Array.from(r).forEach((a, l) => {
    a === void 0 && l % s !== 0 ? --o : a !== void 0 && o && a.forEach((c) => e.node(c).rank += o);
  });
}
function KA(e, n, i, r) {
  let o = {
    width: 0,
    height: 0
  };
  return arguments.length >= 4 && (o.rank = i, o.order = r), Hy(e, "border", o, n);
}
function ZA(e, n = qy) {
  const i = [];
  for (let r = 0; r < e.length; r += n) {
    const o = e.slice(r, r + n);
    i.push(o);
  }
  return i;
}
const qy = 65535;
function Ls(e, n) {
  if (n.length > qy) {
    const i = ZA(n);
    return e.apply(null, i.map((r) => e.apply(null, r)));
  } else
    return e.apply(null, n);
}
function Gy(e) {
  const i = e.nodes().map((r) => {
    let o = e.node(r).rank;
    return o === void 0 ? Number.MIN_VALUE : o;
  });
  return Ls(Math.max, i);
}
function JA(e, n) {
  let i = { lhs: [], rhs: [] };
  return e.forEach((r) => {
    n(r) ? i.lhs.push(r) : i.rhs.push(r);
  }), i;
}
function QA(e, n) {
  let i = Date.now();
  try {
    return n();
  } finally {
    console.log(e + " time: " + (Date.now() - i) + "ms");
  }
}
function eI(e, n) {
  return n();
}
let tI = 0;
function Uy(e) {
  var n = ++tI;
  return toString(e) + n;
}
function Yy(e, n, i = 1) {
  n == null && (n = e, e = 0);
  let r = (s) => s < n;
  i < 0 && (r = (s) => n < s);
  const o = [];
  for (let s = e; r(s); s += i)
    o.push(s);
  return o;
}
function nI(e, n) {
  const i = {};
  for (const r of n)
    e[r] !== void 0 && (i[r] = e[r]);
  return i;
}
function iI(e, n) {
  let i = n;
  return typeof n == "string" && (i = (r) => r[n]), Object.entries(e).reduce((r, [o, s]) => (r[o] = i(s, o), r), {});
}
function hu(e, n) {
  return e.reduce((i, r, o) => (i[r] = n[o], i), {});
}
let rI = $A, oI = Pe.uniqueId;
var sI = {
  run: aI,
  undo: cI
};
function aI(e) {
  (e.graph().acyclicer === "greedy" ? rI(e, i(e)) : lI(e)).forEach((r) => {
    let o = e.edge(r);
    e.removeEdge(r), o.forwardName = r.name, o.reversed = !0, e.setEdge(r.w, r.v, o, oI("rev"));
  });
  function i(r) {
    return (o) => r.edge(o).weight;
  }
}
function lI(e) {
  let n = [], i = {}, r = {};
  function o(s) {
    Object.hasOwn(r, s) || (r[s] = !0, i[s] = !0, e.outEdges(s).forEach((a) => {
      Object.hasOwn(i, a.w) ? n.push(a) : o(a.w);
    }), delete i[s]);
  }
  return e.nodes().forEach(o), n;
}
function cI(e) {
  e.edges().forEach((n) => {
    let i = e.edge(n);
    if (i.reversed) {
      e.removeEdge(n);
      let r = i.forwardName;
      delete i.reversed, delete i.forwardName, e.setEdge(n.w, n.v, i, r);
    }
  });
}
let uI = Pe;
var dI = {
  run: hI,
  undo: pI
};
function hI(e) {
  e.graph().dummyChains = [], e.edges().forEach((n) => fI(e, n));
}
function fI(e, n) {
  let i = n.v, r = e.node(i).rank, o = n.w, s = e.node(o).rank, a = n.name, l = e.edge(n), c = l.labelRank;
  if (s === r + 1) return;
  e.removeEdge(n);
  let u, f, h;
  for (h = 0, ++r; r < s; ++h, ++r)
    l.points = [], f = {
      width: 0,
      height: 0,
      edgeLabel: l,
      edgeObj: n,
      rank: r
    }, u = uI.addDummyNode(e, "edge", f, "_d"), r === c && (f.width = l.width, f.height = l.height, f.dummy = "edge-label", f.labelpos = l.labelpos), e.setEdge(i, u, { weight: l.weight }, a), h === 0 && e.graph().dummyChains.push(u), i = u;
  e.setEdge(i, o, { weight: l.weight }, a);
}
function pI(e) {
  e.graph().dummyChains.forEach((n) => {
    let i = e.node(n), r = i.edgeLabel, o;
    for (e.setEdge(i.edgeObj, r); i.dummy; )
      o = e.successors(n)[0], e.removeNode(n), r.points.push({ x: i.x, y: i.y }), i.dummy === "edge-label" && (r.x = i.x, r.y = i.y, r.width = i.width, r.height = i.height), n = o, i = e.node(n);
  });
}
const { applyWithChunking: mI } = Pe;
var $s = {
  longestPath: gI,
  slack: yI
};
function gI(e) {
  var n = {};
  function i(r) {
    var o = e.node(r);
    if (Object.hasOwn(n, r))
      return o.rank;
    n[r] = !0;
    let s = e.outEdges(r).map((l) => l == null ? Number.POSITIVE_INFINITY : i(l.w) - e.edge(l).minlen);
    var a = mI(Math.min, s);
    return a === Number.POSITIVE_INFINITY && (a = 0), o.rank = a;
  }
  e.sources().forEach(i);
}
function yI(e, n) {
  return e.node(n.w).rank - e.node(n.v).rank - e.edge(n).minlen;
}
var vI = St.Graph, Qo = $s.slack, Xy = wI;
function wI(e) {
  var n = new vI({ directed: !1 }), i = e.nodes()[0], r = e.nodeCount();
  n.setNode(i, {});
  for (var o, s; xI(n, e) < r; )
    o = bI(n, e), s = n.hasNode(o.v) ? Qo(e, o) : -Qo(e, o), kI(n, e, s);
  return n;
}
function xI(e, n) {
  function i(r) {
    n.nodeEdges(r).forEach((o) => {
      var s = o.v, a = r === s ? o.w : s;
      !e.hasNode(a) && !Qo(n, o) && (e.setNode(a, {}), e.setEdge(r, a, {}), i(a));
    });
  }
  return e.nodes().forEach(i), e.nodeCount();
}
function bI(e, n) {
  return n.edges().reduce((r, o) => {
    let s = Number.POSITIVE_INFINITY;
    return e.hasNode(o.v) !== e.hasNode(o.w) && (s = Qo(n, o)), s < r[0] ? [s, o] : r;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function kI(e, n, i) {
  e.nodes().forEach((r) => n.node(r).rank += i);
}
var SI = Xy, lf = $s.slack, _I = $s.longestPath, CI = St.alg.preorder, EI = St.alg.postorder, PI = Pe.simplify, TI = Un;
Un.initLowLimValues = pu;
Un.initCutValues = fu;
Un.calcCutValue = Ky;
Un.leaveEdge = Jy;
Un.enterEdge = Qy;
Un.exchangeEdges = e0;
function Un(e) {
  e = PI(e), _I(e);
  var n = SI(e);
  pu(n), fu(n, e);
  for (var i, r; i = Jy(n); )
    r = Qy(n, e, i), e0(n, e, i, r);
}
function fu(e, n) {
  var i = EI(e, e.nodes());
  i = i.slice(0, i.length - 1), i.forEach((r) => MI(e, n, r));
}
function MI(e, n, i) {
  var r = e.node(i), o = r.parent;
  e.edge(i, o).cutvalue = Ky(e, n, i);
}
function Ky(e, n, i) {
  var r = e.node(i), o = r.parent, s = !0, a = n.edge(i, o), l = 0;
  return a || (s = !1, a = n.edge(o, i)), l = a.weight, n.nodeEdges(i).forEach((c) => {
    var u = c.v === i, f = u ? c.w : c.v;
    if (f !== o) {
      var h = u === s, p = n.edge(c).weight;
      if (l += h ? p : -p, II(e, i, f)) {
        var m = e.edge(i, f).cutvalue;
        l += h ? -m : m;
      }
    }
  }), l;
}
function pu(e, n) {
  arguments.length < 2 && (n = e.nodes()[0]), Zy(e, {}, 1, n);
}
function Zy(e, n, i, r, o) {
  var s = i, a = e.node(r);
  return n[r] = !0, e.neighbors(r).forEach((l) => {
    Object.hasOwn(n, l) || (i = Zy(e, n, i, l, r));
  }), a.low = s, a.lim = i++, o ? a.parent = o : delete a.parent, i;
}
function Jy(e) {
  return e.edges().find((n) => e.edge(n).cutvalue < 0);
}
function Qy(e, n, i) {
  var r = i.v, o = i.w;
  n.hasEdge(r, o) || (r = i.w, o = i.v);
  var s = e.node(r), a = e.node(o), l = s, c = !1;
  s.lim > a.lim && (l = a, c = !0);
  var u = n.edges().filter((f) => c === cf(e, e.node(f.v), l) && c !== cf(e, e.node(f.w), l));
  return u.reduce((f, h) => lf(n, h) < lf(n, f) ? h : f);
}
function e0(e, n, i, r) {
  var o = i.v, s = i.w;
  e.removeEdge(o, s), e.setEdge(r.v, r.w, {}), pu(e), fu(e, n), AI(e, n);
}
function AI(e, n) {
  var i = e.nodes().find((o) => !n.node(o).parent), r = CI(e, i);
  r = r.slice(1), r.forEach((o) => {
    var s = e.node(o).parent, a = n.edge(o, s), l = !1;
    a || (a = n.edge(s, o), l = !0), n.node(o).rank = n.node(s).rank + (l ? a.minlen : -a.minlen);
  });
}
function II(e, n, i) {
  return e.hasEdge(n, i);
}
function cf(e, n, i) {
  return i.low <= n.lim && n.lim <= i.lim;
}
var DI = $s, t0 = DI.longestPath, NI = Xy, RI = TI, LI = $I;
function $I(e) {
  switch (e.graph().ranker) {
    case "network-simplex":
      uf(e);
      break;
    case "tight-tree":
      OI(e);
      break;
    case "longest-path":
      zI(e);
      break;
    default:
      uf(e);
  }
}
var zI = t0;
function OI(e) {
  t0(e), NI(e);
}
function uf(e) {
  RI(e);
}
var VI = BI;
function BI(e) {
  let n = FI(e);
  e.graph().dummyChains.forEach((i) => {
    let r = e.node(i), o = r.edgeObj, s = jI(e, n, o.v, o.w), a = s.path, l = s.lca, c = 0, u = a[c], f = !0;
    for (; i !== o.w; ) {
      if (r = e.node(i), f) {
        for (; (u = a[c]) !== l && e.node(u).maxRank < r.rank; )
          c++;
        u === l && (f = !1);
      }
      if (!f) {
        for (; c < a.length - 1 && e.node(u = a[c + 1]).minRank <= r.rank; )
          c++;
        u = a[c];
      }
      e.setParent(i, u), i = e.successors(i)[0];
    }
  });
}
function jI(e, n, i, r) {
  let o = [], s = [], a = Math.min(n[i].low, n[r].low), l = Math.max(n[i].lim, n[r].lim), c, u;
  c = i;
  do
    c = e.parent(c), o.push(c);
  while (c && (n[c].low > a || l > n[c].lim));
  for (u = c, c = r; (c = e.parent(c)) !== u; )
    s.push(c);
  return { path: o.concat(s.reverse()), lca: u };
}
function FI(e) {
  let n = {}, i = 0;
  function r(o) {
    let s = i;
    e.children(o).forEach(r), n[o] = { low: s, lim: i++ };
  }
  return e.children().forEach(r), n;
}
let es = Pe;
var WI = {
  run: HI,
  cleanup: UI
};
function HI(e) {
  let n = es.addDummyNode(e, "root", {}, "_root"), i = qI(e), r = Object.values(i), o = es.applyWithChunking(Math.max, r) - 1, s = 2 * o + 1;
  e.graph().nestingRoot = n, e.edges().forEach((l) => e.edge(l).minlen *= s);
  let a = GI(e) + 1;
  e.children().forEach((l) => n0(e, n, s, a, o, i, l)), e.graph().nodeRankFactor = s;
}
function n0(e, n, i, r, o, s, a) {
  let l = e.children(a);
  if (!l.length) {
    a !== n && e.setEdge(n, a, { weight: 0, minlen: i });
    return;
  }
  let c = es.addBorderNode(e, "_bt"), u = es.addBorderNode(e, "_bb"), f = e.node(a);
  e.setParent(c, a), f.borderTop = c, e.setParent(u, a), f.borderBottom = u, l.forEach((h) => {
    n0(e, n, i, r, o, s, h);
    let p = e.node(h), m = p.borderTop ? p.borderTop : h, g = p.borderBottom ? p.borderBottom : h, y = p.borderTop ? r : 2 * r, v = m !== g ? 1 : o - s[a] + 1;
    e.setEdge(c, m, {
      weight: y,
      minlen: v,
      nestingEdge: !0
    }), e.setEdge(g, u, {
      weight: y,
      minlen: v,
      nestingEdge: !0
    });
  }), e.parent(a) || e.setEdge(n, c, { weight: 0, minlen: o + s[a] });
}
function qI(e) {
  var n = {};
  function i(r, o) {
    var s = e.children(r);
    s && s.length && s.forEach((a) => i(a, o + 1)), n[r] = o;
  }
  return e.children().forEach((r) => i(r, 1)), n;
}
function GI(e) {
  return e.edges().reduce((n, i) => n + e.edge(i).weight, 0);
}
function UI(e) {
  var n = e.graph();
  e.removeNode(n.nestingRoot), delete n.nestingRoot, e.edges().forEach((i) => {
    var r = e.edge(i);
    r.nestingEdge && e.removeEdge(i);
  });
}
let YI = Pe;
var XI = KI;
function KI(e) {
  function n(i) {
    let r = e.children(i), o = e.node(i);
    if (r.length && r.forEach(n), Object.hasOwn(o, "minRank")) {
      o.borderLeft = [], o.borderRight = [];
      for (let s = o.minRank, a = o.maxRank + 1; s < a; ++s)
        df(e, "borderLeft", "_bl", i, o, s), df(e, "borderRight", "_br", i, o, s);
    }
  }
  e.children().forEach(n);
}
function df(e, n, i, r, o, s) {
  let a = { width: 0, height: 0, rank: s, borderType: n }, l = o[n][s - 1], c = YI.addDummyNode(e, "border", a, i);
  o[n][s] = c, e.setParent(c, r), l && e.setEdge(l, c, { weight: 1 });
}
var ZI = {
  adjust: JI,
  undo: QI
};
function JI(e) {
  let n = e.graph().rankdir.toLowerCase();
  (n === "lr" || n === "rl") && i0(e);
}
function QI(e) {
  let n = e.graph().rankdir.toLowerCase();
  (n === "bt" || n === "rl") && eD(e), (n === "lr" || n === "rl") && (tD(e), i0(e));
}
function i0(e) {
  e.nodes().forEach((n) => hf(e.node(n))), e.edges().forEach((n) => hf(e.edge(n)));
}
function hf(e) {
  let n = e.width;
  e.width = e.height, e.height = n;
}
function eD(e) {
  e.nodes().forEach((n) => ya(e.node(n))), e.edges().forEach((n) => {
    let i = e.edge(n);
    i.points.forEach(ya), Object.hasOwn(i, "y") && ya(i);
  });
}
function ya(e) {
  e.y = -e.y;
}
function tD(e) {
  e.nodes().forEach((n) => va(e.node(n))), e.edges().forEach((n) => {
    let i = e.edge(n);
    i.points.forEach(va), Object.hasOwn(i, "x") && va(i);
  });
}
function va(e) {
  let n = e.x;
  e.x = e.y, e.y = n;
}
let ff = Pe;
var nD = iD;
function iD(e) {
  let n = {}, i = e.nodes().filter((c) => !e.children(c).length), r = i.map((c) => e.node(c).rank), o = ff.applyWithChunking(Math.max, r), s = ff.range(o + 1).map(() => []);
  function a(c) {
    if (n[c]) return;
    n[c] = !0;
    let u = e.node(c);
    s[u.rank].push(c), e.successors(c).forEach(a);
  }
  return i.sort((c, u) => e.node(c).rank - e.node(u).rank).forEach(a), s;
}
let rD = Pe.zipObject;
var oD = sD;
function sD(e, n) {
  let i = 0;
  for (let r = 1; r < n.length; ++r)
    i += aD(e, n[r - 1], n[r]);
  return i;
}
function aD(e, n, i) {
  let r = rD(i, i.map((u, f) => f)), o = n.flatMap((u) => e.outEdges(u).map((f) => ({ pos: r[f.w], weight: e.edge(f).weight })).sort((f, h) => f.pos - h.pos)), s = 1;
  for (; s < i.length; ) s <<= 1;
  let a = 2 * s - 1;
  s -= 1;
  let l = new Array(a).fill(0), c = 0;
  return o.forEach((u) => {
    let f = u.pos + s;
    l[f] += u.weight;
    let h = 0;
    for (; f > 0; )
      f % 2 && (h += l[f + 1]), f = f - 1 >> 1, l[f] += u.weight;
    c += u.weight * h;
  }), c;
}
var lD = cD;
function cD(e, n = []) {
  return n.map((i) => {
    let r = e.inEdges(i);
    if (r.length) {
      let o = r.reduce((s, a) => {
        let l = e.edge(a), c = e.node(a.v);
        return {
          sum: s.sum + l.weight * c.order,
          weight: s.weight + l.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v: i,
        barycenter: o.sum / o.weight,
        weight: o.weight
      };
    } else
      return { v: i };
  });
}
let uD = Pe;
var dD = hD;
function hD(e, n) {
  let i = {};
  e.forEach((o, s) => {
    let a = i[o.v] = {
      indegree: 0,
      in: [],
      out: [],
      vs: [o.v],
      i: s
    };
    o.barycenter !== void 0 && (a.barycenter = o.barycenter, a.weight = o.weight);
  }), n.edges().forEach((o) => {
    let s = i[o.v], a = i[o.w];
    s !== void 0 && a !== void 0 && (a.indegree++, s.out.push(i[o.w]));
  });
  let r = Object.values(i).filter((o) => !o.indegree);
  return fD(r);
}
function fD(e) {
  let n = [];
  function i(o) {
    return (s) => {
      s.merged || (s.barycenter === void 0 || o.barycenter === void 0 || s.barycenter >= o.barycenter) && pD(o, s);
    };
  }
  function r(o) {
    return (s) => {
      s.in.push(o), --s.indegree === 0 && e.push(s);
    };
  }
  for (; e.length; ) {
    let o = e.pop();
    n.push(o), o.in.reverse().forEach(i(o)), o.out.forEach(r(o));
  }
  return n.filter((o) => !o.merged).map((o) => uD.pick(o, ["vs", "i", "barycenter", "weight"]));
}
function pD(e, n) {
  let i = 0, r = 0;
  e.weight && (i += e.barycenter * e.weight, r += e.weight), n.weight && (i += n.barycenter * n.weight, r += n.weight), e.vs = n.vs.concat(e.vs), e.barycenter = i / r, e.weight = r, e.i = Math.min(n.i, e.i), n.merged = !0;
}
let mD = Pe;
var gD = yD;
function yD(e, n) {
  let i = mD.partition(e, (f) => Object.hasOwn(f, "barycenter")), r = i.lhs, o = i.rhs.sort((f, h) => h.i - f.i), s = [], a = 0, l = 0, c = 0;
  r.sort(vD(!!n)), c = pf(s, o, c), r.forEach((f) => {
    c += f.vs.length, s.push(f.vs), a += f.barycenter * f.weight, l += f.weight, c = pf(s, o, c);
  });
  let u = { vs: s.flat(!0) };
  return l && (u.barycenter = a / l, u.weight = l), u;
}
function pf(e, n, i) {
  let r;
  for (; n.length && (r = n[n.length - 1]).i <= i; )
    n.pop(), e.push(r.vs), i++;
  return i;
}
function vD(e) {
  return (n, i) => n.barycenter < i.barycenter ? -1 : n.barycenter > i.barycenter ? 1 : e ? i.i - n.i : n.i - i.i;
}
let wD = lD, xD = dD, bD = gD;
var kD = r0;
function r0(e, n, i, r) {
  let o = e.children(n), s = e.node(n), a = s ? s.borderLeft : void 0, l = s ? s.borderRight : void 0, c = {};
  a && (o = o.filter((p) => p !== a && p !== l));
  let u = wD(e, o);
  u.forEach((p) => {
    if (e.children(p.v).length) {
      let m = r0(e, p.v, i, r);
      c[p.v] = m, Object.hasOwn(m, "barycenter") && _D(p, m);
    }
  });
  let f = xD(u, i);
  SD(f, c);
  let h = bD(f, r);
  if (a && (h.vs = [a, h.vs, l].flat(!0), e.predecessors(a).length)) {
    let p = e.node(e.predecessors(a)[0]), m = e.node(e.predecessors(l)[0]);
    Object.hasOwn(h, "barycenter") || (h.barycenter = 0, h.weight = 0), h.barycenter = (h.barycenter * h.weight + p.order + m.order) / (h.weight + 2), h.weight += 2;
  }
  return h;
}
function SD(e, n) {
  e.forEach((i) => {
    i.vs = i.vs.flatMap((r) => n[r] ? n[r].vs : r);
  });
}
function _D(e, n) {
  e.barycenter !== void 0 ? (e.barycenter = (e.barycenter * e.weight + n.barycenter * n.weight) / (e.weight + n.weight), e.weight += n.weight) : (e.barycenter = n.barycenter, e.weight = n.weight);
}
let CD = St.Graph, ED = Pe;
var PD = TD;
function TD(e, n, i) {
  let r = MD(e), o = new CD({ compound: !0 }).setGraph({ root: r }).setDefaultNodeLabel((s) => e.node(s));
  return e.nodes().forEach((s) => {
    let a = e.node(s), l = e.parent(s);
    (a.rank === n || a.minRank <= n && n <= a.maxRank) && (o.setNode(s), o.setParent(s, l || r), e[i](s).forEach((c) => {
      let u = c.v === s ? c.w : c.v, f = o.edge(u, s), h = f !== void 0 ? f.weight : 0;
      o.setEdge(u, s, { weight: e.edge(c).weight + h });
    }), Object.hasOwn(a, "minRank") && o.setNode(s, {
      borderLeft: a.borderLeft[n],
      borderRight: a.borderRight[n]
    }));
  }), o;
}
function MD(e) {
  for (var n; e.hasNode(n = ED.uniqueId("_root")); ) ;
  return n;
}
var AD = ID;
function ID(e, n, i) {
  let r = {}, o;
  i.forEach((s) => {
    let a = e.parent(s), l, c;
    for (; a; ) {
      if (l = e.parent(a), l ? (c = r[l], r[l] = a) : (c = o, o = a), c && c !== a) {
        n.setEdge(c, a);
        return;
      }
      a = l;
    }
  });
}
let DD = nD, ND = oD, RD = kD, LD = PD, $D = AD, zD = St.Graph, ko = Pe;
var OD = o0;
function o0(e, n) {
  if (n && typeof n.customOrder == "function") {
    n.customOrder(e, o0);
    return;
  }
  let i = ko.maxRank(e), r = mf(e, ko.range(1, i + 1), "inEdges"), o = mf(e, ko.range(i - 1, -1, -1), "outEdges"), s = DD(e);
  if (gf(e, s), n && n.disableOptimalOrderHeuristic)
    return;
  let a = Number.POSITIVE_INFINITY, l;
  for (let c = 0, u = 0; u < 4; ++c, ++u) {
    VD(c % 2 ? r : o, c % 4 >= 2), s = ko.buildLayerMatrix(e);
    let f = ND(e, s);
    f < a && (u = 0, l = Object.assign({}, s), a = f);
  }
  gf(e, l);
}
function mf(e, n, i) {
  return n.map(function(r) {
    return LD(e, r, i);
  });
}
function VD(e, n) {
  let i = new zD();
  e.forEach(function(r) {
    let o = r.graph().root, s = RD(r, o, i, n);
    s.vs.forEach((a, l) => r.node(a).order = l), $D(r, i, s.vs);
  });
}
function gf(e, n) {
  Object.values(n).forEach((i) => i.forEach((r, o) => e.node(r).order = o));
}
let BD = St.Graph, Vt = Pe;
var jD = {
  positionX: HD,
  findType1Conflicts: s0,
  findType2Conflicts: a0,
  addConflict: mu,
  hasConflict: l0,
  verticalAlignment: c0,
  horizontalCompaction: u0,
  alignCoordinates: h0,
  findSmallestWidthAlignment: d0,
  balance: f0
};
function s0(e, n) {
  let i = {};
  function r(o, s) {
    let a = 0, l = 0, c = o.length, u = s[s.length - 1];
    return s.forEach((f, h) => {
      let p = FD(e, f), m = p ? e.node(p).order : c;
      (p || f === u) && (s.slice(l, h + 1).forEach((g) => {
        e.predecessors(g).forEach((y) => {
          let v = e.node(y), w = v.order;
          (w < a || m < w) && !(v.dummy && e.node(g).dummy) && mu(i, y, g);
        });
      }), l = h + 1, a = m);
    }), s;
  }
  return n.length && n.reduce(r), i;
}
function a0(e, n) {
  let i = {};
  function r(s, a, l, c, u) {
    let f;
    Vt.range(a, l).forEach((h) => {
      f = s[h], e.node(f).dummy && e.predecessors(f).forEach((p) => {
        let m = e.node(p);
        m.dummy && (m.order < c || m.order > u) && mu(i, p, f);
      });
    });
  }
  function o(s, a) {
    let l = -1, c, u = 0;
    return a.forEach((f, h) => {
      if (e.node(f).dummy === "border") {
        let p = e.predecessors(f);
        p.length && (c = e.node(p[0]).order, r(a, u, h, l, c), u = h, l = c);
      }
      r(a, u, a.length, c, s.length);
    }), a;
  }
  return n.length && n.reduce(o), i;
}
function FD(e, n) {
  if (e.node(n).dummy)
    return e.predecessors(n).find((i) => e.node(i).dummy);
}
function mu(e, n, i) {
  if (n > i) {
    let o = n;
    n = i, i = o;
  }
  let r = e[n];
  r || (e[n] = r = {}), r[i] = !0;
}
function l0(e, n, i) {
  if (n > i) {
    let r = n;
    n = i, i = r;
  }
  return !!e[n] && Object.hasOwn(e[n], i);
}
function c0(e, n, i, r) {
  let o = {}, s = {}, a = {};
  return n.forEach((l) => {
    l.forEach((c, u) => {
      o[c] = c, s[c] = c, a[c] = u;
    });
  }), n.forEach((l) => {
    let c = -1;
    l.forEach((u) => {
      let f = r(u);
      if (f.length) {
        f = f.sort((p, m) => a[p] - a[m]);
        let h = (f.length - 1) / 2;
        for (let p = Math.floor(h), m = Math.ceil(h); p <= m; ++p) {
          let g = f[p];
          s[u] === u && c < a[g] && !l0(i, u, g) && (s[g] = u, s[u] = o[u] = o[g], c = a[g]);
        }
      }
    });
  }), { root: o, align: s };
}
function u0(e, n, i, r, o) {
  let s = {}, a = WD(e, n, i, o), l = o ? "borderLeft" : "borderRight";
  function c(h, p) {
    let m = a.nodes(), g = m.pop(), y = {};
    for (; g; )
      y[g] ? h(g) : (y[g] = !0, m.push(g), m = m.concat(p(g))), g = m.pop();
  }
  function u(h) {
    s[h] = a.inEdges(h).reduce((p, m) => Math.max(p, s[m.v] + a.edge(m)), 0);
  }
  function f(h) {
    let p = a.outEdges(h).reduce((g, y) => Math.min(g, s[y.w] - a.edge(y)), Number.POSITIVE_INFINITY), m = e.node(h);
    p !== Number.POSITIVE_INFINITY && m.borderType !== l && (s[h] = Math.max(s[h], p));
  }
  return c(u, a.predecessors.bind(a)), c(f, a.successors.bind(a)), Object.keys(r).forEach((h) => s[h] = s[i[h]]), s;
}
function WD(e, n, i, r) {
  let o = new BD(), s = e.graph(), a = qD(s.nodesep, s.edgesep, r);
  return n.forEach((l) => {
    let c;
    l.forEach((u) => {
      let f = i[u];
      if (o.setNode(f), c) {
        var h = i[c], p = o.edge(h, f);
        o.setEdge(h, f, Math.max(a(e, u, c), p || 0));
      }
      c = u;
    });
  }), o;
}
function d0(e, n) {
  return Object.values(n).reduce((i, r) => {
    let o = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY;
    Object.entries(r).forEach(([l, c]) => {
      let u = GD(e, l) / 2;
      o = Math.max(c + u, o), s = Math.min(c - u, s);
    });
    const a = o - s;
    return a < i[0] && (i = [a, r]), i;
  }, [Number.POSITIVE_INFINITY, null])[1];
}
function h0(e, n) {
  let i = Object.values(n), r = Vt.applyWithChunking(Math.min, i), o = Vt.applyWithChunking(Math.max, i);
  ["u", "d"].forEach((s) => {
    ["l", "r"].forEach((a) => {
      let l = s + a, c = e[l];
      if (c === n) return;
      let u = Object.values(c), f = r - Vt.applyWithChunking(Math.min, u);
      a !== "l" && (f = o - Vt.applyWithChunking(Math.max, u)), f && (e[l] = Vt.mapValues(c, (h) => h + f));
    });
  });
}
function f0(e, n) {
  return Vt.mapValues(e.ul, (i, r) => {
    if (n)
      return e[n.toLowerCase()][r];
    {
      let o = Object.values(e).map((s) => s[r]).sort((s, a) => s - a);
      return (o[1] + o[2]) / 2;
    }
  });
}
function HD(e) {
  let n = Vt.buildLayerMatrix(e), i = Object.assign(
    s0(e, n),
    a0(e, n)
  ), r = {}, o;
  ["u", "d"].forEach((a) => {
    o = a === "u" ? n : Object.values(n).reverse(), ["l", "r"].forEach((l) => {
      l === "r" && (o = o.map((h) => Object.values(h).reverse()));
      let c = (a === "u" ? e.predecessors : e.successors).bind(e), u = c0(e, o, i, c), f = u0(
        e,
        o,
        u.root,
        u.align,
        l === "r"
      );
      l === "r" && (f = Vt.mapValues(f, (h) => -h)), r[a + l] = f;
    });
  });
  let s = d0(e, r);
  return h0(r, s), f0(r, e.graph().align);
}
function qD(e, n, i) {
  return (r, o, s) => {
    let a = r.node(o), l = r.node(s), c = 0, u;
    if (c += a.width / 2, Object.hasOwn(a, "labelpos"))
      switch (a.labelpos.toLowerCase()) {
        case "l":
          u = -a.width / 2;
          break;
        case "r":
          u = a.width / 2;
          break;
      }
    if (u && (c += i ? u : -u), u = 0, c += (a.dummy ? n : e) / 2, c += (l.dummy ? n : e) / 2, c += l.width / 2, Object.hasOwn(l, "labelpos"))
      switch (l.labelpos.toLowerCase()) {
        case "l":
          u = l.width / 2;
          break;
        case "r":
          u = -l.width / 2;
          break;
      }
    return u && (c += i ? u : -u), u = 0, c;
  };
}
function GD(e, n) {
  return e.node(n).width;
}
let p0 = Pe, UD = jD.positionX;
var YD = XD;
function XD(e) {
  e = p0.asNonCompoundGraph(e), KD(e), Object.entries(UD(e)).forEach(([n, i]) => e.node(n).x = i);
}
function KD(e) {
  let n = p0.buildLayerMatrix(e), i = e.graph().ranksep, r = 0;
  n.forEach((o) => {
    const s = o.reduce((a, l) => {
      const c = e.node(l).height;
      return a > c ? a : c;
    }, 0);
    o.forEach((a) => e.node(a).y = r + s / 2), r += s + i;
  });
}
let yf = sI, vf = dI, ZD = LI, JD = Pe.normalizeRanks, QD = VI, eN = Pe.removeEmptyRanks, wf = WI, tN = XI, xf = ZI, nN = OD, iN = YD, ft = Pe, rN = St.Graph;
var oN = sN;
function sN(e, n) {
  let i = n && n.debugTiming ? ft.time : ft.notime;
  i("layout", () => {
    let r = i("  buildLayoutGraph", () => gN(e));
    i("  runLayout", () => aN(r, i, n)), i("  updateInputGraph", () => lN(e, r));
  });
}
function aN(e, n, i) {
  n("    makeSpaceForEdgeLabels", () => yN(e)), n("    removeSelfEdges", () => EN(e)), n("    acyclic", () => yf.run(e)), n("    nestingGraph.run", () => wf.run(e)), n("    rank", () => ZD(ft.asNonCompoundGraph(e))), n("    injectEdgeLabelProxies", () => vN(e)), n("    removeEmptyRanks", () => eN(e)), n("    nestingGraph.cleanup", () => wf.cleanup(e)), n("    normalizeRanks", () => JD(e)), n("    assignRankMinMax", () => wN(e)), n("    removeEdgeLabelProxies", () => xN(e)), n("    normalize.run", () => vf.run(e)), n("    parentDummyChains", () => QD(e)), n("    addBorderSegments", () => tN(e)), n("    order", () => nN(e, i)), n("    insertSelfEdges", () => PN(e)), n("    adjustCoordinateSystem", () => xf.adjust(e)), n("    position", () => iN(e)), n("    positionSelfEdges", () => TN(e)), n("    removeBorderNodes", () => CN(e)), n("    normalize.undo", () => vf.undo(e)), n("    fixupEdgeLabelCoords", () => SN(e)), n("    undoCoordinateSystem", () => xf.undo(e)), n("    translateGraph", () => bN(e)), n("    assignNodeIntersects", () => kN(e)), n("    reversePoints", () => _N(e)), n("    acyclic.undo", () => yf.undo(e));
}
function lN(e, n) {
  e.nodes().forEach((i) => {
    let r = e.node(i), o = n.node(i);
    r && (r.x = o.x, r.y = o.y, r.rank = o.rank, n.children(i).length && (r.width = o.width, r.height = o.height));
  }), e.edges().forEach((i) => {
    let r = e.edge(i), o = n.edge(i);
    r.points = o.points, Object.hasOwn(o, "x") && (r.x = o.x, r.y = o.y);
  }), e.graph().width = n.graph().width, e.graph().height = n.graph().height;
}
let cN = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"], uN = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }, dN = ["acyclicer", "ranker", "rankdir", "align"], hN = ["width", "height"], bf = { width: 0, height: 0 }, fN = ["minlen", "weight", "width", "height", "labeloffset"], pN = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
}, mN = ["labelpos"];
function gN(e) {
  let n = new rN({ multigraph: !0, compound: !0 }), i = xa(e.graph());
  return n.setGraph(Object.assign(
    {},
    uN,
    wa(i, cN),
    ft.pick(i, dN)
  )), e.nodes().forEach((r) => {
    let o = xa(e.node(r));
    const s = wa(o, hN);
    Object.keys(bf).forEach((a) => {
      s[a] === void 0 && (s[a] = bf[a]);
    }), n.setNode(r, s), n.setParent(r, e.parent(r));
  }), e.edges().forEach((r) => {
    let o = xa(e.edge(r));
    n.setEdge(r, Object.assign(
      {},
      pN,
      wa(o, fN),
      ft.pick(o, mN)
    ));
  }), n;
}
function yN(e) {
  let n = e.graph();
  n.ranksep /= 2, e.edges().forEach((i) => {
    let r = e.edge(i);
    r.minlen *= 2, r.labelpos.toLowerCase() !== "c" && (n.rankdir === "TB" || n.rankdir === "BT" ? r.width += r.labeloffset : r.height += r.labeloffset);
  });
}
function vN(e) {
  e.edges().forEach((n) => {
    let i = e.edge(n);
    if (i.width && i.height) {
      let r = e.node(n.v), s = { rank: (e.node(n.w).rank - r.rank) / 2 + r.rank, e: n };
      ft.addDummyNode(e, "edge-proxy", s, "_ep");
    }
  });
}
function wN(e) {
  let n = 0;
  e.nodes().forEach((i) => {
    let r = e.node(i);
    r.borderTop && (r.minRank = e.node(r.borderTop).rank, r.maxRank = e.node(r.borderBottom).rank, n = Math.max(n, r.maxRank));
  }), e.graph().maxRank = n;
}
function xN(e) {
  e.nodes().forEach((n) => {
    let i = e.node(n);
    i.dummy === "edge-proxy" && (e.edge(i.e).labelRank = i.rank, e.removeNode(n));
  });
}
function bN(e) {
  let n = Number.POSITIVE_INFINITY, i = 0, r = Number.POSITIVE_INFINITY, o = 0, s = e.graph(), a = s.marginx || 0, l = s.marginy || 0;
  function c(u) {
    let f = u.x, h = u.y, p = u.width, m = u.height;
    n = Math.min(n, f - p / 2), i = Math.max(i, f + p / 2), r = Math.min(r, h - m / 2), o = Math.max(o, h + m / 2);
  }
  e.nodes().forEach((u) => c(e.node(u))), e.edges().forEach((u) => {
    let f = e.edge(u);
    Object.hasOwn(f, "x") && c(f);
  }), n -= a, r -= l, e.nodes().forEach((u) => {
    let f = e.node(u);
    f.x -= n, f.y -= r;
  }), e.edges().forEach((u) => {
    let f = e.edge(u);
    f.points.forEach((h) => {
      h.x -= n, h.y -= r;
    }), Object.hasOwn(f, "x") && (f.x -= n), Object.hasOwn(f, "y") && (f.y -= r);
  }), s.width = i - n + a, s.height = o - r + l;
}
function kN(e) {
  e.edges().forEach((n) => {
    let i = e.edge(n), r = e.node(n.v), o = e.node(n.w), s, a;
    i.points ? (s = i.points[0], a = i.points[i.points.length - 1]) : (i.points = [], s = o, a = r), i.points.unshift(ft.intersectRect(r, s)), i.points.push(ft.intersectRect(o, a));
  });
}
function SN(e) {
  e.edges().forEach((n) => {
    let i = e.edge(n);
    if (Object.hasOwn(i, "x"))
      switch ((i.labelpos === "l" || i.labelpos === "r") && (i.width -= i.labeloffset), i.labelpos) {
        case "l":
          i.x -= i.width / 2 + i.labeloffset;
          break;
        case "r":
          i.x += i.width / 2 + i.labeloffset;
          break;
      }
  });
}
function _N(e) {
  e.edges().forEach((n) => {
    let i = e.edge(n);
    i.reversed && i.points.reverse();
  });
}
function CN(e) {
  e.nodes().forEach((n) => {
    if (e.children(n).length) {
      let i = e.node(n), r = e.node(i.borderTop), o = e.node(i.borderBottom), s = e.node(i.borderLeft[i.borderLeft.length - 1]), a = e.node(i.borderRight[i.borderRight.length - 1]);
      i.width = Math.abs(a.x - s.x), i.height = Math.abs(o.y - r.y), i.x = s.x + i.width / 2, i.y = r.y + i.height / 2;
    }
  }), e.nodes().forEach((n) => {
    e.node(n).dummy === "border" && e.removeNode(n);
  });
}
function EN(e) {
  e.edges().forEach((n) => {
    if (n.v === n.w) {
      var i = e.node(n.v);
      i.selfEdges || (i.selfEdges = []), i.selfEdges.push({ e: n, label: e.edge(n) }), e.removeEdge(n);
    }
  });
}
function PN(e) {
  var n = ft.buildLayerMatrix(e);
  n.forEach((i) => {
    var r = 0;
    i.forEach((o, s) => {
      var a = e.node(o);
      a.order = s + r, (a.selfEdges || []).forEach((l) => {
        ft.addDummyNode(e, "selfedge", {
          width: l.label.width,
          height: l.label.height,
          rank: a.rank,
          order: s + ++r,
          e: l.e,
          label: l.label
        }, "_se");
      }), delete a.selfEdges;
    });
  });
}
function TN(e) {
  e.nodes().forEach((n) => {
    var i = e.node(n);
    if (i.dummy === "selfedge") {
      var r = e.node(i.e.v), o = r.x + r.width / 2, s = r.y, a = i.x - o, l = r.height / 2;
      e.setEdge(i.e, i.label), e.removeNode(n), i.label.points = [
        { x: o + 2 * a / 3, y: s - l },
        { x: o + 5 * a / 6, y: s - l },
        { x: o + a, y: s },
        { x: o + 5 * a / 6, y: s + l },
        { x: o + 2 * a / 3, y: s + l }
      ], i.label.x = i.x, i.label.y = i.y;
    }
  });
}
function wa(e, n) {
  return ft.mapValues(ft.pick(e, n), Number);
}
function xa(e) {
  var n = {};
  return e && Object.entries(e).forEach(([i, r]) => {
    typeof i == "string" && (i = i.toLowerCase()), n[i] = r;
  }), n;
}
let MN = Pe, AN = St.Graph;
var IN = {
  debugOrdering: DN
};
function DN(e) {
  let n = MN.buildLayerMatrix(e), i = new AN({ compound: !0, multigraph: !0 }).setGraph({});
  return e.nodes().forEach((r) => {
    i.setNode(r, { label: r }), i.setParent(r, "layer" + e.node(r).rank);
  }), e.edges().forEach((r) => i.setEdge(r.v, r.w, {}, r.name)), n.forEach((r, o) => {
    let s = "layer" + o;
    i.setNode(s, { rank: "same" }), r.reduce((a, l) => (i.setEdge(a, l, { style: "invis" }), l));
  }), i;
}
var NN = "1.1.4", RN = {
  graphlib: St,
  layout: oN,
  debug: IN,
  util: {
    time: Pe.time,
    notime: Pe.notime
  },
  version: NN
};
const Gi = /* @__PURE__ */ M1(RN), Ve = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 120,
    height: 10,
    minlen: 1,
    weight: 1
  },
  emptyNodeOffset: 120,
  nodeWidth: 330,
  nodeHeight: 180,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function LN() {
  const e = new Gi.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return e.setGraph({
    ...Ve.dagre,
    rankdir: "LR"
  }), e.setDefaultEdgeLabel(() => ({ ...Ve.edgeLabel })), e.setDefaultNodeLabel(() => ({})), e;
}
const hl = "-port";
function $N(e) {
  const n = An([...e]), i = new Set(n), r = new Map(n.map((a) => [a.id, a])), o = new xi(() => null), s = n.reduce((a, l, c, u) => (a.set(
    l,
    u.slice(c + 1).filter(Rp(l)).map((f) => (i.delete(f), f)).reduce((f, h) => (f.some(Ar(h)) || (f.push(h), o.set(h, l)), f), [])
  ), a), new xi(() => []));
  return {
    sorted: n,
    byId: (a) => xe(r.get(a), `Element not found by id: ${a}`),
    root: i,
    parent: (a) => o.get(a),
    children: (a) => s.get(a)
  };
}
function ba(e, n, i) {
  const r = new xi((s) => ({
    id: `${e}-${s}`,
    portId: `${e}-${s}`
  })), o = $N(n);
  for (const s of o.sorted) {
    const a = o.children(s).length > 0, l = s.id, c = `${e}-${l}`, u = a ? `${c}${hl}` : c;
    r.set(l, {
      id: c,
      portId: u
    }), i.setNode(c, {
      column: e,
      element: s,
      isCompound: a,
      portId: u,
      inPorts: [],
      outPorts: [],
      width: Ve.nodeWidth,
      height: Ve.nodeHeight
    }), a && (i.setNode(u, {
      element: s,
      portId: u,
      isCompound: a,
      inPorts: [],
      outPorts: [],
      width: Ve.nodeWidth - Ve.dagre.ranksep,
      height: Ve.compound.labelHeight
    }), i.setParent(u, c));
    const f = o.parent(s);
    f && i.setParent(c, `${e}-${f.id}`);
  }
  return {
    ...o,
    byId: (s) => {
      const a = o.byId(s), l = r.get(a.id);
      return {
        element: a,
        graph: l
      };
    },
    graphNodes: r
  };
}
function zN(e) {
  return Gi.layout(e, {
    // disableOptimalOrderHeuristic: true,
  }), (n) => {
    const i = e.node(n), { x: r, y: o, width: s, height: a } = i;
    return {
      position: {
        x: r - Math.round(s / 2),
        y: o - Math.round(a / 2)
      },
      width: s,
      height: a
    };
  };
}
var ts;
((e) => {
  e.Empty = "@empty";
})(ts || (ts = {}));
function ON(e) {
  const n = LN(), i = ba("incomers", e.incomers, n), r = ba("subjects", e.subjects, n), o = ba("outgoers", e.outgoers, n), s = [];
  ve(
    Ig(
      ve(
        Mr(e.incoming),
        Ce((x) => ({
          id: x.source.id,
          source: i.byId(x.source.id).graph,
          target: r.byId(x.target.id).graph,
          relation: x
        })),
        // Sort by source
        An
      ),
      ve(
        Mr(e.outgoing),
        Ce((x) => ({
          id: x.target.id,
          source: r.byId(x.source.id).graph,
          target: o.byId(x.target.id).graph,
          relation: x
        })),
        // Sort by target
        An
      )
    ),
    Ce((x) => ({
      ...x,
      expr: `${x.source.id}->${x.target.id}`
    })),
    // Group if same source and target
    Tg(et("expr")),
    Mg((x) => {
      const k = x[0].source, _ = x[0].target, S = x[0].expr;
      n.node(k.id).outPorts.push(_.id), n.node(_.id).inPorts.push(k.id), n.setEdge(k.portId, _.portId, {
        ...Ve.edgeLabel
      }, S), s.push({
        name: S,
        source: k.id,
        sourceHandle: k.id + "_out" + (n.node(k.id).outPorts.length - 1),
        target: _.id,
        targetHandle: _.id + "_in" + (n.node(_.id).inPorts.length - 1),
        relations: Ce(x, et("relation"))
      });
    })
  );
  for (const x of r.graphNodes.values()) {
    const k = x.id, _ = n.node(k);
    if (_.isCompound)
      continue;
    const S = Math.max(n.inEdges(k)?.length ?? 0, n.outEdges(k)?.length ?? 0);
    S > 2 && (_.height = _.height + (S - 3) * 14);
  }
  const a = [
    ...i.graphNodes.values(),
    ...r.graphNodes.values(),
    ...o.graphNodes.values()
  ];
  if (i.graphNodes.size == 0) {
    const x = "incomers-empty";
    n.setNode(x, {
      column: "incomers",
      element: null,
      isCompound: !1,
      portId: x,
      inPorts: [],
      outPorts: [],
      width: Ve.nodeWidth,
      height: Ve.nodeHeight
    });
    for (const k of r.graphNodes.values())
      n.setEdge(x, k.portId);
    a.push({
      id: x,
      portId: x
    });
  }
  if (o.graphNodes.size == 0) {
    const x = "outgoers-empty";
    n.setNode(x, {
      column: "outgoers",
      element: null,
      isCompound: !1,
      portId: x,
      inPorts: [],
      outPorts: [],
      width: Ve.nodeWidth,
      height: Ve.nodeHeight
    });
    for (const k of r.graphNodes.values())
      n.setEdge(k.portId, x);
    a.push({
      id: x,
      portId: x
    });
  }
  const l = zN(n), c = ve(
    a,
    // Compound nodes have different portId
    Gt((x) => x.id === x.portId),
    to((x) => [x.id, l(x.id)])
  );
  function u(x) {
    return c[x] ??= ve(
      n.children(x) ?? [],
      Gt((k) => !k.endsWith(hl)),
      Ce((k) => u(k)),
      Sg((k) => {
        me(k.length > 0, `Node ${x} has no nested nodes`);
      }),
      Ei((k, _) => ({
        minY: Math.min(k.minY, _.position.y),
        maxY: Math.max(k.maxY, _.position.y + _.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: k, maxY: _ }) => {
        const {
          position: { x: S },
          width: P
        } = l(x);
        return k = k - Ve.compound.paddingTop, _ = _ + Ve.compound.paddingBottom, {
          position: {
            x: S,
            y: k
          },
          width: P,
          height: _ - k
        };
      }
    );
  }
  function f(x) {
    const k = n.parent(x);
    return k ? f(k) + 1 : 0;
  }
  function h(x) {
    const k = n.children(x) ?? [];
    return k.length === 0 ? 0 : 1 + Math.max(...k.map(h));
  }
  const p = (x, k, _) => ve(
    _,
    Ce((S, P) => ({
      port: x + "_" + k + P,
      topY: u(S).position.y
    })),
    Ho(et("topY")),
    Ce(et("port"))
  );
  let m = 0, g = 0;
  const [y] = [...r.root];
  me(y, "Subjects should not be empty");
  let v = u(r.graphNodes.get(y.id).id);
  const w = a.map(({ id: x }) => {
    const { element: k, inPorts: _, outPorts: S, column: P } = n.node(x);
    let { position: C, width: T, height: M } = u(x);
    if (!k) {
      if (M = Math.min(v.height, 300), C.y = v.position.y + v.height / 2 - M / 2, P === "incomers")
        T = v.position.x - Ve.emptyNodeOffset - C.x;
      else {
        const Q = C.x + T;
        C.x = v.position.x + v.width + Ve.emptyNodeOffset, T = Q - C.x;
      }
      return {
        id: x,
        parent: null,
        position: [C.x, C.y],
        title: "empty node",
        description: null,
        technology: null,
        tags: null,
        links: null,
        color: "muted",
        shape: "rectangle",
        style: {
          border: "dashed",
          opacity: 50
        },
        kind: ts.Empty,
        level: 0,
        labelBBox: {
          x: C.x,
          y: C.y,
          width: T,
          height: M
        },
        inEdges: [],
        outEdges: [],
        children: [],
        width: T,
        height: M,
        column: P,
        ports: {
          in: [],
          out: []
        }
      };
    }
    const D = n.parent(x), L = (n.children(x) ?? []).filter((Q) => !Q.endsWith(hl));
    m = Math.min(m, C.x), g = Math.min(g, C.y);
    const z = k.defaultView?.id ?? null;
    return {
      id: x,
      parent: D ?? null,
      position: [C.x, C.y],
      title: k.title,
      description: k.description,
      technology: k.technology,
      tags: null,
      links: null,
      color: k.color,
      shape: k.shape,
      icon: k.icon ?? "none",
      modelRef: k.id,
      kind: k.kind,
      level: f(x),
      labelBBox: {
        x: C.x,
        y: C.y,
        width: T,
        height: M
      },
      style: {
        ...k.$element.style
      },
      navigateTo: z,
      inEdges: [],
      outEdges: [],
      ...L.length > 0 && { depth: h(x) },
      children: L,
      width: T,
      height: M,
      column: P,
      ports: {
        in: p(x, "in", _),
        out: p(x, "out", S)
      }
    };
  });
  return {
    bounds: {
      x: Math.min(m, 0),
      y: Math.min(g, 0),
      width: n.graph().width ?? 100,
      height: n.graph().height ?? 100
    },
    nodes: w,
    edges: n.edges().reduce((x, k) => {
      const _ = n.edge(k), S = k.name;
      if (!S)
        return x;
      const { name: P, source: C, target: T, relations: M, sourceHandle: D, targetHandle: L } = Dc(s, (G) => G.name === S), z = Vr(M), Q = z?.title ?? "untitled", ee = M.length > 1, Z = _.points.map((G) => [G.x, G.y]);
      if (!ut(Z, 1))
        return x;
      const ae = z?.navigateTo?.id ?? null;
      return x.push({
        id: P,
        source: C,
        sourceHandle: D,
        target: T,
        targetHandle: L,
        label: ee ? `${M.length} relationships` : Q,
        relations: M.map((G) => G.id),
        parent: null,
        points: Z,
        ...ae && { navigateTo: ae },
        head: "normal",
        tail: "none",
        line: z?.$relationship.line ?? "dashed"
      }), x;
    }, [])
  };
}
function VN(e) {
  const n = it(!0);
  return ce(() => ({
    id: `relationships-${e}`,
    title: `Relationships of ${e}`,
    description: null,
    autoLayout: {
      direction: "LR"
    },
    tags: null,
    links: null,
    hash: "empty",
    customColorDefinitions: {},
    ...ON(ju(e, n))
  }), [n, e, ju]);
}
const ns = 0.08, BN = {
  relationships: ru((e) => {
    const { enableNavigateTo: n } = Fe("NavigateTo"), {
      data: {
        navigateTo: i,
        relations: r
      }
    } = e, [o, s, a] = Tp(e), l = de(), c = r.length > 1 ? {
      ...e,
      data: {
        ...e.data,
        line: "solid",
        color: "amber"
      }
    } : e;
    return /* @__PURE__ */ b(su, { ...c, children: [
      /* @__PURE__ */ d(
        au,
        {
          ...c,
          svgPath: o,
          ...r.length > 1 && {
            strokeWidth: 5
          }
        }
      ),
      /* @__PURE__ */ d(
        Ts,
        {
          edgeProps: c,
          labelPosition: {
            x: s,
            y: a,
            translate: "translate(-50%, 0)"
          },
          style: {
            maxWidth: Math.min(Math.abs(e.targetX - e.sourceX - 70), 250)
          },
          children: n && i && /* @__PURE__ */ d(
            ou,
            {
              ...e,
              onClick: (u) => {
                u.stopPropagation(), l.navigateTo(i);
              }
            }
          )
        }
      )
    ] });
  })
}, m0 = Le(null);
function g0() {
  return xe(oe(m0), "No RelationshipsBrowserActorContext");
}
function gu(e, n = Ze) {
  const i = g0();
  return Gn(i, q(e), n);
}
function zs() {
  const e = g0(), [, n] = _l();
  return ce(() => ({
    actor: e,
    getState: () => e.getSnapshot().context,
    send: e.send,
    navigateTo: (i, r) => {
      n(() => {
        e.send({
          type: "navigate.to",
          subject: i,
          fromNode: r
        });
      });
    },
    fitDiagram: () => {
      n(() => {
        e.send({ type: "fitDiagram" });
      });
    },
    close: () => {
      e._parent ? e._parent?.send({ type: "close", actorId: e.id }) : e.send({ type: "close" });
    }
  }), [e]);
}
const jN = (e) => {
  const { enableNavigateTo: n, enableVscode: i } = Fe("NavigateTo", "Vscode"), r = de(), o = zs(), s = gu((u) => u.context.subject), a = [], { navigateTo: l, fqn: c } = e.data;
  return l && n && a.push({
    key: "navigate",
    icon: /* @__PURE__ */ d(kt, {}),
    onClick: (u) => {
      u.stopPropagation(), r.navigateTo(l);
    }
  }), c !== s && a.push({
    key: "relationships",
    icon: /* @__PURE__ */ d(Cs, {}),
    onClick: (u) => {
      u.stopPropagation(), o.navigateTo(c, e.id);
    }
  }), i && a.push({
    key: "goToSource",
    icon: /* @__PURE__ */ d(ro, {}),
    onClick: (u) => {
      u.stopPropagation(), r.openSource({ element: c });
    }
  }), /* @__PURE__ */ d(
    Ms,
    {
      buttons: a,
      ...e
    }
  );
};
var FN = "_1li971z0";
function WN({
  data: {
    column: e
  }
}) {
  return /* @__PURE__ */ d(A, { className: FN, children: /* @__PURE__ */ b($, { c: "dimmed", fz: "lg", fw: 500, children: [
    "No ",
    e === "incomers" ? "incoming" : "outgoing"
  ] }) });
}
const kf = (e) => {
  const n = de();
  return /* @__PURE__ */ d(
    lu,
    {
      ...e,
      onClick: (i) => {
        i.stopPropagation(), n.openElementDetails(e.data.fqn);
      }
    }
  );
}, HN = {
  element: Ct((e) => /* @__PURE__ */ b(Fr, { component: re.div, layoutId: e.id, nodeProps: e, children: [
    /* @__PURE__ */ d(Wr, { ...e }),
    /* @__PURE__ */ d(Jo, { ...e, iconSize: 40 }),
    /* @__PURE__ */ d(kf, { ...e }),
    /* @__PURE__ */ d(jN, { ...e }),
    /* @__PURE__ */ d(qN, { ...e })
  ] }, e.id)),
  compound: Ct((e) => /* @__PURE__ */ b(yi, { component: re.div, layoutId: e.id, nodeProps: e, children: [
    /* @__PURE__ */ d(kf, { ...e }),
    /* @__PURE__ */ d(kr, { ...e }),
    /* @__PURE__ */ d(GN, { ...e })
  ] }, e.id)),
  empty: Ct((e) => /* @__PURE__ */ d(WN, { ...e }))
}, qN = ({ data: { ports: e, height: n } }) => /* @__PURE__ */ b(H, { children: [
  e.in.map((i, r) => /* @__PURE__ */ d(
    Nt,
    {
      id: i,
      type: "target",
      position: Rt.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (r + 1) * ((n - 30) / (e.in.length + 1))}px`
      }
    },
    i
  )),
  e.out.map((i, r) => /* @__PURE__ */ d(
    Nt,
    {
      id: i,
      type: "source",
      position: Rt.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (r + 1) * ((n - 30) / (e.out.length + 1))}px`
      }
    },
    i
  ))
] }), GN = ({ data: e }) => /* @__PURE__ */ b(H, { children: [
  e.ports.in.map((n, i) => /* @__PURE__ */ d(
    Nt,
    {
      id: n,
      type: "target",
      position: Rt.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    n
  )),
  e.ports.out.map((n, i) => /* @__PURE__ */ d(
    Nt,
    {
      id: n,
      type: "source",
      position: Rt.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    n
  ))
] });
var UN = "j1tmo20", YN = "j1tmo21", y0 = "j1tmo22";
const XN = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get label() {
    return YN;
  },
  get node() {
    return UN;
  },
  get scrollArea() {
    return y0;
  }
}, Symbol.toStringTag, { value: "Module" })), KN = ({
  subjectId: e,
  viewId: n,
  scope: i,
  onSelect: r
}) => {
  const o = J(null), a = it(!0).findElement(e), l = WT(i === "view" ? n : void 0), c = Xr({
    multiple: !1
  });
  ie(() => {
    j1(e).reverse().forEach((f) => {
      c.expand(f);
    }), c.select(e);
  }, [e]);
  const u = cs();
  return /* @__PURE__ */ d(A, { pos: "relative", children: /* @__PURE__ */ b(
    Ri,
    {
      position: "bottom-start",
      shadow: "md",
      keepMounted: !1,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          o.current?.querySelector(`[data-value="${e}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ d(Li, { children: /* @__PURE__ */ d(
          le,
          {
            size: "xs",
            variant: "light",
            color: u === "light" ? "dark" : "gray",
            fw: "500",
            maw: 250,
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ d(jc, { size: 16 }),
            children: a?.title ?? "???"
          }
        ) }),
        /* @__PURE__ */ d($i, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ d(jn, { scrollbars: "y", type: "never", viewportRef: o, className: y0, children: /* @__PURE__ */ d(
          Kr,
          {
            allowRangeSelection: !1,
            selectOnClick: !1,
            tree: c,
            data: l,
            classNames: XN,
            levelOffset: 8,
            styles: {
              root: {
                maxWidth: 400,
                overflow: "hidden"
              },
              label: {
                paddingTop: 5,
                paddingBottom: 6
              }
            },
            renderNode: ({ node: f, selected: h, expanded: p, elementProps: m, hasChildren: g }) => /* @__PURE__ */ b(K, { gap: 2, wrap: "nowrap", ...m, py: "3", children: [
              /* @__PURE__ */ d(
                se,
                {
                  variant: "subtle",
                  size: 18,
                  c: "dimmed",
                  style: {
                    visibility: g ? "visible" : "hidden"
                  },
                  children: /* @__PURE__ */ d(
                    io,
                    {
                      stroke: 3.5,
                      style: {
                        transition: "transform 150ms ease",
                        transform: `rotate(${p ? "90deg" : "0"})`,
                        width: "80%"
                      }
                    }
                  )
                }
              ),
              /* @__PURE__ */ d(
                A,
                {
                  flex: "1 1 100%",
                  w: "100%",
                  onClick: (y) => {
                    y.stopPropagation(), r(f.value), c.select(f.value), c.expand(f.value);
                  },
                  children: /* @__PURE__ */ d(
                    $,
                    {
                      fz: "sm",
                      fw: h ? "600" : "400",
                      truncate: "end",
                      children: f.label
                    }
                  )
                }
              )
            ] })
          }
        ) }) })
      ]
    }
  ) });
};
function v0({ actorRef: e }) {
  const n = J(null);
  return n.current == null && (n.current = {
    defaultNodes: [],
    defaultEdges: []
  }), /* @__PURE__ */ d(m0.Provider, { value: e, children: /* @__PURE__ */ d($l, { ...n.current, children: /* @__PURE__ */ d(ki, { id: e.sessionId, inherit: !1, children: /* @__PURE__ */ d(ht, { children: /* @__PURE__ */ d(QN, {}) }) }) }) });
}
const ZN = (e) => ({
  isActive: e.hasTag("active"),
  nodes: e.context.xynodes,
  edges: e.context.xyedges
}), JN = (e, n) => e.isActive === n.isActive && Ze(e.nodes, n.nodes) && Ze(e.edges, n.edges), QN = nt(() => {
  const e = zs(), {
    isActive: n,
    nodes: i,
    edges: r
  } = gu(
    ZN,
    JN
  );
  return /* @__PURE__ */ d(
    Hc,
    {
      id: `relationships-browser-${e.actor.sessionId}`,
      nodes: i,
      edges: r,
      className: j(n ? "initialized" : "not-initialized"),
      nodeTypes: HN,
      edgeTypes: BN,
      fitViewPadding: ns,
      onNodeClick: q((o, s) => {
        o.stopPropagation(), e.send({ type: "xyflow.nodeClick", node: s });
      }),
      onEdgeClick: q((o, s) => {
        o.stopPropagation(), e.send({ type: "xyflow.edgeClick", edge: s });
      }),
      onPaneClick: q((o) => {
        o.stopPropagation(), e.send({ type: "xyflow.paneClick" });
      }),
      onDoubleClick: q((o) => {
        o.stopPropagation(), e.send({ type: "xyflow.paneDblClick" });
      }),
      onViewportResize: q(() => {
        e.send({ type: "xyflow.resized" });
      }),
      onNodesChange: q((o) => {
        e.send({ type: "xyflow.applyNodeChanges", changes: o });
      }),
      onEdgesChange: q((o) => {
        e.send({ type: "xyflow.applyEdgeChanges", changes: o });
      }),
      nodesDraggable: !1,
      fitView: !1,
      pannable: !0,
      zoomable: !0,
      children: /* @__PURE__ */ d(tR, {})
    }
  );
}), eR = (e) => ({
  subjectId: e.context.subject,
  closeable: e.context.closeable,
  enableNavigationMenu: e.context.enableNavigationMenu
}), tR = nt(() => {
  const e = zs(), {
    subjectId: n,
    closeable: i,
    enableNavigationMenu: r
  } = gu(eR), o = ds(), s = Pp();
  ie(() => {
    e.send({ type: "xyflow.init", instance: s, store: o });
  }, [o, s, e]);
  const a = VN(n), [l, c, { history: u, current: f }] = yp(n);
  ie(() => {
    l !== n && c.set(n);
  }, [n]), ie(() => {
    l !== n && e.navigateTo(l);
  }, [l, e]), ie(() => {
    e.send({ type: "update.view", layouted: a });
  }, [a, e]);
  const h = f > 0, p = f + 1 < u.length;
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(
      nR,
      {
        enableNavigationMenu: r,
        subjectId: n,
        hasStepBack: h,
        hasStepForward: p,
        onStepBack: () => c.back(),
        onStepForward: () => c.forward()
      }
    ),
    i && /* @__PURE__ */ d(hs, { position: "top-right", children: /* @__PURE__ */ d(
      se,
      {
        variant: "default",
        color: "gray",
        onClick: (m) => {
          m.stopPropagation(), e.close();
        },
        children: /* @__PURE__ */ d(oo, {})
      }
    ) })
  ] });
}), nR = ({
  enableNavigationMenu: e,
  subjectId: n,
  hasStepBack: i,
  hasStepForward: r,
  onStepBack: o,
  onStepForward: s
}) => {
  const a = zs();
  return /* @__PURE__ */ d(hs, { position: "top-left", children: /* @__PURE__ */ d(K, { gap: 4, wrap: "nowrap", children: /* @__PURE__ */ b(ht, { mode: "popLayout", children: [
    i && /* @__PURE__ */ d(
      re.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ d(
          se,
          {
            variant: "default",
            color: "gray",
            onClick: (l) => {
              l.stopPropagation(), o();
            },
            children: /* @__PURE__ */ d(Oc, {})
          }
        )
      },
      "back"
    ),
    r && /* @__PURE__ */ d(
      re.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(5px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(5px)"
        },
        children: /* @__PURE__ */ d(
          se,
          {
            variant: "default",
            color: "gray",
            onClick: (l) => {
              l.stopPropagation(), s();
            },
            children: /* @__PURE__ */ d(io, {})
          }
        )
      },
      "forward"
    ),
    e && /* @__PURE__ */ b(K, { gap: "xs", wrap: "nowrap", ml: "sm", children: [
      /* @__PURE__ */ d(A, { fz: "xs", fw: "500", style: { whiteSpace: "nowrap", userSelect: "none" }, children: "Relationships of" }),
      /* @__PURE__ */ d(
        KN,
        {
          subjectId: n,
          onSelect: (l) => a.navigateTo(l),
          viewId: a.getState().scope?.id ?? "",
          scope: "global"
        }
      )
    ] })
  ] }) }) });
};
var iR = "bt3ejo0", rR = "bt3ejo1", oR = "bt3ejo2";
const sR = vt.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
});
function aR({
  node: e,
  element: n
}) {
  const i = vM(), r = Gn(i, (h) => h.children[`${i.id}-relationships`]), [o, s] = ge("view"), a = [...n.incoming()].map((h) => h.id), l = [...n.outgoing()].map((h) => h.id), c = e ? hh([...e.incoming()].flatMap((h) => h.$edge.relations)) : [], u = e ? hh([...e.outgoing()].flatMap((h) => h.$edge.relations)) : [], f = [
    ...a,
    ...l
  ].filter((h) => !c.includes(h) && !u.includes(h)).length;
  return /* @__PURE__ */ b(be, { gap: "xs", pos: "relative", w: "100%", h: "100%", children: [
    a.length + l.length > 0 && /* @__PURE__ */ b(K, { gap: "xs", wrap: "nowrap", align: "center", children: [
      /* @__PURE__ */ d(A, { children: /* @__PURE__ */ b(K, { gap: 8, mb: 4, wrap: "nowrap", children: [
        /* @__PURE__ */ d(
          Sf,
          {
            title: "incoming",
            total: a.length,
            included: c.length
          }
        ),
        /* @__PURE__ */ d(wt, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ d(Br, { style: { width: 16 } }) }),
        /* @__PURE__ */ d($, { className: iR, children: Vl(n.id) }),
        /* @__PURE__ */ d(wt, { size: "sm", variant: "transparent", c: "dimmed", children: /* @__PURE__ */ d(Br, { style: { width: 16 } }) }),
        /* @__PURE__ */ d(
          Sf,
          {
            title: "outgoing",
            total: l.length,
            included: u.length
          }
        )
      ] }) }),
      f > 0 && /* @__PURE__ */ d(sR, { label: "Current view does not include some relationships", children: /* @__PURE__ */ b(
        K,
        {
          mt: "xs",
          gap: 6,
          c: "orange",
          style: { cursor: "pointer" },
          children: [
            /* @__PURE__ */ d(_s, { style: { width: 14 } }),
            /* @__PURE__ */ b($, { fz: "sm", children: [
              f,
              " relationship",
              f > 1 ? "s are" : " is",
              " hidden"
            ] })
          ]
        }
      ) })
    ] }),
    /* @__PURE__ */ d(A, { className: oR, children: r && /* @__PURE__ */ d(v0, { actorRef: r }) })
  ] });
}
function Sf({
  title: e,
  total: n,
  included: i
}) {
  return /* @__PURE__ */ d(
    ls,
    {
      withBorder: !0,
      shadow: "none",
      className: rR,
      px: "md",
      py: "xs",
      radius: "md",
      mod: {
        zero: n === 0,
        missing: n !== i
      },
      children: /* @__PURE__ */ b(be, { gap: 4, align: "flex-end", children: [
        /* @__PURE__ */ d($, { component: "div", c: n !== i ? "orange" : "dimmed", tt: "uppercase", fw: 600, fz: 10, lh: 1, children: e }),
        /* @__PURE__ */ d($, { fw: 600, fz: "xl", component: "div", lh: 1, children: n !== i ? /* @__PURE__ */ b(H, { children: [
          i,
          " / ",
          n
        ] }) : /* @__PURE__ */ d(H, { children: n }) })
      ] })
    }
  );
}
var lR = "_956g9l0", cR = "_956g9l1";
const ka = ({
  element: e
}) => /* @__PURE__ */ d(A, { className: cR, children: /* @__PURE__ */ d($, { component: "div", fz: "sm", fw: "500", children: e.title }) });
function uR({
  element: e
}) {
  const n = Xr({
    multiple: !1
  }), i = ce(() => {
    let r = 1;
    const o = (l) => ({
      label: l,
      value: `msg${r++}`,
      type: "message",
      children: []
    }), s = {
      label: /* @__PURE__ */ d(ka, { type: "current", element: e }),
      value: e.id,
      element: e,
      type: "current",
      children: [...e.children()].map((l) => ({
        label: /* @__PURE__ */ d(ka, { type: "descedant", element: l }),
        value: l.id,
        element: l,
        type: "descedant",
        children: []
      }))
    };
    return s.children.length === 0 && s.children.push(
      o(/* @__PURE__ */ d($v, { radius: "sm", children: "no nested" }))
    ), [
      [...e.ancestors()].reduce((l, c) => ({
        label: /* @__PURE__ */ d(ka, { type: "ancestor", element: c }),
        value: c.id,
        element: c,
        type: "ancestor",
        children: [l]
      }), s)
    ];
  }, [e]);
  return ie(() => {
    n.expandAllNodes();
  }, [i]), /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ b(Er, { variant: "light", color: "orange", title: "In development", icon: /* @__PURE__ */ d(_s, {}), children: [
      "We need your feedback. Share your thoughts and ideas -",
      " ",
      /* @__PURE__ */ d(
        fp,
        {
          fz: "sm",
          fw: 500,
          underline: "hover",
          c: "orange",
          href: "https://github.com/likec4/likec4/discussions/",
          target: "_blank",
          children: "GitHub discussions"
        }
      )
    ] }),
    /* @__PURE__ */ d(
      Kr,
      {
        levelOffset: "xl",
        allowRangeSelection: !1,
        expandOnClick: !1,
        expandOnSpace: !1,
        classNames: {
          label: lR
        },
        data: i,
        tree: n
      }
    )
  ] });
}
const _f = Tl.withProps({
  mb: 8,
  labelPosition: "left",
  variant: "dashed"
}), Cf = vt.withProps({
  color: "dark",
  fz: "xs",
  openDelay: 400,
  closeDelay: 150,
  label: "",
  children: null,
  offset: 4
}), Ef = $.withProps({
  component: "div",
  fz: 11,
  fw: 500,
  c: "dimmed",
  lh: 1
}), yu = $.withProps({
  component: "div",
  fz: "xs",
  c: "dimmed",
  className: IM
}), Jn = 24, dR = ["Properties", "Relationships", "Views", "Structure", "Deployments"];
function hR({
  viewId: e,
  fromNode: n,
  rectFromNode: i,
  fqn: r,
  onClose: o
}) {
  const [s, a] = ge(!1), l = zv(), c = l.width || window.innerWidth || 1200, u = l.height || window.innerHeight || 800, [f, h] = Ov({
    key: "likec4:element-details:active-tab",
    defaultValue: "Properties"
  }), p = de(), g = it(!0).view(e), y = n ? g.findNode(n) : g.findNodeWithElement(r), v = g.$model.element(r), [w, x] = ve(
    [...v.views()],
    Ce((E) => E.$view),
    _c((E) => {
      const N = E;
      return F1(N) && N.viewOf === r;
    })
  );
  let k = y?.navigateTo?.$view ?? v.defaultView?.$view ?? null;
  k?.id === e && (k = null);
  const _ = Vr(v.links), S = Yk(), P = (y?.$node.children?.length ?? 0) > 0, C = Math.min(700, c - Jn * 2), T = Math.min(650, u - Jn * 2), M = i ? {
    x: i.x + (P ? i.width - C / 2 : i.width / 2),
    y: i.y + (P ? 0 : i.height / 2)
  } : {
    x: c / 2,
    y: u / 2
  }, D = i ? Math.min(i.width / C, i.height / T, 0.9) : 1, L = Math.round(
    bn(M.x - C / 2, {
      min: Jn,
      max: c - C - Jn
    })
  ), z = Math.round(
    bn(M.y - (P ? 0 : 60), {
      min: Jn,
      max: u - T - Jn
    })
  ), Q = bn((M.x - L) / C, {
    min: 0.1,
    max: 0.9
  }), ee = bn((M.y - z) / T, {
    min: 0.1,
    max: 0.9
  }), Z = lh(C), ae = lh(T);
  Nn(() => {
    Z.set(C), ae.set(T);
  }, [C, T]);
  const G = dt((E, N) => {
    Z.set(Math.max(Z.get() + N.delta.x, 320)), ae.set(Math.max(ae.get() + N.delta.y, 300));
  }, []), te = J(null), $e = Dn(o), Me = ks(
    () => {
      $e.current();
    },
    [],
    50
  ), We = y?.$node.notation ?? null, Ae = Es({
    element: {
      id: r,
      title: v.title,
      icon: y?.icon ?? v.icon
    },
    className: SM
  });
  return Ja(() => {
    te.current?.open || te.current?.showModal();
  }, 30), Ja(() => {
    a(!0);
  }, 120), /* @__PURE__ */ d(
    re.dialog,
    {
      ref: te,
      className: wM,
      layout: !0,
      layoutRoot: !0,
      initial: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "10%"
      },
      animate: {
        "--backdrop-blur": "3px",
        "--backdrop-opacity": "60%"
      },
      exit: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "0%",
        transition: {
          duration: 0.1
        }
      },
      onClick: (E) => {
        E.target?.nodeName?.toUpperCase() === "DIALOG" && (E.stopPropagation(), te.current?.close());
      },
      onClose: (E) => {
        E.stopPropagation(), Me();
      },
      children: /* @__PURE__ */ b(
        Pr,
        {
          drag: !0,
          dragElastic: 0,
          dragMomentum: !1,
          dragListener: !1,
          dragControls: S,
          withBorder: !0,
          shadow: "md",
          component: re.div,
          className: xM,
          initial: {
            top: z,
            left: L,
            width: C,
            height: T,
            opacity: 0,
            originX: Q,
            originY: ee,
            scale: Math.max(D, 0.7)
          },
          animate: {
            opacity: 1,
            scale: 1
          },
          exit: {
            opacity: 0,
            scale: 0.9,
            translateY: -10,
            transition: {
              duration: 0.1
            }
          },
          style: {
            // `style` prop in Mantine doesn't accept motion values
            width: Z,
            height: ae
          },
          "data-likec4-color": y?.color ?? v.color,
          children: [
            /* @__PURE__ */ b(
              A,
              {
                className: bM,
                onPointerDown: (E) => S.start(E),
                children: [
                  /* @__PURE__ */ b(K, { align: "start", justify: "space-between", gap: "sm", mb: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ b(K, { align: "start", gap: "sm", style: { cursor: "default" }, wrap: "nowrap", children: [
                      Ae,
                      /* @__PURE__ */ b(A, { children: [
                        /* @__PURE__ */ d(
                          $,
                          {
                            component: "div",
                            className: kM,
                            children: v.title
                          }
                        ),
                        We && /* @__PURE__ */ d($, { component: "div", c: "dimmed", fz: "sm", fw: 500, lh: 1.3, lineClamp: 1, children: We })
                      ] })
                    ] }),
                    /* @__PURE__ */ d(
                      hp,
                      {
                        size: "lg",
                        onClick: (E) => {
                          E.stopPropagation(), Me();
                        }
                      }
                    )
                  ] }),
                  /* @__PURE__ */ b(K, { align: "baseline", gap: "sm", wrap: "nowrap", children: [
                    /* @__PURE__ */ b(A, { children: [
                      /* @__PURE__ */ d(Ef, { children: "kind" }),
                      /* @__PURE__ */ d(gi, { radius: "sm", size: "sm", fw: 600, color: "gray", children: v.kind })
                    ] }),
                    /* @__PURE__ */ b(A, { flex: 1, children: [
                      /* @__PURE__ */ d(Ef, { children: "tags" }),
                      /* @__PURE__ */ b(Cr, { gap: 4, flex: 1, mt: 6, children: [
                        v.tags.map((E) => /* @__PURE__ */ b(gi, { radius: "sm", size: "sm", fw: 600, variant: "gradient", children: [
                          "#",
                          E
                        ] }, E)),
                        v.tags.length === 0 && /* @__PURE__ */ d(gi, { radius: "sm", size: "sm", fw: 600, color: "gray", children: "" })
                      ] })
                    ] }),
                    /* @__PURE__ */ b(
                      Ml,
                      {
                        style: {
                          alignSelf: "flex-end"
                        },
                        children: [
                          _ && /* @__PURE__ */ d(
                            se,
                            {
                              component: "a",
                              href: _.url,
                              target: "_blank",
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              children: /* @__PURE__ */ d(Bc, { stroke: 1.6, style: { width: "65%" } })
                            }
                          ),
                          /* @__PURE__ */ d($c, { feature: "Vscode", children: /* @__PURE__ */ d(Cf, { label: "Open source", children: /* @__PURE__ */ d(
                            se,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (E) => {
                                E.stopPropagation();
                              },
                              children: /* @__PURE__ */ d(ro, { stroke: 1.8, style: { width: "62%" } })
                            }
                          ) }) }),
                          k && /* @__PURE__ */ d(Cf, { label: "Open default view", children: /* @__PURE__ */ d(
                            se,
                            {
                              size: "lg",
                              variant: "default",
                              radius: "sm",
                              onClick: (E) => {
                                E.stopPropagation(), p.navigateTo(k.id, n ?? void 0);
                              },
                              children: /* @__PURE__ */ d(kt, { style: { width: "70%" } })
                            }
                          ) })
                        ]
                      }
                    )
                  ] })
                ]
              }
            ),
            /* @__PURE__ */ b(
              Al,
              {
                value: f,
                onChange: (E) => h(E),
                variant: "none",
                classNames: {
                  root: EM,
                  list: PM,
                  tab: TM,
                  panel: MM
                },
                children: [
                  /* @__PURE__ */ d(Il, { children: dR.map((E) => /* @__PURE__ */ d(Tr, { value: E, children: E }, E)) }),
                  /* @__PURE__ */ d(Qt, { value: "Properties", children: /* @__PURE__ */ d(Qe, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ b(A, { className: AM, pt: "xs", children: [
                    /* @__PURE__ */ d(Tf, { title: "description", emptyValue: "no description", children: v.description }),
                    v.technology && /* @__PURE__ */ d(Tf, { title: "technology", children: v.technology }),
                    v.links.length > 0 && /* @__PURE__ */ b(H, { children: [
                      /* @__PURE__ */ d(yu, { children: "links" }),
                      /* @__PURE__ */ d(be, { gap: "xs", align: "flex-start", children: v.links.map((E, N) => /* @__PURE__ */ d(cu, { value: E }, N)) })
                    ] }),
                    v.$element.metadata && /* @__PURE__ */ d(fR, { value: v.$element.metadata })
                  ] }) }) }),
                  /* @__PURE__ */ d(Qt, { value: "Relationships", children: /* @__PURE__ */ d(
                    Pi,
                    {
                      overrides: {
                        enableRelationshipBrowser: !1,
                        enableNavigateTo: !1
                      },
                      children: s && f === "Relationships" && /* @__PURE__ */ d(
                        aR,
                        {
                          element: v,
                          node: y ?? null
                        }
                      )
                    }
                  ) }),
                  /* @__PURE__ */ d(Qt, { value: "Views", children: /* @__PURE__ */ d(Qe, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ b(be, { gap: "lg", children: [
                    w.length > 0 && /* @__PURE__ */ b(A, { children: [
                      /* @__PURE__ */ d(_f, { label: "views of the element (scoped)" }),
                      /* @__PURE__ */ d(be, { gap: "sm", children: w.map((E) => /* @__PURE__ */ d(
                        Pf,
                        {
                          view: E,
                          onNavigateTo: (N) => p.navigateTo(N, n ?? void 0)
                        },
                        E.id
                      )) })
                    ] }),
                    x.length > 0 && /* @__PURE__ */ b(A, { children: [
                      /* @__PURE__ */ d(_f, { label: "views including this element" }),
                      /* @__PURE__ */ d(be, { gap: "sm", children: x.map((E) => /* @__PURE__ */ d(
                        Pf,
                        {
                          view: E,
                          onNavigateTo: (N) => p.navigateTo(N, n ?? void 0)
                        },
                        E.id
                      )) })
                    ] })
                  ] }) }) }),
                  /* @__PURE__ */ d(Qt, { value: "Structure", children: /* @__PURE__ */ d(Qe, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ d(uR, { element: v }) }) }),
                  /* @__PURE__ */ d(Qt, { value: "Deployments", children: /* @__PURE__ */ d(Qe, { scrollbars: "y", type: "auto", children: /* @__PURE__ */ d(VM, { elementFqn: v.id }) }) })
                ]
              }
            ),
            /* @__PURE__ */ d(
              re.div,
              {
                className: DM,
                drag: !0,
                dragElastic: 0,
                dragMomentum: !1,
                onDrag: G,
                dragConstraints: { top: 0, left: 0, right: 0, bottom: 0 }
              }
            )
          ]
        }
      )
    }
  );
}
const Pf = ({
  view: e,
  onNavigateTo: n
}) => /* @__PURE__ */ d(Ft, { className: _M, onClick: (i) => n(e.id, i), children: /* @__PURE__ */ b(K, { gap: 6, align: "start", wrap: "nowrap", children: [
  /* @__PURE__ */ d(wt, { size: "sm", variant: "transparent", children: Lp(e) ? /* @__PURE__ */ d(Fc, { stroke: 1.8 }) : /* @__PURE__ */ d(kt, { stroke: 1.8 }) }),
  /* @__PURE__ */ b(A, { children: [
    /* @__PURE__ */ d($, { component: "div", className: CM, lineClamp: 1, children: e.title || "untitled" }),
    e.description && /* @__PURE__ */ d($, { component: "div", mt: 2, fz: "xs", c: "dimmed", lh: 1.4, lineClamp: 1, children: e.description })
  ] })
] }) });
function Tf({
  title: e,
  emptyValue: n = "undefined",
  children: i,
  style: r,
  ...o
}) {
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(yu, { children: e }),
    /* @__PURE__ */ d(
      $,
      {
        component: "div",
        ...Ac(i) && { c: "dimmed" },
        fz: "md",
        style: {
          whiteSpace: "preserve-breaks",
          ...r
        },
        ...o,
        children: i || n
      }
    )
  ] });
}
function fR({
  value: e
}) {
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(yu, { children: "metadata" }),
    /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d(xt, { block: !0, children: JSON.stringify(e, null, 2) }) })
  ] });
}
function pR({
  actorRef: e,
  onClose: n
}) {
  const i = Gn(
    e,
    q((r) => ({
      viewId: r.context.currentView.id,
      fromNode: r.context.initiatedFrom.node,
      rectFromNode: r.context.initiatedFrom.clientRect,
      fqn: r.context.subject
    })),
    Ze
  );
  return /* @__PURE__ */ d(uu, { value: e, children: /* @__PURE__ */ d(
    hR,
    {
      onClose: n,
      ...i
    }
  ) });
}
var mR = "yfv9b31", gR = "yfv9b32";
function Mf({ children: e, onClose: n, className: i, classes: r, ...o }) {
  const [s, a] = ge(!1), l = J(null), c = J(!1), u = Dn(n), f = ks(
    () => {
      c.current || (c.current = !0, u.current());
    },
    [],
    50
  );
  return as(() => {
    const h = (p) => {
      p.preventDefault(), f();
    };
    return l.current?.addEventListener("cancel", h, { capture: !0 }), () => {
      l.current?.removeEventListener("cancel", h, { capture: !0 });
    };
  }, []), Ja(() => {
    l.current?.open || l.current?.showModal(), a(!0);
  }, 30), /* @__PURE__ */ d(
    re.dialog,
    {
      ref: l,
      className: j(mR, r?.dialog, i),
      initial: {
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "5%",
        opacity: 0.85,
        translateY: 12
        // opacity: 02.8,
      },
      animate: {
        "--backdrop-blur": "6px",
        "--backdrop-opacity": "60%",
        translateY: 0,
        opacity: 1
        // transition: {
        //   delay: 0.25,
        // }
      },
      exit: {
        opacity: 0,
        translateY: -10,
        "--backdrop-blur": "0px",
        "--backdrop-opacity": "0%",
        transition: {
          duration: 0.1
        }
      },
      onClick: (h) => {
        if (h.target?.nodeName?.toUpperCase() === "DIALOG") {
          h.stopPropagation(), l.current?.close();
          return;
        }
      },
      onClose: (h) => {
        h.stopPropagation(), f();
      },
      ...o,
      children: /* @__PURE__ */ d(vp, { forwardProps: !0, children: /* @__PURE__ */ d(A, { className: j(gR, r?.body), children: s && /* @__PURE__ */ d(H, { children: e }) }) })
    }
  );
}
function Af(e, n) {
  return n.map((i) => {
    const r = e.find((o) => o.id === i.id);
    return r && r.type === i.type ? Y(r.hidden ?? !1, i.hidden ?? !1) && Y(r.source, i.source) && Y(r.sourceHandle ?? null, i.sourceHandle ?? null) && Y(r.target, i.target) && Y(r.targetHandle ?? null, i.targetHandle ?? null) && Y(r.zIndex ?? 0, i.zIndex ?? 0) && Y(r.data, i.data) ? r : {
      ...bs(r, ["hidden", "zIndex"]),
      ...i,
      data: {
        ...r.data,
        ...i.data
      }
    } : i;
  });
}
function w0(e, n) {
  return Ic(n) ? Af(e, n) : (n = e, (i) => Af(i, n));
}
function If(e, n) {
  return n.map((i) => {
    const r = e.find((o) => o.id === i.id);
    if (r) {
      const { width: o, height: s } = Ut(r);
      return Y(r.type, i.type) && Y(o, i.initialWidth) && Y(s, i.initialHeight) && Y(r.parentId ?? null, i.parentId ?? null) && Y(r.hidden ?? !1, i.hidden ?? !1) && Y(r.zIndex ?? 0, i.zIndex ?? 0) && Y(r.position, i.position) && Y(r.data, i.data) ? r : {
        ...bs(r, ["measured", "parentId", "hidden", "zIndex"]),
        ...i,
        // Force dimensions from update
        width: i.initialWidth,
        height: i.initialHeight,
        data: {
          ...r.data,
          ...i.data
        }
      };
    }
    return i;
  });
}
function fl(e, n) {
  return Ic(n) ? If(e, n) : (n = e, (i) => If(i, n));
}
function x0(e) {
  const n = [], i = [], r = /* @__PURE__ */ new Map(), o = Ip.from(e.nodes.reduce(
    (c, u) => (r.set(u.id, u), u.parent || c.push({ node: u, parent: null }), c),
    []
  )), s = "", a = (c) => xe(r.get(c), `Node not found: ${c}`);
  let l;
  for (; l = o.dequeue(); ) {
    const { node: c, parent: u } = l, f = ut(c.children, 1) || c.kind == cr.Group;
    if (f)
      for (const v of c.children)
        o.enqueue({ node: a(v), parent: c });
    const h = {
      x: c.position[0],
      y: c.position[1]
    };
    u && (h.x -= u.position[0], h.y -= u.position[1]);
    const m = {
      id: s + c.id,
      draggable: !1,
      selectable: !0,
      focusable: !0,
      deletable: !1,
      position: h,
      zIndex: f ? Ht.Compound : Ht.Element,
      style: {
        width: c.width,
        height: c.height
      },
      initialWidth: c.width,
      initialHeight: c.height,
      ...u && {
        parentId: s + u.id
      }
    }, g = ct.modelRef(c), y = { navigateTo: c.navigateTo ?? null };
    switch (!0) {
      case c.kind === ts.Empty: {
        n.push(
          {
            ...m,
            type: "empty",
            data: {
              column: c.column
            }
          }
        );
        break;
      }
      case (f && !!g): {
        n.push(
          {
            ...m,
            type: "compound",
            data: {
              column: c.column,
              title: c.title,
              color: c.color,
              shape: c.shape,
              style: c.style,
              depth: c.depth ?? 0,
              icon: c.icon ?? "none",
              ports: c.ports,
              fqn: g,
              ...y
            }
          }
        );
        break;
      }
      default:
        me(g, "Element should have either modelRef or deploymentRef"), n.push(
          {
            ...m,
            type: "element",
            data: {
              column: c.column,
              fqn: g,
              title: c.title,
              technology: c.technology,
              description: c.description,
              height: c.height,
              width: c.width,
              color: c.color,
              shape: c.shape,
              icon: c.icon ?? "none",
              ports: c.ports,
              style: c.style,
              ...y
            }
          }
        );
    }
  }
  for (const c of e.edges) {
    const u = c.source, f = c.target, h = s + c.id;
    if (!ut(c.points, 2)) {
      console.error("edge should have at least 2 points", c);
      continue;
    }
    if (!ut(c.relations, 1)) {
      console.error("edge should have at least 1 relation", c);
      continue;
    }
    i.push({
      id: h,
      type: "relationships",
      source: s + u,
      target: s + f,
      sourceHandle: c.sourceHandle,
      targetHandle: c.targetHandle,
      zIndex: Ht.Edge,
      // selectable: selectable,
      // hidden: !visiblePredicate(edge),
      deletable: !1,
      data: {
        relations: c.relations,
        color: c.color ?? "gray",
        label: c.label,
        navigateTo: c.navigateTo ?? null,
        // technology: edge.technology,
        // navigateTo: edge.navigateTo,
        // labelBBox: edge.labelBBox ?? null,
        // points: edge.points,
        // color: edge.color ?? 'gray',
        line: c.line ?? "dashed"
        // dir: edge.dir ?? 'forward',
        // head: edge.head ?? 'normal',
        // tail: edge.tail ?? 'none',
      },
      interactionWidth: 20
    });
  }
  return {
    xynodes: n,
    xyedges: i
  };
}
const Df = (e) => e.find(
  (n) => n.data.column === "subjects" && Ac(n.parentId)
), yR = QE(async ({ input: e, self: n, signal: i }) => {
  const {
    subjectId: r,
    navigateFromNode: o,
    xyflow: s,
    xystore: a,
    update: l
  } = e;
  let {
    nodes: c,
    width: u,
    height: f
  } = a.getState();
  const h = x0(l), p = () => {
    const { nodes: D, edges: L } = a.getState();
    return {
      xynodes: fl(D, h.xynodes),
      xyedges: w0(L, h.xyedges)
    };
  }, m = xe(n._parent);
  let g = s.getZoom();
  const y = Math.max(g, 1), v = zl(l.bounds, u, f, Rn, y, ns), w = h.xynodes.find(
    (D) => D.type !== "empty" && D.data.column === "subjects" && D.data.fqn === r
  ) ?? Df(h.xynodes), x = Df(c), k = o ? c.find((D) => D.id === o) : c.find((D) => D.type !== "empty" && D.data.column !== "subjects" && D.data.fqn === r);
  if (!w || !k || w.type === "empty" || !x || w.data.fqn === x.data.fqn)
    return await s.setViewport(v), p();
  const _ = {
    x: w.position.x + (w.initialWidth ?? 0) / 2,
    y: w.position.y + (w.initialHeight ?? 0) / 2
  }, S = s.getInternalNode(x.id), P = GC(S), C = s.getInternalNode(k.id), T = Ut(C), M = /* @__PURE__ */ new Set();
  return c.forEach((D) => {
    if (D.id !== k.id) {
      if (D.data.column === "subjects") {
        M.add(D.id);
        return;
      }
      D.parentId && (D.parentId === k.id || M.has(D.parentId)) && M.add(D.id);
    }
  }), c = fl(
    c,
    c.flatMap((D) => M.has(D.id) ? [] : D.id !== k.id ? {
      ...D,
      data: {
        ...D.data,
        dimmed: D.data.column === "subjects" ? "immediate" : !0
      }
    } : {
      ...bs(D, ["parentId"]),
      position: {
        x: P.x - T.width / 2,
        y: P.y - T.height / 2
      },
      zIndex: Ht.Max,
      hidden: !1,
      data: {
        ...D.data,
        dimmed: !1
      }
    })
  ), m.send({
    type: "update.xydata",
    xynodes: c,
    xyedges: []
  }), g = Math.min(
    g,
    v.zoom
  ), await W1(175), h.xynodes = h.xynodes.map(Ke.setDimmed(!1)), i.aborted || (await s.setCenter(P.x, P.y, { zoom: g, duration: 350 }), await s.setCenter(_.x, _.y, { zoom: g })), p();
}), b0 = qi({
  actors: {
    layouter: yR
  },
  guards: {
    isReady: ({ context: e }) => e.xyflow !== null && e.xystore !== null && e.layouted !== null
  },
  actions: {
    "xyflow.init": U(({ event: e }) => (je(e, "xyflow.init"), {
      xyflow: e.instance,
      xystore: e.store
    })),
    "update.view": U(({ event: e }) => (je(e, "update.view"), {
      layouted: e.layouted,
      ...x0(e.layouted)
    })),
    "xyflow:updateNodeInternals": ({ context: e }) => {
      me(e.xystore, "xystore is not initialized");
      const { domNode: n, updateNodeInternals: i } = e.xystore.getState(), r = new Set(e.xyedges.flatMap((s) => [s.source, s.target]));
      if (r.size === 0 || !n)
        return;
      const o = /* @__PURE__ */ new Map();
      for (const s of r) {
        const a = n.querySelector(`.react-flow__node[data-id="${s}"]`);
        a && o.set(s, { id: s, nodeElement: a, force: !0 });
      }
      requestAnimationFrame(() => i(o, { triggerFitView: !1 }));
    },
    "xyflow:fitDiagram": ({ context: e }, n) => {
      let {
        duration: i = 450,
        bounds: r
      } = n ?? {};
      const { xyflow: o, xystore: s } = e;
      me(o, "xyflow is not initialized"), me(s, "xystore is not initialized"), r ??= e.layouted?.bounds;
      const a = Math.max(o.getZoom(), 1);
      if (r) {
        const { width: l, height: c } = s.getState(), u = zl(r, l, c, Rn, a, ns);
        requestAnimationFrame(() => o.setViewport(u, i > 0 ? { duration: i } : void 0));
      } else
        requestAnimationFrame(
          () => o.fitView({
            minZoom: Rn,
            maxZoom: a,
            padding: ns,
            ...i > 0 && { duration: i }
          })
        );
    }
  }
}).createMachine({
  id: "relationships-browser",
  context: ({ input: e }) => ({
    ...e,
    closeable: e.closeable ?? !0,
    enableNavigationMenu: e.enableNavigationMenu ?? !0,
    xyflow: null,
    xystore: null,
    layouted: null,
    navigateFromNode: null,
    xynodes: [],
    xyedges: []
  }),
  initial: "initializing",
  on: {
    "xyflow.applyNodeChanges": {
      actions: U({
        xynodes: ({ context: e, event: n }) => Ap(n.changes, e.xynodes)
      })
    },
    "xyflow.applyEdgeChanges": {
      actions: U({
        xyedges: ({ context: e, event: n }) => Mp(n.changes, e.xyedges)
      })
    }
  },
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: "xyflow.init",
          target: "isReady"
        },
        "update.view": {
          actions: "update.view",
          target: "isReady"
        },
        stop: "closed",
        close: "closed"
      }
    },
    isReady: {
      always: [{
        guard: "isReady",
        actions: Be({ type: "fitDiagram", duration: 0 }),
        target: "active"
      }, {
        target: "initializing"
      }]
    },
    active: {
      initial: "idle",
      tags: ["active"],
      states: {
        idle: {},
        layouting: {
          invoke: {
            id: "layouter",
            src: "layouter",
            input: ({ context: e }) => ({
              subjectId: e.subject,
              navigateFromNode: e.navigateFromNode,
              xyflow: xe(e.xyflow),
              xystore: xe(e.xystore),
              update: xe(e.layouted)
            }),
            onDone: {
              target: "idle",
              actions: [
                U({
                  xynodes: ({ event: e }) => e.output.xynodes,
                  xyedges: ({ event: e }) => e.output.xyedges,
                  navigateFromNode: null
                }),
                Be({ type: "fitDiagram" }, { id: "fitDiagram", delay: 80 }),
                Be({ type: "xyflow.updateNodeInternals" }, { delay: 100 }),
                Be({ type: "xyflow.updateNodeInternals" }, { delay: 250 }),
                Be({ type: "xyflow.updateNodeInternals" }, { delay: 500 })
              ]
            }
          },
          on: {
            "update.xydata": {
              actions: U({
                xynodes: ({ event: e }) => e.xynodes,
                xyedges: ({ event: e }) => e.xyedges
              })
            },
            "xyflow.applyEdgeChanges": {
              // actions: log('layouting: ignore xyflow.applyEdgeChanges'),
            },
            "xyflow.applyNodeChanges": {
              // actions: log('layouting: ignore xyflow.applyNodeChanges'),
            }
          }
        }
      },
      on: {
        "xyflow.nodeClick": {
          actions: Te(({ event: e, enqueue: n }) => {
            if ("fqn" in e.node.data) {
              const i = e.node.data.fqn;
              n.raise({
                type: "navigate.to",
                subject: i,
                fromNode: e.node.id
              });
            }
          })
        },
        "navigate.to": {
          actions: [
            U({
              subject: ({ event: e }) => e.subject,
              navigateFromNode: ({ event: e }) => e.fromNode ?? null
            })
          ]
        },
        "xyflow.paneDblClick": {
          actions: "xyflow:fitDiagram"
        },
        "update.view": {
          actions: U({
            layouted: ({ event: e }) => e.layouted
          }),
          target: ".layouting"
        },
        "xyflow.updateNodeInternals": {
          actions: "xyflow:updateNodeInternals"
        },
        fitDiagram: {
          actions: {
            type: "xyflow:fitDiagram",
            params: et("event")
          }
        },
        "xyflow.resized": {
          actions: [
            so("fitDiagram"),
            Be({ type: "fitDiagram" }, { id: "fitDiagram", delay: 300 })
          ]
        },
        "xyflow.init": {
          actions: "xyflow.init"
        },
        "xyflow.unmount": {
          target: "initializing"
        },
        close: "closed"
      }
    },
    closed: {
      id: "closed",
      type: "final"
    }
  },
  exit: U({
    xyflow: null,
    layouted: null,
    xystore: null,
    xyedges: [],
    xynodes: []
  })
}), vR = qi({
  actors: {
    relationshipsBrowserLogic: b0
  }
}).createMachine({
  id: "element-details",
  context: ({ input: e }) => ({
    ...e,
    initiatedFrom: {
      node: e.initiatedFrom?.node ?? null,
      clientRect: e.initiatedFrom?.clientRect ?? null
    }
  }),
  initial: "active",
  states: {
    active: {
      entry: ao("relationshipsBrowserLogic", {
        id: ({ self: e }) => `${e.id}-relationships`,
        input: ({ context: e }) => ({
          subject: e.subject,
          scope: e.currentView,
          enableNavigationMenu: !1,
          closeable: !1
        })
      }),
      exit: [
        Sn(({ self: e }) => `${e.id}-relationships`, { type: "close" }),
        Wi(({ self: e }) => `${e.id}-relationships`)
      ],
      on: {
        "change.subject": {
          actions: U({
            subject: ({ event: e }) => e.subject
          })
        },
        close: "closed"
      }
    },
    closed: {
      id: "closed",
      type: "final"
    }
  }
  // exit: assign({
  //   initialized: false,
  //   xyflow: null,
  //   layouted: null,
  //   xystore: null,
  //   xyedges: [],
  //   xynodes: [],
  // }),
}), wR = qi({
  actions: {
    "xyflow:fitDiagram": ({ context: e }, n) => {
      const {
        duration: i = 450,
        bounds: r
      } = n ?? {}, { xyflow: o } = e;
      if (me(o, "xyflow is not initialized"), r)
        o.fitBounds(r, i > 0 ? { duration: i } : void 0);
      else {
        const s = Math.max(o.getZoom(), 1);
        o.fitView({
          minZoom: Rn,
          maxZoom: s,
          padding: 0.1,
          ...i > 0 && { duration: i }
        });
      }
    }
  },
  guards: {
    "enable: navigate.to": () => !0
  }
}).createMachine({
  initial: "opening",
  context: ({ input: e }) => ({
    ...e,
    initialized: !1,
    xyflow: null
  }),
  states: {
    opening: {
      on: {
        "xyflow.init": {
          actions: U({
            initialized: !0,
            xyflow: ({ event: e }) => e.instance
          }),
          target: "active"
        },
        close: {
          target: "closed"
        }
      }
    },
    active: {
      entry: {
        type: "xyflow:fitDiagram",
        params: { duration: 0 }
      },
      on: {
        // 'xyflow.nodeClick': {
        //   actions: enqueueActions(({ event, enqueue }) => {
        //     if ('fqn' in event.node.data) {
        //       const fqn = event.node.data.fqn
        //       enqueue.assign({
        //         subject: fqn,
        //       })
        //       enqueue.raise({ type: 'fitDiagram' }, { delay: 50 })
        //     }
        //   }),
        // },
        "navigate.to": {
          actions: [
            U({
              edgeId: ({ event: e }) => e.edgeId
            }),
            Be({ type: "fitDiagram" }, { delay: 50 })
          ]
        },
        close: {
          target: "closed"
        }
      },
      exit: U({
        initialized: !1,
        xyflow: null
      })
    },
    closed: {
      type: "final"
    }
  },
  on: {
    fitDiagram: {
      actions: {
        type: "xyflow:fitDiagram",
        params: et("event")
      }
    },
    "xyflow.resized": {
      actions: [
        so("fitDiagram"),
        Be({ type: "fitDiagram" }, { id: "fitDiagram", delay: 200 })
      ]
    }
  }
}), xR = vy(({ sendBack: e }) => {
  const n = La([
    ["Escape", () => e({ type: "close" }), {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", n, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", n, { capture: !0 });
  };
}), bR = qi({
  actors: {
    relationshipDetails: wR,
    elementDetails: vR,
    relationshipsBrowser: b0,
    hotkey: xR
  },
  actions: {
    closeLastOverlay: Te(({ context: e, enqueue: n }) => {
      if (e.overlays.length === 0)
        return;
      const i = yn(e.overlays)?.id;
      i && (n.sendTo(i, { type: "close" }), n.stopChild(i), n.assign({
        overlays: e.overlays.filter((r) => r.id !== i)
      }));
    }),
    closeSpecificOverlay: Te(({ context: e, enqueue: n }, i) => {
      const r = e.overlays.find((o) => o.id === i.actorId)?.id;
      r && (n.sendTo(r, { type: "close" }), n.stopChild(r), n.assign({
        overlays: e.overlays.filter((o) => o.id !== r)
      }));
    }),
    closeAllOverlays: Te(({ context: e, enqueue: n }) => {
      for (const { id: i } of _g(e.overlays))
        n.sendTo(i, { type: "close" }), n.stopChild(i);
      n.assign({ overlays: [] });
    }),
    openElementDetails: Te(({ context: e, enqueue: n, event: i }) => {
      if (je(i, "open.elementDetails"), e.overlays.some((o) => o.type === "elementDetails" && o.subject === i.subject))
        return;
      const r = `elementDetails-${e.seq}`;
      n.spawnChild("elementDetails", {
        id: r,
        input: i
      }), n.assign({
        seq: e.seq + 1,
        overlays: [
          ...e.overlays,
          {
            type: "elementDetails",
            id: r,
            subject: i.subject
          }
        ]
      });
    }),
    openRelationshipDetails: Te(({ context: e, enqueue: n, event: i }) => {
      je(i, "open.relationshipDetails");
      const r = yn(e.overlays);
      if (r?.type === "relationshipDetails") {
        n.sendTo(r.id, {
          type: "navigate.to",
          edgeId: i.edgeId
        });
        return;
      }
      const o = `relationshipDetails-${e.seq}`;
      n.spawnChild("relationshipDetails", {
        id: o,
        input: i
      }), n.assign({
        seq: e.seq + 1,
        overlays: [
          ...e.overlays,
          {
            type: "relationshipDetails",
            id: o
          }
        ]
      });
    }),
    openRelationshipsBrowser: Te(({ context: e, enqueue: n, event: i }) => {
      je(i, "open.relationshipsBrowser");
      const r = yn(e.overlays);
      if (r?.type === "relationshipsBrowser") {
        n.sendTo(r.id, {
          type: "navigate.to",
          subject: i.subject
        });
        return;
      }
      const o = `relationshipsBrowser-${e.seq}`;
      n.spawnChild("relationshipsBrowser", {
        id: o,
        input: i
      }), n.assign({
        seq: e.seq + 1,
        overlays: [
          ...e.overlays,
          {
            type: "relationshipsBrowser",
            id: o,
            subject: i.subject
          }
        ]
      });
    }),
    listenToEsc: ao("hotkey", {
      id: "hotkey"
    }),
    stopListeningToEsc: Wi("hotkey")
  },
  guards: {
    "has overlays?": ({ context: e }) => e.overlays.length > 0,
    "close specific overlay?": ({ context: e, event: n }) => (je(n, "close"), Tc(n.actorId) && e.overlays.some((i) => i.id === n.actorId)),
    "last: is relationshipDetails?": ({ context: e }) => yn(e.overlays)?.type === "relationshipDetails",
    "last: is relationshipsBrowser?": ({ context: e }) => yn(e.overlays)?.type === "relationshipsBrowser"
  }
}).createMachine({
  id: "overlays",
  context: () => ({
    seq: 1,
    overlays: []
  }),
  initial: "idle",
  on: {
    "open.elementDetails": {
      actions: "openElementDetails",
      target: ".active",
      reenter: !1
    },
    "open.relationshipDetails": {
      actions: "openRelationshipDetails",
      target: ".active",
      reenter: !1
    },
    "open.relationshipsBrowser": {
      actions: "openRelationshipsBrowser",
      target: ".active",
      reenter: !1
    }
  },
  states: {
    idle: {},
    active: {
      entry: "listenToEsc",
      exit: "stopListeningToEsc",
      on: {
        close: [
          {
            guard: "close specific overlay?",
            actions: {
              type: "closeSpecificOverlay",
              params: ({ event: e }) => ({ actorId: e.actorId })
            },
            target: "closing"
          },
          {
            actions: "closeLastOverlay",
            target: "closing"
          }
        ],
        "close.all": {
          actions: [
            "closeAllOverlays",
            "stopListeningToEsc"
          ],
          target: "idle"
        }
      }
    },
    closing: {
      always: [
        {
          guard: "has overlays?",
          target: "active"
        },
        {
          actions: "stopListeningToEsc",
          target: "idle"
        }
      ]
    }
  },
  exit: [
    "stopListeningToEsc",
    "closeAllOverlays"
  ]
}), kR = {
  relationship: ru((e) => {
    const { enableNavigateTo: n } = Fe("NavigateTo"), {
      sourceX: i,
      targetY: r,
      data: { navigateTo: o }
    } = e, [s, a, l] = Tp(e), c = de();
    return /* @__PURE__ */ b(su, { ...e, children: [
      /* @__PURE__ */ d(au, { ...e, svgPath: s }),
      /* @__PURE__ */ d(
        Ts,
        {
          edgeProps: e,
          labelPosition: {
            x: a,
            y: l,
            translate: "translate(-50%, 0)"
          },
          style: {
            maxWidth: Math.abs(e.targetX - e.sourceX - 70)
          },
          children: n && o && /* @__PURE__ */ d(
            ou,
            {
              ...e,
              onClick: (u) => {
                u.stopPropagation(), c.navigateTo(o);
              }
            }
          )
        }
      )
    ] });
  })
}, k0 = Le(null);
function S0() {
  return xe(oe(k0), "No RelationshipDetailsActorContext");
}
function SR(e, n = Ze) {
  const i = q(e), r = S0();
  return Gn(r, i, n);
}
function vu() {
  const e = S0(), [, n] = _l();
  return ce(() => ({
    getState: () => e.getSnapshot().context,
    send: e.send,
    navigateTo: (i) => {
      n(() => {
        e.send({
          type: "navigate.to",
          edgeId: i
        });
      });
    },
    fitDiagram: () => {
      n(() => {
        e.send({ type: "fitDiagram" });
      });
    },
    close: () => {
      n(() => {
        e.send({ type: "close" });
      });
    }
  }), [e]);
}
const _R = (e) => {
  const { enableNavigateTo: n } = Fe("NavigateTo"), i = de(), r = [], { navigateTo: o } = e.data;
  return o && n && r.push({
    key: "navigate",
    icon: /* @__PURE__ */ d(kt, {}),
    onClick: (s) => {
      s.stopPropagation(), i.navigateTo(o);
    }
  }), /* @__PURE__ */ d(
    Ms,
    {
      buttons: r,
      ...e
    }
  );
}, Nf = (e) => {
  const n = de();
  return /* @__PURE__ */ d(
    lu,
    {
      ...e,
      onClick: (i) => {
        i.stopPropagation(), n.openElementDetails(e.data.fqn);
      }
    }
  );
}, CR = {
  element: Ct((e) => /* @__PURE__ */ b(Fr, { nodeProps: e, children: [
    /* @__PURE__ */ d(Wr, { ...e }),
    /* @__PURE__ */ d(Jo, { ...e, iconSize: 40 }),
    /* @__PURE__ */ d(Nf, { ...e }),
    /* @__PURE__ */ d(_R, { ...e }),
    /* @__PURE__ */ d(ER, { ...e })
  ] })),
  compound: Ct((e) => /* @__PURE__ */ b(yi, { nodeProps: e, children: [
    /* @__PURE__ */ d(Nf, { ...e }),
    /* @__PURE__ */ d(kr, { ...e }),
    /* @__PURE__ */ d(PR, { ...e })
  ] }))
}, ER = ({ data: { ports: e, height: n } }) => /* @__PURE__ */ b(H, { children: [
  e.in.map((i, r) => /* @__PURE__ */ d(
    Nt,
    {
      id: i,
      type: "target",
      position: Rt.Left,
      style: {
        visibility: "hidden",
        top: `${15 + (r + 1) * ((n - 30) / (e.in.length + 1))}px`
      }
    },
    i
  )),
  e.out.map((i, r) => /* @__PURE__ */ d(
    Nt,
    {
      id: i,
      type: "source",
      position: Rt.Right,
      style: {
        visibility: "hidden",
        top: `${15 + (r + 1) * ((n - 30) / (e.out.length + 1))}px`
      }
    },
    i
  ))
] }), PR = ({ data: e }) => /* @__PURE__ */ b(H, { children: [
  e.ports.in.map((n, i) => /* @__PURE__ */ d(
    Nt,
    {
      id: n,
      type: "target",
      position: Rt.Left,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    n
  )),
  e.ports.out.map((n, i) => /* @__PURE__ */ d(
    Nt,
    {
      id: n,
      type: "source",
      position: Rt.Right,
      style: {
        visibility: "hidden",
        top: `${20 * (i + 1)}px`
      }
    },
    n
  ))
] });
var Rf = "_1rsd9ys1 _1rsd9ys0", TR = "_1rsd9ys2 _1rsd9ys0", Lf = "_1rsd9ys3 _1rsd9ys0", MR = "_1rsd9ys4", AR = "_1rsd9ys5", IR = "_1rsd9ys6", DR = "_1rsd9ys8";
const NR = ({
  edge: e,
  view: n
}) => {
  const i = vu(), r = J(null);
  Fi();
  const o = cs(), s = n.nodes.find((c) => c.id === e.source), a = n.nodes.find((c) => c.id === e.target), l = n.edges.map((c) => {
    const u = n.nodes.find((h) => h.id === c.source), f = n.nodes.find((h) => h.id === c.target);
    return {
      id: c.id,
      source: u,
      target: f,
      label: c.label
    };
  });
  return /* @__PURE__ */ b(
    Ri,
    {
      position: "bottom-start",
      shadow: "md",
      keepMounted: !0,
      withinPortal: !1,
      closeOnClickOutside: !0,
      clickOutsideEvents: ["pointerdown", "mousedown", "click"],
      onOpen: () => {
        setTimeout(() => {
          r.current?.querySelector(`[data-edge-id="${e.id}"]`)?.scrollIntoView({ behavior: "instant", block: "nearest" });
        }, 100);
      },
      children: [
        /* @__PURE__ */ d(Li, { children: /* @__PURE__ */ b(
          le,
          {
            size: "xs",
            variant: "light",
            color: o === "light" ? "dark" : "gray",
            fw: "500",
            style: { padding: "0.25rem 0.75rem" },
            rightSection: /* @__PURE__ */ d(jc, { size: 16 }),
            children: [
              /* @__PURE__ */ d(
                A,
                {
                  className: Rf,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": s.color
                  },
                  children: /* @__PURE__ */ d($, { component: "span", truncate: !0, children: s.title })
                }
              ),
              /* @__PURE__ */ d(wt, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ d(Br, { style: { width: "80%" } }) }),
              /* @__PURE__ */ d(
                A,
                {
                  className: Lf,
                  maw: 160,
                  p: 0,
                  mod: {
                    "likec4-color": a.color
                  },
                  children: /* @__PURE__ */ d($, { component: "span", truncate: !0, children: a.title })
                }
              )
            ]
          }
        ) }),
        /* @__PURE__ */ d($i, { p: 0, miw: 250, maw: 400, children: /* @__PURE__ */ d(jn, { className: DR, scrollbars: "y", type: "never", viewportRef: r, children: /* @__PURE__ */ d(A, { className: IR, p: "xs", maw: 400, children: l.map((c) => /* @__PURE__ */ b(
          "div",
          {
            className: AR,
            "data-selected": c.id === e.id,
            onClick: (u) => {
              u.stopPropagation(), i.navigateTo(c.id);
            },
            children: [
              /* @__PURE__ */ d(
                A,
                {
                  className: Rf,
                  mod: {
                    "edge-id": c.id,
                    "likec4-color": c.source.color
                  },
                  children: /* @__PURE__ */ d($, { component: "span", truncate: !0, children: c.source.title })
                }
              ),
              /* @__PURE__ */ d(A, { className: TR, children: /* @__PURE__ */ d(wt, { color: "dark", variant: "transparent", size: "xs", children: /* @__PURE__ */ d(Br, { style: { width: "80%" } }) }) }),
              /* @__PURE__ */ d(
                A,
                {
                  className: Lf,
                  mod: {
                    "likec4-color": c.target.color
                  },
                  children: /* @__PURE__ */ d($, { component: "span", truncate: !0, children: c.target.title })
                }
              ),
              /* @__PURE__ */ d(A, { className: MR, children: /* @__PURE__ */ d($, { component: "span", truncate: !0, children: c.label || "untitled" }) })
            ]
          },
          c.id
        )) }) }) })
      ]
    }
  );
}, Pn = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 120,
    height: 10,
    minlen: 1
  },
  nodeWidth: 330,
  hodeHeight: 180,
  compoundLabelHeight: 5
}, _0 = {
  compound: 2,
  edge: 3,
  element: 4,
  max: 5
};
function RR() {
  const e = new Gi.graphlib.Graph({
    directed: !0,
    compound: !0
  });
  return e.setGraph({
    ...Pn.dagre,
    rankdir: "LR"
  }), e.setDefaultEdgeLabel(() => ({ ...Pn.edgeLabel })), e.setDefaultNodeLabel(() => ({})), e;
}
const LR = (e = Pn.hodeHeight) => ({
  width: Pn.nodeWidth,
  height: e
}), is = (e) => ({
  id: e.id,
  port: e.type === "compound" ? `${e.id}::port` : e.id
});
function $R(e, n) {
  let i = n.diagramNodes.get(e.id);
  const r = i ?? ve(
    e.ancestors().toArray(),
    Ce((o) => n.diagramNodes.get(o.id)),
    Gt(rn),
    on()
  );
  return {
    fqn: e.id,
    title: i?.title ?? e.title,
    technology: i?.technology ?? e.technology,
    description: i?.description ?? e.description,
    color: i?.color ?? r?.color ?? e.color,
    shape: i?.shape ?? e.shape,
    icon: i?.icon ?? e.icon ?? "none",
    style: i?.style ?? e.$element.style ?? {},
    navigateTo: i?.navigateTo ?? on(e.scopedViews().take(1).toArray())?.id ?? null,
    width: 0,
    height: 0,
    depth: 1,
    ports: {
      in: [],
      out: []
    }
  };
}
function C0(e, n, i) {
  let r = i.xynodes.get(n.id);
  if (r)
    return r;
  const o = i.g, s = ve(
    [...n.ancestors()],
    oS((u) => !Ar(u.id, i.edge.source) && !Ar(u.id, i.edge.target)),
    on(),
    (u) => u ? C0("compound", u, i) : null
  ), l = {
    ...{
      id: n.id,
      draggable: !1,
      selectable: !0,
      focusable: !0,
      deletable: !1,
      position: { x: 0, y: 0 },
      zIndex: _0[e],
      initialWidth: 0,
      initialHeight: 0,
      ...!!s && { parentId: s.id }
    },
    type: e,
    data: $R(n, i)
  };
  i.xynodes.set(n.id, l);
  const c = is(l);
  if (o.setNode(c.id, LR()), l.type === "compound" && (o.setNode(c.port, {
    width: Pn.nodeWidth - Pn.dagre.ranksep,
    height: Pn.compoundLabelHeight
  }), o.setParent(c.port, c.id)), s) {
    const u = is(s).id;
    o.setParent(c.id, u);
  }
  return l;
}
function zR(e) {
  return Gi.layout(e), function n(i, r) {
    const { x: o, y: s, width: a, height: l } = e.node(i), c = {
      position: {
        x: o - Math.round(a / 2),
        y: s - Math.round(l / 2)
      },
      width: a,
      height: l
    };
    if (!r)
      return c;
    const u = n(r).position;
    return {
      position: {
        x: c.position.x - u.x,
        y: c.position.y - u.y
      },
      width: c.width,
      height: c.height
    };
  };
}
function $f(e, n, i) {
  const r = /* @__PURE__ */ new Set([e.source, e.target]), o = e.relations.map((h) => {
    const p = i.relationship(h);
    return r.add(p.source.id), r.add(p.target.id), {
      source: p.source.id,
      target: p.target.id,
      relation: p.$relationship
    };
  }).sort(H1).reverse(), s = new Map(n.nodes.map((h) => [h.id, h])), a = RR(), l = {
    g: a,
    xynodes: /* @__PURE__ */ new Map(),
    edge: e,
    diagramNodes: s,
    xyedges: []
  };
  ve(
    [...r],
    lS(q1),
    _g(),
    NS((h) => {
      const p = i.element(h);
      C0("element", p, l);
    })
  ), o.length === 1 && r.size < 4 && a.setDefaultEdgeLabel(() => ({ width: 250 }));
  for (const { relation: h, ...p } of o) {
    const m = l.xynodes.get(p.source);
    me(m, "source node not found");
    const g = l.xynodes.get(p.target);
    me(g, "target node not found"), m.data.ports.out.push(g.id), g.data.ports.in.push(m.id), a.setEdge(is(m).port, is(g).port);
    const y = {
      id: h.id,
      type: "relationship",
      source: m.id,
      target: g.id,
      sourceHandle: m.id + "_out" + (m.data.ports.out.length - 1),
      targetHandle: g.id + "_in" + (g.data.ports.in.length - 1),
      data: {
        relationId: h.id,
        color: h.color,
        label: h.title ?? null,
        technology: h.technology,
        description: h.description,
        navigateTo: h.navigateTo ?? null,
        line: h.line ?? "dashed"
      },
      zIndex: _0.edge
    };
    l.xyedges.push(y);
  }
  const c = zR(l.g), u = (h, p, m) => ve(
    m,
    Ce((g, y) => ({
      port: h + "_" + p + y,
      topY: c(g).position.y
    })),
    Ho(et("topY")),
    Ce(et("port"))
  ), f = [...l.xynodes.values()].map((h) => {
    const { position: p, width: m, height: g } = c(h.id, h.parentId);
    return h.data.ports.in = u(h.id, "in", h.data.ports.in), h.data.ports.out = u(h.id, "out", h.data.ports.out), h.type === "element" && (h.data.width = m, h.data.height = g), h.position = p, h.initialHeight = g, h.initialWidth = m, h.style = {
      width: m,
      height: g
    }, h;
  });
  return {
    edge: e,
    xyedges: l.xyedges,
    xynodes: f,
    bounds: {
      x: 0,
      y: 0,
      width: a.graph().width ?? 0,
      height: a.graph().height ?? 0
    }
  };
}
function OR(e, n) {
  const i = n.edges.find((o) => o.id === e);
  me(i, `edge ${e} not found in ${n.id}`);
  const r = it(!0);
  return ce(() => $f(
    i,
    n,
    r
  ), [
    i,
    n,
    $f
  ]);
}
function VR({ actorRef: e }) {
  const n = J(null);
  return n.current == null && (n.current = {
    defaultNodes: [],
    defaultEdges: []
  }), /* @__PURE__ */ d(k0.Provider, { value: e, children: /* @__PURE__ */ d($l, { ...n.current, children: /* @__PURE__ */ d(jR, {}) }) });
}
const BR = (e) => ({
  edgeId: e.context.edgeId,
  view: e.context.view,
  initialized: e.context.initialized
}), jR = nt(() => {
  const e = vu(), {
    edgeId: n,
    view: i,
    initialized: r
  } = SR(BR), {
    edge: o,
    xynodes: s,
    xyedges: a,
    bounds: l
  } = OR(n, i), [c, u, f] = A1(s), [h, p, m] = I1(a);
  Nn(() => {
    u(fl(s)), p(w0(a));
  }, [s, a]);
  const [g, y, { history: v, current: w }] = yp(n);
  ie(() => {
    g !== n && y.set(n);
  }, [n]), ie(() => {
  }, [g]);
  const x = w > 0, k = w + 1 < v.length;
  return /* @__PURE__ */ d(ki, { children: /* @__PURE__ */ b(
    Hc,
    {
      id: "relationship-details",
      nodes: c,
      edges: h,
      className: j(r ? "initialized" : "not-initialized"),
      nodeTypes: CR,
      edgeTypes: kR,
      onEdgesChange: m,
      onNodesChange: f,
      fitViewPadding: 0.05,
      onInit: q((_) => {
        e.send({ type: "xyflow.init", instance: _ });
      }),
      onNodeClick: q((_, S) => {
        _.stopPropagation(), e.send({ type: "xyflow.nodeClick", node: S });
      }),
      onEdgeClick: q((_, S) => {
        _.stopPropagation(), e.send({ type: "xyflow.edgeClick", edge: S });
      }),
      onPaneClick: q((_) => {
        _.stopPropagation(), e.send({ type: "xyflow.paneClick" });
      }),
      onViewportResize: q(() => {
        e.send({ type: "xyflow.resized" });
      }),
      nodesDraggable: !1,
      fitView: !1,
      pannable: !0,
      zoomable: !0,
      children: [
        /* @__PURE__ */ d(
          FR,
          {
            edge: o,
            view: i,
            hasStepBack: x,
            hasStepForward: k,
            onStepBack: () => y.back(),
            onStepForward: () => y.forward()
          }
        ),
        /* @__PURE__ */ d(hs, { position: "top-right", children: /* @__PURE__ */ d(
          se,
          {
            variant: "default",
            color: "gray",
            onClick: (_) => {
              _.stopPropagation(), e.close();
            },
            children: /* @__PURE__ */ d(oo, {})
          }
        ) })
      ]
    }
  ) });
}), FR = ({
  edge: e,
  view: n,
  hasStepBack: i,
  hasStepForward: r,
  onStepBack: o,
  onStepForward: s
}) => (vu(), /* @__PURE__ */ d(hs, { position: "top-left", children: /* @__PURE__ */ d(K, { gap: 4, wrap: "nowrap", children: /* @__PURE__ */ b(ht, { mode: "popLayout", children: [
  i && /* @__PURE__ */ d(
    re.div,
    {
      layout: !0,
      initial: { opacity: 0.05, transform: "translateX(-5px)" },
      animate: { opacity: 1, transform: "translateX(0)" },
      exit: {
        opacity: 0.05,
        transform: "translateX(-10px)"
      },
      children: /* @__PURE__ */ d(
        se,
        {
          variant: "default",
          color: "gray",
          onClick: (a) => {
            a.stopPropagation(), o();
          },
          children: /* @__PURE__ */ d(Oc, {})
        }
      )
    },
    "back"
  ),
  r && /* @__PURE__ */ d(
    re.div,
    {
      layout: !0,
      initial: { opacity: 0.05, transform: "translateX(5px)" },
      animate: { opacity: 1, transform: "translateX(0)" },
      exit: {
        opacity: 0,
        transform: "translateX(5px)"
      },
      children: /* @__PURE__ */ d(
        se,
        {
          variant: "default",
          color: "gray",
          onClick: (a) => {
            a.stopPropagation(), s();
          },
          children: /* @__PURE__ */ d(io, {})
        }
      )
    },
    "forward"
  ),
  /* @__PURE__ */ d(K, { gap: "xs", wrap: "nowrap", ml: "sm", children: /* @__PURE__ */ d(NR, { edge: e, view: n }) })
] }) }) }));
function WR({ error: e, resetErrorBoundary: n }) {
  const i = e instanceof Error ? e.message : "Unknown error";
  return /* @__PURE__ */ d(A, { pos: "fixed", top: 0, left: 0, w: "100%", p: 0, style: { zIndex: 1e3 }, children: /* @__PURE__ */ b(
    wp,
    {
      icon: /* @__PURE__ */ d(oo, { style: { width: 16, height: 16 } }),
      styles: {
        icon: {
          alignSelf: "flex-start"
        }
      },
      color: "red",
      title: "Oops, something went wrong",
      p: "xl",
      withCloseButton: !1,
      children: [
        /* @__PURE__ */ d(jn, { maw: "100%", mah: 400, children: /* @__PURE__ */ d(xt, { block: !0, children: i }) }),
        /* @__PURE__ */ d(K, { gap: "xs", mt: "xl", children: /* @__PURE__ */ d(le, { color: "gray", size: "xs", variant: "light", onClick: () => n(), children: "Reset" }) })
      ]
    }
  ) });
}
const HR = (e) => e.context.overlays.map((n) => {
  switch (n.type) {
    case "relationshipsBrowser":
      return e.children[n.id] ? {
        type: n.type,
        actorRef: e.children[n.id]
      } : null;
    case "relationshipDetails":
      return e.children[n.id] ? {
        type: n.type,
        actorRef: e.children[n.id]
      } : null;
    case "elementDetails":
      return e.children[n.id] ? {
        type: n.type,
        actorRef: e.children[n.id]
      } : null;
    default:
      Pt(n);
  }
}).filter(qo), qR = (e, n) => e.length === n.length && e.every((i, r) => i.actorRef === n[r].actorRef), E0 = nt(({ overlaysActorRef: e }) => {
  const n = Wc((c) => c.domNode), i = ce(() => n?.querySelector(".react-flow__renderer") ?? null, [
    n
  ]), r = Gn(e, HR, qR), o = _k() ?? !1, s = r.length > 0;
  ie(() => {
    !i || o || qk(i, {
      opacity: s ? 0.7 : 1,
      filter: s ? "grayscale(1)" : "grayscale(0)",
      transform: s ? "perspective(400px) translateZ(-12px) translateY(3px)" : "translateY(0)"
    }, {
      duration: s ? 0.35 : 0.17
    });
  }, [s, i]);
  const a = (c) => {
    e.send({ type: "close", actorId: c.id });
  }, l = r.map((c) => {
    switch (c.type) {
      case "relationshipsBrowser":
        return /* @__PURE__ */ d(
          Mf,
          {
            onClose: () => a(c.actorRef),
            children: /* @__PURE__ */ d(v0, { actorRef: c.actorRef })
          },
          c.actorRef.sessionId
        );
      case "relationshipDetails":
        return /* @__PURE__ */ d(
          Mf,
          {
            onClose: () => a(c.actorRef),
            children: /* @__PURE__ */ d(VR, { actorRef: c.actorRef })
          },
          c.actorRef.sessionId
        );
      case "elementDetails":
        return /* @__PURE__ */ d(
          pR,
          {
            actorRef: c.actorRef,
            onClose: () => a(c.actorRef)
          },
          c.actorRef.sessionId
        );
      default:
        Pt(c);
    }
  });
  return /* @__PURE__ */ d(Pi.Overlays, { children: /* @__PURE__ */ d(Ly, { FallbackComponent: WR, onReset: () => e.send({ type: "close.all" }), children: /* @__PURE__ */ d(ht, { children: l }) }) });
});
E0.displayName = "Overlays";
var GR = "_1l5vnhl2", UR = "_1l5vnhl3";
function YR({ className: e, ...n }) {
  const i = D1();
  return /* @__PURE__ */ d(Ft, { ...n, className: j(GR, e), children: /* @__PURE__ */ b(K, { gap: "xs", children: [
    /* @__PURE__ */ d(Wg, { style: { width: Re(15), height: Re(15) }, stroke: 2 }),
    /* @__PURE__ */ d($, { fz: "sm", fw: "500", pr: 50, children: "Search" }),
    /* @__PURE__ */ d($, { fw: 700, className: UR, children: i ? " + K" : "Ctrl + K" })
  ] }) });
}
var zf = "_18qwnzc4", XR = "_1dcurnd1", KR = "_1dcurnd2", ZR = "_1dcurnd3", JR = "_1dcurnd4", QR = "_1dcurnd5", e3 = "_1dcurnd6 _18qwnzc3", t3 = "_1dcurnd7", n3 = "_1dcurnd8 _18qwnzc5", i3 = "_1dcurnd9", r3 = "_1dcurnda _18qwnzc6", o3 = "_1dcurndb", s3 = "_1dcurndc";
let mt = [], Zt = 0;
const So = 4;
let No = 0, Os = (e) => {
  let n = [], i = {
    get() {
      return i.lc || i.listen(() => {
      })(), i.value;
    },
    lc: 0,
    listen(r) {
      return i.lc = n.push(r), () => {
        for (let s = Zt + So; s < mt.length; )
          mt[s] === r ? mt.splice(s, So) : s += So;
        let o = n.indexOf(r);
        ~o && (n.splice(o, 1), --i.lc || i.off());
      };
    },
    notify(r, o) {
      No++;
      let s = !mt.length;
      for (let a of n)
        mt.push(
          a,
          i.value,
          r,
          o
        );
      if (s) {
        for (Zt = 0; Zt < mt.length; Zt += So)
          mt[Zt](
            mt[Zt + 1],
            mt[Zt + 2],
            mt[Zt + 3]
          );
        mt.length = 0;
      }
    },
    /* It will be called on last listener unsubscribing.
       We will redefine it in onMount and onStop. */
    off() {
    },
    set(r) {
      let o = i.value;
      o !== r && (i.value = r, i.notify(o));
    },
    subscribe(r) {
      let o = i.listen(r);
      return r(i.value), o;
    },
    value: e
  };
  return i;
};
const a3 = 5, _o = 6, Co = 10;
let l3 = (e, n, i, r) => (e.events = e.events || {}, e.events[i + Co] || (e.events[i + Co] = r((o) => {
  e.events[i].reduceRight((s, a) => (a(s), s), {
    shared: {},
    ...o
  });
})), e.events[i] = e.events[i] || [], e.events[i].push(n), () => {
  let o = e.events[i], s = o.indexOf(n);
  o.splice(s, 1), o.length || (delete e.events[i], e.events[i + Co](), delete e.events[i + Co]);
}), c3 = 1e3, wu = (e, n) => l3(e, (r) => {
  let o = n(r);
  o && e.events[_o].push(o);
}, a3, (r) => {
  let o = e.listen;
  e.listen = (...a) => (!e.lc && !e.active && (e.active = !0, r()), o(...a));
  let s = e.off;
  return e.events[_o] = [], e.off = () => {
    s(), setTimeout(() => {
      if (e.active && !e.lc) {
        e.active = !1;
        for (let a of e.events[_o]) a();
        e.events[_o] = [];
      }
    }, c3);
  }, () => {
    e.listen = o, e.off = s;
  };
}), u3 = (e, n, i) => {
  Array.isArray(e) || (e = [e]);
  let r, o, s = () => {
    if (o === No) return;
    o = No;
    let u = e.map((f) => f.get());
    if (!r || u.some((f, h) => f !== r[h])) {
      r = u;
      let f = n(...u);
      f && f.then && f.t ? f.then((h) => {
        r === u && a.set(h);
      }) : (a.set(f), o = No);
    }
  }, a = Os(void 0), l = a.get;
  a.get = () => (s(), l());
  let c = s;
  return wu(a, () => {
    let u = e.map((f) => f.listen(c));
    return s(), () => {
      for (let f of u) f();
    };
  }), a;
}, P0 = (e, n) => u3(e, n);
function d3(e, n, i) {
  let r = /* @__PURE__ */ new Set([...n, void 0]);
  return e.listen((o, s, a) => {
    r.has(a) && i(o, s, a);
  });
}
let Sa = (e, n) => (i) => {
  e.current !== i && (e.current = i, n());
};
function co(e, { keys: n, deps: i = [e, n] } = {}) {
  let r = J();
  r.current = e.get();
  let o = dt((a) => (Sa(r, a)(e.value), n?.length > 0 ? d3(e, n, Sa(r, a)) : e.listen(Sa(r, a))), i), s = () => r.current;
  return Tv(o, s, s);
}
const Vs = Os("");
function Qn(e) {
  Vs.set(e);
}
function h3() {
  return co(Vs);
}
const f3 = P0(Vs, (e) => {
  const n = e.trim().toLowerCase();
  return n.length > 1 ? n : "";
});
function T0() {
  return Mv(co(f3));
}
const [p3, M0] = Vv("LikeC4Search"), $n = Os(null);
wu(Vs, () => {
  $n.set(null);
});
function m3() {
  return co($n);
}
function rs(e) {
  $n.set(e);
}
function g3() {
  return $n.get() !== null ? ($n.set(null), !0) : !1;
}
const y3 = P0($n, (e) => e !== null);
function v3() {
  return co(y3);
}
function A0() {
  const e = de(), n = M0();
  return q((i, r) => {
    n(() => {
      r ??= $n.get()?.elementFqn, rs(null);
      const o = r ? e.getContext().view.nodes.find((s) => ct.modelRef(s) === r)?.id : void 0;
      if (e.currentView.id === i && o) {
        e.focusNode(o);
        return;
      }
      e.navigateTo(i, o);
    });
  });
}
function lt(e) {
  e.stopPropagation(), e.preventDefault();
}
function I0(e) {
  const n = e.getBoundingClientRect();
  return n.y + Math.floor(n.height / 2);
}
function xu() {
  const e = document.getElementById("likec4searchinput");
  if (e) {
    const n = e.value.length;
    e.focus(), e.setSelectionRange(n, n);
  }
}
const w3 = (e) => e.view.id;
function x3() {
  return pt(w3);
}
var b3 = "_18qwnzc7", k3 = "_18qwnzc4", S3 = "fs466o0 _18qwnzc3", _3 = "fs466o1 _18qwnzc5", C3 = "fs466o2 _18qwnzc6";
const D0 = () => /* @__PURE__ */ d(A, { className: b3, children: "Nothing found" });
function E3() {
  const e = T0();
  let n = [...it(!0).views()];
  return e && (e.startsWith("kind:") ? n = [] : n = n.filter((i) => e.startsWith("#") ? i.tags.some((r) => r.toLocaleLowerCase().includes(e.slice(1))) : (i.title ?? "" + i.$view.description ?? "").toLocaleLowerCase().includes(e))), /* @__PURE__ */ b(
    be,
    {
      renderRoot: (i) => /* @__PURE__ */ d(re.div, { layout: !0, ...i }),
      gap: 8,
      "data-likec4-search-views": !0,
      onKeyDown: (i) => {
        if (i.key === "ArrowLeft" || i.key === "ArrowRight") {
          const r = i.target.getBoundingClientRect().y, o = [...document.querySelectorAll(
            "[data-likec4-search-elements] .likec4-element-button"
          )];
          let s = o.length > 1 ? o.find((a, l, c) => I0(a) > r || l === c.length - 1) : null;
          s ??= on(o), s && (i.stopPropagation(), s.focus());
          return;
        }
      },
      children: [
        n.length === 0 && /* @__PURE__ */ d(D0, {}),
        n.length > 0 && /* @__PURE__ */ d(Bv, { children: /* @__PURE__ */ d(
          Ft,
          {
            "data-likec4-view": !0,
            tabIndex: -1,
            onFocus: (i) => {
              i.stopPropagation(), xu();
            }
          }
        ) }),
        n.map((i, r) => /* @__PURE__ */ d(re.div, { layoutId: `@view${i.id}`, children: /* @__PURE__ */ d(
          pl,
          {
            view: i,
            search: e,
            tabIndex: r === 0 ? 0 : -1
          }
        ) }, i.id))
      ]
    }
  );
}
function pl({ className: e, view: n, loop: i = !1, search: r, ...o }) {
  const s = A0(), a = x3(), l = n.id === a;
  return /* @__PURE__ */ b(
    Ft,
    {
      ...o,
      className: j(k3, S3, e),
      "data-likec4-view": n.id,
      ...l && { "data-disabled": !0 },
      onClick: (c) => {
        c.stopPropagation(), s(n.id);
      },
      onKeyDown: jv({
        siblingSelector: "[data-likec4-view]",
        parentSelector: "[data-likec4-search-views]",
        activateOnFocus: !1,
        loop: i,
        orientation: "vertical",
        onKeyDown: (c) => {
          c.nativeEvent.code === "Space" && (c.stopPropagation(), s(n.id));
        }
      }),
      children: [
        /* @__PURE__ */ d(wt, { variant: "transparent", children: Lp(n) ? /* @__PURE__ */ d(Fc, { stroke: 1.8 }) : /* @__PURE__ */ d(kt, { stroke: 1.8 }) }),
        /* @__PURE__ */ b(A, { style: { flexGrow: 1 }, children: [
          /* @__PURE__ */ b(K, { gap: "xs", wrap: "nowrap", align: "center", children: [
            /* @__PURE__ */ d(gr, { component: "div", highlight: r, className: _3, children: n.title || "untitled" }),
            l && /* @__PURE__ */ d(gi, { size: "xs", fz: 9, radius: "sm", children: "current" })
          ] }),
          /* @__PURE__ */ d(
            gr,
            {
              highlight: n.$view.description ? r : "",
              component: "div",
              className: C3,
              lineClamp: 1,
              children: n.$view.description || "No description"
            }
          )
        ] })
      ]
    }
  );
}
function P3() {
  const e = T0(), n = it(!0), {
    all: i,
    byid: r,
    roots: o
  } = ce(() => {
    const l = e.split(".");
    let c;
    Mc(e) || e === "kind:" ? c = n.elements() : c = G1(n.elements(), (h) => e.startsWith("kind:") ? h.kind.toLocaleLowerCase().startsWith(e.slice(5)) : e.startsWith("#") ? h.tags.some((p) => p.toLocaleLowerCase().includes(e.slice(1))) : (h.title + " " + h.id + " " + (h.description ?? "")).toLocaleLowerCase().includes(e));
    const { all: u, roots: f } = ve(
      c,
      Mr(),
      An,
      Ei((h, p) => {
        const m = {
          label: p.title,
          value: p.id,
          element: p,
          searchTerms: l,
          children: []
        }, g = h.all.findLast((y) => Ar(y.value, m.value));
        return g ? (g.children.push(m), g.children.length > 1 && g.children.sort(Hr)) : h.roots.push(m), h.all.push(m), h;
      }, {
        all: [],
        roots: []
      })
    );
    return {
      all: u,
      byid: IS(u, et("value")),
      roots: f.sort(Hr)
    };
  }, [n, e]), s = Xr({
    multiple: !1
  });
  ie(() => {
    s.collapseAllNodes();
    for (const l of i)
      l.children.length > 0 && s.expand(l.value);
  }, [i]);
  const a = N0();
  return /* @__PURE__ */ b(H, { children: [
    o.length === 0 && /* @__PURE__ */ d(D0, {}),
    /* @__PURE__ */ d(
      Kr,
      {
        "data-likec4-search-elements": !0,
        allowRangeSelection: !1,
        clearSelectionOnOutsideClick: !0,
        selectOnClick: !1,
        tree: s,
        data: o,
        levelOffset: "lg",
        classNames: {
          root: KR,
          node: j(zf, XR),
          label: ZR,
          subtree: JR
        },
        onKeyDownCapture: (l) => {
          const c = l.target, u = c.getAttribute("data-value"), f = !!u && r[u];
          if (f) {
            if (l.key === "ArrowUp") {
              u === o[0]?.value && (lt(l), xu());
              return;
            }
            if (l.key === "ArrowRight") {
              if (f.children.length > 0 && s.expandedState[u] === !1)
                return;
              const m = (l.target.querySelector(".mantine-Tree-label") ?? c).getBoundingClientRect().y, g = [...document.querySelectorAll(
                `[data-likec4-search-views] .${zf}`
              )];
              let y = g.length > 1 ? g.find((v, w, x) => I0(v) > m || w === x.length - 1) : null;
              y ??= on(g), y && (lt(l), y.focus());
              return;
            }
            if (l.key === " " || l.key === "Enter") {
              lt(l), a(f.element);
              return;
            }
          }
        },
        renderNode: T3
      }
    )
  ] });
}
function T3({ node: e, elementProps: n, hasChildren: i, expanded: r }) {
  const { element: o, searchTerms: s } = e, a = CC({
    element: {
      id: o.id,
      title: o.title,
      shape: o.shape,
      icon: o.icon
    },
    className: o3
  }), l = [...o.views()], c = N0(), u = `@tree.${e.value}`;
  return /* @__PURE__ */ b(re.div, { layoutId: u, ...n, children: [
    /* @__PURE__ */ d(
      se,
      {
        variant: "transparent",
        size: 16,
        tabIndex: -1,
        className: j(QR),
        style: {
          visibility: i ? "visible" : "hidden"
        },
        children: /* @__PURE__ */ d(
          io,
          {
            stroke: 3.5,
            style: {
              transition: "transform 150ms ease",
              transform: `rotate(${r ? "90deg" : "0"})`,
              width: "100%"
            }
          }
        )
      }
    ),
    /* @__PURE__ */ b(
      Ft,
      {
        component: re.button,
        layout: !0,
        tabIndex: -1,
        className: j(e3, "likec4-element-button"),
        ...l.length > 0 && {
          onClick: (f) => {
            (!i || r) && (f.stopPropagation(), c(o));
          }
        },
        children: [
          a,
          /* @__PURE__ */ b(A, { style: { flexGrow: 1 }, children: [
            /* @__PURE__ */ b(K, { gap: "xs", wrap: "nowrap", align: "center", className: t3, children: [
              /* @__PURE__ */ d(gr, { component: "div", highlight: s, className: n3, children: e.label }),
              /* @__PURE__ */ d(vt, { label: o.id, withinPortal: !1, fz: "xs", disabled: !o.id.includes("."), children: /* @__PURE__ */ d(gr, { component: "div", highlight: s, className: i3, children: Vl(o.id) }) })
            ] }),
            /* @__PURE__ */ d(gr, { component: "div", highlight: s, className: r3, lineClamp: 1, children: o.description || "No description" })
          ] }),
          /* @__PURE__ */ d($, { component: "div", className: s3, children: l.length === 0 ? "No views" : /* @__PURE__ */ b(H, { children: [
            l.length,
            " view",
            l.length > 1 ? "s" : ""
          ] }) })
        ]
      }
    )
  ] }, u);
}
function N0() {
  const e = A0();
  return q((n) => {
    const i = [...n.views()];
    if (i.length === 0)
      return;
    const r = Vr(i);
    if (r) {
      e(r.id, n.id);
      return;
    }
    const [o, s] = _c(i, (a) => a.viewOf?.id === n.id);
    rs({
      elementFqn: n.id,
      scoped: o,
      others: s
    });
  });
}
var Of = "_18qwnzc4", M3 = "arnu170", ml = "arnu171", A3 = "arnu172", I3 = "arnu173", D3 = "arnu174", Vf = "arnu175", Bf = "arnu176";
function jf(e) {
  return e.match(/^(k|ki|kin|kind|kind:)$/) != null;
}
const _a = ["#", "kind:"];
function N3() {
  const e = v3(), n = it(!0), i = Fv({
    scrollBehavior: "smooth"
  }), { ref: r, focused: o } = Wv(), s = h3(), a = i_(s), l = Hv(), [c] = mp(s === "" && !l, Tc(a) ? 400 : 1e3);
  xp(
    "keydown",
    (h) => {
      try {
        !o && !e && (h.key === "Backspace" || h.key.startsWith("Arrow") || h.key.match(/^\p{L}$/u)) && xu();
      } catch (p) {
        console.warn(p);
      }
    }
  );
  let u = [], f = !1;
  switch (!0) {
    case (s === "" && (c || _a.includes(a ?? ""))): {
      u = _a.map((h) => /* @__PURE__ */ b(Ys, { value: h, children: [
        /* @__PURE__ */ d($, { component: "span", opacity: 0.5, mr: 4, fz: "sm", children: "Search by" }),
        h
      ] }, h));
      break;
    }
    case s.startsWith("#"): {
      const h = s.toLocaleLowerCase().slice(1), p = n.allTags().filter((m) => m.toLocaleLowerCase().includes(h)).sort(
        Ol
      );
      f = Vr(p)?.toLocaleLowerCase() === h, p.length === 0 ? u = [
        /* @__PURE__ */ d($u, { children: "No tags found" }, "empty-tags")
      ] : u = p.map((m) => /* @__PURE__ */ b(Ys, { value: `#${m}`, children: [
        /* @__PURE__ */ d($, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "#" }),
        m
      ] }, m));
      break;
    }
    case s.startsWith("kind:"):
    case jf(s): {
      const h = s.length > 5 ? s.slice(5).toLocaleLowerCase() : "";
      let p = Ec(n.$model.specification.elements);
      h && (p = p.filter((m) => m.toLocaleLowerCase().includes(h)), f = Vr(p)?.toLocaleLowerCase() === h), p.length === 0 ? u = [
        /* @__PURE__ */ d($u, { children: "No kinds found" }, "empty-kinds")
      ] : u = p.map((m) => /* @__PURE__ */ b(Ys, { value: `kind:${m}`, children: [
        /* @__PURE__ */ d($, { component: "span", opacity: 0.5, mr: 1, fz: "sm", children: "kind:" }),
        m
      ] }, m));
      break;
    }
  }
  return /* @__PURE__ */ b(
    qv,
    {
      onOptionSubmit: (h) => {
        Qn(h), i.resetSelectedOption(), _a.includes(h) || (i.closeDropdown(), setTimeout(() => {
          document.querySelector(`.${ml} .${Of}`)?.focus();
        }, 50));
      },
      width: "max-content",
      position: "bottom-start",
      shadow: "md",
      offset: {
        mainAxis: 4,
        crossAxis: 50
      },
      store: i,
      withinPortal: !1,
      children: [
        /* @__PURE__ */ d(Gv, { children: /* @__PURE__ */ d(
          Uv,
          {
            ref: r,
            id: "likec4searchinput",
            placeholder: "Search by title, description or start with # or kind:",
            tabIndex: 0,
            classNames: {
              input: A3
            },
            size: "xl",
            value: s,
            leftSection: /* @__PURE__ */ d(Wg, { style: { width: Re(20) }, stroke: 2 }),
            onChange: (h) => {
              Qn(h.currentTarget.value), i.openDropdown(), i.updateSelectedOptionIndex();
            },
            onClick: () => i.openDropdown(),
            onFocus: () => i.openDropdown(),
            onBlur: () => i.closeDropdown(),
            onKeyDownCapture: (h) => {
              if (h.key === "Tab") {
                switch (!0) {
                  case i.getSelectedOptionIndex() >= 0:
                    return i.clickSelectedOption(), lt(h);
                  case u.length === 1:
                    return i.selectFirstOption() && i.clickSelectedOption(), lt(h);
                  case jf(s):
                    return Qn("kind:"), lt(h);
                }
                return;
              }
              if (h.key === "Backspace" && i.dropdownOpened) {
                if (s === "kind:")
                  return Qn(""), i.resetSelectedOption(), lt(h);
                if (s.startsWith("kind:") && f)
                  return Qn("kind:"), i.resetSelectedOption(), lt(h);
                if (s.startsWith("#") && f)
                  return Qn("#"), i.resetSelectedOption(), lt(h);
              }
              if (h.key === "Escape" && i.dropdownOpened && u.length > 0) {
                lt(h), i.closeDropdown();
                return;
              }
              if (h.key === "ArrowDown" && (!i.dropdownOpened || u.length === 0 || f || // reached the last option and the search is empty
              s === "" && i.getSelectedOptionIndex() === u.length - 1)) {
                i.closeDropdown(), lt(h), document.querySelector(`.${ml} .${Of}`)?.focus();
                return;
              }
            }
          }
        ) }),
        /* @__PURE__ */ d(Yv, { hidden: u.length === 0, style: { minWidth: 300 }, children: /* @__PURE__ */ d(Xv, { children: /* @__PURE__ */ d(jn, { mah: "min(322px, calc(100cqh - 50px))", type: "scroll", children: u }) }) })
      ]
    }
  );
}
function R3() {
  const [e, n] = bp(!1);
  Kv([
    ["mod+k", () => n.toggle(), {
      preventDefault: !0
    }],
    ["mod+f", () => n.toggle(), {
      preventDefault: !0
    }]
  ]);
  const i = J(null), r = q((a) => {
    i.current = a ?? null, n.close();
  }), o = q(() => {
    i.current && (i.current(), i.current = null);
  }), { portalProps: s } = Fi();
  return /* @__PURE__ */ b(p3, { value: r, children: [
    /* @__PURE__ */ d(
      YR,
      {
        onClick: (a) => {
          a.stopPropagation(), n.toggle();
        }
      }
    ),
    /* @__PURE__ */ d(Zv, { ...s, children: /* @__PURE__ */ d(vp, { enabled: e, children: /* @__PURE__ */ d(ht, { onExitComplete: o, children: e && /* @__PURE__ */ b(H, { children: [
      /* @__PURE__ */ d(
        re.div,
        {
          className: M3,
          initial: { opacity: 0.7 },
          animate: {
            opacity: 1,
            transition: {
              duration: 0.1
            }
          },
          exit: {
            opacity: 0,
            transition: {
              duration: 0.075
            }
          }
        },
        "backdrop"
      ),
      /* @__PURE__ */ d(L3, {}, "overlay")
    ] }) }) }) })
  ] });
}
function L3() {
  const e = M0(), n = kp();
  return xp(
    "keydown",
    (i) => {
      if (i.key === "Escape") {
        lt(i), g3() || e();
        return;
      }
    }
  ), /* @__PURE__ */ b(
    re.div,
    {
      ref: n,
      className: ml,
      animate: {
        opacity: 1,
        scale: 1,
        translateY: 0
      },
      exit: {
        opacity: 0,
        scale: 0.9,
        transition: {
          duration: 0.1
        }
      },
      children: [
        /* @__PURE__ */ b(K, { wrap: "nowrap", children: [
          /* @__PURE__ */ d(A, { flex: 1, px: "sm", children: /* @__PURE__ */ d(N3, {}) }),
          /* @__PURE__ */ d(A, { flex: "0 0 auto", children: /* @__PURE__ */ d(
            se,
            {
              size: "lg",
              variant: "default",
              onClick: (i) => {
                i.stopPropagation(), e();
              },
              children: /* @__PURE__ */ d(oo, {})
            }
          ) })
        ] }),
        /* @__PURE__ */ b(zu, { children: [
          /* @__PURE__ */ d(uo, { span: 6, children: /* @__PURE__ */ d(mi, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Elements" }) }),
          /* @__PURE__ */ d(uo, { span: 6, children: /* @__PURE__ */ d(mi, { component: "div", order: 6, c: "dimmed", pl: "sm", children: "Views" }) })
        ] }),
        /* @__PURE__ */ b(
          zu,
          {
            style: {
              containerName: "likec4-search-elements",
              containerType: "size",
              overflow: "hidden",
              flexGrow: 1
            },
            children: [
              /* @__PURE__ */ d(uo, { span: 6, children: /* @__PURE__ */ d(
                Qe,
                {
                  type: "hover",
                  className: Bf,
                  pr: "xs",
                  scrollbars: "y",
                  children: /* @__PURE__ */ d(ht, { children: /* @__PURE__ */ d(ki, { id: "likec4-search-elements", children: /* @__PURE__ */ d(P3, {}) }) })
                }
              ) }),
              /* @__PURE__ */ d(uo, { span: 6, children: /* @__PURE__ */ d(
                Qe,
                {
                  type: "hover",
                  className: Bf,
                  pr: "xs",
                  scrollbars: "y",
                  children: /* @__PURE__ */ d(ht, { children: /* @__PURE__ */ d(ki, { id: "likec4-search-views", children: /* @__PURE__ */ d(E3, {}) }) })
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ d(A, {}),
        /* @__PURE__ */ d($3, {})
      ]
    }
  );
}
function $3() {
  const e = m3(), n = kp(!!e);
  return Jv({
    opened: !!e
  }), /* @__PURE__ */ d(ht, { children: /* @__PURE__ */ d(ki, { id: "likec4-search-pickview", children: e && /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(
      re.div,
      {
        className: I3,
        onClick: (i) => {
          i.stopPropagation(), rs(null);
        }
      },
      "backdrop"
    ),
    /* @__PURE__ */ b(
      re.div,
      {
        initial: {
          opacity: 0,
          scale: 0.95,
          originY: 0,
          translateX: "-50%",
          translateY: -20
        },
        animate: {
          opacity: 1,
          scale: 1,
          translateY: 0
        },
        exit: {
          opacity: 0,
          scale: 0.98,
          translateY: -20,
          transition: {
            duration: 0.1
          }
        },
        className: D3,
        "data-likec4-search-views": !0,
        ref: n,
        children: [
          /* @__PURE__ */ b(K, { px: "sm", py: "md", justify: "space-between", children: [
            /* @__PURE__ */ d(mi, { order: 2, lh: 1, children: "Select view" }),
            /* @__PURE__ */ d(
              se,
              {
                size: "md",
                variant: "default",
                onClick: (i) => {
                  i.stopPropagation(), rs(null);
                },
                children: /* @__PURE__ */ d(oo, {})
              }
            )
          ] }),
          /* @__PURE__ */ b(jn, { mah: "calc(100vh - 8rem - 50px)", type: "never", children: [
            e.scoped.length > 0 && /* @__PURE__ */ b(be, { gap: "sm", px: "sm", className: Vf, children: [
              /* @__PURE__ */ d(mi, { order: 6, c: "dimmed", children: "scoped views of the element" }),
              e.scoped.map((i, r) => /* @__PURE__ */ d(
                pl,
                {
                  view: i,
                  search: "",
                  loop: !0,
                  mod: {
                    autofocus: r === 0
                  }
                },
                i.id
              ))
            ] }),
            e.others.length > 0 && /* @__PURE__ */ b(be, { gap: "sm", px: "sm", className: Vf, children: [
              /* @__PURE__ */ d(mi, { order: 6, c: "dimmed", children: "views including this element" }),
              e.others.map((i, r) => /* @__PURE__ */ d(
                pl,
                {
                  view: i,
                  search: "",
                  loop: !0,
                  mod: {
                    autofocus: r === 0 && e.scoped.length === 0
                  }
                },
                i.id
              ))
            ] })
          ] })
        ]
      },
      "pickview"
    )
  ] }) }) });
}
const Di = vt.withProps({
  color: "dark",
  fz: "xs",
  position: "right",
  openDelay: 600,
  closeDelay: 120,
  label: "",
  children: null,
  offset: 8,
  withinPortal: !1
}), Dt = se.withProps({
  classNames: {
    root: "action-icon"
  },
  variant: "default",
  color: "gray"
});
var z3 = "_1gr801g0", O3 = "_1gr801g1", V3 = "_1gr801g2", Eo = "_1gr801g4", B3 = "_1gr801g5", j3 = "_1gr801g6", F3 = "_1gr801g7";
const W3 = (e) => ({
  viewId: e.view.id,
  autoLayout: e.view.autoLayout
}), H3 = (e) => {
  const {
    onChange: n
  } = ji(), i = de(), [r, o] = ge(null), [s, a] = ge({}), {
    autoLayout: l,
    viewId: c
  } = pt(W3), { ref: u, hovered: f } = Qv(), h = (g) => (y) => {
    s[g] = y, a(s);
  }, p = (g) => (y) => {
    y.stopPropagation(), n?.({
      change: {
        op: "change-autolayout",
        layout: {
          ...l,
          direction: g
        }
      }
    });
  }, m = (g, y) => {
    i.fitDiagram(), n?.({
      change: {
        op: "change-autolayout",
        layout: {
          ...l,
          nodeSep: g,
          rankSep: y
        }
      }
    });
  };
  return /* @__PURE__ */ b(
    Ri,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...e,
      children: [
        /* @__PURE__ */ d(Li, { children: /* @__PURE__ */ d(Di, { label: "Change Auto Layout", children: /* @__PURE__ */ d(Dt, { children: /* @__PURE__ */ d(Fg, {}) }) }) }),
        /* @__PURE__ */ d($i, { className: "likec4-top-left-panel", p: 8, pt: 6, opacity: f ? 0.6 : 1, children: /* @__PURE__ */ b(A, { pos: "relative", ref: o, children: [
          /* @__PURE__ */ d(
            e1,
            {
              target: s[l.direction],
              parent: r,
              className: B3
            }
          ),
          /* @__PURE__ */ d(A, { mb: 10, children: /* @__PURE__ */ d($, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Auto layout:" }) }),
          /* @__PURE__ */ b(Cr, { gap: 2, wrap: "wrap", justify: "stretch", maw: 160, children: [
            /* @__PURE__ */ d(Ft, { className: Eo, ref: h("TB"), onClick: p("TB"), children: "Top-Bottom" }),
            /* @__PURE__ */ d(Ft, { className: Eo, ref: h("BT"), onClick: p("BT"), children: "Bottom-Top" }),
            /* @__PURE__ */ d(Ft, { className: Eo, ref: h("LR"), onClick: p("LR"), children: "Left-Right" }),
            /* @__PURE__ */ d(Ft, { className: Eo, ref: h("RL"), onClick: p("RL"), children: "Right-Left" })
          ] }),
          /* @__PURE__ */ d(A, { my: 10, children: /* @__PURE__ */ d($, { inline: !0, fz: "xs", c: "dimmed", fw: 500, children: "Spacing:" }) }),
          /* @__PURE__ */ d(
            q3,
            {
              ref: u,
              isVertical: l.direction === "TB" || l.direction === "BT",
              nodeSep: l.nodeSep,
              rankSep: l.rankSep,
              onChange: m
            },
            c
          )
        ] }) })
      ]
    }
  );
}, ei = 400, q3 = an(({
  isVertical: e,
  nodeSep: n,
  rankSep: i,
  onChange: r
}, o) => {
  e || ([n, i] = [i, n]);
  const s = ks(
    ({ x: p, y: m }) => {
      e || ([p, m] = [m, p]), r(Math.round(p * ei), Math.round(m * ei));
    },
    [r, e],
    250,
    2e3
  ), [a, l] = t1({
    defaultValue: r1({
      x: (n ?? 100) / ei,
      y: (i ?? 120) / ei
    }),
    onChange: s
  }), { ref: c } = n1(l);
  let u = Math.round(a.x * ei), f = Math.round(a.y * ei);
  e || ([u, f] = [f, u]);
  const h = i1(c, o);
  return /* @__PURE__ */ b(A, { ref: h, className: j3, pt: "100%", children: [
    /* @__PURE__ */ d(
      A,
      {
        className: F3,
        style: {
          left: `${a.x * 100}%`,
          top: `${a.y * 100}%`
        }
      }
    ),
    /* @__PURE__ */ d(A, { pos: "absolute", left: 2, bottom: 2, children: /* @__PURE__ */ b($, { component: "div", fz: 8, c: "dimmed", fw: 500, children: [
      f,
      ", ",
      u
    ] }) })
  ] });
}), G3 = (e) => /* @__PURE__ */ b(
  Sp,
  {
    position: "right-start",
    openDelay: 200,
    closeDelay: 100,
    ...e,
    children: [
      /* @__PURE__ */ d(_p, { children: /* @__PURE__ */ b(Dt, { c: "orange", children: [
        /* @__PURE__ */ d(o1, { color: MC.colors.orange.lightHover, backgroundOpacity: 1 }),
        /* @__PURE__ */ d(zc, {})
      ] }) }),
      /* @__PURE__ */ d(Cp, { p: "0", children: /* @__PURE__ */ b(
        wp,
        {
          color: "orange",
          withBorder: !1,
          withCloseButton: !1,
          title: "Manual layout issues",
          children: [
            /* @__PURE__ */ b($, { mt: 2, size: "sm", lh: "xs", children: [
              "View contains new elements or their sizes have changed,",
              /* @__PURE__ */ d("br", {}),
              "last manual layout can not be applied."
            ] }),
            /* @__PURE__ */ b($, { mt: "xs", size: "sm", lh: "xs", children: [
              "Update view predicates or remove ",
              /* @__PURE__ */ d(xt, { children: "@likec4-generated" })
            ] })
          ]
        }
      ) })
    ]
  }
), Ot = ({
  label: e,
  icon: n,
  onClick: i
}) => /* @__PURE__ */ d(Di, { label: e, withinPortal: !1, position: "top", children: /* @__PURE__ */ d(Dt, { onClick: i, children: n }) }), U3 = (e) => {
  const n = de();
  return /* @__PURE__ */ b(
    Ri,
    {
      position: "right-start",
      clickOutsideEvents: [
        "pointerdown"
      ],
      radius: "xs",
      shadow: "lg",
      offset: {
        mainAxis: 10
      },
      ...e,
      children: [
        /* @__PURE__ */ d(Li, { children: /* @__PURE__ */ d(Di, { label: "Manual layouting tools", withinPortal: !1, position: "top-end", children: /* @__PURE__ */ d(Dt, { children: /* @__PURE__ */ d(oC, {}) }) }) }),
        /* @__PURE__ */ d($i, { p: 0, children: /* @__PURE__ */ b(K, { gap: "xs", children: [
          /* @__PURE__ */ b(Ml, { pos: "relative", children: [
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align in columns",
                icon: /* @__PURE__ */ d(Ch, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Column");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align left",
                icon: /* @__PURE__ */ d(tC, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Left");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align center",
                icon: /* @__PURE__ */ d(eC, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Center");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align right",
                icon: /* @__PURE__ */ d(iC, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Right");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align in rows",
                icon: /* @__PURE__ */ d(Ch, { style: { transform: "rotate(90deg)" } }),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Row");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align top",
                icon: /* @__PURE__ */ d(rC, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Top");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align middle",
                icon: /* @__PURE__ */ d(nC, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Middle");
                }
              }
            ),
            /* @__PURE__ */ d(
              Ot,
              {
                label: "Align bottom",
                icon: /* @__PURE__ */ d(Q_, {}),
                onClick: (i) => {
                  i.stopPropagation(), n.align("Bottom");
                }
              }
            )
          ] }),
          /* @__PURE__ */ d(
            Ot,
            {
              label: "Reset all control points",
              icon: /* @__PURE__ */ d(fC, {}),
              onClick: (i) => {
                i.stopPropagation(), n.resetEdgeControlPoints();
              }
            }
          )
        ] }) })
      ]
    }
  );
}, Y3 = () => {
  const e = de(), {
    hasStepBack: n,
    hasStepForward: i
  } = pt((r) => ({
    hasStepBack: r.navigationHistory.currentIndex > 0,
    hasStepForward: r.navigationHistory.currentIndex < r.navigationHistory.history.length - 1
  }));
  return /* @__PURE__ */ b(ht, { children: [
    n && /* @__PURE__ */ d(
      re.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(-10px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0.05,
          transform: "translateX(-10px)"
        },
        children: /* @__PURE__ */ d(
          Dt,
          {
            onClick: (r) => {
              r.stopPropagation(), e.navigate("back");
            },
            children: /* @__PURE__ */ d(Oc, {})
          }
        )
      },
      "back"
    ),
    i && /* @__PURE__ */ d(
      re.div,
      {
        layout: !0,
        initial: { opacity: 0.05, transform: "translateX(10px)" },
        animate: { opacity: 1, transform: "translateX(0)" },
        exit: {
          opacity: 0,
          transform: "translateX(10px)"
        },
        children: /* @__PURE__ */ d(
          Dt,
          {
            onClick: (r) => {
              r.stopPropagation(), e.navigate("forward");
            },
            children: /* @__PURE__ */ d(io, {})
          }
        )
      },
      "forward"
    )
  ] });
}, X3 = (e) => ({
  visible: e.features.enableReadOnly !== !0,
  isReadOnly: e.toggledFeatures.enableReadOnly ?? e.features.enableReadOnly
}), K3 = () => {
  const { visible: e, isReadOnly: n } = pt(X3), i = de();
  return e ? /* @__PURE__ */ d(Di, { label: n ? "Enable editing" : "Disable editing", children: /* @__PURE__ */ d(
    Dt,
    {
      onClick: (r) => {
        r.stopPropagation(), i.toggleFeature("ReadOnly");
      },
      children: n ? /* @__PURE__ */ d(aC, {}) : /* @__PURE__ */ d(sC, {})
    }
  ) }) : null;
}, Z3 = nt(() => {
  const { viewId: e, hasLayoutDrift: n, viewportChanged: i } = pt((m) => ({
    viewId: m.view.id,
    hasLayoutDrift: m.view.hasLayoutDrift ?? !1,
    viewportChanged: m.viewportChangedManually
  })), r = de(), {
    onOpenSource: o,
    onBurgerMenuClick: s
  } = ji(), {
    enableControls: a,
    enableSearch: l,
    enableNavigationButtons: c,
    enableReadOnly: u,
    enableVscode: f
  } = Lc(), h = !u, p = Fi();
  return /* @__PURE__ */ b(
    K,
    {
      align: "flex-start",
      className: j(
        "react-flow__panel",
        O3,
        "likec4-top-left-panel"
      ),
      gap: "xs",
      onClick: Ee,
      children: [
        /* @__PURE__ */ b(be, { align: "flex-start", gap: "xs", children: [
          /* @__PURE__ */ d(ki, { children: /* @__PURE__ */ b(
            K,
            {
              className: j(z3, "likec4-navigation-webview"),
              gap: "xs",
              children: [
                s && /* @__PURE__ */ d(
                  Dt,
                  {
                    onClick: (m) => {
                      m.stopPropagation(), s();
                    },
                    children: /* @__PURE__ */ d(lC, {})
                  }
                ),
                c && /* @__PURE__ */ d(Y3, {})
              ]
            }
          ) }),
          /* @__PURE__ */ b(Ml, { className: V3, orientation: "vertical", children: [
            f && /* @__PURE__ */ d(Di, { label: "Open source", ...p, children: /* @__PURE__ */ d(
              Dt,
              {
                onClick: (m) => {
                  m.stopPropagation(), o?.({ view: e });
                },
                children: /* @__PURE__ */ d(ro, { stroke: 1.5 })
              }
            ) }),
            a && /* @__PURE__ */ d(K3, {}),
            a && n && /* @__PURE__ */ d(G3, { ...p }),
            a && h && /* @__PURE__ */ b(H, { children: [
              /* @__PURE__ */ d(H3, { ...p }),
              /* @__PURE__ */ d(U3, { ...p })
            ] }),
            a && /* @__PURE__ */ d(Di, { label: i ? "Center camera" : "Camera is centered", ...p, children: /* @__PURE__ */ d(
              Dt,
              {
                onClick: (m) => {
                  m.stopPropagation(), r.fitDiagram();
                },
                children: /* @__PURE__ */ d(K_, {})
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ d(K, { children: l && /* @__PURE__ */ d(R3, {}) })
      ]
    }
  );
});
var J3 = "_1qhzp5e0", Q3 = "_1qhzp5e1", eL = "_1qhzp5e2", tL = "_1qhzp5e3";
function nL() {
  const { id: e, title: n, description: i, links: r, isNotActiveWalkthrough: o } = pt((c) => ({
    id: c.view.id,
    title: c.view.title ?? "untitled",
    description: c.view.description,
    links: c.view.links,
    isNotActiveWalkthrough: c.activeWalkthrough === null
  })), [s, a] = Dl({
    key: "diagram-title-webview-collapsed",
    defaultValue: !1
  }), l = () => a((c) => !c);
  return /* @__PURE__ */ d(ht, { mode: "wait", children: o && /* @__PURE__ */ d(
    re.div,
    {
      initial: { opacity: 0.05, scale: 0.7 },
      animate: { opacity: 1, scale: 1 },
      exit: {
        opacity: 0.05,
        scale: 0.6
      },
      className: j("react-flow__panel", J3),
      style: {
        transformOrigin: "left center"
      },
      children: /* @__PURE__ */ b(
        Pr,
        {
          radius: "sm",
          className: Q3,
          withBorder: !s,
          p: s ? "sm" : "md",
          onDoubleClick: (c) => c.stopPropagation(),
          children: [
            s && /* @__PURE__ */ d(Ou, { children: /* @__PURE__ */ d(
              le,
              {
                fullWidth: !0,
                justify: "stretch",
                size: "md",
                radius: "0",
                variant: "subtle",
                color: "gray",
                onClick: l,
                fw: 500,
                fz: "sm",
                tabIndex: -1,
                children: n
              }
            ) }),
            !s && /* @__PURE__ */ b(H, { children: [
              /* @__PURE__ */ d(Ou, { mb: "xs", children: /* @__PURE__ */ d(
                le,
                {
                  fullWidth: !0,
                  size: "xs",
                  h: "sm",
                  py: 2,
                  radius: "0",
                  variant: "subtle",
                  color: "gray",
                  onClick: l,
                  tabIndex: -1,
                  children: /* @__PURE__ */ d(cC, { size: 11, opacity: 0.7 })
                }
              ) }),
              /* @__PURE__ */ b(K, { justify: "stretch", wrap: "nowrap", mb: "sm", children: [
                /* @__PURE__ */ d(
                  $,
                  {
                    component: "div",
                    flex: "1",
                    size: "md",
                    fw: 500,
                    lh: 1.1,
                    className: eL,
                    children: n
                  }
                ),
                /* @__PURE__ */ b(
                  $,
                  {
                    hidden: s,
                    component: "div",
                    flex: "0 0 auto",
                    inline: !0,
                    size: "xs",
                    fz: 9,
                    fw: 500,
                    c: "dimmed",
                    style: {
                      userSelect: "all"
                    },
                    children: [
                      /* @__PURE__ */ b("span", { style: { userSelect: "none" }, children: [
                        "id:",
                        " "
                      ] }),
                      e
                    ]
                  }
                )
              ] }),
              i && /* @__PURE__ */ d(
                s1,
                {
                  maxHeight: 42,
                  showLabel: /* @__PURE__ */ d(le, { color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "show more" }),
                  hideLabel: /* @__PURE__ */ d(le, { color: "gray", variant: "light", fz: "10", size: "compact-xs", tabIndex: -1, children: "hide" }),
                  children: /* @__PURE__ */ d(
                    $,
                    {
                      component: "div",
                      size: "sm",
                      className: tL,
                      children: i || "no description"
                    }
                  )
                }
              ),
              !i && /* @__PURE__ */ d(
                $,
                {
                  component: "div",
                  size: "xs",
                  c: "dimmed",
                  children: "no description"
                }
              ),
              r && /* @__PURE__ */ d(
                be,
                {
                  mt: "xs",
                  gap: 4,
                  justify: "stretch",
                  align: "stretch",
                  children: r.map((c) => /* @__PURE__ */ d(cu, { value: c }, c.url))
                }
              )
            ] })
          ]
        }
      )
    },
    e
  ) });
}
var Ca = "ee8it60", iL = "ee8it61", rL = "ee8it62", oL = "ee8it63", sL = "ee8it65";
const aL = ({ value: e }) => {
  const {
    title: n,
    color: i = "primary",
    shape: r = "rectangle"
  } = e, [o, s] = ge(null);
  de();
  const a = 300, l = 200;
  return /* @__PURE__ */ d(
    Pr,
    {
      shadow: "none",
      px: "xs",
      py: "sm",
      className: oL,
      mod: {
        "likec4-color": i
      },
      onMouseEnter: () => {
        s(null);
      },
      onMouseLeave: () => {
        s(null);
      },
      children: /* @__PURE__ */ b(
        K,
        {
          gap: "sm",
          align: "stretch",
          wrap: "nowrap",
          children: [
            /* @__PURE__ */ d(
              A,
              {
                flex: "0 0 70px",
                style: {
                  position: "relative",
                  width: 70,
                  height: qS(70 * (l / a), 0)
                },
                children: /* @__PURE__ */ d(
                  Wr,
                  {
                    data: {
                      shape: r,
                      width: a,
                      height: l
                    }
                  }
                )
              }
            ),
            /* @__PURE__ */ b(be, { gap: 4, flex: 1, children: [
              /* @__PURE__ */ d(K, { gap: 4, flex: "0 0 auto", children: e.kinds.map((c) => /* @__PURE__ */ d(
                gi,
                {
                  className: sL,
                  onMouseEnter: () => {
                    s(c);
                  },
                  onMouseLeave: () => {
                    s(null);
                  },
                  opacity: qo(o) && o !== c ? 0.25 : 1,
                  color: qo(o) && o !== c ? "gray" : el.element.fill,
                  children: c
                },
                c
              )) }),
              /* @__PURE__ */ d(
                $,
                {
                  component: "div",
                  fz: "sm",
                  fw: 500,
                  lh: "1.25",
                  style: {
                    textWrap: "pretty"
                  },
                  children: n
                }
              )
            ] })
          ]
        }
      )
    }
  );
}, lL = (e) => ({
  id: e.view.id,
  notations: e.view.notation?.elements ?? [],
  isVisible: !0
  // isVisible: isNullish(s.focusedNodeId ?? s.activeWalkthrough),
}), cL = nt(() => {
  const e = Wc((c) => c.height), {
    id: n,
    notations: i,
    isVisible: r
  } = pt(lL), [o, s] = Dl({
    key: "notation-webview-collapsed",
    defaultValue: !0
  }), a = i.length > 0, l = Fi();
  return /* @__PURE__ */ b(ht, { children: [
    !a && r && /* @__PURE__ */ d(
      re.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: j("react-flow__panel", Ca),
        children: /* @__PURE__ */ d(vt, { label: "View has no notations", color: "orange", ...l, children: /* @__PURE__ */ d(
          wt,
          {
            size: "lg",
            variant: "light",
            color: "orange",
            radius: "md",
            children: /* @__PURE__ */ d(zc, {})
          }
        ) })
      },
      "empty"
    ),
    a && r && o && /* @__PURE__ */ d(
      re.div,
      {
        initial: { opacity: 0.75, translateX: "50%" },
        animate: { opacity: 1, translateX: 0 },
        exit: {
          translateX: "100%",
          opacity: 0.6
        },
        className: j("react-flow__panel", Ca),
        children: /* @__PURE__ */ d(vt, { label: "Show notation", color: "dark", fz: "xs", ...l, children: /* @__PURE__ */ d(
          se,
          {
            size: "lg",
            variant: "default",
            color: "gray",
            radius: "md",
            onClick: () => s(!1),
            children: /* @__PURE__ */ d(J_, { stroke: 1.5 })
          }
        ) })
      },
      "collapsed"
    ),
    a && r && !o && /* @__PURE__ */ d(
      re.div,
      {
        initial: {
          opacity: 0.75,
          // translateX: '50%',
          scale: 0.2
        },
        animate: { opacity: 1, scale: 1 },
        exit: {
          opacity: 0,
          scale: 0.25
        },
        className: j("react-flow__panel", Ca),
        style: {
          transformOrigin: "bottom right"
        },
        children: /* @__PURE__ */ d(
          ls,
          {
            radius: "sm",
            withBorder: !0,
            shadow: "lg",
            className: iL,
            children: /* @__PURE__ */ b(Al, { defaultValue: "first", radius: "xs", children: [
              /* @__PURE__ */ b(Il, { children: [
                /* @__PURE__ */ d(
                  se,
                  {
                    size: "md",
                    variant: "subtle",
                    color: "gray",
                    ml: 2,
                    style: {
                      alignSelf: "center"
                    },
                    onClick: () => s(!0),
                    children: /* @__PURE__ */ d(H_, { stroke: 2 })
                  }
                ),
                /* @__PURE__ */ d(Tr, { value: "first", fz: "xs", children: "Elements" }),
                /* @__PURE__ */ d(Tr, { value: "second", fz: "xs", disabled: !0, children: "Relationships" })
              ] }),
              /* @__PURE__ */ d(Qt, { value: "first", className: rL, hidden: o, children: /* @__PURE__ */ d(
                jn,
                {
                  viewportProps: {
                    style: {
                      maxHeight: `min(40vh, ${Math.max(e - 60, 50)}px)`
                    }
                  },
                  children: /* @__PURE__ */ d(be, { gap: 0, children: i.map((c, u) => /* @__PURE__ */ d(aL, { value: c }, u)) })
                }
              ) })
            ] })
          }
        )
      },
      n
    )
  ] });
});
var uL = "krxd1i0", Ff = "krxd1i1", Wf = "krxd1i3", dL = "krxd1i4";
function hL() {
  const e = Wc((l) => l.width <= 750), {
    isActive: n,
    isParallel: i,
    hasNext: r,
    hasPrevious: o
  } = pt((l) => ({
    isActive: Pg(l.activeWalkthrough),
    isParallel: rn(l.activeWalkthrough?.parallelPrefix),
    hasNext: l.xyedges.findIndex((c) => c.id === l.activeWalkthrough?.stepId) < l.xyedges.length - 1,
    hasPrevious: l.xyedges.findIndex((c) => c.id === l.activeWalkthrough?.stepId) > 0
  })), s = de(), a = {
    className: Wf,
    size: e ? "compact-md" : "lg",
    radius: e ? "lg" : "xl"
  };
  return /* @__PURE__ */ b(ht, { children: [
    i && /* @__PURE__ */ d(
      A,
      {
        layout: !0,
        component: re.div,
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        className: j("react-flow__panel", dL)
      },
      "parallel-frame"
    ),
    /* @__PURE__ */ b(
      A,
      {
        className: j("react-flow__panel", uL),
        onClick: (l) => l.stopPropagation(),
        onDoubleClick: (l) => l.stopPropagation(),
        children: [
          !n && /* @__PURE__ */ d(
            le,
            {
              ...a,
              className: j(Ff, Wf),
              rightSection: /* @__PURE__ */ d(wC, {}),
              onClick: () => s.startWalkthrough(),
              px: "xl",
              children: "Start"
            }
          ),
          i && /* @__PURE__ */ d(
            gi,
            {
              component: re.div,
              initial: { opacity: 0.05, transform: "translateY(20px)" },
              animate: { opacity: 1, transform: "translateY(0)" },
              exit: {
                opacity: 0,
                transform: "translateY(20px)"
              },
              variant: "gradient",
              size: e ? "xs" : "md",
              gradient: { from: "red", to: "orange", deg: 90 },
              radius: "sm",
              children: "parallel"
            },
            "parallel-badge"
          ),
          n && /* @__PURE__ */ b(a1, { className: Ff, children: [
            /* @__PURE__ */ d(
              le,
              {
                ...a,
                pl: "lg",
                disabled: !o,
                onClick: () => s.walkthroughStep("previous"),
                children: /* @__PURE__ */ d(xC, {})
              }
            ),
            /* @__PURE__ */ b(
              le,
              {
                ...a,
                px: r ? "md" : "xl",
                onClick: (l) => {
                  l.stopPropagation(), s.stopWalkthrough();
                },
                children: [
                  r && /* @__PURE__ */ d(kC, {}),
                  !r && "End"
                ]
              }
            ),
            r && /* @__PURE__ */ d(
              le,
              {
                ...a,
                pr: "lg",
                onClick: () => s.walkthroughStep("next"),
                children: /* @__PURE__ */ d(bC, {})
              }
            )
          ] })
        ]
      }
    )
  ] });
}
function fL() {
  const {
    enableViewTitle: e,
    enableNotations: n,
    enableDynamicViewWalkthrough: i
  } = Lc(), r = ky((o) => o.children.overlays);
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(Z3, {}),
    r && /* @__PURE__ */ d(E0, { overlaysActorRef: r }),
    e && /* @__PURE__ */ d(nL, {}),
    n && /* @__PURE__ */ d(cL, {}),
    i && /* @__PURE__ */ d(hL, {})
  ] });
}
class hi {
  static LeftPadding = 40;
  static RightPadding = 40;
  static TopPadding = 55;
  static BottomPadding = 40;
  id;
  minX = 1 / 0;
  minY = 1 / 0;
  maxX = -1 / 0;
  maxY = -1 / 0;
  get positionAbsolute() {
    return {
      x: this.minX,
      y: this.minY
    };
  }
  set positionAbsolute(n) {
    const i = Math.round(n.x), r = Math.round(n.y);
    this.maxX += i - this.minX, this.maxY += r - this.minY, this.minX = i, this.minY = r;
  }
  get dimensions() {
    return {
      width: this.maxX - this.minX,
      height: this.maxY - this.minY
    };
  }
  // Position relative to parent
  get position() {
    const n = this.positionAbsolute;
    if (!this.parent)
      return n;
    const i = this.parent.positionAbsolute;
    return {
      x: n.x - i.x,
      y: n.y - i.y
    };
  }
  constructor(n, i = null) {
    this.id = n.id, this.positionAbsolute = i ? {
      x: n.position.x + i.minX,
      y: n.position.y + i.minY
    } : n.position;
    const { width: r, height: o } = Ut(n);
    this.maxX = this.minX + Math.ceil(r), this.maxY = this.minY + Math.ceil(o), i && i.children.push(this);
  }
}
class Ea extends hi {
  constructor(n, i = null) {
    super(n, i), this.parent = i;
  }
  children = [];
}
class pL extends hi {
  constructor(n, i = null) {
    super(n, i), this.parent = i;
  }
}
function R0(e, n) {
  const { parentLookup: i, nodeLookup: r } = e.getState(), o = /* @__PURE__ */ new Map(), s = (m) => {
    const g = [];
    let v = r.get(m)?.parentId, w;
    for (; v && (w = r.get(v)); )
      g.push(w.id), v = w.parentId;
    return g;
  }, a = new Set(
    n.flatMap(s)
  ), l = new Array();
  for (const [, m] of r)
    Ac(m.parentId) && l.push({
      xynode: m,
      parent: null
    });
  for (; l.length > 0; ) {
    const { xynode: m, parent: g } = l.shift(), v = !n.includes(m.id) && (m.type === "compound-element" || m.type === "compound-deployment" || m.type === "view-group") && a.has(m.id), w = v ? new Ea(m, g) : new pL(m, g);
    o.set(m.id, w), v && i.get(m.id)?.forEach((x) => {
      l.push({
        xynode: x,
        parent: w
      });
    });
  }
  const c = [...o.values()];
  u(c);
  function u(m) {
    m.filter((g) => g instanceof Ea).forEach((g) => {
      u(g.children);
      const y = g.children.reduce((v, w) => ({
        minX: Math.min(v.minX, w.minX),
        minY: Math.min(v.minY, w.minY),
        maxX: Math.max(v.maxX, w.maxX),
        maxY: Math.max(v.maxY, w.maxY)
      }), {
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
      });
      g.minX = y.minX - hi.LeftPadding, g.minY = y.minY - hi.TopPadding, g.maxX = y.maxX + hi.RightPadding, g.maxY = y.maxY + hi.BottomPadding;
    });
  }
  function f() {
    u(c), e.getState().triggerNodeChanges(
      c.reduce((m, g) => (m.push({
        id: g.id,
        type: "position",
        dragging: !1,
        position: g.position,
        positionAbsolute: g.positionAbsolute
      }), g instanceof Ea && m.push({
        id: g.id,
        type: "dimensions",
        setAttributes: !0,
        dimensions: g.dimensions
      }), m), [])
    );
  }
  let h = null;
  function p(m) {
    c.length !== 0 && (h ??= requestAnimationFrame(() => {
      h = null, m(
        ve(
          n,
          Gt((g) => o.has(g) && r.has(g)),
          Ce((g) => ({
            rect: xe(o.get(g)),
            node: xe(r.get(g))
          }))
        )
      ), f();
    }));
  }
  return {
    updateXYFlowNodes: f,
    onMove: p
  };
}
function mL() {
  const e = Yg(), n = de(), i = J(void 0);
  return ce(() => ({
    onNodeDragStart: (r, o) => {
      n.cancelSaveManualLayout();
      const { nodeLookup: s } = e.getState(), a = ve(
        Array.from(s.values()),
        Gt((l) => l.dragging === !0 || l.id === o.id || l.selected === !0),
        Gt((l) => l.draggable !== !1),
        Ce((l) => l.id)
      );
      ut(a, 1) && (i.current = R0(e, a));
    },
    onNodeDrag: () => {
      i.current?.onMove((r) => {
        r.forEach(({ rect: o, node: s }) => {
          o.positionAbsolute = s.internals.positionAbsolute;
        });
      });
    },
    onNodeDragStop: () => {
      i.current?.updateXYFlowNodes(), n.scheduleSaveManualLayout(), i.current = void 0;
    }
  }), [e, n]);
}
const gL = (e) => ({
  initialized: e.initialized,
  nodes: e.xynodes,
  edges: e.xyedges,
  pannable: e.pannable,
  zoomable: e.zoomable,
  fitViewPadding: e.fitViewPadding,
  enableFitView: e.features.enableFitView,
  enableReadOnly: e.features.enableReadOnly || e.toggledFeatures.enableReadOnly,
  ...!e.features.enableFitView && {
    viewport: {
      x: -Math.min(e.view.bounds.x, 0),
      y: -Math.min(e.view.bounds.y, 0),
      zoom: 1
    }
  }
}), yL = (e, n) => e.initialized === n.initialized && e.pannable === n.pannable && e.zoomable === n.zoomable && e.fitViewPadding === n.fitViewPadding && e.enableFitView === n.enableFitView && e.enableReadOnly === n.enableReadOnly && Ze(e.nodes, n.nodes) && Ze(e.edges, n.edges) && Ze(e.viewport, n.viewport), vL = nt(({ background: e, nodesDraggable: n, nodesSelectable: i }) => {
  const r = de(), {
    initialized: o,
    nodes: s,
    edges: a,
    enableReadOnly: l,
    enableFitView: c,
    ...u
  } = pt(gL, yL), {
    onNodeContextMenu: f,
    onCanvasContextMenu: h,
    onEdgeContextMenu: p,
    onNodeClick: m,
    onEdgeClick: g,
    onCanvasClick: y,
    onCanvasDblClick: v
  } = ji(), w = !l, x = mL(), k = q(() => {
    r.send({ type: "xyflow.resized" });
  });
  return /* @__PURE__ */ d(
    Hc,
    {
      nodes: s,
      edges: a,
      className: j(o ? "initialized" : "not-initialized"),
      nodeTypes: pM,
      edgeTypes: mM,
      onNodesChange: q((_) => {
        r.send({ type: "xyflow.applyNodeChanges", changes: _ });
      }),
      onEdgesChange: q((_) => {
        r.send({ type: "xyflow.applyEdgeChanges", changes: _ });
      }),
      background: o ? e : "transparent",
      fitView: !1,
      onNodeClick: q((_, S) => {
        _.stopPropagation(), r.send({ type: "xyflow.nodeClick", node: S }), m?.(r.findDiagramNode(S.id), _);
      }),
      onEdgeClick: q((_, S) => {
        _.stopPropagation(), r.send({ type: "xyflow.edgeClick", edge: S }), g?.(r.findDiagramEdge(S.id), _);
      }),
      onPaneClick: q((_) => {
        _.stopPropagation(), r.send({ type: "xyflow.paneClick" }), y?.(_);
      }),
      onDoubleClick: q((_) => {
        _.stopPropagation(), _.preventDefault(), r.send({ type: "xyflow.paneDblClick" }), v?.(_);
      }),
      onMoveEnd: q((_, S) => {
        r.send({ type: "xyflow.viewportMoved", viewport: S, manually: !!_ });
      }),
      onInit: q((_) => {
        r.send({ type: "xyflow.init", instance: _ });
      }),
      onNodeContextMenu: q((_, S) => {
        const P = xe(
          r.findDiagramNode(S.id),
          `diagramNode ${S.id} not found`
        );
        f?.(P, _);
      }),
      onEdgeContextMenu: q((_, S) => {
        const P = xe(
          r.findDiagramEdge(S.id),
          `diagramEdge ${S.id} not found`
        );
        p?.(P, _);
      }),
      onPaneContextMenu: q((_) => {
        h?.(_);
      }),
      ...c && {
        onViewportResize: k
      },
      nodesDraggable: w && n,
      nodesSelectable: i,
      ...w && n && x,
      ...u,
      children: /* @__PURE__ */ d(fL, {})
    }
  );
}, Ze);
class L0 {
}
class ti extends L0 {
  constructor(n, i, r) {
    super(), this.getEdgePosition = n, this.computePosition = i, this.propertyToEdit = r;
  }
  alignTo;
  computeLayout(n) {
    this.alignTo = this.getEdgePosition(n);
  }
  applyPosition(n) {
    return {
      [this.propertyToEdit]: this.computePosition(this.alignTo, n)
    };
  }
}
class wL extends L0 {
  layout = /* @__PURE__ */ new Map();
  axisPreset;
  get primaryAxisCoord() {
    return this.axisPreset.primaryAxisCoord;
  }
  get secondaryAxisCoord() {
    return this.axisPreset.secondaryAxisCoord;
  }
  get primaryAxisDimension() {
    return this.axisPreset.primaryAxisDimension;
  }
  get secondaryAxisDimension() {
    return this.axisPreset.secondaryAxisDimension;
  }
  constructor(n) {
    super(), this.axisPreset = n === "Column" ? {
      primaryAxisDimension: "width",
      secondaryAxisDimension: "height",
      primaryAxisCoord: "x",
      secondaryAxisCoord: "y"
    } : {
      primaryAxisDimension: "height",
      secondaryAxisDimension: "width",
      primaryAxisCoord: "y",
      secondaryAxisCoord: "x"
    };
  }
  applyPosition(n) {
    return this.layout?.get(n.id) ?? {};
  }
  computeLayout(n) {
    const i = ve(
      n,
      Ho((s) => s[this.primaryAxisCoord])
    ), r = this.getLayoutRect(i), o = this.getLayers(i);
    this.layout = this.buildLayout(o, r, i);
  }
  getLayoutRect(n) {
    const i = Math.min(...n.map((a) => a.x)), r = Math.min(...n.map((a) => a.y)), o = Math.max(...n.map((a) => a.x + a.width)), s = Math.max(...n.map((a) => a.y + a.height));
    return {
      x: i,
      y: r,
      width: o - i,
      height: s - r
    };
  }
  getLayers(n) {
    const i = [];
    let r = 0, o = null;
    for (let s of n)
      if (o && s[this.primaryAxisCoord] < r)
        o.nodes.push(s), o.primaryAxisSize = Math.max(o.primaryAxisSize, s[this.primaryAxisDimension]), o.occupiedSpace += s[this.secondaryAxisDimension], r = Math.max(
          s[this.primaryAxisCoord] + s[this.primaryAxisDimension],
          r
        );
      else {
        o = {
          primaryAxisSize: s[this.primaryAxisDimension],
          nodes: [s],
          occupiedSpace: s[this.secondaryAxisDimension],
          layout: null
        }, i.push(o), r = s[this.primaryAxisCoord] + s[this.primaryAxisDimension];
        continue;
      }
    return i.forEach((s) => s.nodes.sort((a, l) => a[this.secondaryAxisCoord] - l[this.secondaryAxisCoord])), i;
  }
  buildLayout(n, i, r) {
    const o = new Map(r.map((g) => [g.id, g])), s = [], a = n.reduce((g, y) => g + y.primaryAxisSize, 0), l = n.length > 1 ? (i[this.primaryAxisDimension] - a) / (n.length - 1) : 0, c = n.reduce(
      (g, y, v) => n[g].occupiedSpace < y.occupiedSpace ? v : g,
      0
    ), u = n[c], f = n.slice(0, c).reduce(
      (g, y) => g + y.primaryAxisSize + l,
      i[this.primaryAxisCoord]
    ), h = this.buildLayerLayout(
      u,
      i,
      f,
      o,
      null
    );
    u.layout = h, s.push(...h.nodePositions);
    let p = f + u.primaryAxisSize + l, m = u;
    for (let g = c + 1; g < n.length; g++) {
      const y = n[g];
      y.layout = this.buildLayerLayout(y, i, p, o, m), s.push(...y.layout.nodePositions), m = y.layout.refLayer ?? y, p += y.primaryAxisSize + l;
    }
    p = f, m = u;
    for (let g = c - 1; g >= 0; g--) {
      const y = n[g];
      p -= y.primaryAxisSize + l, y.layout = this.buildLayerLayout(y, i, p, o, m), s.push(...y.layout.nodePositions), m = y.layout.refLayer ?? y;
    }
    return new Map(s);
  }
  buildLayerLayout(n, i, r, o, s) {
    let a = this.scoreLayout(
      this.spaceAround(n, i, r),
      o
    );
    if (n.nodes.length != 1) {
      const l = this.scoreLayout(
        this.spaceBetween(n, i, r),
        o
      );
      a = l[0] < a[0] ? l : a;
    }
    if (s && s.nodes.length - 1 >= n.nodes.length) {
      const l = this.scoreLayout(
        this.placeInGaps(n, r, s),
        o
      );
      a = l[0] < a[0] ? l : a;
    }
    if (s && s.nodes.length >= n.nodes.length) {
      const l = this.scoreLayout(
        this.placeInCells(n, r, s),
        o
      );
      a = l[0] < a[0] ? l : a;
    }
    return a[1];
  }
  spaceBetween(n, i, r) {
    const s = (i[this.secondaryAxisDimension] - n.occupiedSpace) / (n.nodes.length - 1);
    let a = i[this.secondaryAxisCoord];
    const l = /* @__PURE__ */ new Map();
    for (let c of n.nodes)
      l.set(c.id, {
        [this.secondaryAxisCoord]: a,
        [this.primaryAxisCoord]: r
      }), a += c[this.secondaryAxisDimension] + s;
    return { nodePositions: l, refLayer: null };
  }
  spaceAround(n, i, r) {
    const s = (i[this.secondaryAxisDimension] - n.occupiedSpace) / (n.nodes.length + 1);
    let a = i[this.secondaryAxisCoord] + s;
    const l = /* @__PURE__ */ new Map();
    for (let c of Ho(n.nodes, (u) => u[this.secondaryAxisCoord]))
      l.set(c.id, {
        [this.secondaryAxisCoord]: a,
        [this.primaryAxisCoord]: r
      }), a += c[this.secondaryAxisDimension] + s;
    return { nodePositions: l, refLayer: null };
  }
  placeInGaps(n, i, r) {
    const o = /* @__PURE__ */ new Map(), s = n.nodes, a = this.getGapsPositions(r);
    let l = 0;
    for (let c = 0, u = s[c]; c < s.length; c++, u = s[c]) {
      const f = u[this.secondaryAxisCoord] + u[this.secondaryAxisDimension] / 2;
      let h = 1 / 0;
      for (; l - c <= a.length - s.length; ) {
        const m = a[l] - f;
        if (Math.abs(m) < Math.abs(h))
          h = m, l++;
        else
          break;
      }
      o.set(u.id, {
        [this.secondaryAxisCoord]: u[this.secondaryAxisCoord] + h,
        [this.primaryAxisCoord]: i
      });
    }
    return { nodePositions: o, refLayer: r };
  }
  placeInCells(n, i, r) {
    const o = /* @__PURE__ */ new Map(), s = n.nodes, a = this.getNodePositions(r);
    let l = 0;
    for (let c = 0, u = s[c]; c < s.length; c++, u = s[c]) {
      const f = u[this.secondaryAxisCoord] + u[this.secondaryAxisDimension] / 2;
      let h = 1 / 0;
      for (; l - c <= a.length - s.length; ) {
        const m = a[l] - f;
        if (Math.abs(m) < Math.abs(h))
          h = m, l++;
        else
          break;
      }
      o.set(u.id, {
        [this.secondaryAxisCoord]: u[this.secondaryAxisCoord] + h,
        [this.primaryAxisCoord]: i
      });
    }
    return { nodePositions: o, refLayer: r };
  }
  scoreLayout(n, i) {
    return [
      ve(
        Array.from(n.nodePositions),
        Ce(([r, o]) => {
          const s = i.get(r);
          return me(s, `Could not find original rect for node ${r}`), [Cc(s, ["x", "y"]), o];
        }),
        Ce(
          ([r, o]) => Math.abs(r[this.secondaryAxisCoord] - o[this.secondaryAxisCoord])
        ),
        Ei((r, o) => r + o, 0)
      ),
      n
    ];
  }
  getGapsPositions(n) {
    const i = [], { layout: r, nodes: o } = n;
    me(r, "Layout of the layer must be computed before calling getGapsPositions");
    for (let s = 1; s < o.length; s++) {
      const a = o[s - 1], l = o[s], c = r.nodePositions.get(a.id), u = r.nodePositions.get(l.id);
      i.push(
        (u[this.secondaryAxisCoord] + c[this.secondaryAxisCoord] + a[this.secondaryAxisDimension]) / 2
      );
    }
    return i;
  }
  getNodePositions(n) {
    const i = [], { layout: r, nodes: o } = n;
    me(r, "Layout of the layer must be computed before calling getGapsPositions");
    for (let s = 0; s < o.length; s++) {
      const a = o[s], l = r.nodePositions.get(a.id);
      i.push(
        l[this.secondaryAxisCoord] + a[this.secondaryAxisDimension] / 2
      );
    }
    return i;
  }
}
function xL(e) {
  switch (e) {
    case "Left":
      return new ti(
        (n) => Math.min(...n.map((i) => i.x)),
        (n, i) => Math.floor(n),
        "x"
      );
    case "Top":
      return new ti(
        (n) => Math.min(...n.map((i) => i.y)),
        (n, i) => Math.floor(n),
        "y"
      );
    case "Right":
      return new ti(
        (n) => Math.max(...n.map((i) => i.x + i.width)),
        (n, i) => Math.floor(n - i.width),
        "x"
      );
    case "Bottom":
      return new ti(
        (n) => Math.max(...n.map((i) => i.y + i.height)),
        (n, i) => Math.floor(n - i.height),
        "y"
      );
    case "Center":
      return new ti(
        (n) => Math.min(...n.map((i) => i.x + i.width / 2)),
        (n, i) => Math.floor(n - i.width / 2),
        "x"
      );
    case "Middle":
      return new ti(
        (n) => Math.min(...n.map((i) => i.y + i.height / 2)),
        (n, i) => Math.floor(n - i.height / 2),
        "y"
      );
  }
}
function Hf(e) {
  const { width: n, height: i } = Ut(e);
  return {
    ...e.internals.positionAbsolute,
    id: e.id,
    width: n,
    height: i
  };
}
function bL(e) {
  switch (e) {
    case "Left":
    case "Right":
    case "Top":
    case "Bottom":
    case "Center":
    case "Middle":
      return xL(e);
    case "Column":
    case "Row":
      return new wL(e);
    default:
      Pt(e);
  }
}
function Pa(e) {
  const { lastClickedNode: n } = e.context;
  return !n || n.id !== e.event.node.id ? {
    id: e.event.node.id,
    clicks: 1,
    timestamp: Date.now()
  } : {
    id: n.id,
    clicks: n.clicks + 1,
    timestamp: Date.now()
  };
}
function qf({ context: e, event: n }) {
  je(n, "update.view");
  const i = n.view, r = e.view.id === i.id, o = e.xynodes, s = n.xynodes.map((l) => {
    const c = o.find((u) => u.id === l.id);
    if (c) {
      const { width: u, height: f } = Ut(c);
      return Y(c.type, l.type) && Y(u, l.initialWidth) && Y(f, l.initialHeight) && Y(c.hidden ?? !1, l.hidden ?? !1) && Y(c.position, l.position) && Y(c.data, l.data) && Y(c.parentId ?? null, l.parentId ?? null) ? c : {
        ...bs(c, ["measured", "parentId"]),
        ...l,
        // Force dimensions from update
        width: l.initialWidth,
        height: l.initialHeight,
        data: {
          ...c.data,
          ...l.data
        }
      };
    }
    return l;
  });
  let a = n.xyedges;
  if (r && !i.hasLayoutDrift) {
    const l = e.xyedges;
    a = n.xyedges.map((c) => {
      const u = l.find((f) => f.id === c.id);
      return u ? Y(u.hidden ?? !1, c.hidden ?? !1) && Y(u.data, c.data) ? u : {
        ...u,
        ...c,
        data: {
          ...u.data,
          ...c.data
        }
      } : c;
    });
  }
  if (!r) {
    for (const l of s)
      l.data = {
        ...l.data,
        dimmed: !1,
        hovered: !1
      };
    for (const l of a)
      l.data = {
        ...l.data,
        dimmed: !1,
        hovered: !1,
        active: !1
      };
  }
  return {
    xynodes: s,
    xyedges: a,
    view: i
  };
}
function Ta(e) {
  const { xynodes: n, xyedges: i, focusedNode: r } = e.context;
  if (!r)
    return {};
  const o = /* @__PURE__ */ new Set([r]), s = i.map((a) => a.source === r || a.target === r ? (o.add(a.source), o.add(a.target), Ke.setData(a, {
    dimmed: !1,
    active: !0
  })) : Ke.setData(a, {
    dimmed: !0,
    active: !1
  }));
  return {
    xynodes: n.map((a) => Ke.setDimmed(a, !o.has(a.id))),
    xyedges: s
  };
}
function Gf({ context: e }) {
  const { xynodes: n, xyedges: i } = e;
  return {
    xynodes: n.map(Ke.setDimmed(!1)),
    xyedges: i.map(Ke.setData({
      dimmed: !1,
      active: !1
    }))
  };
}
function Uf({ context: e, event: n }) {
  je(n, "update.view");
  let {
    view: i,
    navigationHistory: {
      currentIndex: r,
      history: o
    },
    lastOnNavigate: s,
    viewport: a
  } = e;
  const l = xe(o[r]);
  if (l.viewId !== n.view.id) {
    if (!s) {
      const c = r > 0 ? xe(o[r - 1]) : null;
      if (c && c.viewId === n.view.id)
        return {
          navigationHistory: {
            currentIndex: r - 1,
            history: o
          },
          lastOnNavigate: {
            fromView: l.viewId,
            toView: c.viewId,
            fromNode: l.fromNode
          }
        };
      const u = r < o.length - 1 ? xe(o[r + 1]) : null;
      if (u && u.viewId === n.view.id)
        return {
          navigationHistory: {
            currentIndex: r + 1,
            history: o
          },
          lastOnNavigate: {
            fromView: l.viewId,
            toView: u.viewId,
            fromNode: u.fromNode
          }
        };
    }
    return o = [
      ...o.slice(0, r + 1),
      {
        viewId: n.view.id,
        fromNode: s?.fromNode ?? null,
        viewport: { ...a }
      }
    ], r = o.length - 1, {
      navigationHistory: {
        currentIndex: r,
        history: o
      }
    };
  }
  return {};
}
function kL({ context: e }) {
  const {
    navigationHistory: {
      currentIndex: n,
      history: i
    }
  } = e;
  me(n > 0, "Cannot navigate back");
  const r = i[n], o = i[n - 1];
  return {
    navigationHistory: {
      currentIndex: n - 1,
      history: i
    },
    lastOnNavigate: {
      fromView: r.viewId,
      toView: o.viewId,
      fromNode: r.fromNode
    }
  };
}
function SL({ context: e }) {
  const {
    navigationHistory: {
      currentIndex: n,
      history: i
    }
  } = e;
  me(n < i.length - 1, "Cannot navigate forward");
  const r = i[n], o = i[n + 1];
  return {
    navigationHistory: {
      currentIndex: n + 1,
      history: i
    },
    lastOnNavigate: {
      fromView: r.viewId,
      toView: o.viewId,
      fromNode: o.fromNode
    }
  };
}
function _L({ context: e, event: n }) {
  return je(n, "update.nodeData"), { xynodes: e.xynodes.map(
    (r) => r.id !== n.nodeId ? r : {
      ...r,
      data: Cg(r.data, n.data)
    }
  ) };
}
function CL({ context: e, event: n }) {
  return je(n, "update.edgeData"), { xyedges: e.xyedges.map(
    (r) => r.id !== n.edgeId ? r : {
      ...r,
      data: Cg(r.data, n.data)
    }
  ) };
}
function EL({ context: e }) {
  const { xynodes: n } = e;
  function i(s, a) {
    const l = En({ x: s.width || 0, y: s.height || 0 });
    let c = En(s.position).add(l.mul(0.5)), u = s;
    do {
      const f = u.parentId && a.find((h) => h.id == u.parentId);
      if (!f)
        break;
      u = f, c = c.add(f.position);
    } while (!0);
    return c;
  }
  function r(s) {
    const a = n.find((m) => m.id == s.source), l = n.find((m) => m.id == s.target);
    if (!a || !l)
      return [];
    const c = i(a, n), u = i(l, n);
    if (!c || !u)
      return [];
    if (a === l) {
      const g = new Xe(0, a.height || 0).mul(-0.5).add(c);
      return [
        g.add(new Xe(-80 / 2.5, -80)),
        g.add(new Xe(80 / 2.5, -80))
      ];
    }
    const f = u.sub(c), h = o(a, c, f), p = o(l, u, f.mul(-1));
    return [h.add(p.sub(h).mul(0.3))];
  }
  function o(s, a, l) {
    const c = (s.width || 0) / 2 / l.x, u = (s.height || 0) / 2 / l.y, f = Math.min(Math.abs(c), Math.abs(u));
    return En(l).mul(f).add(a);
  }
  return {
    xyedges: e.xyedges.map((s) => !s.data.controlPoints || Mc(s.data.controlPoints) ? s : {
      ...s,
      data: {
        ...s.data,
        controlPoints: r(s)
      }
    })
  };
}
function Yf({ context: e }) {
  const { stepId: n, parallelPrefix: i } = xe(e.activeWalkthrough, "activeWalkthrough is null"), r = xe(e.xyedges.find((o) => o.id === n));
  return {
    xyedges: e.xyedges.map((o) => {
      const s = n === o.id || !!i && o.id.startsWith(i);
      return Ke.setData(o, {
        active: s,
        dimmed: !s
      });
    }),
    xynodes: e.xynodes.map((o) => {
      const s = r.source === o.id || r.target === o.id;
      return Ke.setDimmed(o, !s);
    })
  };
}
const PL = vy(({ sendBack: e }) => {
  const n = La([
    ["Escape", () => e({ type: "key.esc" }), {
      preventDefault: !0
    }]
  ]), i = La([
    ["ArrowLeft", () => e({ type: "key.arrow.left" }), {
      preventDefault: !0
    }],
    ["ArrowRight", () => e({ type: "key.arrow.right" }), {
      preventDefault: !0
    }]
  ]);
  return document.body.addEventListener("keydown", n), document.body.addEventListener("keydown", i, { capture: !0 }), () => {
    document.body.removeEventListener("keydown", n), document.body.removeEventListener("keydown", i, { capture: !0 });
  };
}), $0 = qi({
  delays: {
    timeout: 2e3
  },
  actions: {
    "trigger:OnChange": (e, n) => {
    }
  },
  guards: {
    "same view": ({ context: e }) => e.parent.getSnapshot().context.view.id === e.viewId
  }
}).createMachine({
  initial: "idle",
  context: ({ input: e }) => ({
    ...e
  }),
  states: {
    idle: {
      tags: "ready",
      on: {
        sync: {
          target: "pending"
        }
      }
    },
    paused: {
      tags: "pending",
      on: {
        sync: {
          target: "pending"
        }
      }
    },
    pending: {
      tags: "pending",
      on: {
        sync: {
          target: "pending",
          reenter: !0
        },
        cancel: {
          target: "paused"
        }
      },
      after: {
        timeout: [{
          guard: "same view",
          actions: {
            type: "trigger:OnChange",
            params: ({ context: e }) => ({ change: TL(e.parent.getSnapshot().context) })
          },
          target: "synced"
        }, {
          target: "stopped"
        }]
      }
    },
    synced: {
      tags: "ready",
      on: {
        sync: {
          target: "pending"
        }
      }
    },
    stopped: {
      entry: U({
        parent: null
      }),
      type: "final"
    }
  },
  on: {
    synced: {
      target: ".synced"
    },
    stop: {
      target: ".stopped"
    }
  }
});
function TL(e) {
  const { view: n, xystore: i, xyflow: r } = e, { nodeLookup: o } = i.getState(), s = /* @__PURE__ */ new Set();
  let a;
  const l = Ei([...o.values()], (u, f) => {
    const h = Ut(f);
    (!hr(f.internals.positionAbsolute, f.data.position) || f.initialWidth !== h.width || f.initialHeight !== h.height) && s.add(f.id);
    const p = u[f.id] = {
      isCompound: f.type !== "element" && f.type !== "deployment",
      x: Math.floor(f.internals.positionAbsolute.x),
      y: Math.floor(f.internals.positionAbsolute.y),
      width: Math.ceil(h.width),
      height: Math.ceil(h.height)
    };
    return a = a ? Bu(a, p) : p, u;
  }, {}), c = Ei(r?.getEdges() ?? [], (u, { source: f, target: h, data: p }) => {
    let m = p.controlPoints ?? [];
    const g = s.has(f) || s.has(h);
    if (m.length === 0 && g && (m = Jg(p)), p.points.length === 0 && m.length === 0)
      return u;
    const y = u[p.id] = {
      points: p.points
    };
    p.labelXY && p.labelBBox && (y.labelBBox = {
      ...p.labelBBox,
      ...p.labelXY
    }), p.labelBBox && (y.labelBBox ??= p.labelBBox), ut(m, 1) && (y.controlPoints = m);
    const v = [
      ...p.points.map((k) => k[0]),
      ...m.map((k) => k.x),
      ...y.labelBBox ? [y.labelBBox.x, y.labelBBox.x + y.labelBBox.width] : []
    ], w = [
      ...p.points.map((k) => k[1]),
      ...m.map((k) => k.y),
      ...y.labelBBox ? [y.labelBBox.y, y.labelBBox.y + y.labelBBox.height] : []
    ], x = N1({
      x: Math.floor(Math.min(...v)),
      y: Math.floor(Math.min(...w)),
      x2: Math.ceil(Math.max(...v)),
      y2: Math.ceil(Math.max(...w))
    });
    return a = a ? Bu(a, x) : x, u;
  }, {});
  return a ??= n.bounds, {
    op: "save-manual-layout",
    layout: {
      hash: n.hash,
      autoLayout: n.autoLayout,
      nodes: l,
      edges: c,
      ...a
    }
  };
}
const ML = qi({
  actors: {
    syncManualLayoutActorLogic: $0,
    hotkeyActorLogic: PL,
    overlaysActorLogic: bR
  },
  guards: {
    "enabled: FitView": ({ context: e }) => e.features.enableFitView,
    "enabled: FocusMode": ({ context: e }) => e.features.enableFocusMode,
    "enabled: Readonly": ({ context: e }) => e.features.enableReadOnly,
    "not readonly": ({ context: e }) => !e.features.enableReadOnly,
    "is dynamic view": ({ context: e }) => e.view.__ === "dynamic",
    "is another view": ({ context: e, event: n }) => {
      if (je(n, ["update.view", "navigate.to"]), n.type === "update.view")
        return e.view.id !== n.view.id;
      if (n.type === "navigate.to")
        return e.view.id !== n.viewId;
      Pt(n.type);
    },
    "click: selected node ": ({ event: e }) => (je(e, "xyflow.nodeClick"), e.node.selected === !0),
    "click: same node": ({ context: e, event: n }) => (je(n, "xyflow.nodeClick"), e.lastClickedNode?.id === n.node.id),
    "click: focused node": ({ context: e, event: n }) => (je(n, "xyflow.nodeClick"), e.focusedNode === n.node.id)
  },
  actions: {
    "trigger:NavigateTo": (e, n) => {
    },
    "trigger:OnChange": (e, n) => {
    },
    "trigger:OpenSource": (e, n) => {
    },
    "open source of focused node": Te(({ context: e, enqueue: n }) => {
      if (!e.focusedNode || !e.features.enableVscode) return;
      const i = Zo(e, e.focusedNode);
      i && (n.cancel("openSource"), ct.deploymentRef(i) ? n.raise({ type: "open.source", deployment: ct.deploymentRef(i) }, {
        id: "openSource",
        delay: 100
      }) : ct.modelRef(i) && n.raise({ type: "open.source", element: ct.modelRef(i) }, {
        id: "openSource",
        delay: 100
      }));
    }),
    "xyflow:fitDiagram": ({ context: e }, n) => {
      const {
        bounds: i = e.view.bounds,
        duration: r = 450
      } = n ?? {}, { width: o, height: s, panZoom: a, transform: l } = e.xystore.getState(), c = Math.max(1, l[2]), u = zl(
        i,
        o,
        s,
        Rn,
        c,
        e.fitViewPadding
      );
      u.x = Math.round(u.x), u.y = Math.round(u.y), a?.setViewport(u, r > 0 ? { duration: r } : void 0);
    },
    "xyflow:setViewportCenter": ({ context: e }, n) => {
      const { x: i, y: r } = n;
      me(e.xyflow, "xyflow is not initialized");
      const o = e.xyflow.getZoom();
      e.xyflow.setCenter(Math.round(i), Math.round(r), { zoom: o });
    },
    "xyflow:setViewport": ({ context: e }, n) => {
      const {
        viewport: i,
        duration: r = 350
      } = n, { panZoom: o } = e.xystore.getState();
      o?.setViewport(i, r > 0 ? { duration: r } : void 0);
    },
    "xyflow:alignNodeFromToAfterNavigate": ({ context: e }, n) => {
      const i = xe(e.xyflow, "xyflow is not initialized"), r = i.getInternalNode(n.fromNode);
      if (!r) return;
      const o = i.flowToScreenPosition({
        x: r.internals.positionAbsolute.x,
        // + dimensions.width / 2,
        y: r.internals.positionAbsolute.y
        // + dimensions.height / 2
      }), s = i.flowToScreenPosition(n.toPosition), a = {
        x: Math.round(o.x - s.x),
        y: Math.round(o.y - s.y)
      };
      e.xystore.getState().panBy(a);
    },
    "layout.align": ({ context: e }, n) => {
      const { mode: i } = n, { xystore: r } = e, { nodeLookup: o, parentLookup: s } = r.getState(), l = [...new Set(o.values().filter((f) => f.selected).map((f) => f.id)).difference(new Set(s.keys()))];
      if (!ut(l, 2)) {
        console.warn("At least 2 nodes must be selected to align");
        return;
      }
      const c = R0(r, l), u = bL(i);
      c.onMove((f) => {
        u.computeLayout(f.map(({ node: h }) => Hf(h))), f.forEach(({ rect: h, node: p }) => {
          h.positionAbsolute = {
            ...h.positionAbsolute,
            ...u.applyPosition(Hf(p))
          };
        });
      });
    },
    updateFeatures: Te(({ enqueue: e, system: n, event: i }) => {
      je(i, "update.features");
      const { features: r } = i;
      e.assign({
        features: { ...r }
      });
      const o = r.enableElementDetails || r.enableRelationshipDetails || r.enableRelationshipBrowser, s = rr(n).overlaysActorRef;
      if (o && !s) {
        e.spawnChild("overlaysActorLogic", { id: "overlays", systemId: "overlays" });
        return;
      }
      !o && s && e.stopChild("overlays");
    }),
    closeAllOverlays: Te(({ system: e, enqueue: n }) => {
      const i = rr(e).overlaysActorRef;
      i && n.sendTo(i, { type: "close.all" });
    }),
    stopSyncLayout: Te(({ context: e, enqueue: n }) => {
      n.sendTo(e.syncLayoutActorRef, { type: "stop" }), n.stopChild(e.syncLayoutActorRef), n.assign({
        syncLayoutActorRef: null
      });
    })
  }
}).createMachine({
  initial: "initializing",
  context: ({ input: e, self: n, spawn: i }) => ({
    ...e,
    features: { ...Vg },
    toggledFeatures: {
      enableReadOnly: !0
    },
    initialized: !1,
    viewportChangedManually: !1,
    lastOnNavigate: null,
    lastClickedNode: null,
    focusedNode: null,
    activeElementDetails: null,
    viewportBeforeFocus: null,
    navigationHistory: {
      currentIndex: 0,
      history: []
    },
    viewport: { x: 0, y: 0, zoom: 1 },
    xyflow: null,
    syncLayoutActorRef: i("syncManualLayoutActorLogic", {
      id: "syncLayout",
      input: { parent: n, viewId: e.view.id }
    }),
    activeWalkthrough: null
  }),
  // entry: ({ spawn }) => spawn(layoutActor, { id: 'layout', input: { parent: self } }),
  states: {
    initializing: {
      on: {
        "xyflow.init": {
          actions: Te(({ enqueue: e, check: n }) => {
            e.assign({
              initialized: !0,
              xyflow: ({ event: i }) => i.instance,
              navigationHistory: ({ context: i, event: r }) => ({
                currentIndex: 0,
                history: [{
                  viewId: i.view.id,
                  fromNode: null,
                  viewport: { ...r.instance.getViewport() }
                }]
              })
            }), n("enabled: FitView") && e({
              type: "xyflow:fitDiagram",
              params: { duration: 0 }
            });
          }),
          target: "idle"
        }
      }
    },
    idle: {
      id: "idle",
      on: {
        "xyflow.nodeClick": [
          {
            // TODO: xstate fails to infer the type of the guard
            guard: kE([
              "enabled: FocusMode",
              _E([
                "click: same node",
                "click: selected node "
              ])
            ]),
            actions: [
              U({
                lastClickedNode: Pa,
                focusedNode: ({ event: e }) => e.node.id
              })
            ],
            target: "focused"
          },
          {
            actions: U({
              lastClickedNode: Pa
            })
          }
        ],
        "xyflow.paneClick": {
          actions: [
            U({
              lastClickedNode: null
            })
          ]
        },
        "xyflow.paneDblClick": {
          actions: [
            { type: "xyflow:fitDiagram" },
            { type: "trigger:OpenSource", params: ({ context: e }) => ({ view: e.view.id }) }
          ]
        },
        "saveManualLayout.*": {
          guard: "not readonly",
          actions: Sn((e) => e.context.syncLayoutActorRef, ({ event: e }) => {
            if (e.type === "saveManualLayout.schedule")
              return { type: "sync" };
            if (e.type === "saveManualLayout.cancel")
              return { type: "cancel" };
            Pt(e);
          })
        },
        "focus.node": {
          guard: "enabled: FocusMode",
          actions: U({
            focusedNode: ({ event: e }) => e.nodeId
          }),
          target: "focused"
        }
      }
    },
    focused: {
      entry: [
        U((e) => ({
          ...Ta(e),
          viewportBeforeFocus: { ...e.context.viewport }
        })),
        "open source of focused node",
        ao("hotkeyActorLogic", { id: "hotkey" }),
        {
          type: "xyflow:fitDiagram",
          params: or
        }
      ],
      exit: Te(({ enqueue: e, context: n }) => {
        e.stopChild("hotkey"), n.viewportBeforeFocus ? e({ type: "xyflow:setViewport", params: { viewport: n.viewportBeforeFocus } }) : e({ type: "xyflow:fitDiagram" }), e.assign((i) => ({
          ...Gf(i),
          viewportBeforeFocus: null,
          focusedNode: null
        }));
      }),
      on: {
        "xyflow.nodeClick": [
          {
            guard: "click: focused node",
            target: "#idle"
          },
          {
            actions: [
              U({
                lastClickedNode: Pa,
                focusedNode: ({ event: e }) => e.node.id
              }),
              U(Ta),
              "open source of focused node",
              {
                type: "xyflow:fitDiagram",
                params: or
              }
            ]
          }
        ],
        "focus.node": {
          actions: [
            U({
              focusedNode: ({ event: e }) => e.nodeId
            }),
            U(Ta),
            "open source of focused node",
            {
              type: "xyflow:fitDiagram",
              params: or
            }
          ]
        },
        "key.esc": {
          target: "idle"
        },
        "xyflow.paneClick": {
          actions: U({
            lastClickedNode: null
          }),
          target: "idle"
        },
        "saveManualLayout.*": {
          guard: "not readonly",
          actions: Sn((e) => e.context.syncLayoutActorRef, ({ event: e }) => {
            if (e.type === "saveManualLayout.schedule")
              return { type: "sync" };
            if (e.type === "saveManualLayout.cancel")
              return { type: "cancel" };
            Pt(e);
          })
        }
      }
    },
    // Navigating to another view (after `navigateTo` event)
    navigating: {
      initial: "pending",
      type: "compound",
      states: {
        pending: {
          entry: Te(({ enqueue: e }) => {
            e("closeAllOverlays"), e("stopSyncLayout"), e({
              type: "trigger:NavigateTo",
              params: ({ context: n }) => ({
                viewId: xe(n.lastOnNavigate, "Invalid state, lastOnNavigate is null").toView
              })
            });
          }),
          on: {
            "update.view": {
              actions: Te(({ enqueue: e, context: n, event: i }) => {
                const { fromNode: r, toNode: o } = Kf(n, i);
                r && o ? (e({
                  type: "xyflow:alignNodeFromToAfterNavigate",
                  params: {
                    fromNode: r.id,
                    toPosition: {
                      x: o.position[0],
                      y: o.position[1]
                    }
                  }
                }), e.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 80 })) : (e({
                  type: "xyflow:setViewportCenter",
                  params: Fu(i.view.bounds)
                }), e.raise({ type: "fitDiagram", duration: 200 }, { id: "fitDiagram", delay: 25 })), e.assign(Uf), e.assign(qf);
              }),
              target: "done"
            }
          }
        },
        done: {
          type: "final"
        }
      },
      onDone: {
        target: "idle"
      },
      exit: U({
        syncLayoutActorRef: ({ self: e, context: n, spawn: i }) => i("syncManualLayoutActorLogic", {
          id: "syncLayout",
          systemId: "syncLayout",
          input: { parent: e, viewId: n.view.id }
        }),
        lastOnNavigate: null
      })
    },
    walkthrough: {
      entry: [
        // spawnChild('hotkeyActor', { id: 'hotkey' }),
        U({
          viewportBeforeFocus: ({ context: e }) => e.viewport,
          activeWalkthrough: ({ context: e, event: n }) => {
            je(n, "walkthrough.start");
            const i = n.stepId ?? on(e.xyedges).id;
            return {
              stepId: i,
              parallelPrefix: Wu(i)
            };
          }
        }),
        U(Yf),
        {
          type: "xyflow:fitDiagram",
          params: or
        }
      ],
      on: {
        "key.esc": {
          target: "idle"
        },
        "key.arrow.left": {
          actions: Be({ type: "walkthrough.step", direction: "previous" })
        },
        "key.arrow.right": {
          actions: Be({ type: "walkthrough.step", direction: "next" })
        },
        "walkthrough.step": {
          actions: Te(({ enqueue: e, context: n, event: i }) => {
            const { stepId: r } = n.activeWalkthrough, o = n.xyedges.findIndex((l) => l.id === r), s = bn(i.direction === "next" ? o + 1 : o - 1, {
              min: 0,
              max: n.xyedges.length - 1
            });
            if (s === o)
              return;
            const a = n.xyedges[s].id;
            e.assign({
              activeWalkthrough: {
                stepId: a,
                parallelPrefix: Wu(a)
              }
            }), e.assign(Yf), e({
              type: "xyflow:fitDiagram",
              params: or
            });
          })
        },
        "walkthrough.end": {
          target: "idle"
        },
        // We received another view, close overlay and process event again
        "update.view": {
          guard: "is another view",
          actions: Be(({ event: e }) => e, { delay: 50 }),
          target: "idle"
        }
      },
      exit: Te(({ enqueue: e, context: n }) => {
        e.stopChild("hotkey"), n.viewportBeforeFocus ? e({ type: "xyflow:setViewport", params: { viewport: n.viewportBeforeFocus } }) : e({ type: "xyflow:fitDiagram" }), e.assign((i) => ({
          activeWalkthrough: null,
          ...Gf(i),
          viewportBeforeFocus: null
        }));
      })
    }
  },
  on: {
    "xyflow.applyNodeChanges": {
      actions: U({
        xynodes: ({ context: e, event: n }) => Ap(n.changes, e.xynodes)
      })
    },
    "xyflow.applyEdgeChanges": {
      actions: U({
        xyedges: ({ context: e, event: n }) => Mp(n.changes, e.xyedges)
      })
    },
    "xyflow.viewportMoved": {
      actions: U({
        viewportChangedManually: ({ event: e }) => e.manually,
        viewport: ({ event: e }) => e.viewport
      })
    },
    fitDiagram: {
      guard: "enabled: FitView",
      actions: {
        type: "xyflow:fitDiagram",
        params: et("event")
      }
    },
    "navigate.to": {
      guard: "is another view",
      actions: [
        U({
          lastOnNavigate: ({ context: e, event: n }) => ({
            fromView: e.view.id,
            toView: n.viewId,
            fromNode: n.fromNode ?? null
          })
        })
      ],
      target: ".navigating"
    },
    "navigate.back": {
      guard: ({ context: e }) => e.navigationHistory.currentIndex > 0,
      actions: U(kL),
      target: ".navigating"
    },
    "navigate.forward": {
      guard: ({ context: e }) => e.navigationHistory.currentIndex < e.navigationHistory.history.length - 1,
      actions: U(SL),
      target: ".navigating"
    },
    "update.view": {
      actions: [
        U(Uf),
        Te(({ enqueue: e, event: n, check: i, context: r }) => {
          if (i("is another view")) {
            const s = n.view.id;
            e("closeAllOverlays"), e("stopSyncLayout"), e.assign({
              focusedNode: null,
              syncLayoutActorRef: ({ self: c, spawn: u }) => u("syncManualLayoutActorLogic", {
                id: "syncLayout",
                input: { parent: c, viewId: s }
              })
            });
            const { fromNode: a, toNode: l } = Kf(r, n);
            a && l ? (e({
              type: "xyflow:alignNodeFromToAfterNavigate",
              params: {
                fromNode: a.id,
                toPosition: {
                  x: l.position[0],
                  y: l.position[1]
                }
              }
            }), e.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 80 })) : (e({
              type: "xyflow:setViewportCenter",
              params: Fu(n.view.bounds)
            }), e.raise({ type: "fitDiagram", duration: 200 }, { id: "fitDiagram", delay: 25 }));
          } else
            e.sendTo((s) => s.context.syncLayoutActorRef, { type: "synced" }), r.viewportChangedManually || e.raise({ type: "fitDiagram" }, { id: "fitDiagram", delay: 50 });
          e.assign(qf), e.assign({
            lastOnNavigate: null
          });
        })
      ]
    },
    "update.inputs": {
      actions: U(({ event: e }) => ({ ...e.inputs }))
    },
    "update.features": {
      actions: "updateFeatures"
    },
    "update.nodeData": {
      actions: U(_L)
    },
    "update.edgeData": {
      actions: U(CL)
    },
    "layout.align": {
      guard: "not readonly",
      actions: [
        { type: "layout.align", params: ({ event: e }) => ({ mode: e.mode }) },
        Be({ type: "saveManualLayout.schedule" })
      ]
    },
    "layout.resetEdgeControlPoints": {
      guard: "not readonly",
      actions: [
        U(EL),
        Be({ type: "saveManualLayout.schedule" })
      ]
    },
    "xyflow.resized": {
      guard: ({ context: e }) => e.features.enableFitView && !e.viewportChangedManually,
      actions: [
        so("fitDiagram"),
        Be({ type: "fitDiagram" }, { id: "fitDiagram", delay: 200 })
      ]
    },
    "open.elementDetails": {
      actions: Te(({ context: e, enqueue: n, system: i, event: r }) => {
        let o = null;
        const s = r.fromNode ?? e.view.nodes.find((l) => ct.modelRef(l) === r.fqn)?.id, a = s ? e.xystore.getState().nodeLookup.get(s) : null;
        if (s && a) {
          const l = R1(a), c = e.xyflow.getZoom(), u = {
            ...e.xyflow.flowToScreenPosition(l),
            width: l.width * c,
            height: l.height * c
          };
          o = {
            node: s,
            clientRect: u
          };
        }
        n.sendTo(rr(i).overlaysActorRef, {
          type: "open.elementDetails",
          subject: r.fqn,
          currentView: e.view,
          ...o && { initiatedFrom: o }
        });
      })
    },
    "open.relationshipsBrowser": {
      actions: Sn(({ system: e }) => rr(e).overlaysActorRef, ({ context: e, event: n }) => ({
        type: "open.relationshipsBrowser",
        subject: n.fqn,
        scope: e.view
      }))
    },
    "open.relationshipDetails": {
      actions: Sn(({ system: e }) => rr(e).overlaysActorRef, ({ context: e, event: n }) => ({
        type: "open.relationshipDetails",
        view: e.view,
        edgeId: n.edgeId
      }))
    },
    "open.source": {
      actions: {
        type: "trigger:OpenSource",
        params: et("event")
      }
    },
    "walkthrough.start": {
      guard: "is dynamic view",
      target: ".walkthrough"
    },
    "toggle.feature": {
      actions: U({
        toggledFeatures: ({ context: e, event: n }) => ({
          ...e.toggledFeatures,
          [`enable${n.feature}`]: n.forceValue ?? !(e.toggledFeatures[`enable${n.feature}`] ?? e.features[`enable${n.feature}`])
        })
      })
    }
  },
  exit: [
    "stopSyncLayout",
    Wi("hotkey"),
    U({
      xyflow: null,
      xystore: null,
      initialized: !1,
      syncLayoutActorRef: null
    })
  ]
}), Xf = (e) => ct.modelRef(e) ?? ct.deploymentRef(e);
function Kf(e, n) {
  const i = e.lastOnNavigate?.fromNode, r = i && e.view.nodes.find((a) => a.id === i), o = r && Xf(r), s = o && n.view.nodes.find((a) => Xf(a) === o);
  return { fromNode: r, toNode: s };
}
function AL({ input: e, children: n }) {
  const i = o_(), r = ds(), o = mP(
    ML.provide({
      actions: {
        "trigger:NavigateTo": (s, { viewId: a }) => {
          i.current.onNavigateTo?.(a);
        },
        "trigger:OnChange": (s, a) => {
          i.current.onChange?.(a);
        },
        "trigger:OpenSource": (s, a) => {
          i.current.onOpenSource?.(a);
        }
      },
      actors: {
        syncManualLayoutActorLogic: $0.provide({
          actions: {
            "trigger:OnChange": (s, a) => {
              i.current.onChange?.(a);
            }
          }
        })
      }
    }),
    {
      id: `diagram:${e.view.id}`,
      systemId: "diagram",
      // ...inspector,
      input: {
        xystore: r,
        ...e
      }
    }
  );
  return /* @__PURE__ */ b(eu, { value: o, children: [
    /* @__PURE__ */ d(IL, { input: e, actorRef: o }),
    /* @__PURE__ */ d(DL, { actorRef: o, children: n })
  ] });
}
const IL = ({ input: { view: e, xyedges: n, xynodes: i, ...r }, actorRef: o }) => {
  const s = Lc();
  return Nn(() => {
    o.send({ type: "update.inputs", inputs: r });
  }, [o, r]), ie(() => {
    o.send({ type: "update.features", features: s });
  }, [o, s]), Nn(() => {
    o.send({ type: "update.view", view: e, xyedges: n, xynodes: i });
  }, [o, e, n, i]), null;
};
function DL({ children: e, actorRef: n }) {
  const i = Gn(n, q((r) => r.context.toggledFeatures), Ze);
  return /* @__PURE__ */ d(Pi, { overrides: i, children: e });
}
function bu({
  view: e,
  className: n,
  fitView: i = !0,
  fitViewPadding: r = 0,
  readonly: o = !0,
  pannable: s = !0,
  zoomable: a = !0,
  background: l = "dots",
  enableFocusMode: c = !1,
  enableElementDetails: u = !1,
  enableRelationshipDetails: f = u,
  enableRelationshipBrowser: h = f,
  nodesSelectable: p = !o || c,
  nodesDraggable: m = !o,
  controls: g = !o,
  showDiagramTitle: y = !0,
  showNotations: v = !0,
  enableDynamicViewWalkthrough: w = !1,
  enableSearch: x = !0,
  initialWidth: k,
  initialHeight: _,
  experimentalEdgeEditing: S = !1,
  onCanvasClick: P,
  onCanvasContextMenu: C,
  onCanvasDblClick: T,
  onEdgeClick: M,
  onChange: D,
  onEdgeContextMenu: L,
  onNavigateTo: z,
  onNodeClick: Q,
  onNodeContextMenu: ee,
  onOpenSource: Z,
  onBurgerMenuClick: ae,
  renderIcon: G,
  where: te,
  showNavigationButtons: $e = !!z
}) {
  const Me = !!it(), We = J(null), Ae = NC({
    view: e,
    where: te,
    nodesSelectable: p
  }), E = e.__ === "dynamic";
  return We.current == null && (We.current = {
    defaultEdges: [],
    defaultNodes: [],
    initialWidth: k ?? e.bounds.width,
    initialHeight: _ ?? e.bounds.height
  }), /* @__PURE__ */ d(Bg, { children: /* @__PURE__ */ d(Xk, { children: /* @__PURE__ */ d(SC, { value: G ?? null, children: /* @__PURE__ */ d(
    Pi,
    {
      features: {
        enableFitView: i,
        enableReadOnly: o,
        enableFocusMode: c,
        enableNavigateTo: !!z,
        enableElementDetails: u,
        enableRelationshipDetails: f,
        enableRelationshipBrowser: h,
        enableSearch: x,
        enableNavigationButtons: $e && !!z,
        enableDynamicViewWalkthrough: E && w,
        enableEdgeEditing: S,
        enableNotations: v,
        enableVscode: !!Z,
        enableControls: g,
        enableViewTitle: y,
        enableLikeC4Model: Me
      },
      children: /* @__PURE__ */ d(
        r_,
        {
          handlers: {
            onCanvasClick: P,
            onCanvasContextMenu: C,
            onCanvasDblClick: T,
            onEdgeClick: M,
            onChange: D,
            onEdgeContextMenu: L,
            onNavigateTo: z,
            onNodeClick: Q,
            onNodeContextMenu: ee,
            onOpenSource: Z,
            onBurgerMenuClick: ae
          },
          children: /* @__PURE__ */ b(PC, { className: n, children: [
            !Mc(e.customColorDefinitions) && /* @__PURE__ */ d(Ug, { customColors: e.customColorDefinitions }),
            /* @__PURE__ */ d(
              $l,
              {
                fitView: i,
                ...We.current,
                children: /* @__PURE__ */ d(
                  AL,
                  {
                    input: {
                      view: e,
                      pannable: s,
                      zoomable: a,
                      fitViewPadding: r,
                      ...Ae
                    },
                    children: /* @__PURE__ */ d(
                      vL,
                      {
                        nodesDraggable: m,
                        nodesSelectable: p,
                        background: l
                      }
                    )
                  }
                )
              }
            )
          ] })
        }
      )
    }
  ) }) }) });
}
function NL({
  children: e,
  likec4model: n
}) {
  return /* @__PURE__ */ d(Iy.Provider, { value: n, children: e });
}
function Bs({
  view: e,
  fitView: n = !0,
  fitViewPadding: i = 0,
  enableElementDetails: r = !1,
  enableRelationshipDetails: o = !1,
  enableRelationshipBrowser: s = o,
  background: a = "transparent",
  ...l
}) {
  return /* @__PURE__ */ d(
    bu,
    {
      view: e,
      readonly: !0,
      fitView: n,
      fitViewPadding: i,
      pannable: !1,
      zoomable: !1,
      controls: !1,
      background: a,
      showDiagramTitle: !1,
      showNotations: !1,
      enableElementDetails: r,
      enableRelationshipDetails: o,
      enableRelationshipBrowser: s,
      enableDynamicViewWalkthrough: !1,
      showNavigationButtons: !1,
      experimentalEdgeEditing: !1,
      enableFocusMode: !1,
      enableSearch: !1,
      nodesSelectable: !1,
      nodesDraggable: !1,
      ...l
    }
  );
}
function RL({ children: e }) {
  const n = Fn();
  return /* @__PURE__ */ d(NL, { likec4model: n, children: e });
}
const LL = (e) => {
  if (typeof e != "string")
    return;
  const n = e.toLowerCase();
  if (n === "light" || n === "dark")
    return n;
}, $L = (e) => {
  switch (!0) {
    case typeof e == "number":
      return Math.round(e);
    case typeof e == "string":
      return Math.round(parseFloat(e));
  }
}, un = gv()({
  component: zL,
  validateSearch: (e) => ({
    padding: $L(e.padding),
    theme: LL(e.theme)
  })
});
function zL() {
  const { theme: e } = un.useSearch();
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(yv, {}),
    /* @__PURE__ */ d(RL, { children: /* @__PURE__ */ d(ap, {}) })
  ] });
}
var OL = "_15b5f732", VL = "_15b5f733";
function BL() {
  const e = Ec(Fn().$model.views);
  return /* @__PURE__ */ d(
    c1,
    {
      p: { base: "md", sm: "xl" },
      cols: { base: 1, sm: 2, md: 3, lg: 5 },
      spacing: { base: 10, sm: "xl" },
      verticalSpacing: { base: "md", sm: "xl" },
      children: e.map((n) => /* @__PURE__ */ d(jL, { viewId: n }, n))
    }
  );
}
const jL = nt(({ viewId: e }) => {
  const n = Fn().findView(e)?.$view;
  if (!n)
    return null;
  const { id: i, title: r, description: o } = n;
  return /* @__PURE__ */ b(
    Pr,
    {
      shadow: "xs",
      padding: "lg",
      radius: "sm",
      withBorder: !0,
      children: [
        /* @__PURE__ */ d(Pr.Section, { children: /* @__PURE__ */ d(FL, { diagram: n }) }),
        /* @__PURE__ */ d(K, { justify: "space-between", mt: "md", mb: "xs", children: /* @__PURE__ */ d($, { fw: 500, children: r }) }),
        /* @__PURE__ */ d($, { size: "sm", c: "dimmed", children: o }),
        /* @__PURE__ */ d(jt, { to: "/view/$viewId", params: { viewId: i }, search: !0, className: VL })
      ]
    }
  );
});
function FL({ diagram: e }) {
  const { ref: n, inViewport: i } = l1(), [r, o] = ge(i);
  return as(() => {
    i && !r && o(!0);
  }, [i]), /* @__PURE__ */ d(A, { ref: n, className: OL, style: { height: 175 }, children: r && /* @__PURE__ */ d(
    Bs,
    {
      background: "transparent",
      view: e,
      renderIcon: zi,
      fitView: !0,
      fitViewPadding: 0.1
    }
  ) });
}
const WL = /* @__PURE__ */ Iv(() => import("./-index-overview-fhfhEsGb.js"));
function HL() {
  return /* @__PURE__ */ d(Av, { children: /* @__PURE__ */ d(WL, {}) });
}
const qL = bt("/")({
  component: us ? HL : BL
});
var ku = "_1dn84dq1", z0 = "_1dn84dq3", GL = "_1dn84dq4", UL = "_1dn84dq5", YL = "_1dn84dq6";
const O0 = bt("/webcomponent/$")({
  component: XL
});
function XL() {
  const e = Vn(), n = O0.useParams()._splat || "index", { colorScheme: i } = Nl();
  let r = e.basepath.endsWith("/") ? e.basepath : `${e.basepath}/`;
  const o = new URL(
    `${r}likec4-views.js`,
    window.location.href
  ), s = `
    <!DOCTYPE html>
    <html lang="en-US" style="color-scheme: ${i};">
    <head>
      <meta charset="utf-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no" />
      <style>
        * {
          border-width: 0px;
          border-style: solid;
          box-sizing: border-box;
          overflow-wrap: break-word;
        }
        html, body {
          margin: 0;
          background-color: transparent !important;
          width: 100%;
          height: 100%;
          font-size: 16px;
        }
        body {
          position: relative;
          min-height: 100%;
          padding: clamp(0.5rem, 5vh, 4rem) clamp(0.5rem, 5vw, 5rem);
        }
      </style>
    </head>
    <body>
      <script type="module" src="${o.href}"><\/script>
      <${Lo.View} view-id="${encodeURIComponent(n)}"></${Lo.View}>
    </body>
    </html>
  `;
  return /* @__PURE__ */ d(Cr, { direction: "column", className: UL, children: /* @__PURE__ */ d(A, { className: YL, children: /* @__PURE__ */ d(
    "iframe",
    {
      srcDoc: s,
      allowtransparency: "true"
    }
  ) }) });
}
const V0 = (e) => "type" in e && ["file", "folder", "view", "deployment-view"].includes(e.type);
function KL(e) {
  return e === "" ? "" : e.split("/").slice(0, -1).join("/");
}
function Zf(e, n) {
  return e.children.length === 0 && n.children.length > 0 ? 1 : e.children.length > 0 && n.children.length === 0 ? -1 : Ol(e.label, n.label);
}
function ZL(e, n) {
  const i = {
    value: "",
    label: "Diagrams",
    type: "folder",
    children: []
  }, r = (o) => {
    let s = i;
    if (o === "")
      return s;
    const a = o.split("/"), l = ["@fs"];
    for (; a.length; ) {
      const c = a.shift();
      l.push(c);
      const u = l.join("/");
      let f = Dc(s.children, (h) => h.value === u);
      f || (f = { label: c, value: u, type: "folder", children: [] }, s.children.push(f)), s = f;
    }
    return s;
  };
  for (const o of e) {
    let s;
    switch (n) {
      case "by-files":
        s = o.relativePath ?? "";
        break;
      case "by-folders":
        s = KL(o.relativePath ?? "");
        break;
      case "none":
        s = "";
        break;
      default:
        Pt(n);
    }
    const a = r(s);
    a.children.push({
      value: o.id,
      label: o.title ?? o.id,
      type: U1.isDeployment(o) ? "deployment-view" : "view",
      children: []
    }), a !== i && (a.children.sort(Zf), n === "by-files" && a.type !== "file" && (a.type = "file"));
  }
  return i.children.sort(Zf);
}
function JL(e = "by-files") {
  const n = Fn().$model.views;
  return ce(() => ZL(eS(n), e), [n, e]);
}
const QL = (e) => V0(e) && e.type === "file", e4 = ({ node: e, expanded: n }) => QL(e) ? /* @__PURE__ */ d(wt, { size: "sm", variant: "transparent", color: "indigo", children: /* @__PURE__ */ d(X_, { size: 16 }) }) : /* @__PURE__ */ d(wt, { size: "sm", variant: "transparent", color: "violet", children: n ? /* @__PURE__ */ d(Z_, { size: 16 }) : /* @__PURE__ */ d(vC, { size: 16 }) }), t4 = /* @__PURE__ */ nt(({ groupBy: e }) => {
  const n = JL(e), { viewId: i } = lp({
    from: "/view/$viewId"
  }), r = Vn(), o = it(!0).findView(i)?.$view, s = Xr({
    multiple: !1
  }), a = o?.relativePath ?? null;
  Nn(() => {
    s.collapseAllNodes();
  }, [e]), ie(() => {
    if (a) {
      const c = a.split("/");
      let u = "@fs";
      for (const f of c)
        u += `/${f}`, s.expand(u);
    }
  }, [a, e]), ie(() => {
    s.select(i);
  }, [i]);
  const l = cs();
  return /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d(
    Kr,
    {
      allowRangeSelection: !1,
      tree: s,
      data: n,
      styles: {
        node: {
          marginTop: 2,
          marginBottom: 2
        }
      },
      levelOffset: "md",
      renderNode: ({ node: c, selected: u, expanded: f, elementProps: h, hasChildren: p }) => /* @__PURE__ */ d(n4, { viewId: p ? null : c.value, ...h, children: /* @__PURE__ */ d(
        le,
        {
          fullWidth: !0,
          color: l === "light" ? "dark" : "gray",
          variant: u ? "transparent" : "subtle",
          size: "sm",
          fz: "sm",
          fw: p ? "600" : "500",
          justify: "flex-start",
          styles: {
            section: {
              opacity: 0.5
            }
          },
          leftSection: /* @__PURE__ */ b(H, { children: [
            !p && c.value === "index" && /* @__PURE__ */ d(Hg, { size: 14, opacity: 0.7 }),
            !p && c.value !== "index" && V0(c) && /* @__PURE__ */ b(H, { children: [
              c.type === "deployment-view" && /* @__PURE__ */ d(Fc, { size: 14 }),
              c.type === "view" && /* @__PURE__ */ d(Fg, { size: 14 })
            ] }),
            p && /* @__PURE__ */ d(e4, { node: c, expanded: f })
          ] }),
          ...!p && {
            onClick: (m) => {
              m.stopPropagation(), r.buildAndCommitLocation({
                params: {
                  viewId: c.value
                }
              });
            }
          },
          children: c.label
        }
      ) })
    }
  ) });
});
function n4({
  viewId: e,
  children: n,
  ...i
}) {
  return e ? /* @__PURE__ */ d(A, { ...i, children: /* @__PURE__ */ d(i4, { viewId: e, onClick: i.onClick, children: n }) }) : /* @__PURE__ */ d(A, { ...i, children: n });
}
function i4({
  viewId: e,
  children: n,
  onClick: i
}) {
  const r = it(!0, "layouted").view(e).$view;
  if (!r)
    return n;
  const o = Math.max(r.bounds.width / 400, r.bounds.height / 300), s = Math.round(r.bounds.width / o), a = Math.round(r.bounds.height / o);
  return /* @__PURE__ */ b(Sp, { position: "right-start", openDelay: 400, closeDelay: 100, keepMounted: !1, shadow: "lg", children: [
    /* @__PURE__ */ d(_p, { children: n }),
    /* @__PURE__ */ d(Cp, { style: { width: s, height: a }, p: "xs", onClick: i, children: /* @__PURE__ */ d(
      Bs,
      {
        view: r,
        renderIcon: zi,
        fitView: !0,
        fitViewPadding: 0,
        enableElementDetails: !1,
        initialWidth: s,
        initialHeight: a
      }
    ) })
  ] });
}
const qr = Os(!1);
wu(qr, () => {
  qr.set(!1);
});
const r4 = () => co(qr), Ui = {
  open: () => qr.set(!0),
  close: () => qr.set(!1)
};
function o4() {
  const e = r4(), [n, i] = Dl({
    key: "sidebar-drawer-grouping",
    defaultValue: "by-files"
  });
  return /* @__PURE__ */ b(
    Yn.Root,
    {
      keepMounted: !0,
      opened: e,
      scrollAreaComponent: Qe.Autosize,
      onClose: Ui.close,
      children: [
        /* @__PURE__ */ d(Yn.Overlay, { blur: 0.5 }),
        /* @__PURE__ */ b(Yn.Content, { children: [
          /* @__PURE__ */ b(Yn.Header, { children: [
            /* @__PURE__ */ b(K, { gap: "xs", children: [
              /* @__PURE__ */ d(
                le,
                {
                  component: jt,
                  to: "/",
                  leftSection: /* @__PURE__ */ d(q_, { size: 14 }),
                  color: "dimmed",
                  variant: "subtle",
                  px: Re(5),
                  styles: {
                    section: {
                      marginInlineEnd: 4
                    }
                  },
                  size: "xs",
                  children: "Overview"
                }
              ),
              /* @__PURE__ */ d(
                gp,
                {
                  size: "xs",
                  withItemsBorders: !1,
                  value: n,
                  onChange: i,
                  data: [
                    { label: "By files", value: "by-files" },
                    { label: "By folders", value: "by-folders" },
                    { label: "List", value: "none" }
                  ]
                }
              ),
              /* @__PURE__ */ d(
                le,
                {
                  leftSection: /* @__PURE__ */ d(Hg, { size: 12, stroke: 2 }),
                  color: "dimmed",
                  variant: "subtle",
                  px: Re(5),
                  styles: {
                    section: {
                      marginInlineEnd: 4
                    }
                  },
                  size: "xs",
                  renderRoot: (r) => /* @__PURE__ */ d(
                    jt,
                    {
                      to: "/view/$viewId",
                      params: { viewId: "index" },
                      ...r
                    }
                  ),
                  children: "Open index"
                }
              )
            ] }),
            /* @__PURE__ */ d(Yn.CloseButton, {})
          ] }),
          /* @__PURE__ */ d(Yn.Body, { children: /* @__PURE__ */ d(t4, { groupBy: n }) })
        ] })
      ]
    }
  );
}
function s4() {
  const { setColorScheme: e } = Nl(), n = cs("light", { getInitialValueInEffect: !0 });
  return /* @__PURE__ */ d(
    se,
    {
      visibleFrom: "sm",
      size: "md",
      variant: "subtle",
      color: "gray",
      onClick: () => e(n === "light" ? "dark" : "light"),
      "aria-label": "Toggle color scheme",
      children: n === "light" ? /* @__PURE__ */ d(uC, { stroke: 1.5 }) : /* @__PURE__ */ d(mC, { stroke: 1.5 })
    }
  );
}
var a4 = "yr9aef0";
const B0 = () => /* @__PURE__ */ d(
  Er,
  {
    color: "yellow",
    icon: /* @__PURE__ */ d(zc, {}),
    title: "Localhost URL",
    styles: { body: { gap: Re(4) } },
    children: /* @__PURE__ */ d($, { c: "yellow", size: "sm", children: "You need to deploy your project to make it available on the internet" })
  }
), gl = ({ copied: e, copy: n }) => /* @__PURE__ */ d(
  le,
  {
    size: "xs",
    color: e ? "teal" : "gray",
    variant: "light",
    leftSection: e ? /* @__PURE__ */ d(Ss, { style: { width: Re(16) } }) : /* @__PURE__ */ d(Vc, { style: { width: Re(16) } }),
    onClick: n,
    children: e ? "Copied" : "Copy to clipboard"
  }
), l4 = ({ diagram: e }) => {
  const n = Vn(), { colorScheme: i } = Nl(), [r, o] = ge(i), s = 20, a = new URL(
    n.buildLocation({
      to: "/embed/$viewId",
      params: { viewId: e.id },
      search: {
        padding: s,
        theme: r !== "auto" ? r : void 0
      }
    }).href,
    window.location.href
  ), l = e.bounds.width + s * 2, c = e.bounds.height + s * 2, u = a.href, f = `
<div style="aspect-ratio:${l}/${c};width:100%;height:auto;max-width:${l}px;margin:0 auto">
  <iframe src="${u}" width="100%" height="100%" style="border:0;background:transparent;"></iframe>
</div>
`.trim();
  return /* @__PURE__ */ b(be, { children: [
    f.includes("http://localhost") && /* @__PURE__ */ d(B0, {}),
    /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d($, { size: "sm", children: "Embedded view is an iframe with a static diagram" }) }),
    /* @__PURE__ */ b(be, { gap: "xs", children: [
      /* @__PURE__ */ b(K, { justify: "space-between", children: [
        /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d($, { fw: "500", size: "sm", children: "HTML" }) }),
        /* @__PURE__ */ b(K, { gap: "xs", children: [
          /* @__PURE__ */ d(se, { component: "a", href: u, target: "_blank", variant: "light", color: "gray", children: /* @__PURE__ */ d(Bc, {}) }),
          /* @__PURE__ */ d(_r, { value: f, timeout: 1500, children: gl })
        ] })
      ] }),
      /* @__PURE__ */ d(xt, { block: !0, children: f }),
      /* @__PURE__ */ d(
        A,
        {
          style: {
            alignSelf: "flex-start"
          },
          children: /* @__PURE__ */ d(
            u1,
            {
              label: "Color scheme",
              value: r,
              allowDeselect: !1,
              onChange: (h) => o(h ?? "auto"),
              data: [
                { value: "auto", label: "Auto" },
                { value: "light", label: "Light" },
                { value: "dark", label: "Dark" }
              ]
            }
          )
        }
      )
    ] })
  ] });
};
function c4({ diagram: e }) {
  const n = Vn();
  let i = n.basepath.endsWith("/") ? n.basepath : `${n.basepath}/`;
  const s = `
  <script module src="${new URL(
    `${i}likec4-views.js`,
    window.location.href
  ).href}"><\/script>
`.trim(), a = `
  <${Lo.View} view-id="${encodeURIComponent(e.id)}"></${Lo.View}>
`.trim(), l = n.buildLocation(
    {
      to: "/webcomponent/$",
      params: { _splat: e.id },
      search: !0
    }
  );
  return /* @__PURE__ */ b(be, { children: [
    s.includes("http://localhost") && /* @__PURE__ */ d(B0, {}),
    /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d($, { size: "sm", children: "Add this script to your page:" }) }),
    /* @__PURE__ */ b(be, { gap: "xs", children: [
      /* @__PURE__ */ b(K, { justify: "space-between", children: [
        /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d($, { fw: "500", size: "sm", children: "JavaScript" }) }),
        /* @__PURE__ */ b(K, { gap: "xs", children: [
          /* @__PURE__ */ d(se, { component: "a", href: l.href, target: "_blank", variant: "light", color: "gray", children: /* @__PURE__ */ d(Bc, {}) }),
          /* @__PURE__ */ d(
            _r,
            {
              value: s,
              timeout: 1500,
              children: gl
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ d(xt, { block: !0, children: s }),
      /* @__PURE__ */ d(A, { children: /* @__PURE__ */ b($, { size: "sm", c: "dimmed", children: [
        "This script defines a custom element (webcomponent) that renders your diagrams.",
        /* @__PURE__ */ d("br", {}),
        "Script must be inserted once in the ",
        /* @__PURE__ */ d("code", { children: "<head>" }),
        " or at the end of the ",
        /* @__PURE__ */ d("code", { children: "<body>" }),
        " ",
        "tag."
      ] }) })
    ] }),
    /* @__PURE__ */ b(be, { gap: "xs", children: [
      /* @__PURE__ */ b(K, { justify: "space-between", children: [
        /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d($, { fw: "500", size: "sm", children: "HTML" }) }),
        /* @__PURE__ */ d(A, { children: /* @__PURE__ */ d(
          _r,
          {
            value: a,
            timeout: 1500,
            children: gl
          }
        ) })
      ] }),
      /* @__PURE__ */ d(xt, { block: !0, children: a }),
      /* @__PURE__ */ d(A, { children: /* @__PURE__ */ b($, { size: "sm", c: "dimmed", children: [
        "Insert this code to your page. Page may have multiple ",
        /* @__PURE__ */ d("code", { children: "<likec4-view>" }),
        "."
      ] }) })
    ] })
  ] });
}
function u4({
  opened: e,
  onClose: n,
  diagram: i
}) {
  const [r, o] = ge("webcomponent");
  return /* @__PURE__ */ b(
    d1,
    {
      size: "xl",
      opened: e,
      keepMounted: !0,
      onClose: n,
      children: [
        /* @__PURE__ */ d(h1, { backgroundOpacity: 0.5, blur: 3 }),
        /* @__PURE__ */ d(f1, { children: /* @__PURE__ */ b(p1, { children: [
          /* @__PURE__ */ b(Al, { value: r, onChange: (s) => o(s ?? "webcomponent"), children: [
            /* @__PURE__ */ b(Il, { children: [
              /* @__PURE__ */ d(Tr, { value: "webcomponent", children: "Webcomponent" }),
              /* @__PURE__ */ d(Tr, { value: "embed", children: "Embedded" })
            ] }),
            /* @__PURE__ */ d(Qt, { value: "embed", pt: "md", children: /* @__PURE__ */ d(l4, { diagram: i }) }),
            /* @__PURE__ */ d(Qt, { value: "webcomponent", pt: "md", children: /* @__PURE__ */ d(c4, { diagram: i }) })
          ] }),
          /* @__PURE__ */ d(K, { justify: "flex-end", mt: "lg", children: /* @__PURE__ */ d(le, { size: "sm", onClick: n, children: "Close" }) })
        ] }) })
      ]
    }
  );
}
function d4({ diagram: e }) {
  const i = vv().matches.some(
    ({ routeId: c }) => c === "/view/$viewId/" || c === "/view/$viewId/editor"
  ), { breakpoints: r } = m1(), o = g1(`(min-width: ${r.md})`) ?? !1, [s, { open: a, close: l }] = bp(!1);
  return /* @__PURE__ */ b(
    ls,
    {
      className: a4,
      pos: "fixed",
      top: "0.5rem",
      right: "0.5rem",
      p: 4,
      radius: "sm",
      shadow: "lg",
      children: [
        /* @__PURE__ */ b(K, { gap: o ? 6 : 4, wrap: "nowrap", children: [
          i ? /* @__PURE__ */ b(H, { children: [
            /* @__PURE__ */ d(le, { size: o ? "sm" : "xs", leftSection: /* @__PURE__ */ d(pC, { size: 14 }), onClick: a, children: "Share" }),
            /* @__PURE__ */ d(h4, {})
          ] }) : /* @__PURE__ */ d(
            le,
            {
              component: jt,
              to: "/view/$viewId/",
              size: o ? "sm" : "xs",
              variant: "subtle",
              color: "gray",
              children: "Back to diagram"
            }
          ),
          /* @__PURE__ */ d(Tl, { orientation: "vertical", visibleFrom: "md" }),
          /* @__PURE__ */ d(s4, {}),
          /* @__PURE__ */ d(Ro, {})
        ] }),
        /* @__PURE__ */ d(
          u4,
          {
            opened: s,
            onClose: l,
            diagram: e
          }
        )
      ]
    }
  );
}
function h4() {
  const e = lp({
    from: "/view/$viewId"
  }), n = Y1(e.viewId);
  return /* @__PURE__ */ b(wn, { shadow: "md", width: 200, trigger: "click-hover", openDelay: 200, children: [
    /* @__PURE__ */ d(El, { children: /* @__PURE__ */ d(
      le,
      {
        variant: "subtle",
        size: "sm",
        color: "gray",
        px: "sm",
        rightSection: /* @__PURE__ */ d(U_, { opacity: 0.5, size: 14 }),
        visibleFrom: "md",
        children: "Export"
      }
    ) }),
    /* @__PURE__ */ b(Pl, { children: [
      /* @__PURE__ */ d(Na, { children: "Current view" }),
      n ? /* @__PURE__ */ d(
        _t,
        {
          component: "a",
          href: n,
          download: `${e.viewId}.png`,
          target: "_blank",
          children: "Export as .png"
        }
      ) : /* @__PURE__ */ d(
        _t,
        {
          renderRoot: (i) => /* @__PURE__ */ d(
            jt,
            {
              target: "_blank",
              to: "/export/$viewId",
              search: { download: !0 },
              params: e,
              ...i
            }
          ),
          children: "Export as .png"
        }
      ),
      /* @__PURE__ */ d(
        _t,
        {
          renderRoot: (i) => /* @__PURE__ */ d(
            jt,
            {
              to: "/view/$viewId/dot",
              search: !0,
              params: e,
              ...i
            }
          ),
          children: "Export as .dot"
        }
      ),
      /* @__PURE__ */ d(
        _t,
        {
          renderRoot: (i) => /* @__PURE__ */ d(
            jt,
            {
              to: "/view/$viewId/d2",
              search: !0,
              params: e,
              ...i
            }
          ),
          children: "Export as .d2"
        }
      ),
      /* @__PURE__ */ d(
        _t,
        {
          renderRoot: (i) => /* @__PURE__ */ d(
            jt,
            {
              to: "/view/$viewId/mmd",
              search: !0,
              params: e,
              ...i
            }
          ),
          children: "Export as .mmd"
        }
      ),
      /* @__PURE__ */ d(_t, { disabled: !0, children: "Export to Draw.io" }),
      /* @__PURE__ */ d(_t, { disabled: !0, children: "Export to Miro" }),
      /* @__PURE__ */ d(_t, { disabled: !0, children: "Export to Notion" })
    ] })
  ] });
}
const Su = bt("/view/$viewId")({
  component: p4
});
function f4({ error: e, resetErrorBoundary: n }) {
  const i = Vn(), { viewId: r } = Su.useParams();
  return Nn(() => {
    n();
  }, [r]), wv(e) ? /* @__PURE__ */ d(Da, { my: "md", children: /* @__PURE__ */ b(Er, { variant: "light", color: "orange", children: [
    /* @__PURE__ */ b($, { c: "orange", fz: "md", children: [
      "The diagram",
      " ",
      /* @__PURE__ */ d(xt, { color: "orange", children: r }),
      " ",
      "does not exist or contains errors"
    ] }),
    /* @__PURE__ */ d(
      le,
      {
        onClick: () => {
          n(), i.navigate({
            to: "/",
            search: !0
          });
        },
        variant: "light",
        color: "orange",
        mt: "lg",
        size: "xs",
        children: "Go to overview"
      }
    )
  ] }) }) : /* @__PURE__ */ d(Da, { my: "md", children: /* @__PURE__ */ b(Er, { variant: "filled", color: "red", title: "Something went wrong", children: [
    /* @__PURE__ */ d(xt, { block: !0, color: "red", children: e.stack ?? e.message }),
    /* @__PURE__ */ d(le, { onClick: n, color: "red", variant: "white", mt: "lg", size: "xs", children: "Try again" })
  ] }) });
}
function p4() {
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ d(A, { className: z0, children: /* @__PURE__ */ d(Ly, { FallbackComponent: f4, children: /* @__PURE__ */ d(ap, {}) }) }),
    /* @__PURE__ */ d(m4, {}),
    !us && /* @__PURE__ */ d(o4, {})
  ] });
}
function m4() {
  const e = Fn().findView(Su.useParams().viewId)?.$view;
  return e ? /* @__PURE__ */ d(d4, { diagram: e }) : null;
}
const Et = {
  dagre: {
    ranksep: 60,
    nodesep: 35,
    edgesep: 25
  },
  edgeLabel: {
    width: 120,
    height: 10,
    minlen: 1,
    weight: 1
  },
  nodeWidth: 340,
  nodeHeight: 190,
  compound: {
    labelHeight: 2,
    paddingTop: 50,
    paddingBottom: 32
  }
};
function g4() {
  const e = new Gi.graphlib.Graph({
    directed: !0,
    compound: !0,
    multigraph: !0
  });
  return e.setGraph({
    ...Et.dagre,
    rankdir: "LR"
  }), e.setDefaultEdgeLabel(() => ({ ...Et.edgeLabel })), e.setDefaultNodeLabel(() => ({})), e;
}
const yl = "-port";
function y4(e) {
  const n = An([...e]), i = new Set(n), r = new Map(n.map((a) => [a.id, a])), o = new xi(() => null), s = n.reduce((a, l, c, u) => (a.set(
    l,
    u.slice(c + 1).filter(Rp(l)).map((f) => (i.delete(f), f)).reduce((f, h) => (f.some(Ar(h)) || (f.push(h), o.set(h, l)), f), [])
  ), a), new xi(() => []));
  return {
    sorted: n,
    byId: (a) => xe(r.get(a), `Element not found by id: ${a}`),
    root: i,
    parent: (a) => o.get(a),
    children: (a) => s.get(a)
  };
}
function Ma(e, n, i) {
  const r = new xi((s) => ({
    id: `${e}-${s}`,
    portId: `${e}-${s}`
  })), o = y4(n);
  for (const s of o.sorted) {
    const a = o.children(s).length > 0, l = s.id, c = `${e}-${l}`, u = a ? `${c}${yl}` : c;
    r.set(l, {
      id: c,
      portId: u
    }), i.setNode(c, {
      element: s,
      isCompound: a,
      portId: u,
      inPorts: [],
      outPorts: [],
      width: Et.nodeWidth,
      height: Et.nodeHeight
    }), a && (i.setNode(u, {
      element: s,
      portId: u,
      isCompound: a,
      inPorts: [],
      outPorts: [],
      width: Et.nodeWidth - Et.dagre.ranksep,
      height: Et.compound.labelHeight
    }), i.setParent(u, c));
    const f = o.parent(s);
    f && i.setParent(c, `${e}-${f.id}`);
  }
  return {
    ...o,
    byId: (s) => {
      const a = o.byId(s), l = r.get(a.id);
      return {
        element: a,
        graph: l
      };
    },
    graphNodes: r
  };
}
function v4(e) {
  return Gi.layout(e, {
    // disableOptimalOrderHeuristic: true,
  }), (n) => {
    const i = e.node(n), { x: r, y: o, width: s, height: a } = i;
    return {
      position: {
        x: r - Math.round(s / 2),
        y: o - Math.round(a / 2)
      },
      width: s,
      height: a
    };
  };
}
function w4(e) {
  const n = g4(), i = Ma("in", e.incomers, n), r = Ma("subject", e.subjects, n), o = Ma("out", e.outgoers, n), s = [];
  ve(
    Ig(
      ve(
        Mr(e.incoming),
        Ce((y) => ({
          id: y.source.id,
          source: i.byId(y.source.id).graph,
          target: r.byId(y.target.id).graph,
          relation: y
        })),
        // Sort by source
        An
      ),
      ve(
        Mr(e.outgoing),
        Ce((y) => ({
          id: y.target.id,
          source: r.byId(y.source.id).graph,
          target: o.byId(y.target.id).graph,
          relation: y
        })),
        // Sort by target
        An
      )
    ),
    Ce((y) => ({
      ...y,
      expr: `${y.source.id}->${y.target.id}`
    })),
    // Group if same source and target
    Tg(et("expr")),
    Mg((y) => {
      const v = y[0].source, w = y[0].target, x = y[0].expr;
      n.node(v.id).outPorts.push(w.id), n.node(w.id).inPorts.push(v.id), n.setEdge(v.portId, w.portId, {
        ...Et.edgeLabel
      }, x), s.push({
        name: x,
        source: v.id,
        target: w.id,
        relations: Ce(y, et("relation"))
      });
    })
  );
  for (const y of r.graphNodes.values()) {
    const v = y.id, w = n.node(v);
    if (w.isCompound)
      continue;
    const x = Math.max(n.inEdges(v)?.length ?? 0, n.outEdges(v)?.length ?? 0);
    x > 2 && (w.height = w.height + (x - 3) * 14);
  }
  const a = v4(n), l = [
    ...i.graphNodes.values(),
    ...r.graphNodes.values(),
    ...o.graphNodes.values()
  ], c = ve(
    l,
    // Compound nodes have different portId
    Gt((y) => y.id === y.portId),
    to((y) => [y.id, a(y.id)])
  );
  function u(y) {
    return c[y] ??= ve(
      n.children(y) ?? [],
      Gt((v) => !v.endsWith(yl)),
      Ce((v) => u(v)),
      Sg((v) => {
        me(v.length > 0, `Node ${y} has no nested nodes`);
      }),
      Ei((v, w) => ({
        minY: Math.min(v.minY, w.position.y),
        maxY: Math.max(v.maxY, w.position.y + w.height)
      }), { minY: 1 / 0, maxY: -1 / 0 }),
      ({ minY: v, maxY: w }) => {
        const {
          position: { x },
          width: k
        } = a(y);
        return v = v - Et.compound.paddingTop, w = w + Et.compound.paddingBottom, {
          position: {
            x,
            y: v
          },
          width: k,
          height: w - v
        };
      }
    );
  }
  function f(y) {
    const v = n.parent(y);
    return v ? f(v) + 1 : 0;
  }
  function h(y) {
    const v = n.children(y) ?? [];
    return v.length === 0 ? 0 : 1 + Math.max(...v.map(h));
  }
  let p = 0, m = 0;
  const g = l.map(({ id: y }) => {
    const { element: v } = n.node(y);
    let { position: w, width: x, height: k } = u(y);
    const _ = n.parent(y), S = (n.children(y) ?? []).filter((C) => !C.endsWith(yl));
    p = Math.min(p, w.x), m = Math.min(m, w.y);
    const P = v.defaultView?.id ?? null;
    return {
      id: y,
      parent: _ ?? null,
      position: [w.x, w.y],
      title: v.title,
      description: v.description,
      technology: v.technology,
      tags: null,
      links: null,
      color: v.color,
      shape: v.shape,
      modelRef: v.id,
      kind: v.kind,
      level: f(y),
      labelBBox: {
        x: w.x,
        y: w.y,
        width: x,
        height: k
      },
      style: {
        ...v.$element.style
      },
      navigateTo: P,
      inEdges: [],
      outEdges: [],
      ...S.length > 0 && { depth: h(y) },
      children: S,
      width: x,
      height: k
    };
  });
  return {
    bounds: {
      x: p,
      y: m,
      width: n.graph().width ?? 100,
      height: n.graph().height ?? 100
    },
    nodes: g,
    edges: n.edges().map((y) => {
      const v = n.edge(y), w = y.name;
      me(w, `Edge ${y} has no name`);
      const { name: x, source: k, target: _, relations: S } = Dc(s, (C) => C.name === w), P = v.points.map((C) => [C.x, C.y]);
      return me(ut(P, 1), `Edge ${x} has less than 2 points`), {
        id: x,
        source: k,
        target: _,
        label: null,
        relations: S.map((C) => C.id),
        parent: null,
        points: P
      };
    })
  };
}
function x4(e) {
  const n = Fn();
  return ce(() => ({
    id: `relationships-${e}`,
    title: `Relationships of ${e}`,
    description: null,
    autoLayout: {
      direction: "LR"
    },
    tags: null,
    links: null,
    hash: "empty",
    customColorDefinitions: {},
    ...w4(Hu(e, n))
  }), [n, e, Hu]);
}
const j0 = bt("/relationships/$fqn")({
  component: b4
});
function b4() {
  const { fqn: e } = j0.useParams();
  return x4(e), /* @__PURE__ */ d(H, { children: /* @__PURE__ */ d(A, { className: z0 }) });
}
function F0(e = !0) {
  QS(() => {
    const n = document.body.parentElement;
    if (!n || e !== !0) return;
    const i = "transparent-bg";
    return n.classList.add(i), () => {
      n.classList.remove(i);
    };
  }, [e]);
}
function js(e) {
  return Fn().findView(e)?.$view ?? null;
}
async function k4({
  pngFilename: e,
  viewport: n
}) {
  const { toBlob: i } = await import("./index-B1tnNgDX.js"), {
    width: r,
    height: o
  } = n.getBoundingClientRect();
  try {
    const l = await i(n, {
      backgroundColor: "transparent",
      width: r,
      height: o,
      cacheBust: !0,
      imagePlaceholder: "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="
    });
    if (!l)
      throw new Error("Failed to create PNG blob");
    var s = URL.createObjectURL(l), a = document.createElement("a");
    a.setAttribute("download", `${e}.png`), a.href = s, document.body.appendChild(a), a.click(), await new Promise((c) => setTimeout(c, 1e3)), document.body.removeChild(a), URL.revokeObjectURL(s), window.close();
  } catch (l) {
    console.error(l), window.alert("Failed to export to PNG, check the console for more details.");
  }
}
const S4 = (e) => {
  if (typeof e == "boolean")
    return e;
  if (typeof e == "string")
    return e === "true";
}, vl = bt("/export/$viewId")({
  component: _4,
  validateSearch: (e) => ({
    download: S4(e.download)
  })
});
function _4() {
  const {
    padding: e = 20,
    download: n = !1
  } = vl.useSearch(), { viewId: i } = vl.useParams(), r = js(i), o = J(null), s = J(null), a = J(!1);
  if (F0(), ie(() => {
    document.querySelectorAll(".react-flow__viewport").forEach((u) => {
      u.style.transform = "";
    });
  }), Nc(
    () => {
      const u = o.current;
      if (!n || !u || !r)
        return;
      const f = s.current;
      f && (f.style.display = "none"), !a.current && (a.current = !0, k4({
        pngFilename: i,
        viewport: u
      }));
    },
    [],
    500
  ), !r)
    throw Bn();
  const l = r.bounds.width + e * 2, c = r.bounds.height + e * 2;
  return /* @__PURE__ */ b(
    A,
    {
      ref: o,
      className: GL,
      role: "presentation",
      style: {
        padding: e,
        minWidth: l,
        width: l,
        minHeight: c,
        height: c
      },
      children: [
        n && /* @__PURE__ */ d(y1, { ref: s, visible: !0 }),
        /* @__PURE__ */ d(
          Bs,
          {
            view: r,
            fitView: !1,
            fitViewPadding: 0,
            background: "transparent",
            renderIcon: zi,
            initialWidth: r.bounds.width,
            initialHeight: r.bounds.height
          }
        )
      ]
    }
  );
}
const wl = bt("/embed/$viewId")({
  component: C4
});
function C4() {
  const { padding: e = 20 } = wl.useSearch(), { viewId: n } = wl.useParams(), i = js(n);
  if (F0(!!i), !i)
    throw Bn();
  return /* @__PURE__ */ d(
    A,
    {
      pos: "absolute",
      style: {
        top: 0,
        left: "50%",
        boxSizing: "border-box",
        padding: e,
        transform: "translateX(-50%)",
        aspectRatio: `${i.bounds.width + e * 2} / ${i.bounds.height + e * 2}`,
        width: "100vw",
        maxWidth: i.bounds.width + e * 2,
        height: "auto",
        maxHeight: "100vh"
      },
      children: /* @__PURE__ */ d(
        Bs,
        {
          view: i,
          fitView: !0,
          background: "transparent",
          renderIcon: zi,
          initialWidth: i.bounds.width,
          initialHeight: i.bounds.height
        }
      )
    }
  );
}
const W0 = bt("/view/$viewId/")({
  component: E4
});
function E4() {
  const e = Vn(), { viewId: n } = W0.useParams(), i = js(n), r = q((a) => {
    e.navigate({
      to: "/view/$viewId",
      params: { viewId: a },
      search: !0
    });
  });
  if (!i)
    throw Bn();
  const s = (i.notation?.elements ?? []).length > 0;
  return /* @__PURE__ */ d(
    bu,
    {
      view: i,
      readonly: !0,
      zoomable: !0,
      pannable: !0,
      controls: !0,
      fitViewPadding: 0.12,
      showDiagramTitle: !0,
      showNavigationButtons: !0,
      enableFocusMode: !0,
      enableDynamicViewWalkthrough: !0,
      enableElementDetails: !0,
      enableRelationshipDetails: !0,
      enableRelationshipBrowser: !0,
      experimentalEdgeEditing: !1,
      showNotations: Ep || s,
      nodesDraggable: !1,
      nodesSelectable: !0,
      renderIcon: zi,
      onNavigateTo: r,
      onBurgerMenuClick: us ? () => {
        e.navigate({
          to: "/",
          search: !0
        });
      } : Ui.open
    }
  );
}
const {
  createElement: Ni,
  createContext: P4,
  forwardRef: H0,
  useCallback: Ge,
  useContext: q0,
  useEffect: Tn,
  useImperativeHandle: G0,
  useLayoutEffect: T4,
  useMemo: M4,
  useRef: Ye,
  useState: vi
} = Yr, Jf = Yr[`useId${Math.random()}`.slice(0, 5)], A4 = T4, Fs = P4(null);
Fs.displayName = "PanelGroupContext";
const Mn = A4, I4 = typeof Jf == "function" ? Jf : () => null;
let D4 = 0;
function _u(e = null) {
  const n = I4(), i = Ye(e || n || null);
  return i.current === null && (i.current = "" + D4++), e ?? i.current;
}
function U0({
  children: e,
  className: n = "",
  collapsedSize: i,
  collapsible: r,
  defaultSize: o,
  forwardedRef: s,
  id: a,
  maxSize: l,
  minSize: c,
  onCollapse: u,
  onExpand: f,
  onResize: h,
  order: p,
  style: m,
  tagName: g = "div",
  ...y
}) {
  const v = q0(Fs);
  if (v === null)
    throw Error("Panel components must be rendered within a PanelGroup container");
  const {
    collapsePanel: w,
    expandPanel: x,
    getPanelSize: k,
    getPanelStyle: _,
    groupId: S,
    isPanelCollapsed: P,
    reevaluatePanelConstraints: C,
    registerPanel: T,
    resizePanel: M,
    unregisterPanel: D
  } = v, L = _u(a), z = Ye({
    callbacks: {
      onCollapse: u,
      onExpand: f,
      onResize: h
    },
    constraints: {
      collapsedSize: i,
      collapsible: r,
      defaultSize: o,
      maxSize: l,
      minSize: c
    },
    id: L,
    idIsFromProps: a !== void 0,
    order: p
  });
  Ye({
    didLogMissingDefaultSizeWarning: !1
  }), Mn(() => {
    const {
      callbacks: ee,
      constraints: Z
    } = z.current, ae = {
      ...Z
    };
    z.current.id = L, z.current.idIsFromProps = a !== void 0, z.current.order = p, ee.onCollapse = u, ee.onExpand = f, ee.onResize = h, Z.collapsedSize = i, Z.collapsible = r, Z.defaultSize = o, Z.maxSize = l, Z.minSize = c, (ae.collapsedSize !== Z.collapsedSize || ae.collapsible !== Z.collapsible || ae.maxSize !== Z.maxSize || ae.minSize !== Z.minSize) && C(z.current, ae);
  }), Mn(() => {
    const ee = z.current;
    return T(ee), () => {
      D(ee);
    };
  }, [p, L, T, D]), G0(s, () => ({
    collapse: () => {
      w(z.current);
    },
    expand: (ee) => {
      x(z.current, ee);
    },
    getId() {
      return L;
    },
    getSize() {
      return k(z.current);
    },
    isCollapsed() {
      return P(z.current);
    },
    isExpanded() {
      return !P(z.current);
    },
    resize: (ee) => {
      M(z.current, ee);
    }
  }), [w, x, k, P, L, M]);
  const Q = _(z.current, o);
  return Ni(g, {
    ...y,
    children: e,
    className: n,
    id: a,
    style: {
      ...Q,
      ...m
    },
    // CSS selectors
    "data-panel": "",
    "data-panel-collapsible": r || void 0,
    "data-panel-group-id": S,
    "data-panel-id": L,
    "data-panel-size": parseFloat("" + Q.flexGrow).toFixed(1)
  });
}
const zn = H0((e, n) => Ni(U0, {
  ...e,
  forwardedRef: n
}));
U0.displayName = "Panel";
zn.displayName = "forwardRef(Panel)";
let xl = null, _n = null;
function N4(e, n) {
  if (n) {
    const i = (n & J0) !== 0, r = (n & Q0) !== 0, o = (n & ev) !== 0, s = (n & tv) !== 0;
    if (i)
      return o ? "se-resize" : s ? "ne-resize" : "e-resize";
    if (r)
      return o ? "sw-resize" : s ? "nw-resize" : "w-resize";
    if (o)
      return "s-resize";
    if (s)
      return "n-resize";
  }
  switch (e) {
    case "horizontal":
      return "ew-resize";
    case "intersection":
      return "move";
    case "vertical":
      return "ns-resize";
  }
}
function R4() {
  _n !== null && (document.head.removeChild(_n), xl = null, _n = null);
}
function Aa(e, n) {
  const i = N4(e, n);
  xl !== i && (xl = i, _n === null && (_n = document.createElement("style"), document.head.appendChild(_n)), _n.innerHTML = `*{cursor: ${i}!important;}`);
}
function Y0(e) {
  return e.type === "keydown";
}
function X0(e) {
  return e.type.startsWith("pointer");
}
function K0(e) {
  return e.type.startsWith("mouse");
}
function Ws(e) {
  if (X0(e)) {
    if (e.isPrimary)
      return {
        x: e.clientX,
        y: e.clientY
      };
  } else if (K0(e))
    return {
      x: e.clientX,
      y: e.clientY
    };
  return {
    x: 1 / 0,
    y: 1 / 0
  };
}
function L4() {
  if (typeof matchMedia == "function")
    return matchMedia("(pointer:coarse)").matches ? "coarse" : "fine";
}
function $4(e, n, i) {
  return e.x < n.x + n.width && e.x + e.width > n.x && e.y < n.y + n.height && e.y + e.height > n.y;
}
function z4(e, n) {
  if (e === n) throw new Error("Cannot compare node with itself");
  const i = {
    a: tp(e),
    b: tp(n)
  };
  let r;
  for (; i.a.at(-1) === i.b.at(-1); )
    e = i.a.pop(), n = i.b.pop(), r = e;
  X(r, "Stacking order can only be calculated for elements with a common ancestor");
  const o = {
    a: ep(Qf(i.a)),
    b: ep(Qf(i.b))
  };
  if (o.a === o.b) {
    const s = r.childNodes, a = {
      a: i.a.at(-1),
      b: i.b.at(-1)
    };
    let l = s.length;
    for (; l--; ) {
      const c = s[l];
      if (c === a.a) return 1;
      if (c === a.b) return -1;
    }
  }
  return Math.sign(o.a - o.b);
}
const O4 = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function V4(e) {
  var n;
  const i = getComputedStyle((n = Z0(e)) !== null && n !== void 0 ? n : e).display;
  return i === "flex" || i === "inline-flex";
}
function B4(e) {
  const n = getComputedStyle(e);
  return !!(n.position === "fixed" || n.zIndex !== "auto" && (n.position !== "static" || V4(e)) || +n.opacity < 1 || "transform" in n && n.transform !== "none" || "webkitTransform" in n && n.webkitTransform !== "none" || "mixBlendMode" in n && n.mixBlendMode !== "normal" || "filter" in n && n.filter !== "none" || "webkitFilter" in n && n.webkitFilter !== "none" || "isolation" in n && n.isolation === "isolate" || O4.test(n.willChange) || n.webkitOverflowScrolling === "touch");
}
function Qf(e) {
  let n = e.length;
  for (; n--; ) {
    const i = e[n];
    if (X(i, "Missing node"), B4(i)) return i;
  }
  return null;
}
function ep(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function tp(e) {
  const n = [];
  for (; e; )
    n.push(e), e = Z0(e);
  return n;
}
function Z0(e) {
  const {
    parentNode: n
  } = e;
  return n && n instanceof ShadowRoot ? n.host : n;
}
const J0 = 1, Q0 = 2, ev = 4, tv = 8, j4 = L4() === "coarse";
let yt = [], wi = !1, en = /* @__PURE__ */ new Map(), Hs = /* @__PURE__ */ new Map();
const Gr = /* @__PURE__ */ new Set();
function F4(e, n, i, r, o) {
  var s;
  const {
    ownerDocument: a
  } = n, l = {
    direction: i,
    element: n,
    hitAreaMargins: r,
    setResizeHandlerState: o
  }, c = (s = en.get(a)) !== null && s !== void 0 ? s : 0;
  return en.set(a, c + 1), Gr.add(l), os(), function() {
    var f;
    Hs.delete(e), Gr.delete(l);
    const h = (f = en.get(a)) !== null && f !== void 0 ? f : 1;
    if (en.set(a, h - 1), os(), h === 1 && en.delete(a), yt.includes(l)) {
      const p = yt.indexOf(l);
      p >= 0 && yt.splice(p, 1), Eu(), o("up", !0, null);
    }
  };
}
function np(e) {
  const {
    target: n
  } = e, {
    x: i,
    y: r
  } = Ws(e);
  wi = !0, Cu({
    target: n,
    x: i,
    y: r
  }), os(), yt.length > 0 && (ss("down", e), e.preventDefault(), e.stopPropagation());
}
function lr(e) {
  const {
    x: n,
    y: i
  } = Ws(e);
  if (wi && e.buttons === 0 && (wi = !1, ss("up", e)), !wi) {
    const {
      target: r
    } = e;
    Cu({
      target: r,
      x: n,
      y: i
    });
  }
  ss("move", e), Eu(), yt.length > 0 && e.preventDefault();
}
function ni(e) {
  const {
    target: n
  } = e, {
    x: i,
    y: r
  } = Ws(e);
  Hs.clear(), wi = !1, yt.length > 0 && e.preventDefault(), ss("up", e), Cu({
    target: n,
    x: i,
    y: r
  }), Eu(), os();
}
function Cu({
  target: e,
  x: n,
  y: i
}) {
  yt.splice(0);
  let r = null;
  (e instanceof HTMLElement || e instanceof SVGElement) && (r = e), Gr.forEach((o) => {
    const {
      element: s,
      hitAreaMargins: a
    } = o, l = s.getBoundingClientRect(), {
      bottom: c,
      left: u,
      right: f,
      top: h
    } = l, p = j4 ? a.coarse : a.fine;
    if (n >= u - p && n <= f + p && i >= h - p && i <= c + p) {
      if (r !== null && document.contains(r) && s !== r && !s.contains(r) && !r.contains(s) && // Calculating stacking order has a cost, so we should avoid it if possible
      // That is why we only check potentially intersecting handles,
      // and why we skip if the event target is within the handle's DOM
      z4(r, s) > 0) {
        let g = r, y = !1;
        for (; g && !g.contains(s); ) {
          if ($4(g.getBoundingClientRect(), l)) {
            y = !0;
            break;
          }
          g = g.parentElement;
        }
        if (y)
          return;
      }
      yt.push(o);
    }
  });
}
function Ia(e, n) {
  Hs.set(e, n);
}
function Eu() {
  let e = !1, n = !1;
  yt.forEach((r) => {
    const {
      direction: o
    } = r;
    o === "horizontal" ? e = !0 : n = !0;
  });
  let i = 0;
  Hs.forEach((r) => {
    i |= r;
  }), e && n ? Aa("intersection", i) : e ? Aa("horizontal", i) : n ? Aa("vertical", i) : R4();
}
function os() {
  en.forEach((e, n) => {
    const {
      body: i
    } = n;
    i.removeEventListener("contextmenu", ni), i.removeEventListener("pointerdown", np), i.removeEventListener("pointerleave", lr), i.removeEventListener("pointermove", lr);
  }), window.removeEventListener("pointerup", ni), window.removeEventListener("pointercancel", ni), Gr.size > 0 && (wi ? (yt.length > 0 && en.forEach((e, n) => {
    const {
      body: i
    } = n;
    e > 0 && (i.addEventListener("contextmenu", ni), i.addEventListener("pointerleave", lr), i.addEventListener("pointermove", lr));
  }), window.addEventListener("pointerup", ni), window.addEventListener("pointercancel", ni)) : en.forEach((e, n) => {
    const {
      body: i
    } = n;
    e > 0 && (i.addEventListener("pointerdown", np, {
      capture: !0
    }), i.addEventListener("pointermove", lr));
  }));
}
function ss(e, n) {
  Gr.forEach((i) => {
    const {
      setResizeHandlerState: r
    } = i, o = yt.includes(i);
    r(e, o, n);
  });
}
function W4() {
  const [e, n] = vi(0);
  return Ge(() => n((i) => i + 1), []);
}
function X(e, n) {
  if (!e)
    throw console.error(n), Error(n);
}
const Pu = 10;
function On(e, n, i = Pu) {
  return e.toFixed(i) === n.toFixed(i) ? 0 : e > n ? 1 : -1;
}
function Bt(e, n, i = Pu) {
  return On(e, n, i) === 0;
}
function Je(e, n, i) {
  return On(e, n, i) === 0;
}
function H4(e, n, i) {
  if (e.length !== n.length)
    return !1;
  for (let r = 0; r < e.length; r++) {
    const o = e[r], s = n[r];
    if (!Je(o, s, i))
      return !1;
  }
  return !0;
}
function fi({
  panelConstraints: e,
  panelIndex: n,
  size: i
}) {
  const r = e[n];
  X(r != null, `Panel constraints not found for index ${n}`);
  let {
    collapsedSize: o = 0,
    collapsible: s,
    maxSize: a = 100,
    minSize: l = 0
  } = r;
  if (On(i, l) < 0)
    if (s) {
      const c = (o + l) / 2;
      On(i, c) < 0 ? i = o : i = l;
    } else
      i = l;
  return i = Math.min(a, i), i = parseFloat(i.toFixed(Pu)), i;
}
function pr({
  delta: e,
  initialLayout: n,
  panelConstraints: i,
  pivotIndices: r,
  prevLayout: o,
  trigger: s
}) {
  if (Je(e, 0))
    return n;
  const a = [...n], [l, c] = r;
  X(l != null, "Invalid first pivot index"), X(c != null, "Invalid second pivot index");
  let u = 0;
  if (s === "keyboard") {
    {
      const h = e < 0 ? c : l, p = i[h];
      X(p, `Panel constraints not found for index ${h}`);
      const {
        collapsedSize: m = 0,
        collapsible: g,
        minSize: y = 0
      } = p;
      if (g) {
        const v = n[h];
        if (X(v != null, `Previous layout not found for panel index ${h}`), Je(v, m)) {
          const w = y - v;
          On(w, Math.abs(e)) > 0 && (e = e < 0 ? 0 - w : w);
        }
      }
    }
    {
      const h = e < 0 ? l : c, p = i[h];
      X(p, `No panel constraints found for index ${h}`);
      const {
        collapsedSize: m = 0,
        collapsible: g,
        minSize: y = 0
      } = p;
      if (g) {
        const v = n[h];
        if (X(v != null, `Previous layout not found for panel index ${h}`), Je(v, y)) {
          const w = v - m;
          On(w, Math.abs(e)) > 0 && (e = e < 0 ? 0 - w : w);
        }
      }
    }
  }
  {
    const h = e < 0 ? 1 : -1;
    let p = e < 0 ? c : l, m = 0;
    for (; ; ) {
      const y = n[p];
      X(y != null, `Previous layout not found for panel index ${p}`);
      const w = fi({
        panelConstraints: i,
        panelIndex: p,
        size: 100
      }) - y;
      if (m += w, p += h, p < 0 || p >= i.length)
        break;
    }
    const g = Math.min(Math.abs(e), Math.abs(m));
    e = e < 0 ? 0 - g : g;
  }
  {
    let p = e < 0 ? l : c;
    for (; p >= 0 && p < i.length; ) {
      const m = Math.abs(e) - Math.abs(u), g = n[p];
      X(g != null, `Previous layout not found for panel index ${p}`);
      const y = g - m, v = fi({
        panelConstraints: i,
        panelIndex: p,
        size: y
      });
      if (!Je(g, v) && (u += g - v, a[p] = v, u.toPrecision(3).localeCompare(Math.abs(e).toPrecision(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? p-- : p++;
    }
  }
  if (H4(o, a))
    return o;
  {
    const h = e < 0 ? c : l, p = n[h];
    X(p != null, `Previous layout not found for panel index ${h}`);
    const m = p + u, g = fi({
      panelConstraints: i,
      panelIndex: h,
      size: m
    });
    if (a[h] = g, !Je(g, m)) {
      let y = m - g, w = e < 0 ? c : l;
      for (; w >= 0 && w < i.length; ) {
        const x = a[w];
        X(x != null, `Previous layout not found for panel index ${w}`);
        const k = x + y, _ = fi({
          panelConstraints: i,
          panelIndex: w,
          size: k
        });
        if (Je(x, _) || (y -= _ - x, a[w] = _), Je(y, 0))
          break;
        e > 0 ? w-- : w++;
      }
    }
  }
  const f = a.reduce((h, p) => p + h, 0);
  return Je(f, 100) ? a : o;
}
function q4({
  layout: e,
  panelsArray: n,
  pivotIndices: i
}) {
  let r = 0, o = 100, s = 0, a = 0;
  const l = i[0];
  X(l != null, "No pivot index found"), n.forEach((h, p) => {
    const {
      constraints: m
    } = h, {
      maxSize: g = 100,
      minSize: y = 0
    } = m;
    p === l ? (r = y, o = g) : (s += y, a += g);
  });
  const c = Math.min(o, 100 - s), u = Math.max(r, 100 - a), f = e[l];
  return {
    valueMax: c,
    valueMin: u,
    valueNow: f
  };
}
function Ur(e, n = document) {
  return Array.from(n.querySelectorAll(`[data-panel-resize-handle-id][data-panel-group-id="${e}"]`));
}
function nv(e, n, i = document) {
  const o = Ur(e, i).findIndex((s) => s.getAttribute("data-panel-resize-handle-id") === n);
  return o ?? null;
}
function iv(e, n, i) {
  const r = nv(e, n, i);
  return r != null ? [r, r + 1] : [-1, -1];
}
function rv(e, n = document) {
  var i;
  if (n instanceof HTMLElement && (n == null || (i = n.dataset) === null || i === void 0 ? void 0 : i.panelGroupId) == e)
    return n;
  const r = n.querySelector(`[data-panel-group][data-panel-group-id="${e}"]`);
  return r || null;
}
function qs(e, n = document) {
  const i = n.querySelector(`[data-panel-resize-handle-id="${e}"]`);
  return i || null;
}
function G4(e, n, i, r = document) {
  var o, s, a, l;
  const c = qs(n, r), u = Ur(e, r), f = c ? u.indexOf(c) : -1, h = (o = (s = i[f]) === null || s === void 0 ? void 0 : s.id) !== null && o !== void 0 ? o : null, p = (a = (l = i[f + 1]) === null || l === void 0 ? void 0 : l.id) !== null && a !== void 0 ? a : null;
  return [h, p];
}
function U4({
  committedValuesRef: e,
  eagerValuesRef: n,
  groupId: i,
  layout: r,
  panelDataArray: o,
  panelGroupElement: s,
  setLayout: a
}) {
  Ye({
    didWarnAboutMissingResizeHandle: !1
  }), Mn(() => {
    if (!s)
      return;
    const l = Ur(i, s);
    for (let c = 0; c < o.length - 1; c++) {
      const {
        valueMax: u,
        valueMin: f,
        valueNow: h
      } = q4({
        layout: r,
        panelsArray: o,
        pivotIndices: [c, c + 1]
      }), p = l[c];
      if (p != null) {
        const m = o[c];
        X(m, `No panel data found for index "${c}"`), p.setAttribute("aria-controls", m.id), p.setAttribute("aria-valuemax", "" + Math.round(u)), p.setAttribute("aria-valuemin", "" + Math.round(f)), p.setAttribute("aria-valuenow", h != null ? "" + Math.round(h) : "");
      }
    }
    return () => {
      l.forEach((c, u) => {
        c.removeAttribute("aria-controls"), c.removeAttribute("aria-valuemax"), c.removeAttribute("aria-valuemin"), c.removeAttribute("aria-valuenow");
      });
    };
  }, [i, r, o, s]), Tn(() => {
    if (!s)
      return;
    const l = n.current;
    X(l, "Eager values not found");
    const {
      panelDataArray: c
    } = l, u = rv(i, s);
    X(u != null, `No group found for id "${i}"`);
    const f = Ur(i, s);
    X(f, `No resize handles found for group id "${i}"`);
    const h = f.map((p) => {
      const m = p.getAttribute("data-panel-resize-handle-id");
      X(m, "Resize handle element has no handle id attribute");
      const [g, y] = G4(i, m, c, s);
      if (g == null || y == null)
        return () => {
        };
      const v = (w) => {
        if (!w.defaultPrevented)
          switch (w.key) {
            case "Enter": {
              w.preventDefault();
              const x = c.findIndex((k) => k.id === g);
              if (x >= 0) {
                const k = c[x];
                X(k, `No panel data found for index ${x}`);
                const _ = r[x], {
                  collapsedSize: S = 0,
                  collapsible: P,
                  minSize: C = 0
                } = k.constraints;
                if (_ != null && P) {
                  const T = pr({
                    delta: Je(_, S) ? C - S : S - _,
                    initialLayout: r,
                    panelConstraints: c.map((M) => M.constraints),
                    pivotIndices: iv(i, m, s),
                    prevLayout: r,
                    trigger: "keyboard"
                  });
                  r !== T && a(T);
                }
              }
              break;
            }
          }
      };
      return p.addEventListener("keydown", v), () => {
        p.removeEventListener("keydown", v);
      };
    });
    return () => {
      h.forEach((p) => p());
    };
  }, [s, e, n, i, r, o, a]);
}
function ip(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let i = 0; i < e.length; i++)
    if (e[i] !== n[i])
      return !1;
  return !0;
}
function ov(e, n) {
  const i = e === "horizontal", {
    x: r,
    y: o
  } = Ws(n);
  return i ? r : o;
}
function Y4(e, n, i, r, o) {
  const s = i === "horizontal", a = qs(n, o);
  X(a, `No resize handle element found for id "${n}"`);
  const l = a.getAttribute("data-panel-group-id");
  X(l, "Resize handle element has no group id attribute");
  let {
    initialCursorPosition: c
  } = r;
  const u = ov(i, e), f = rv(l, o);
  X(f, `No group element found for id "${l}"`);
  const h = f.getBoundingClientRect(), p = s ? h.width : h.height;
  return (u - c) / p * 100;
}
function X4(e, n, i, r, o, s) {
  if (Y0(e)) {
    const a = i === "horizontal";
    let l = 0;
    e.shiftKey ? l = 100 : o != null ? l = o : l = 10;
    let c = 0;
    switch (e.key) {
      case "ArrowDown":
        c = a ? 0 : l;
        break;
      case "ArrowLeft":
        c = a ? -l : 0;
        break;
      case "ArrowRight":
        c = a ? l : 0;
        break;
      case "ArrowUp":
        c = a ? 0 : -l;
        break;
      case "End":
        c = 100;
        break;
      case "Home":
        c = -100;
        break;
    }
    return c;
  } else
    return r == null ? 0 : Y4(e, n, i, r, s);
}
function K4({
  panelDataArray: e
}) {
  const n = Array(e.length), i = e.map((s) => s.constraints);
  let r = 0, o = 100;
  for (let s = 0; s < e.length; s++) {
    const a = i[s];
    X(a, `Panel constraints not found for index ${s}`);
    const {
      defaultSize: l
    } = a;
    l != null && (r++, n[s] = l, o -= l);
  }
  for (let s = 0; s < e.length; s++) {
    const a = i[s];
    X(a, `Panel constraints not found for index ${s}`);
    const {
      defaultSize: l
    } = a;
    if (l != null)
      continue;
    const c = e.length - r, u = o / c;
    r++, n[s] = u, o -= u;
  }
  return n;
}
function ii(e, n, i) {
  n.forEach((r, o) => {
    const s = e[o];
    X(s, `Panel data not found for index ${o}`);
    const {
      callbacks: a,
      constraints: l,
      id: c
    } = s, {
      collapsedSize: u = 0,
      collapsible: f
    } = l, h = i[c];
    if (h == null || r !== h) {
      i[c] = r;
      const {
        onCollapse: p,
        onExpand: m,
        onResize: g
      } = a;
      g && g(r, h), f && (p || m) && (m && (h == null || Bt(h, u)) && !Bt(r, u) && m(), p && (h == null || !Bt(h, u)) && Bt(r, u) && p());
    }
  });
}
function Po(e, n) {
  if (e.length !== n.length)
    return !1;
  for (let i = 0; i < e.length; i++)
    if (e[i] != n[i])
      return !1;
  return !0;
}
function Z4({
  defaultSize: e,
  dragState: n,
  layout: i,
  panelData: r,
  panelIndex: o,
  precision: s = 3
}) {
  const a = i[o];
  let l;
  return a == null ? l = e != null ? e.toPrecision(s) : "1" : r.length === 1 ? l = "1" : l = a.toPrecision(s), {
    flexBasis: 0,
    flexGrow: l,
    flexShrink: 1,
    // Without this, Panel sizes may be unintentionally overridden by their content
    overflow: "hidden",
    // Disable pointer events inside of a panel during resize
    // This avoid edge cases like nested iframes
    pointerEvents: n !== null ? "none" : void 0
  };
}
function J4(e, n = 10) {
  let i = null;
  return (...o) => {
    i !== null && clearTimeout(i), i = setTimeout(() => {
      e(...o);
    }, n);
  };
}
function rp(e) {
  try {
    if (typeof localStorage < "u")
      e.getItem = (n) => localStorage.getItem(n), e.setItem = (n, i) => {
        localStorage.setItem(n, i);
      };
    else
      throw new Error("localStorage not supported in this environment");
  } catch (n) {
    console.error(n), e.getItem = () => null, e.setItem = () => {
    };
  }
}
function sv(e) {
  return `react-resizable-panels:${e}`;
}
function av(e) {
  return e.map((n) => {
    const {
      constraints: i,
      id: r,
      idIsFromProps: o,
      order: s
    } = n;
    return o ? r : s ? `${s}:${JSON.stringify(i)}` : JSON.stringify(i);
  }).sort((n, i) => n.localeCompare(i)).join(",");
}
function lv(e, n) {
  try {
    const i = sv(e), r = n.getItem(i);
    if (r) {
      const o = JSON.parse(r);
      if (typeof o == "object" && o != null)
        return o;
    }
  } catch {
  }
  return null;
}
function Q4(e, n, i) {
  var r, o;
  const s = (r = lv(e, i)) !== null && r !== void 0 ? r : {}, a = av(n);
  return (o = s[a]) !== null && o !== void 0 ? o : null;
}
function e5(e, n, i, r, o) {
  var s;
  const a = sv(e), l = av(n), c = (s = lv(e, o)) !== null && s !== void 0 ? s : {};
  c[l] = {
    expandToSizes: Object.fromEntries(i.entries()),
    layout: r
  };
  try {
    o.setItem(a, JSON.stringify(c));
  } catch (u) {
    console.error(u);
  }
}
function op({
  layout: e,
  panelConstraints: n
}) {
  const i = [...e], r = i.reduce((s, a) => s + a, 0);
  if (i.length !== n.length)
    throw Error(`Invalid ${n.length} panel layout: ${i.map((s) => `${s}%`).join(", ")}`);
  if (!Je(r, 100) && i.length > 0)
    for (let s = 0; s < n.length; s++) {
      const a = i[s];
      X(a != null, `No layout data found for index ${s}`);
      const l = 100 / r * a;
      i[s] = l;
    }
  let o = 0;
  for (let s = 0; s < n.length; s++) {
    const a = i[s];
    X(a != null, `No layout data found for index ${s}`);
    const l = fi({
      panelConstraints: n,
      panelIndex: s,
      size: a
    });
    a != l && (o += a - l, i[s] = l);
  }
  if (!Je(o, 0))
    for (let s = 0; s < n.length; s++) {
      const a = i[s];
      X(a != null, `No layout data found for index ${s}`);
      const l = a + o, c = fi({
        panelConstraints: n,
        panelIndex: s,
        size: l
      });
      if (a !== c && (o -= c - a, i[s] = c, Je(o, 0)))
        break;
    }
  return i;
}
const t5 = 100, mr = {
  getItem: (e) => (rp(mr), mr.getItem(e)),
  setItem: (e, n) => {
    rp(mr), mr.setItem(e, n);
  }
}, sp = {};
function cv({
  autoSaveId: e = null,
  children: n,
  className: i = "",
  direction: r,
  forwardedRef: o,
  id: s = null,
  onLayout: a = null,
  keyboardResizeBy: l = null,
  storage: c = mr,
  style: u,
  tagName: f = "div",
  ...h
}) {
  const p = _u(s), m = Ye(null), [g, y] = vi(null), [v, w] = vi([]), x = W4(), k = Ye({}), _ = Ye(/* @__PURE__ */ new Map()), S = Ye(0), P = Ye({
    autoSaveId: e,
    direction: r,
    dragState: g,
    id: p,
    keyboardResizeBy: l,
    onLayout: a,
    storage: c
  }), C = Ye({
    layout: v,
    panelDataArray: [],
    panelDataArrayChanged: !1
  });
  Ye({
    didLogIdAndOrderWarning: !1,
    didLogPanelConstraintsWarning: !1,
    prevPanelIds: []
  }), G0(o, () => ({
    getId: () => P.current.id,
    getLayout: () => {
      const {
        layout: E
      } = C.current;
      return E;
    },
    setLayout: (E) => {
      const {
        onLayout: N
      } = P.current, {
        layout: R,
        panelDataArray: O
      } = C.current, V = op({
        layout: E,
        panelConstraints: O.map((W) => W.constraints)
      });
      ip(R, V) || (w(V), C.current.layout = V, N && N(V), ii(O, V, k.current));
    }
  }), []), Mn(() => {
    P.current.autoSaveId = e, P.current.direction = r, P.current.dragState = g, P.current.id = p, P.current.onLayout = a, P.current.storage = c;
  }), U4({
    committedValuesRef: P,
    eagerValuesRef: C,
    groupId: p,
    layout: v,
    panelDataArray: C.current.panelDataArray,
    setLayout: w,
    panelGroupElement: m.current
  }), Tn(() => {
    const {
      panelDataArray: E
    } = C.current;
    if (e) {
      if (v.length === 0 || v.length !== E.length)
        return;
      let N = sp[e];
      N == null && (N = J4(e5, t5), sp[e] = N);
      const R = [...E], O = new Map(_.current);
      N(e, R, O, v, c);
    }
  }, [e, v, c]), Tn(() => {
  });
  const T = Ge((E) => {
    const {
      onLayout: N
    } = P.current, {
      layout: R,
      panelDataArray: O
    } = C.current;
    if (E.constraints.collapsible) {
      const V = O.map((He) => He.constraints), {
        collapsedSize: W = 0,
        panelSize: ne,
        pivotIndices: pe
      } = pn(O, E, R);
      if (X(ne != null, `Panel size not found for panel "${E.id}"`), !Bt(ne, W)) {
        _.current.set(E.id, ne);
        const ke = oi(O, E) === O.length - 1 ? ne - W : W - ne, he = pr({
          delta: ke,
          initialLayout: R,
          panelConstraints: V,
          pivotIndices: pe,
          prevLayout: R,
          trigger: "imperative-api"
        });
        Po(R, he) || (w(he), C.current.layout = he, N && N(he), ii(O, he, k.current));
      }
    }
  }, []), M = Ge((E, N) => {
    const {
      onLayout: R
    } = P.current, {
      layout: O,
      panelDataArray: V
    } = C.current;
    if (E.constraints.collapsible) {
      const W = V.map((ze) => ze.constraints), {
        collapsedSize: ne = 0,
        panelSize: pe = 0,
        minSize: He = 0,
        pivotIndices: ke
      } = pn(V, E, O), he = N ?? He;
      if (Bt(pe, ne)) {
        const ze = _.current.get(E.id), rt = ze != null && ze >= he ? ze : he, Yt = oi(V, E) === V.length - 1 ? pe - rt : rt - pe, De = pr({
          delta: Yt,
          initialLayout: O,
          panelConstraints: W,
          pivotIndices: ke,
          prevLayout: O,
          trigger: "imperative-api"
        });
        Po(O, De) || (w(De), C.current.layout = De, R && R(De), ii(V, De, k.current));
      }
    }
  }, []), D = Ge((E) => {
    const {
      layout: N,
      panelDataArray: R
    } = C.current, {
      panelSize: O
    } = pn(R, E, N);
    return X(O != null, `Panel size not found for panel "${E.id}"`), O;
  }, []), L = Ge((E, N) => {
    const {
      panelDataArray: R
    } = C.current, O = oi(R, E);
    return Z4({
      defaultSize: N,
      dragState: g,
      layout: v,
      panelData: R,
      panelIndex: O
    });
  }, [g, v]), z = Ge((E) => {
    const {
      layout: N,
      panelDataArray: R
    } = C.current, {
      collapsedSize: O = 0,
      collapsible: V,
      panelSize: W
    } = pn(R, E, N);
    return X(W != null, `Panel size not found for panel "${E.id}"`), V === !0 && Bt(W, O);
  }, []), Q = Ge((E) => {
    const {
      layout: N,
      panelDataArray: R
    } = C.current, {
      collapsedSize: O = 0,
      collapsible: V,
      panelSize: W
    } = pn(R, E, N);
    return X(W != null, `Panel size not found for panel "${E.id}"`), !V || On(W, O) > 0;
  }, []), ee = Ge((E) => {
    const {
      panelDataArray: N
    } = C.current;
    N.push(E), N.sort((R, O) => {
      const V = R.order, W = O.order;
      return V == null && W == null ? 0 : V == null ? -1 : W == null ? 1 : V - W;
    }), C.current.panelDataArrayChanged = !0, x();
  }, [x]);
  Mn(() => {
    if (C.current.panelDataArrayChanged) {
      C.current.panelDataArrayChanged = !1;
      const {
        autoSaveId: E,
        onLayout: N,
        storage: R
      } = P.current, {
        layout: O,
        panelDataArray: V
      } = C.current;
      let W = null;
      if (E) {
        const pe = Q4(E, V, R);
        pe && (_.current = new Map(Object.entries(pe.expandToSizes)), W = pe.layout);
      }
      W == null && (W = K4({
        panelDataArray: V
      }));
      const ne = op({
        layout: W,
        panelConstraints: V.map((pe) => pe.constraints)
      });
      ip(O, ne) || (w(ne), C.current.layout = ne, N && N(ne), ii(V, ne, k.current));
    }
  }), Mn(() => {
    const E = C.current;
    return () => {
      E.layout = [];
    };
  }, []);
  const Z = Ge((E) => {
    let N = !1;
    const R = m.current;
    return R && window.getComputedStyle(R, null).getPropertyValue("direction") === "rtl" && (N = !0), function(V) {
      V.preventDefault();
      const W = m.current;
      if (!W)
        return () => null;
      const {
        direction: ne,
        dragState: pe,
        id: He,
        keyboardResizeBy: ke,
        onLayout: he
      } = P.current, {
        layout: ze,
        panelDataArray: rt
      } = C.current, {
        initialLayout: Lt
      } = pe ?? {}, Yt = iv(He, E, W);
      let De = X4(V, E, ne, pe, ke, W);
      const Du = ne === "horizontal";
      Du && N && (De = -De);
      const fv = rt.map((pv) => pv.constraints), Xi = pr({
        delta: De,
        initialLayout: Lt ?? ze,
        panelConstraints: fv,
        pivotIndices: Yt,
        prevLayout: ze,
        trigger: Y0(V) ? "keyboard" : "mouse-or-touch"
      }), Nu = !Po(ze, Xi);
      (X0(V) || K0(V)) && S.current != De && (S.current = De, !Nu && De !== 0 ? Du ? Ia(E, De < 0 ? J0 : Q0) : Ia(E, De < 0 ? ev : tv) : Ia(E, 0)), Nu && (w(Xi), C.current.layout = Xi, he && he(Xi), ii(rt, Xi, k.current));
    };
  }, []), ae = Ge((E, N) => {
    const {
      onLayout: R
    } = P.current, {
      layout: O,
      panelDataArray: V
    } = C.current, W = V.map((ze) => ze.constraints), {
      panelSize: ne,
      pivotIndices: pe
    } = pn(V, E, O);
    X(ne != null, `Panel size not found for panel "${E.id}"`);
    const ke = oi(V, E) === V.length - 1 ? ne - N : N - ne, he = pr({
      delta: ke,
      initialLayout: O,
      panelConstraints: W,
      pivotIndices: pe,
      prevLayout: O,
      trigger: "imperative-api"
    });
    Po(O, he) || (w(he), C.current.layout = he, R && R(he), ii(V, he, k.current));
  }, []), G = Ge((E, N) => {
    const {
      layout: R,
      panelDataArray: O
    } = C.current, {
      collapsedSize: V = 0,
      collapsible: W
    } = N, {
      collapsedSize: ne = 0,
      collapsible: pe,
      maxSize: He = 100,
      minSize: ke = 0
    } = E.constraints, {
      panelSize: he
    } = pn(O, E, R);
    he != null && (W && pe && Bt(he, V) ? Bt(V, ne) || ae(E, ne) : he < ke ? ae(E, ke) : he > He && ae(E, He));
  }, [ae]), te = Ge((E, N) => {
    const {
      direction: R
    } = P.current, {
      layout: O
    } = C.current;
    if (!m.current)
      return;
    const V = qs(E, m.current);
    X(V, `Drag handle element not found for id "${E}"`);
    const W = ov(R, N);
    y({
      dragHandleId: E,
      dragHandleRect: V.getBoundingClientRect(),
      initialCursorPosition: W,
      initialLayout: O
    });
  }, []), $e = Ge(() => {
    y(null);
  }, []), Me = Ge((E) => {
    const {
      panelDataArray: N
    } = C.current, R = oi(N, E);
    R >= 0 && (N.splice(R, 1), delete k.current[E.id], C.current.panelDataArrayChanged = !0, x());
  }, [x]), We = M4(() => ({
    collapsePanel: T,
    direction: r,
    dragState: g,
    expandPanel: M,
    getPanelSize: D,
    getPanelStyle: L,
    groupId: p,
    isPanelCollapsed: z,
    isPanelExpanded: Q,
    reevaluatePanelConstraints: G,
    registerPanel: ee,
    registerResizeHandle: Z,
    resizePanel: ae,
    startDragging: te,
    stopDragging: $e,
    unregisterPanel: Me,
    panelGroupElement: m.current
  }), [T, g, r, M, D, L, p, z, Q, G, ee, Z, ae, te, $e, Me]), Ae = {
    display: "flex",
    flexDirection: r === "horizontal" ? "row" : "column",
    height: "100%",
    overflow: "hidden",
    width: "100%"
  };
  return Ni(Fs.Provider, {
    value: We
  }, Ni(f, {
    ...h,
    children: n,
    className: i,
    id: s,
    ref: m,
    style: {
      ...Ae,
      ...u
    },
    // CSS selectors
    "data-panel-group": "",
    "data-panel-group-direction": r,
    "data-panel-group-id": p
  }));
}
const Gs = H0((e, n) => Ni(cv, {
  ...e,
  forwardedRef: n
}));
cv.displayName = "PanelGroup";
Gs.displayName = "forwardRef(PanelGroup)";
function oi(e, n) {
  return e.findIndex((i) => i === n || i.id === n.id);
}
function pn(e, n, i) {
  const r = oi(e, n), s = r === e.length - 1 ? [r - 1, r] : [r, r + 1], a = i[r];
  return {
    ...n.constraints,
    panelSize: a,
    pivotIndices: s
  };
}
function n5({
  disabled: e,
  handleId: n,
  resizeHandler: i,
  panelGroupElement: r
}) {
  Tn(() => {
    if (e || i == null || r == null)
      return;
    const o = qs(n, r);
    if (o == null)
      return;
    const s = (a) => {
      if (!a.defaultPrevented)
        switch (a.key) {
          case "ArrowDown":
          case "ArrowLeft":
          case "ArrowRight":
          case "ArrowUp":
          case "End":
          case "Home": {
            a.preventDefault(), i(a);
            break;
          }
          case "F6": {
            a.preventDefault();
            const l = o.getAttribute("data-panel-group-id");
            X(l, `No group element found for id "${l}"`);
            const c = Ur(l, r), u = nv(l, n, r);
            X(u !== null, `No resize element found for id "${n}"`);
            const f = a.shiftKey ? u > 0 ? u - 1 : c.length - 1 : u + 1 < c.length ? u + 1 : 0;
            c[f].focus();
            break;
          }
        }
    };
    return o.addEventListener("keydown", s), () => {
      o.removeEventListener("keydown", s);
    };
  }, [r, e, n, i]);
}
function Us({
  children: e = null,
  className: n = "",
  disabled: i = !1,
  hitAreaMargins: r,
  id: o,
  onBlur: s,
  onDragging: a,
  onFocus: l,
  style: c = {},
  tabIndex: u = 0,
  tagName: f = "div",
  ...h
}) {
  var p, m;
  const g = Ye(null), y = Ye({
    onDragging: a
  });
  Tn(() => {
    y.current.onDragging = a;
  });
  const v = q0(Fs);
  if (v === null)
    throw Error("PanelResizeHandle components must be rendered within a PanelGroup container");
  const {
    direction: w,
    groupId: x,
    registerResizeHandle: k,
    startDragging: _,
    stopDragging: S,
    panelGroupElement: P
  } = v, C = _u(o), [T, M] = vi("inactive"), [D, L] = vi(!1), [z, Q] = vi(null), ee = Ye({
    state: T
  });
  Mn(() => {
    ee.current.state = T;
  }), Tn(() => {
    if (i)
      Q(null);
    else {
      const te = k(C);
      Q(() => te);
    }
  }, [i, C, k]);
  const Z = (p = r?.coarse) !== null && p !== void 0 ? p : 15, ae = (m = r?.fine) !== null && m !== void 0 ? m : 5;
  return Tn(() => {
    if (i || z == null)
      return;
    const te = g.current;
    return X(te, "Element ref not attached"), F4(C, te, w, {
      coarse: Z,
      fine: ae
    }, (Me, We, Ae) => {
      if (We)
        switch (Me) {
          case "down": {
            M("drag"), X(Ae, 'Expected event to be defined for "down" action'), _(C, Ae);
            const {
              onDragging: E
            } = y.current;
            E && E(!0);
            break;
          }
          case "move": {
            const {
              state: E
            } = ee.current;
            E !== "drag" && M("hover"), X(Ae, 'Expected event to be defined for "move" action'), z(Ae);
            break;
          }
          case "up": {
            M("hover"), S();
            const {
              onDragging: E
            } = y.current;
            E && E(!1);
            break;
          }
        }
      else
        M("inactive");
    });
  }, [Z, w, i, ae, k, C, z, _, S]), n5({
    disabled: i,
    handleId: C,
    resizeHandler: z,
    panelGroupElement: P
  }), Ni(f, {
    ...h,
    children: e,
    className: n,
    id: o,
    onBlur: () => {
      L(!1), s?.();
    },
    onFocus: () => {
      L(!0), l?.();
    },
    ref: g,
    role: "separator",
    style: {
      ...{
        touchAction: "none",
        userSelect: "none"
      },
      ...c
    },
    tabIndex: u,
    // CSS selectors
    "data-panel-group-direction": w,
    "data-panel-group-id": x,
    "data-resize-handle": "",
    "data-resize-handle-active": T === "drag" ? "pointer" : D ? "keyboard" : void 0,
    "data-resize-handle-state": T,
    "data-panel-resize-handle-enabled": !i,
    "data-panel-resize-handle-id": C
  });
}
Us.displayName = "PanelResizeHandle";
function i5({ text: e }) {
  return /* @__PURE__ */ d(_r, { value: e, timeout: 2e3, children: ({ copied: n, copy: i }) => /* @__PURE__ */ d(vt, { label: n ? "Copied" : "Copy", withArrow: !0, position: "right", children: /* @__PURE__ */ d(se, { color: n ? "teal" : "gray", variant: n ? "light" : "subtle", onClick: i, children: n ? /* @__PURE__ */ d(Ss, { style: { width: Re(16) } }) : /* @__PURE__ */ d(Vc, { style: { width: Re(16) } }) }) }) });
}
function Tu({ text: e }) {
  return /* @__PURE__ */ d(A, { pos: "absolute", top: "0", right: "0", p: "4", children: /* @__PURE__ */ d(i5, { text: e }) });
}
var Mu = "_5k2wbq0", Au = "_5k2wbq1", Iu = "_5k2wbq2";
const bl = bt("/view/$viewId/mmd")({
  component: o5,
  loader: async ({ params: e }) => {
    const { viewId: n } = e;
    try {
      const { mmdSource: i } = await import("./-view-lazy-data-CI4xD57c.js");
      return {
        source: i(n)
      };
    } catch {
      throw Bn();
    }
  }
}), r5 = async (e, n) => {
  const { default: i } = await import("https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.esm.min.mjs");
  i.initialize({
    theme: "dark"
  });
  const { svg: r } = await i.render(e, n);
  return r;
};
function o5() {
  const { viewId: e } = bl.useParams(), { source: n } = bl.useLoaderData(), [i, { execute: r }] = $g(r5, null);
  return ie(() => {
    r(e, n);
  }, [n]), /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ b(Gs, { className: Iu, direction: "horizontal", autoSaveId: "viewAsMmd", children: [
      /* @__PURE__ */ d(zn, { children: /* @__PURE__ */ b(
        Qe,
        {
          className: Mu,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ d(xt, { block: !0, className: Au, children: n }),
            /* @__PURE__ */ d(Tu, { text: n })
          ]
        }
      ) }),
      /* @__PURE__ */ d(
        Us,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ d(zn, { children: /* @__PURE__ */ d(Qe, { h: "100%", children: i.result && /* @__PURE__ */ d("div", { className: ku, dangerouslySetInnerHTML: { __html: i.result } }) }) })
    ] }),
    /* @__PURE__ */ d(
      A,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ d(
          Rl,
          {
            size: "sm",
            onClick: Ui.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const uv = bt("/view/$viewId/editor")({
  component: s5
});
function s5() {
  const e = Vn(), { viewId: n } = uv.useParams(), i = js(n), r = q((a) => {
    e.navigate({
      to: "/view/$viewId/editor",
      params: { viewId: a },
      startTransition: !0,
      search: !0
    });
  });
  if (!i)
    throw Bn();
  const s = (i.notation?.elements ?? []).length > 0;
  return /* @__PURE__ */ d(
    bu,
    {
      view: i,
      readonly: !1,
      zoomable: !0,
      pannable: !0,
      nodesDraggable: !0,
      experimentalEdgeEditing: !0,
      fitViewPadding: 0.08,
      showDiagramTitle: !0,
      showNavigationButtons: !0,
      showNotations: Ep || s,
      enableDynamicViewWalkthrough: !0,
      enableFocusMode: !1,
      enableElementDetails: !0,
      enableRelationshipDetails: !0,
      enableRelationshipBrowser: !0,
      onNavigateTo: r,
      renderIcon: zi,
      onChange: (a) => console.log(a),
      onBurgerMenuClick: us ? () => {
        e.navigate({
          to: "/",
          search: !0
        });
      } : Ui.open
    }
  );
}
const dv = bt("/view/$viewId/dot")({
  component: a5,
  loader: async ({ params: e }) => {
    const { viewId: n } = e;
    try {
      const { dotSource: i, svgSource: r } = await import("./-view-lazy-data-CI4xD57c.js"), o = i(n), s = r(n);
      return {
        dot: o,
        dotSvg: s
      };
    } catch (i) {
      throw console.error(i), Bn();
    }
  }
});
function a5() {
  const { dot: e, dotSvg: n } = dv.useLoaderData();
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ b(Gs, { className: Iu, direction: "horizontal", autoSaveId: "viewAsDot", children: [
      /* @__PURE__ */ d(zn, { children: /* @__PURE__ */ b(
        Qe,
        {
          className: Mu,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ d(xt, { block: !0, className: Au, children: e }),
            /* @__PURE__ */ d(Tu, { text: e })
          ]
        }
      ) }),
      /* @__PURE__ */ d(
        Us,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ d(zn, { children: /* @__PURE__ */ d(Qe, { h: "100%", children: /* @__PURE__ */ d("div", { className: ku, dangerouslySetInnerHTML: { __html: n } }) }) })
    ] }),
    /* @__PURE__ */ d(
      A,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ d(
          Rl,
          {
            size: "sm",
            onClick: Ui.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const hv = bt("/view/$viewId/d2")({
  component: c5,
  loader: async ({ params: e }) => {
    const { viewId: n } = e;
    try {
      const { d2Source: i } = await import("./-view-lazy-data-CI4xD57c.js");
      return {
        source: i(n)
      };
    } catch {
      throw Bn();
    }
  }
}), l5 = async (e) => await (await fetch(x1, {
  method: "POST",
  cache: "force-cache",
  body: JSON.stringify({
    diagram_source: e,
    // diagram_options: {
    //   theme: 'colorblind-clear'
    // },
    output_format: "svg"
  }),
  headers: {
    "Content-Type": "application/json"
  }
})).text();
function c5() {
  const { source: e } = hv.useLoaderData(), [n, { execute: i }] = $g(l5, null);
  return /* @__PURE__ */ b(H, { children: [
    /* @__PURE__ */ b(Gs, { className: Iu, direction: "horizontal", autoSaveId: "viewAsD2", children: [
      /* @__PURE__ */ d(zn, { children: /* @__PURE__ */ b(
        Qe,
        {
          className: Mu,
          p: 5,
          styles: {
            viewport: {
              borderRadius: 6
            }
          },
          children: [
            /* @__PURE__ */ d(xt, { block: !0, className: Au, children: e }),
            /* @__PURE__ */ d(Tu, { text: e })
          ]
        }
      ) }),
      /* @__PURE__ */ d(
        Us,
        {
          style: {
            width: 10
          }
        }
      ),
      /* @__PURE__ */ d(zn, { children: /* @__PURE__ */ b(Qe, { h: "100%", children: [
        n.status !== "success" && /* @__PURE__ */ b(H, { children: [
          /* @__PURE__ */ d(
            le,
            {
              mt: "xs",
              variant: "light",
              disabled: n.status === "loading",
              onClick: () => void i(e),
              children: n.status === "loading" ? "Loading..." : "Render with Kroki"
            }
          ),
          n.status === "error" && /* @__PURE__ */ d(A, { children: n.error?.message })
        ] }),
        n.status === "success" && /* @__PURE__ */ d(A, { className: ku, children: n.result ? /* @__PURE__ */ d("div", { dangerouslySetInnerHTML: { __html: n.result } }) : /* @__PURE__ */ d(A, { children: "Empty result" }) })
      ] }) })
    ] }),
    /* @__PURE__ */ d(
      A,
      {
        pos: "fixed",
        top: 14,
        left: 10,
        children: /* @__PURE__ */ d(
          Rl,
          {
            size: "sm",
            onClick: Ui.open,
            "aria-label": "Toggle navigation"
          }
        )
      }
    )
  ] });
}
const u5 = qL.update({
  id: "/",
  path: "/",
  getParentRoute: () => un
}), d5 = O0.update({
  id: "/webcomponent/$",
  path: "/webcomponent/$",
  getParentRoute: () => un
}), Yi = Su.update({
  id: "/view/$viewId",
  path: "/view/$viewId",
  getParentRoute: () => un
}), h5 = j0.update({
  id: "/relationships/$fqn",
  path: "/relationships/$fqn",
  getParentRoute: () => un
}), f5 = vl.update({
  id: "/export/$viewId",
  path: "/export/$viewId",
  getParentRoute: () => un
}), p5 = wl.update({
  id: "/embed/$viewId",
  path: "/embed/$viewId",
  getParentRoute: () => un
}), m5 = W0.update({
  id: "/",
  path: "/",
  getParentRoute: () => Yi
}), g5 = bl.update({
  id: "/mmd",
  path: "/mmd",
  getParentRoute: () => Yi
}), y5 = uv.update({
  id: "/editor",
  path: "/editor",
  getParentRoute: () => Yi
}), v5 = dv.update({
  id: "/dot",
  path: "/dot",
  getParentRoute: () => Yi
}), w5 = hv.update({
  id: "/d2",
  path: "/d2",
  getParentRoute: () => Yi
}), x5 = {
  ViewViewIdD2Route: w5,
  ViewViewIdDotRoute: v5,
  ViewViewIdEditorRoute: y5,
  ViewViewIdMmdRoute: g5,
  ViewViewIdIndexRoute: m5
}, b5 = Yi._addFileChildren(
  x5
), k5 = {
  IndexRoute: u5,
  EmbedViewIdRoute: p5,
  ExportViewIdRoute: f5,
  RelationshipsFqnRoute: h5,
  ViewViewIdRoute: b5,
  WebcomponentSplatRoute: d5
}, S5 = un._addFileChildren(k5)._addFileTypes(), _5 = v1({
  autoContrast: !0,
  primaryColor: "indigo",
  cursorType: "pointer",
  fontFamily: "var(--likec4-app-font)",
  headings: {
    fontWeight: "500",
    sizes: {
      h1: {
        // fontSize: '2rem',
        fontWeight: "600"
      },
      h2: {
        // fontSize: '1.85rem',
      }
    }
  }
});
function C5() {
  return bv({
    routeTree: S5,
    context: {},
    basepath: k1,
    trailingSlash: "preserve",
    history: b1 ? kv() : Sv(),
    defaultStaleTime: 1 / 0,
    defaultNotFoundComponent: () => /* @__PURE__ */ d(tw, {})
    // defaultPendingComponent: () => (
    //   <Box p={'md'}>
    //     <Loader type="dots" />
    //   </Box>
    // )
  });
}
function E5() {
  const e = ce(() => C5(), []), { theme: n } = e.parseLocation().search;
  return /* @__PURE__ */ d(
    w1,
    {
      ...n && { forceColorScheme: n },
      defaultColorScheme: n ?? "auto",
      theme: _5,
      children: /* @__PURE__ */ d(xv, { router: e })
    }
  );
}
mv(document.getElementById("like4-root")).render(
  // <StrictMode>
  /* @__PURE__ */ d(E5, {})
  // </StrictMode>
);
export {
  vC as I,
  B as c,
  Cc as i,
  Ac as n,
  Nn as u
};
