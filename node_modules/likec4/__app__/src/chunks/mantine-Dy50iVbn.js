import * as _ from "react";
import Zo, { useState as W, Fragment as za, createContext as Kt, useContext as gt, useRef as G, useEffect as U, useMemo as Nt, useCallback as Y, useLayoutEffect as Wn, useId as Ba, forwardRef as J, cloneElement as ct, Children as Fa, createElement as an } from "react";
import { jsx as v, jsxs as Z, Fragment as Ce } from "react/jsx-runtime";
import * as Kc from "react-dom";
import Xc, { createPortal as Uc } from "react-dom";
var Ue = function() {
  return Ue = Object.assign || function(t) {
    for (var n, o = 1, r = arguments.length; o < r; o++) {
      n = arguments[o];
      for (var s in n) Object.prototype.hasOwnProperty.call(n, s) && (t[s] = n[s]);
    }
    return t;
  }, Ue.apply(this, arguments);
};
function Ha(e, t) {
  var n = {};
  for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && t.indexOf(o) < 0 && (n[o] = e[o]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var r = 0, o = Object.getOwnPropertySymbols(e); r < o.length; r++)
      t.indexOf(o[r]) < 0 && Object.prototype.propertyIsEnumerable.call(e, o[r]) && (n[o[r]] = e[o[r]]);
  return n;
}
function qc(e, t, n) {
  if (n || arguments.length === 2) for (var o = 0, r = t.length, s; o < r; o++)
    (s || !(o in t)) && (s || (s = Array.prototype.slice.call(t, 0, o)), s[o] = t[o]);
  return e.concat(s || Array.prototype.slice.call(t));
}
var An = "right-scroll-bar-position", Dn = "width-before-scroll-bar", Zc = "with-scroll-bars-hidden", Jc = "--removed-body-scroll-bar-size";
function Eo(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Qc(e, t) {
  var n = W(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(o) {
          var r = n.value;
          r !== o && (n.value = o, n.callback(o, r));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var eu = typeof window < "u" ? _.useLayoutEffect : _.useEffect, As = /* @__PURE__ */ new WeakMap();
function tu(e, t) {
  var n = Qc(null, function(o) {
    return e.forEach(function(r) {
      return Eo(r, o);
    });
  });
  return eu(function() {
    var o = As.get(n);
    if (o) {
      var r = new Set(o), s = new Set(e), a = n.current;
      r.forEach(function(i) {
        s.has(i) || Eo(i, null);
      }), s.forEach(function(i) {
        r.has(i) || Eo(i, a);
      });
    }
    As.set(n, e);
  }, [e]), n;
}
function nu(e) {
  return e;
}
function ou(e, t) {
  t === void 0 && (t = nu);
  var n = [], o = !1, r = {
    read: function() {
      if (o)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(s) {
      var a = t(s, o);
      return n.push(a), function() {
        n = n.filter(function(i) {
          return i !== a;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (o = !0; n.length; ) {
        var a = n;
        n = [], a.forEach(s);
      }
      n = {
        push: function(i) {
          return s(i);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(s) {
      o = !0;
      var a = [];
      if (n.length) {
        var i = n;
        n = [], i.forEach(s), a = n;
      }
      var c = function() {
        var u = a;
        a = [], u.forEach(s);
      }, l = function() {
        return Promise.resolve().then(c);
      };
      l(), n = {
        push: function(u) {
          a.push(u), l();
        },
        filter: function(u) {
          return a = a.filter(u), n;
        }
      };
    }
  };
  return r;
}
function ru(e) {
  e === void 0 && (e = {});
  var t = ou(null);
  return t.options = Ue({ async: !0, ssr: !1 }, e), t;
}
var Va = function(e) {
  var t = e.sideCar, n = Ha(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var o = t.read();
  if (!o)
    throw new Error("Sidecar medium not found");
  return _.createElement(o, Ue({}, n));
};
Va.isSideCarExport = !0;
function su(e, t) {
  return e.useMedium(t), Va;
}
var Wa = ru(), ko = function() {
}, jn = _.forwardRef(function(e, t) {
  var n = _.useRef(null), o = _.useState({
    onScrollCapture: ko,
    onWheelCapture: ko,
    onTouchMoveCapture: ko
  }), r = o[0], s = o[1], a = e.forwardProps, i = e.children, c = e.className, l = e.removeScrollBar, u = e.enabled, d = e.shards, p = e.sideCar, f = e.noIsolation, h = e.inert, m = e.allowPinchZoom, g = e.as, b = g === void 0 ? "div" : g, w = e.gapMode, y = Ha(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), S = p, x = tu([n, t]), C = Ue(Ue({}, y), r);
  return _.createElement(
    _.Fragment,
    null,
    u && _.createElement(S, { sideCar: Wa, removeScrollBar: l, shards: d, noIsolation: f, inert: h, setCallbacks: s, allowPinchZoom: !!m, lockRef: n, gapMode: w }),
    a ? _.cloneElement(_.Children.only(i), Ue(Ue({}, C), { ref: x })) : _.createElement(b, Ue({}, C, { className: c, ref: x }), i)
  );
});
jn.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
jn.classNames = {
  fullWidth: Dn,
  zeroRight: An
};
var Ds, au = function() {
  if (Ds)
    return Ds;
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function iu() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = au();
  return t && e.setAttribute("nonce", t), e;
}
function lu(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function cu(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var uu = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = iu()) && (lu(t, n), cu(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, du = function() {
  var e = uu();
  return function(t, n) {
    _.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, ja = function() {
  var e = du(), t = function(n) {
    var o = n.styles, r = n.dynamic;
    return e(o, r), null;
  };
  return t;
}, fu = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, Mo = function(e) {
  return parseInt(e || "", 10) || 0;
}, pu = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], o = t[e === "padding" ? "paddingTop" : "marginTop"], r = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [Mo(n), Mo(o), Mo(r)];
}, mu = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return fu;
  var t = pu(e), n = document.documentElement.clientWidth, o = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, o - n + t[2] - t[0])
  };
}, hu = ja(), Ft = "data-scroll-locked", vu = function(e, t, n, o) {
  var r = e.left, s = e.top, a = e.right, i = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Zc, ` {
   overflow: hidden `).concat(o, `;
   padding-right: `).concat(i, "px ").concat(o, `;
  }
  body[`).concat(Ft, `] {
    overflow: hidden `).concat(o, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(o, ";"),
    n === "margin" && `
    padding-left: `.concat(r, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(a, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(i, "px ").concat(o, `;
    `),
    n === "padding" && "padding-right: ".concat(i, "px ").concat(o, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(An, ` {
    right: `).concat(i, "px ").concat(o, `;
  }
  
  .`).concat(Dn, ` {
    margin-right: `).concat(i, "px ").concat(o, `;
  }
  
  .`).concat(An, " .").concat(An, ` {
    right: 0 `).concat(o, `;
  }
  
  .`).concat(Dn, " .").concat(Dn, ` {
    margin-right: 0 `).concat(o, `;
  }
  
  body[`).concat(Ft, `] {
    `).concat(Jc, ": ").concat(i, `px;
  }
`);
}, Is = function() {
  var e = parseInt(document.body.getAttribute(Ft) || "0", 10);
  return isFinite(e) ? e : 0;
}, gu = function() {
  _.useEffect(function() {
    return document.body.setAttribute(Ft, (Is() + 1).toString()), function() {
      var e = Is() - 1;
      e <= 0 ? document.body.removeAttribute(Ft) : document.body.setAttribute(Ft, e.toString());
    };
  }, []);
}, yu = function(e) {
  var t = e.noRelative, n = e.noImportant, o = e.gapMode, r = o === void 0 ? "margin" : o;
  gu();
  var s = _.useMemo(function() {
    return mu(r);
  }, [r]);
  return _.createElement(hu, { styles: vu(s, !t, r, n ? "" : "!important") });
}, Jo = !1;
if (typeof window < "u")
  try {
    var _n = Object.defineProperty({}, "passive", {
      get: function() {
        return Jo = !0, !0;
      }
    });
    window.addEventListener("test", _n, _n), window.removeEventListener("test", _n, _n);
  } catch {
    Jo = !1;
  }
var Dt = Jo ? { passive: !1 } : !1, bu = function(e) {
  return e.tagName === "TEXTAREA";
}, Ga = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !bu(e) && n[t] === "visible")
  );
}, wu = function(e) {
  return Ga(e, "overflowY");
}, Su = function(e) {
  return Ga(e, "overflowX");
}, Os = function(e, t) {
  var n = t.ownerDocument, o = t;
  do {
    typeof ShadowRoot < "u" && o instanceof ShadowRoot && (o = o.host);
    var r = Ya(e, o);
    if (r) {
      var s = Ka(e, o), a = s[1], i = s[2];
      if (a > i)
        return !0;
    }
    o = o.parentNode;
  } while (o && o !== n.body);
  return !1;
}, xu = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, o = e.clientHeight;
  return [
    t,
    n,
    o
  ];
}, Cu = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, o = e.clientWidth;
  return [
    t,
    n,
    o
  ];
}, Ya = function(e, t) {
  return e === "v" ? wu(t) : Su(t);
}, Ka = function(e, t) {
  return e === "v" ? xu(t) : Cu(t);
}, $u = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, Pu = function(e, t, n, o, r) {
  var s = $u(e, window.getComputedStyle(t).direction), a = s * o, i = n.target, c = t.contains(i), l = !1, u = a > 0, d = 0, p = 0;
  do {
    var f = Ka(e, i), h = f[0], m = f[1], g = f[2], b = m - g - s * h;
    (h || b) && Ya(e, i) && (d += b, p += h), i instanceof ShadowRoot ? i = i.host : i = i.parentNode;
  } while (
    // portaled content
    !c && i !== document.body || // self content
    c && (t.contains(i) || t === i)
  );
  return (u && (r && Math.abs(d) < 1 || !r && a > d) || !u && (r && Math.abs(p) < 1 || !r && -a > p)) && (l = !0), l;
}, Rn = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Ls = function(e) {
  return [e.deltaX, e.deltaY];
}, zs = function(e) {
  return e && "current" in e ? e.current : e;
}, _u = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, Ru = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, Nu = 0, It = [];
function Tu(e) {
  var t = _.useRef([]), n = _.useRef([0, 0]), o = _.useRef(), r = _.useState(Nu++)[0], s = _.useState(ja)[0], a = _.useRef(e);
  _.useEffect(function() {
    a.current = e;
  }, [e]), _.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(r));
      var m = qc([e.lockRef.current], (e.shards || []).map(zs), !0).filter(Boolean);
      return m.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(r));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(r)), m.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(r));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var i = _.useCallback(function(m, g) {
    if ("touches" in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey)
      return !a.current.allowPinchZoom;
    var b = Rn(m), w = n.current, y = "deltaX" in m ? m.deltaX : w[0] - b[0], S = "deltaY" in m ? m.deltaY : w[1] - b[1], x, C = m.target, R = Math.abs(y) > Math.abs(S) ? "h" : "v";
    if ("touches" in m && R === "h" && C.type === "range")
      return !1;
    var P = Os(R, C);
    if (!P)
      return !0;
    if (P ? x = R : (x = R === "v" ? "h" : "v", P = Os(R, C)), !P)
      return !1;
    if (!o.current && "changedTouches" in m && (y || S) && (o.current = x), !x)
      return !0;
    var M = o.current || x;
    return Pu(M, g, m, M === "h" ? y : S, !0);
  }, []), c = _.useCallback(function(m) {
    var g = m;
    if (!(!It.length || It[It.length - 1] !== s)) {
      var b = "deltaY" in g ? Ls(g) : Rn(g), w = t.current.filter(function(x) {
        return x.name === g.type && (x.target === g.target || g.target === x.shadowParent) && _u(x.delta, b);
      })[0];
      if (w && w.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!w) {
        var y = (a.current.shards || []).map(zs).filter(Boolean).filter(function(x) {
          return x.contains(g.target);
        }), S = y.length > 0 ? i(g, y[0]) : !a.current.noIsolation;
        S && g.cancelable && g.preventDefault();
      }
    }
  }, []), l = _.useCallback(function(m, g, b, w) {
    var y = { name: m, delta: g, target: b, should: w, shadowParent: Eu(b) };
    t.current.push(y), setTimeout(function() {
      t.current = t.current.filter(function(S) {
        return S !== y;
      });
    }, 1);
  }, []), u = _.useCallback(function(m) {
    n.current = Rn(m), o.current = void 0;
  }, []), d = _.useCallback(function(m) {
    l(m.type, Ls(m), m.target, i(m, e.lockRef.current));
  }, []), p = _.useCallback(function(m) {
    l(m.type, Rn(m), m.target, i(m, e.lockRef.current));
  }, []);
  _.useEffect(function() {
    return It.push(s), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", c, Dt), document.addEventListener("touchmove", c, Dt), document.addEventListener("touchstart", u, Dt), function() {
      It = It.filter(function(m) {
        return m !== s;
      }), document.removeEventListener("wheel", c, Dt), document.removeEventListener("touchmove", c, Dt), document.removeEventListener("touchstart", u, Dt);
    };
  }, []);
  var f = e.removeScrollBar, h = e.inert;
  return _.createElement(
    _.Fragment,
    null,
    h ? _.createElement(s, { styles: Ru(r) }) : null,
    f ? _.createElement(yu, { gapMode: e.gapMode }) : null
  );
}
function Eu(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const ku = su(Wa, Tu);
var Xa = _.forwardRef(function(e, t) {
  return _.createElement(jn, Ue({}, e, { ref: t, sideCar: ku }));
});
Xa.classNames = jn.classNames;
const Mu = Xa;
function ce(e) {
  return Object.keys(e);
}
function Ao(e) {
  return e && typeof e == "object" && !Array.isArray(e);
}
function mr(e, t) {
  const n = { ...e }, o = t;
  return Ao(e) && Ao(t) && Object.keys(t).forEach((r) => {
    Ao(o[r]) && r in e ? n[r] = mr(n[r], o[r]) : n[r] = o[r];
  }), n;
}
function Au(e) {
  return e.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
}
function Du(e) {
  return typeof e != "string" || !e.includes("var(--mantine-scale)") ? e : e.match(/^calc\((.*?)\)$/)?.[1].split("*")[0].trim();
}
function cn(e) {
  const t = Du(e);
  return typeof t == "number" ? t : typeof t == "string" ? t.includes("calc") || t.includes("var") ? t : t.includes("px") ? Number(t.replace("px", "")) : t.includes("rem") ? Number(t.replace("rem", "")) * 16 : t.includes("em") ? Number(t.replace("em", "")) * 16 : Number(t) : NaN;
}
function Do(e) {
  return e === "0rem" ? "0rem" : `calc(${e} * var(--mantine-scale))`;
}
function Ua(e, { shouldScale: t = !1 } = {}) {
  function n(o) {
    if (o === 0 || o === "0")
      return `0${e}`;
    if (typeof o == "number") {
      const r = `${o / 16}${e}`;
      return t ? Do(r) : r;
    }
    if (typeof o == "string") {
      if (o === "" || o.startsWith("calc(") || o.startsWith("clamp(") || o.includes("rgba("))
        return o;
      if (o.includes(","))
        return o.split(",").map((s) => n(s)).join(",");
      if (o.includes(" "))
        return o.split(" ").map((s) => n(s)).join(" ");
      if (o.includes(e))
        return t ? Do(o) : o;
      const r = o.replace("px", "");
      if (!Number.isNaN(Number(r))) {
        const s = `${Number(r) / 16}${e}`;
        return t ? Do(s) : s;
      }
    }
    return o;
  }
  return n;
}
const E = Ua("rem", { shouldScale: !0 }), Qo = Ua("em");
function yt(e) {
  return Object.keys(e).reduce((t, n) => (e[n] !== void 0 && (t[n] = e[n]), t), {});
}
function qa(e) {
  if (typeof e == "number")
    return !0;
  if (typeof e == "string") {
    if (e.startsWith("calc(") || e.startsWith("var(") || e.includes(" ") && e.trim() !== "")
      return !0;
    const t = /^[+-]?[0-9]+(\.[0-9]+)?(px|em|rem|ex|ch|lh|rlh|vw|vh|vmin|vmax|vb|vi|svw|svh|lvw|lvh|dvw|dvh|cm|mm|in|pt|pc|q|cqw|cqh|cqi|cqb|cqmin|cqmax|%)?$/;
    return e.trim().split(/\s+/).every((o) => t.test(o));
  }
  return !1;
}
function ut(e) {
  return Array.isArray(e) || e === null ? !1 : typeof e == "object" ? e.type !== za : !1;
}
function Ee(e) {
  const t = Kt(null);
  return [({ children: r, value: s }) => /* @__PURE__ */ v(t.Provider, { value: s, children: r }), () => {
    const r = gt(t);
    if (r === null)
      throw new Error(e);
    return r;
  }];
}
function mn(e = null) {
  const t = Kt(e);
  return [({ children: r, value: s }) => /* @__PURE__ */ v(t.Provider, { value: s, children: r }), () => gt(t)];
}
function Bs(e, t) {
  return (n) => {
    if (typeof n != "string" || n.trim().length === 0)
      throw new Error(t);
    return `${e}-${n}`;
  };
}
function Vt(e, t) {
  let n = e;
  for (; (n = n.parentElement) && !n.matches(t); )
    ;
  return n;
}
function Iu(e, t, n) {
  for (let o = e - 1; o >= 0; o -= 1)
    if (!t[o].disabled)
      return o;
  if (n) {
    for (let o = t.length - 1; o > -1; o -= 1)
      if (!t[o].disabled)
        return o;
  }
  return e;
}
function Ou(e, t, n) {
  for (let o = e + 1; o < t.length; o += 1)
    if (!t[o].disabled)
      return o;
  if (n) {
    for (let o = 0; o < t.length; o += 1)
      if (!t[o].disabled)
        return o;
  }
  return e;
}
function Lu(e, t, n) {
  return Vt(e, n) === Vt(t, n);
}
function Za({
  parentSelector: e,
  siblingSelector: t,
  onKeyDown: n,
  loop: o = !0,
  activateOnFocus: r = !1,
  dir: s = "rtl",
  orientation: a
}) {
  return (i) => {
    n?.(i);
    const c = Array.from(
      Vt(i.currentTarget, e)?.querySelectorAll(
        t
      ) || []
    ).filter((h) => Lu(i.currentTarget, h, e)), l = c.findIndex((h) => i.currentTarget === h), u = Ou(l, c, o), d = Iu(l, c, o), p = s === "rtl" ? d : u, f = s === "rtl" ? u : d;
    switch (i.key) {
      case "ArrowRight": {
        a === "horizontal" && (i.stopPropagation(), i.preventDefault(), c[p].focus(), r && c[p].click());
        break;
      }
      case "ArrowLeft": {
        a === "horizontal" && (i.stopPropagation(), i.preventDefault(), c[f].focus(), r && c[f].click());
        break;
      }
      case "ArrowUp": {
        a === "vertical" && (i.stopPropagation(), i.preventDefault(), c[d].focus(), r && c[d].click());
        break;
      }
      case "ArrowDown": {
        a === "vertical" && (i.stopPropagation(), i.preventDefault(), c[u].focus(), r && c[u].click());
        break;
      }
      case "Home": {
        i.stopPropagation(), i.preventDefault(), !c[0].disabled && c[0].focus();
        break;
      }
      case "End": {
        i.stopPropagation(), i.preventDefault();
        const h = c.length - 1;
        !c[h].disabled && c[h].focus();
        break;
      }
    }
  };
}
const zu = {
  app: 100,
  modal: 200,
  popover: 300,
  overlay: 400,
  max: 9999
};
function je(e) {
  return zu[e];
}
const Ja = () => {
};
function Bu(e, t = { active: !0 }) {
  return typeof e != "function" || !t.active ? t.onKeyDown || Ja : (n) => {
    n.key === "Escape" && (e(n), t.onTrigger?.());
  };
}
function Q(e, t = "size", n = !0) {
  if (e !== void 0)
    return qa(e) ? n ? E(e) : e : `var(--${t}-${e})`;
}
function we(e) {
  return Q(e, "mantine-spacing");
}
function ie(e) {
  return e === void 0 ? "var(--mantine-radius-default)" : Q(e, "mantine-radius");
}
function Se(e) {
  return Q(e, "mantine-font-size");
}
function Fu(e) {
  return Q(e, "mantine-line-height", !1);
}
function hr(e) {
  if (e)
    return Q(e, "mantine-shadow", !1);
}
function $e(e, t) {
  return (n) => {
    e?.(n), t?.(n);
  };
}
function Hu(e, t) {
  return e in t ? cn(t[e]) : cn(e);
}
function vr(e, t) {
  const n = e.map((o) => ({
    value: o,
    px: Hu(o, t)
  }));
  return n.sort((o, r) => o.px - r.px), n;
}
function Fe(e) {
  return typeof e == "object" && e !== null ? "base" in e ? e.base : void 0 : e;
}
function Vu(e, t, n) {
  return n ? Array.from(
    Vt(n, t)?.querySelectorAll(e) || []
  ).findIndex((o) => o === n) : null;
}
function Wu() {
  const [e, t] = W(-1);
  return [e, { setHovered: t, resetHovered: () => t(-1) }];
}
function _t(e, t, n) {
  return t === void 0 && n === void 0 ? e : t !== void 0 && n === void 0 ? Math.max(e, t) : Math.min(t === void 0 && n !== void 0 ? e : Math.max(e, t), n);
}
function ju(e = "mantine-") {
  return `${e}${Math.random().toString(36).slice(2, 11)}`;
}
function $t(e) {
  const t = G(e);
  return U(() => {
    t.current = e;
  }), Nt(() => (...n) => t.current?.(...n), []);
}
const Gu = () => {
};
function Gn(e, t) {
  const n = typeof t == "number" ? t : t.delay, o = typeof t == "number" ? !1 : t.flushOnUnmount, r = $t(e), s = G(0), a = Object.assign(
    Y(
      (...i) => {
        window.clearTimeout(s.current);
        const c = () => {
          s.current !== 0 && (s.current = 0, r(...i));
        };
        a.flush = c, s.current = window.setTimeout(c, n);
      },
      [r, n]
    ),
    { flush: Gu }
  );
  return U(
    () => () => {
      window.clearTimeout(s.current), o && a.flush();
    },
    [a, o]
  ), a;
}
const Fs = ["mousedown", "touchstart"];
function Qa(e, t, n) {
  const o = G(null);
  return U(() => {
    const r = (s) => {
      const { target: a } = s ?? {};
      if (Array.isArray(n)) {
        const i = a?.hasAttribute("data-ignore-outside-clicks") || !document.body.contains(a) && a.tagName !== "HTML";
        n.every((l) => !!l && !s.composedPath().includes(l)) && !i && e();
      } else o.current && !o.current.contains(a) && e();
    };
    return (t || Fs).forEach((s) => document.addEventListener(s, r)), () => {
      (t || Fs).forEach((s) => document.removeEventListener(s, r));
    };
  }, [o, e, n]), o;
}
function Yu({ timeout: e = 2e3 } = {}) {
  const [t, n] = W(null), [o, r] = W(!1), [s, a] = W(null), i = (u) => {
    window.clearTimeout(s), a(window.setTimeout(() => r(!1), e)), r(u);
  };
  return { copy: (u) => {
    "clipboard" in navigator ? navigator.clipboard.writeText(u).then(() => i(!0)).catch((d) => n(d)) : n(new Error("useClipboard: navigator.clipboard is not supported"));
  }, reset: () => {
    r(!1), n(null), window.clearTimeout(s);
  }, error: t, copied: o };
}
function Ku(e, t) {
  try {
    return e.addEventListener("change", t), () => e.removeEventListener("change", t);
  } catch {
    return e.addListener(t), () => e.removeListener(t);
  }
}
function Xu(e, t) {
  return typeof window < "u" && "matchMedia" in window ? window.matchMedia(e).matches : !1;
}
function ei(e, t, { getInitialValueInEffect: n } = {
  getInitialValueInEffect: !0
}) {
  const [o, r] = W(
    n ? t : Xu(e)
  ), s = G(null);
  return U(() => {
    if ("matchMedia" in window)
      return s.current = window.matchMedia(e), r(s.current.matches), Ku(s.current, (a) => r(a.matches));
  }, [e]), o;
}
function ti(e, t) {
  return ei("(prefers-color-scheme: dark)", e === "dark", t) ? "dark" : "light";
}
function ib(e, t, n = { leading: !1 }) {
  const [o, r] = W(e), s = G(!1), a = G(null), i = G(!1), c = () => window.clearTimeout(a.current);
  return U(() => {
    s.current && (!i.current && n.leading ? (i.current = !0, r(e)) : (c(), a.current = window.setTimeout(() => {
      i.current = !1, r(e);
    }, t)));
  }, [e, n.leading, t]), U(() => (s.current = !0, c), []), [o, c];
}
const hn = typeof document < "u" ? Wn : U;
function ht(e, t) {
  const n = G(!1);
  U(
    () => () => {
      n.current = !1;
    },
    []
  ), U(() => {
    if (n.current)
      return e();
    n.current = !0;
  }, t);
}
function ni({ opened: e, shouldReturnFocus: t = !0 }) {
  const n = G(null), o = () => {
    n.current && "focus" in n.current && typeof n.current.focus == "function" && n.current?.focus({ preventScroll: !0 });
  };
  return ht(() => {
    let r = -1;
    const s = (a) => {
      a.key === "Tab" && window.clearTimeout(r);
    };
    return document.addEventListener("keydown", s), e ? n.current = document.activeElement : t && (r = window.setTimeout(o, 10)), () => {
      window.clearTimeout(r), document.removeEventListener("keydown", s);
    };
  }, [e, t]), o;
}
const Uu = /input|select|textarea|button|object/, oi = "a, input, select, textarea, button, object, [tabindex]";
function qu(e) {
  return e.style.display === "none";
}
function Zu(e) {
  if (e.getAttribute("aria-hidden") || e.getAttribute("hidden") || e.getAttribute("type") === "hidden")
    return !1;
  let n = e;
  for (; n && !(n === document.body || n.nodeType === 11); ) {
    if (qu(n))
      return !1;
    n = n.parentNode;
  }
  return !0;
}
function ri(e) {
  let t = e.getAttribute("tabindex");
  return t === null && (t = void 0), parseInt(t, 10);
}
function er(e) {
  const t = e.nodeName.toLowerCase(), n = !Number.isNaN(ri(e));
  return /* @ts-expect-error function accepts any html element but if it is a button, it should not be disabled to trigger the condition */ (Uu.test(t) && !e.disabled || e instanceof HTMLAnchorElement && e.href || n) && Zu(e);
}
function si(e) {
  const t = ri(e);
  return (Number.isNaN(t) || t >= 0) && er(e);
}
function Ju(e) {
  return Array.from(e.querySelectorAll(oi)).filter(si);
}
function Qu(e, t) {
  const n = Ju(e);
  if (!n.length) {
    t.preventDefault();
    return;
  }
  const o = n[t.shiftKey ? 0 : n.length - 1], r = e.getRootNode();
  let s = o === r.activeElement || e === r.activeElement;
  const a = r.activeElement;
  if (a.tagName === "INPUT" && a.getAttribute("type") === "radio" && (s = n.filter(
    (u) => u.getAttribute("type") === "radio" && u.getAttribute("name") === a.getAttribute("name")
  ).includes(o)), !s)
    return;
  t.preventDefault();
  const c = n[t.shiftKey ? n.length - 1 : 0];
  c && c.focus();
}
function ed(e = !0) {
  const t = G(null), n = (r) => {
    let s = r.querySelector("[data-autofocus]");
    if (!s) {
      const a = Array.from(r.querySelectorAll(oi));
      s = a.find(si) || a.find(er) || null, !s && er(r) && (s = r);
    }
    s && s.focus({ preventScroll: !0 });
  }, o = Y(
    (r) => {
      e && r !== null && t.current !== r && (r ? (setTimeout(() => {
        r.getRootNode() && n(r);
      }), t.current = r) : t.current = null);
    },
    [e]
  );
  return U(() => {
    if (!e)
      return;
    t.current && setTimeout(() => n(t.current));
    const r = (s) => {
      s.key === "Tab" && t.current && Qu(t.current, s);
    };
    return document.addEventListener("keydown", r), () => document.removeEventListener("keydown", r);
  }, [e]), o;
}
const td = Zo.useId || (() => {
});
function nd() {
  const e = td();
  return e ? `mantine-${e.replace(/:/g, "")}` : "";
}
function Je(e) {
  const t = nd(), [n, o] = W(t);
  return hn(() => {
    o(ju());
  }, []), typeof e == "string" ? e : typeof window > "u" ? t : n;
}
function un(e, t, n) {
  U(() => (window.addEventListener(e, t, n), () => window.removeEventListener(e, t, n)), [e, t]);
}
function od(e, t = "use-local-storage") {
  try {
    return JSON.stringify(e);
  } catch {
    throw new Error(`@mantine/hooks ${t}: Failed to serialize the value`);
  }
}
function rd(e) {
  try {
    return e && JSON.parse(e);
  } catch {
    return e;
  }
}
function sd(e) {
  return { getItem: (r) => {
    try {
      return window[e].getItem(r);
    } catch {
      return console.warn("use-local-storage: Failed to get value from storage, localStorage is blocked"), null;
    }
  }, setItem: (r, s) => {
    try {
      window[e].setItem(r, s);
    } catch {
      console.warn("use-local-storage: Failed to set value to storage, localStorage is blocked");
    }
  }, removeItem: (r) => {
    try {
      window[e].removeItem(r);
    } catch {
      console.warn(
        "use-local-storage: Failed to remove value from storage, localStorage is blocked"
      );
    }
  } };
}
function ai(e, t) {
  const n = e === "localStorage" ? "mantine-local-storage" : "mantine-session-storage", { getItem: o, setItem: r, removeItem: s } = sd(e);
  return function({
    key: i,
    defaultValue: c,
    getInitialValueInEffect: l = !0,
    sync: u = !0,
    deserialize: d = rd,
    serialize: p = (f) => od(f, t)
  }) {
    const f = Y(
      (w) => {
        let y;
        try {
          y = typeof window > "u" || !(e in window) || window[e] === null || !!w;
        } catch {
          y = !0;
        }
        if (y)
          return c;
        const S = o(i);
        return S !== null ? d(S) : c;
      },
      [i, c]
    ), [h, m] = W(f(l)), g = Y(
      (w) => {
        w instanceof Function ? m((y) => {
          const S = w(y);
          return r(i, p(S)), window.dispatchEvent(
            new CustomEvent(n, { detail: { key: i, value: w(y) } })
          ), S;
        }) : (r(i, p(w)), window.dispatchEvent(new CustomEvent(n, { detail: { key: i, value: w } })), m(w));
      },
      [i]
    ), b = Y(() => {
      s(i), window.dispatchEvent(new CustomEvent(n, { detail: { key: i, value: c } }));
    }, []);
    return un("storage", (w) => {
      u && w.storageArea === window[e] && w.key === i && m(d(w.newValue ?? void 0));
    }), un(n, (w) => {
      u && w.detail.key === i && m(w.detail.value);
    }), U(() => {
      c !== void 0 && h === void 0 && g(c);
    }, [c, h, g]), U(() => {
      const w = f();
      w !== void 0 && g(w);
    }, [i]), [h === void 0 ? c : h, g, b];
  };
}
function lb(e) {
  return ai("localStorage", "use-local-storage")(e);
}
function cb(e) {
  return ai("sessionStorage", "use-session-storage")(e);
}
function tr(e, t) {
  if (typeof e == "function")
    return e(t);
  typeof e == "object" && e !== null && "current" in e && (e.current = t);
}
function ad(...e) {
  const t = /* @__PURE__ */ new Map();
  return (n) => {
    if (e.forEach((o) => {
      const r = tr(o, n);
      r && t.set(o, r);
    }), t.size > 0)
      return () => {
        e.forEach((o) => {
          const r = t.get(o);
          r ? r() : tr(o, null);
        }), t.clear();
      };
  };
}
function ue(...e) {
  return Y(ad(...e), e);
}
function ub(e) {
  return {
    x: _t(e.x, 0, 1),
    y: _t(e.y, 0, 1)
  };
}
function id(e, t, n = "ltr") {
  const o = G(null), r = G(!1), s = G(!1), a = G(0), [i, c] = W(!1);
  return U(() => {
    r.current = !0;
  }, []), U(() => {
    const l = o.current, u = ({ x: y, y: S }) => {
      cancelAnimationFrame(a.current), a.current = requestAnimationFrame(() => {
        if (r.current && l) {
          l.style.userSelect = "none";
          const x = l.getBoundingClientRect();
          if (x.width && x.height) {
            const C = _t((y - x.left) / x.width, 0, 1);
            e({
              x: n === "ltr" ? C : 1 - C,
              y: _t((S - x.top) / x.height, 0, 1)
            });
          }
        }
      });
    }, d = () => {
      document.addEventListener("mousemove", g), document.addEventListener("mouseup", h), document.addEventListener("touchmove", w), document.addEventListener("touchend", h);
    }, p = () => {
      document.removeEventListener("mousemove", g), document.removeEventListener("mouseup", h), document.removeEventListener("touchmove", w), document.removeEventListener("touchend", h);
    }, f = () => {
      !s.current && r.current && (s.current = !0, typeof t?.onScrubStart == "function" && t.onScrubStart(), c(!0), d());
    }, h = () => {
      s.current && r.current && (s.current = !1, c(!1), p(), setTimeout(() => {
        typeof t?.onScrubEnd == "function" && t.onScrubEnd();
      }, 0));
    }, m = (y) => {
      f(), y.preventDefault(), g(y);
    }, g = (y) => u({ x: y.clientX, y: y.clientY }), b = (y) => {
      y.cancelable && y.preventDefault(), f(), w(y);
    }, w = (y) => {
      y.cancelable && y.preventDefault(), u({ x: y.changedTouches[0].clientX, y: y.changedTouches[0].clientY });
    };
    return l?.addEventListener("mousedown", m), l?.addEventListener("touchstart", b, { passive: !1 }), () => {
      l && (l.removeEventListener("mousedown", m), l.removeEventListener("touchstart", b));
    };
  }, [n, e]), { ref: o, active: i };
}
function st({
  value: e,
  defaultValue: t,
  finalValue: n,
  onChange: o = () => {
  }
}) {
  const [r, s] = W(
    t !== void 0 ? t : n
  ), a = (i, ...c) => {
    s(i), o?.(i, ...c);
  };
  return e !== void 0 ? [e, o, !0] : [r, a, !1];
}
function ii(e, t) {
  return ei("(prefers-reduced-motion: reduce)", e, t);
}
const ld = {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  top: 0,
  left: 0,
  bottom: 0,
  right: 0
};
function cd(e) {
  const t = G(0), n = G(null), [o, r] = W(ld), s = Nt(
    () => typeof window < "u" ? new ResizeObserver((a) => {
      const i = a[0];
      i && (cancelAnimationFrame(t.current), t.current = requestAnimationFrame(() => {
        n.current && r(i.contentRect);
      }));
    }) : null,
    []
  );
  return U(() => (n.current && s?.observe(n.current, e), () => {
    s?.disconnect(), t.current && cancelAnimationFrame(t.current);
  }), [n.current]), [n, o];
}
function ud(e) {
  const [t, { width: n, height: o }] = cd(e);
  return { ref: t, width: n, height: o };
}
const Hs = {
  passive: !0
};
function db() {
  const [e, t] = W({
    width: 0,
    height: 0
  }), n = Y(() => {
    t({ width: window.innerWidth || 0, height: window.innerHeight || 0 });
  }, []);
  return un("resize", n, Hs), un("orientationchange", n, Hs), U(n, []), e;
}
function dd(e) {
  const t = e.toLowerCase().split("+").map((s) => s.trim()), n = {
    alt: t.includes("alt"),
    ctrl: t.includes("ctrl"),
    meta: t.includes("meta"),
    mod: t.includes("mod"),
    shift: t.includes("shift"),
    plus: t.includes("[plus]")
  }, o = ["alt", "ctrl", "meta", "shift", "mod"], r = t.find((s) => !o.includes(s));
  return {
    ...n,
    key: r === "[plus]" ? "+" : r
  };
}
function fd(e, t, n) {
  const { alt: o, ctrl: r, meta: s, mod: a, shift: i, key: c } = e, { altKey: l, ctrlKey: u, metaKey: d, shiftKey: p, key: f, code: h } = t;
  if (o !== l)
    return !1;
  if (a) {
    if (!u && !d)
      return !1;
  } else if (r !== u || s !== d)
    return !1;
  return i !== p ? !1 : !!(c && (!n && f.toLowerCase() === c.toLowerCase() || h.replace("Key", "").toLowerCase() === c.toLowerCase()));
}
function li(e, t) {
  return (n) => fd(dd(e), n, t);
}
function fb(e) {
  return (t) => {
    const n = "nativeEvent" in t ? t.nativeEvent : t;
    e.forEach(
      ([o, r, s = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
        li(o, s.usePhysicalKeys)(n) && (s.preventDefault && t.preventDefault(), r(n));
      }
    );
  };
}
function pd(e, t, n = !1) {
  return e.target instanceof HTMLElement ? (n || !e.target.isContentEditable) && !t.includes(e.target.tagName) : !0;
}
function pb(e, t = ["INPUT", "TEXTAREA", "SELECT"], n = !1) {
  U(() => {
    const o = (r) => {
      e.forEach(
        ([s, a, i = { preventDefault: !0, usePhysicalKeys: !1 }]) => {
          li(s, i.usePhysicalKeys)(r) && pd(r, t, n) && (i.preventDefault && r.preventDefault(), a(r));
        }
      );
    };
    return document.documentElement.addEventListener("keydown", o), () => document.documentElement.removeEventListener("keydown", o);
  }, [e]);
}
function mb() {
  const [e, t] = W(!1), n = G(null), o = Y(() => t(!0), []), r = Y(() => t(!1), []);
  return U(() => {
    const s = n.current;
    if (s)
      return s.addEventListener("mouseenter", o), s.addEventListener("mouseleave", r), () => {
        s?.removeEventListener("mouseenter", o), s?.removeEventListener("mouseleave", r);
      };
  }, [n.current]), { ref: n, hovered: e };
}
function md(e = !1, t) {
  const { onOpen: n, onClose: o } = t || {}, [r, s] = W(e), a = Y(() => {
    s((l) => l || (n?.(), !0));
  }, [n]), i = Y(() => {
    s((l) => l && (o?.(), !1));
  }, [o]), c = Y(() => {
    r ? i() : a();
  }, [i, a, r]);
  return [r, { open: a, close: i, toggle: c }];
}
function hd(e) {
  return e.currentTarget instanceof HTMLElement && e.relatedTarget instanceof HTMLElement ? e.currentTarget.contains(e.relatedTarget) : !1;
}
function hb({
  onBlur: e,
  onFocus: t
} = {}) {
  const n = G(null), [o, r] = W(!1), s = G(!1), a = (l) => {
    r(l), s.current = l;
  }, i = (l) => {
    s.current || (a(!0), t?.(l));
  }, c = (l) => {
    s.current && !hd(l) && (a(!1), e?.(l));
  };
  return U(() => {
    const l = n.current;
    if (l)
      return l.addEventListener("focusin", i), l.addEventListener("focusout", c), () => {
        l?.removeEventListener("focusin", i), l?.removeEventListener("focusout", c);
      };
  }, [i, c]), { ref: n, focused: o };
}
function vd(e, t, n = { autoInvoke: !1 }) {
  const o = G(null), r = Y(
    (...a) => {
      o.current || (o.current = window.setTimeout(() => {
        e(a), o.current = null;
      }, t));
    },
    [t]
  ), s = Y(() => {
    o.current && (window.clearTimeout(o.current), o.current = null);
  }, []);
  return U(() => (n.autoInvoke && r(), s), [s, r]), { start: r, clear: s };
}
function gd(e) {
  const t = G(void 0);
  return U(() => {
    t.current = e;
  }, [e]), t.current;
}
function vb() {
  const e = G(null), [t, n] = W(!1);
  return { ref: Y((r) => {
    typeof IntersectionObserver < "u" && (r && !e.current ? e.current = new IntersectionObserver(
      (s) => n(s.some((a) => a.isIntersecting))
    ) : e.current?.disconnect(), r ? e.current?.observe(r) : n(!1));
  }, []), inViewport: t };
}
function yd(e, t, n) {
  const o = G(null), r = G(null);
  return U(() => {
    const s = typeof n == "function" ? n() : n;
    return (s || r.current) && (o.current = new MutationObserver(e), o.current.observe(s || r.current, t)), () => {
      o.current?.disconnect();
    };
  }, [e, t]), r;
}
function bd() {
  const [e, t] = W(!1);
  return U(() => t(!0), []), e;
}
function gb(e) {
  const [t, n] = W({
    history: [e],
    current: 0
  }), o = Y(
    (c) => n((l) => {
      const u = [...l.history.slice(0, l.current + 1), c];
      return {
        history: u,
        current: u.length - 1
      };
    }),
    []
  ), r = Y(
    (c = 1) => n((l) => ({
      history: l.history,
      current: Math.max(0, l.current - c)
    })),
    []
  ), s = Y(
    (c = 1) => n((l) => ({
      history: l.history,
      current: Math.min(l.history.length - 1, l.current + c)
    })),
    []
  ), a = Y(() => {
    n({ history: [e], current: 0 });
  }, [e]), i = Nt(() => ({ back: r, forward: s, reset: a, set: o }), [r, s, a, o]);
  return [t.history[t.current], i, t];
}
function yb() {
  const e = G(!0);
  return e.current === !0 ? (e.current = !1, !0) : e.current;
}
function wd() {
  return typeof process < "u" && process.env ? "production" : "development";
}
function ci(e) {
  const t = /* @__PURE__ */ new Map();
  return (...n) => {
    const o = JSON.stringify(n);
    if (t.has(o))
      return t.get(o);
    const r = e(...n);
    return t.set(o, r), r;
  };
}
function Vs(e, t) {
  return t.length === 0 ? e : t.reduce(
    (n, o) => Math.abs(o - e) < Math.abs(n - e) ? o : n
  );
}
function Yn(e) {
  const t = Zo.version;
  return typeof Zo.version != "string" || t.startsWith("18.") ? e?.ref : e?.props?.ref;
}
function ui(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = ui(e[t])) && (o && (o += " "), o += n);
  } else for (n in e) e[n] && (o && (o += " "), o += n);
  return o;
}
function ve() {
  for (var e, t, n = 0, o = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = ui(e)) && (o && (o += " "), o += t);
  return o;
}
const Sd = {};
function xd(e) {
  const t = {};
  return e.forEach((n) => {
    Object.entries(n).forEach(([o, r]) => {
      t[o] ? t[o] = ve(t[o], r) : t[o] = r;
    });
  }), t;
}
function Kn({ theme: e, classNames: t, props: n, stylesCtx: o }) {
  const s = (Array.isArray(t) ? t : [t]).map(
    (a) => typeof a == "function" ? a(e, n, o) : a || Sd
  );
  return xd(s);
}
function Ln({ theme: e, styles: t, props: n, stylesCtx: o }) {
  return (Array.isArray(t) ? t : [t]).reduce((s, a) => typeof a == "function" ? { ...s, ...a(e, n, o) } : { ...s, ...a }, {});
}
const gr = Kt(null);
function bt() {
  const e = gt(gr);
  if (!e)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  return e;
}
function Cd() {
  return bt().cssVariablesResolver;
}
function $d() {
  return bt().classNamesPrefix;
}
function Xn() {
  return bt().getStyleNonce;
}
function Pd() {
  return bt().withStaticClasses;
}
function _d() {
  return bt().headless;
}
function Rd() {
  return bt().stylesTransform?.sx;
}
function Nd() {
  return bt().stylesTransform?.styles;
}
function di() {
  return bt().env || "default";
}
function Td(e) {
  return /^#?([0-9A-F]{3}){1,2}([0-9A-F]{2})?$/i.test(e);
}
function Ed(e) {
  let t = e.replace("#", "");
  if (t.length === 3) {
    const a = t.split("");
    t = [
      a[0],
      a[0],
      a[1],
      a[1],
      a[2],
      a[2]
    ].join("");
  }
  if (t.length === 8) {
    const a = parseInt(t.slice(6, 8), 16) / 255;
    return {
      r: parseInt(t.slice(0, 2), 16),
      g: parseInt(t.slice(2, 4), 16),
      b: parseInt(t.slice(4, 6), 16),
      a
    };
  }
  const n = parseInt(t, 16), o = n >> 16 & 255, r = n >> 8 & 255, s = n & 255;
  return {
    r: o,
    g: r,
    b: s,
    a: 1
  };
}
function kd(e) {
  const [t, n, o, r] = e.replace(/[^0-9,./]/g, "").split(/[/,]/).map(Number);
  return { r: t, g: n, b: o, a: r || 1 };
}
function Md(e) {
  const t = /^hsla?\(\s*(\d+)\s*,\s*(\d+%)\s*,\s*(\d+%)\s*(,\s*(0?\.\d+|\d+(\.\d+)?))?\s*\)$/i, n = e.match(t);
  if (!n)
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 1
    };
  const o = parseInt(n[1], 10), r = parseInt(n[2], 10) / 100, s = parseInt(n[3], 10) / 100, a = n[5] ? parseFloat(n[5]) : void 0, i = (1 - Math.abs(2 * s - 1)) * r, c = o / 60, l = i * (1 - Math.abs(c % 2 - 1)), u = s - i / 2;
  let d, p, f;
  return c >= 0 && c < 1 ? (d = i, p = l, f = 0) : c >= 1 && c < 2 ? (d = l, p = i, f = 0) : c >= 2 && c < 3 ? (d = 0, p = i, f = l) : c >= 3 && c < 4 ? (d = 0, p = l, f = i) : c >= 4 && c < 5 ? (d = l, p = 0, f = i) : (d = i, p = 0, f = l), {
    r: Math.round((d + u) * 255),
    g: Math.round((p + u) * 255),
    b: Math.round((f + u) * 255),
    a: a || 1
  };
}
function yr(e) {
  return Td(e) ? Ed(e) : e.startsWith("rgb") ? kd(e) : e.startsWith("hsl") ? Md(e) : {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  };
}
function Nn(e, t) {
  if (e.startsWith("var("))
    return `color-mix(in srgb, ${e}, black ${t * 100}%)`;
  const { r: n, g: o, b: r, a: s } = yr(e), a = 1 - t, i = (c) => Math.round(c * a);
  return `rgba(${i(n)}, ${i(o)}, ${i(r)}, ${s})`;
}
function dn(e, t) {
  return typeof e.primaryShade == "number" ? e.primaryShade : t === "dark" ? e.primaryShade.dark : e.primaryShade.light;
}
function Io(e) {
  return e <= 0.03928 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
}
function Ad(e) {
  const t = e.match(/oklch\((.*?)%\s/);
  return t ? parseFloat(t[1]) : null;
}
function Dd(e) {
  if (e.startsWith("oklch("))
    return (Ad(e) || 0) / 100;
  const { r: t, g: n, b: o } = yr(e), r = t / 255, s = n / 255, a = o / 255, i = Io(r), c = Io(s), l = Io(a);
  return 0.2126 * i + 0.7152 * c + 0.0722 * l;
}
function nn(e, t = 0.179) {
  return e.startsWith("var(") ? !1 : Dd(e) > t;
}
function Et({
  color: e,
  theme: t,
  colorScheme: n
}) {
  if (typeof e != "string")
    throw new Error(
      `[@mantine/core] Failed to parse color. Expected color to be a string, instead got ${typeof e}`
    );
  if (e === "bright")
    return {
      color: e,
      value: n === "dark" ? t.white : t.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: nn(
        n === "dark" ? t.white : t.black,
        t.luminanceThreshold
      ),
      variable: "--mantine-color-bright"
    };
  if (e === "dimmed")
    return {
      color: e,
      value: n === "dark" ? t.colors.dark[2] : t.colors.gray[7],
      shade: void 0,
      isThemeColor: !1,
      isLight: nn(
        n === "dark" ? t.colors.dark[2] : t.colors.gray[6],
        t.luminanceThreshold
      ),
      variable: "--mantine-color-dimmed"
    };
  if (e === "white" || e === "black")
    return {
      color: e,
      value: e === "white" ? t.white : t.black,
      shade: void 0,
      isThemeColor: !1,
      isLight: nn(
        e === "white" ? t.white : t.black,
        t.luminanceThreshold
      ),
      variable: `--mantine-color-${e}`
    };
  const [o, r] = e.split("."), s = r ? Number(r) : void 0, a = o in t.colors;
  if (a) {
    const i = s !== void 0 ? t.colors[o][s] : t.colors[o][dn(t, n || "light")];
    return {
      color: o,
      value: i,
      shade: s,
      isThemeColor: a,
      isLight: nn(i, t.luminanceThreshold),
      variable: r ? `--mantine-color-${o}-${s}` : `--mantine-color-${o}-filled`
    };
  }
  return {
    color: e,
    value: e,
    isThemeColor: a,
    isLight: nn(e, t.luminanceThreshold),
    shade: s,
    variable: void 0
  };
}
function xe(e, t) {
  const n = Et({ color: e || t.primaryColor, theme: t });
  return n.variable ? `var(${n.variable})` : e;
}
function nr(e, t) {
  const n = {
    from: e?.from || t.defaultGradient.from,
    to: e?.to || t.defaultGradient.to,
    deg: e?.deg ?? t.defaultGradient.deg ?? 0
  }, o = xe(n.from, t), r = xe(n.to, t);
  return `linear-gradient(${n.deg}deg, ${o} 0%, ${r} 100%)`;
}
function Xe(e, t) {
  if (typeof e != "string" || t > 1 || t < 0)
    return "rgba(0, 0, 0, 1)";
  if (e.startsWith("var(")) {
    const s = (1 - t) * 100;
    return `color-mix(in srgb, ${e}, transparent ${s}%)`;
  }
  if (e.startsWith("oklch"))
    return e.includes("/") ? e.replace(/\/\s*[\d.]+\s*\)/, `/ ${t})`) : e.replace(")", ` / ${t})`);
  const { r: n, g: o, b: r } = yr(e);
  return `rgba(${n}, ${o}, ${r}, ${t})`;
}
const Ot = Xe, Id = ({
  color: e,
  theme: t,
  variant: n,
  gradient: o,
  autoContrast: r
}) => {
  const s = Et({ color: e, theme: t }), a = typeof r == "boolean" ? r : t.autoContrast;
  if (n === "filled") {
    const i = a && s.isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
    return s.isThemeColor ? s.shade === void 0 ? {
      background: `var(--mantine-color-${e}-filled)`,
      hover: `var(--mantine-color-${e}-filled-hover)`,
      color: i,
      border: `${E(1)} solid transparent`
    } : {
      background: `var(--mantine-color-${s.color}-${s.shade})`,
      hover: `var(--mantine-color-${s.color}-${s.shade === 9 ? 8 : s.shade + 1})`,
      color: i,
      border: `${E(1)} solid transparent`
    } : {
      background: e,
      hover: Nn(e, 0.1),
      color: i,
      border: `${E(1)} solid transparent`
    };
  }
  if (n === "light") {
    if (s.isThemeColor) {
      if (s.shade === void 0)
        return {
          background: `var(--mantine-color-${e}-light)`,
          hover: `var(--mantine-color-${e}-light-hover)`,
          color: `var(--mantine-color-${e}-light-color)`,
          border: `${E(1)} solid transparent`
        };
      const i = t.colors[s.color][s.shade];
      return {
        background: Xe(i, 0.1),
        hover: Xe(i, 0.12),
        color: `var(--mantine-color-${s.color}-${Math.min(s.shade, 6)})`,
        border: `${E(1)} solid transparent`
      };
    }
    return {
      background: Xe(e, 0.1),
      hover: Xe(e, 0.12),
      color: e,
      border: `${E(1)} solid transparent`
    };
  }
  if (n === "outline")
    return s.isThemeColor ? s.shade === void 0 ? {
      background: "transparent",
      hover: `var(--mantine-color-${e}-outline-hover)`,
      color: `var(--mantine-color-${e}-outline)`,
      border: `${E(1)} solid var(--mantine-color-${e}-outline)`
    } : {
      background: "transparent",
      hover: Xe(t.colors[s.color][s.shade], 0.05),
      color: `var(--mantine-color-${s.color}-${s.shade})`,
      border: `${E(1)} solid var(--mantine-color-${s.color}-${s.shade})`
    } : {
      background: "transparent",
      hover: Xe(e, 0.05),
      color: e,
      border: `${E(1)} solid ${e}`
    };
  if (n === "subtle") {
    if (s.isThemeColor) {
      if (s.shade === void 0)
        return {
          background: "transparent",
          hover: `var(--mantine-color-${e}-light-hover)`,
          color: `var(--mantine-color-${e}-light-color)`,
          border: `${E(1)} solid transparent`
        };
      const i = t.colors[s.color][s.shade];
      return {
        background: "transparent",
        hover: Xe(i, 0.12),
        color: `var(--mantine-color-${s.color}-${Math.min(s.shade, 6)})`,
        border: `${E(1)} solid transparent`
      };
    }
    return {
      background: "transparent",
      hover: Xe(e, 0.12),
      color: e,
      border: `${E(1)} solid transparent`
    };
  }
  return n === "transparent" ? s.isThemeColor ? s.shade === void 0 ? {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${e}-light-color)`,
    border: `${E(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: `var(--mantine-color-${s.color}-${Math.min(s.shade, 6)})`,
    border: `${E(1)} solid transparent`
  } : {
    background: "transparent",
    hover: "transparent",
    color: e,
    border: `${E(1)} solid transparent`
  } : n === "white" ? s.isThemeColor ? s.shade === void 0 ? {
    background: "var(--mantine-color-white)",
    hover: Nn(t.white, 0.01),
    color: `var(--mantine-color-${e}-filled)`,
    border: `${E(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: Nn(t.white, 0.01),
    color: `var(--mantine-color-${s.color}-${s.shade})`,
    border: `${E(1)} solid transparent`
  } : {
    background: "var(--mantine-color-white)",
    hover: Nn(t.white, 0.01),
    color: e,
    border: `${E(1)} solid transparent`
  } : n === "gradient" ? {
    background: nr(o, t),
    hover: nr(o, t),
    color: "var(--mantine-color-white)",
    border: "none"
  } : n === "default" ? {
    background: "var(--mantine-color-default)",
    hover: "var(--mantine-color-default-hover)",
    color: "var(--mantine-color-default-color)",
    border: `${E(1)} solid var(--mantine-color-default-border)`
  } : {};
}, Od = {
  dark: [
    "#C9C9C9",
    "#b8b8b8",
    "#828282",
    "#696969",
    "#424242",
    "#3b3b3b",
    "#2e2e2e",
    "#242424",
    "#1f1f1f",
    "#141414"
  ],
  gray: [
    "#f8f9fa",
    "#f1f3f5",
    "#e9ecef",
    "#dee2e6",
    "#ced4da",
    "#adb5bd",
    "#868e96",
    "#495057",
    "#343a40",
    "#212529"
  ],
  red: [
    "#fff5f5",
    "#ffe3e3",
    "#ffc9c9",
    "#ffa8a8",
    "#ff8787",
    "#ff6b6b",
    "#fa5252",
    "#f03e3e",
    "#e03131",
    "#c92a2a"
  ],
  pink: [
    "#fff0f6",
    "#ffdeeb",
    "#fcc2d7",
    "#faa2c1",
    "#f783ac",
    "#f06595",
    "#e64980",
    "#d6336c",
    "#c2255c",
    "#a61e4d"
  ],
  grape: [
    "#f8f0fc",
    "#f3d9fa",
    "#eebefa",
    "#e599f7",
    "#da77f2",
    "#cc5de8",
    "#be4bdb",
    "#ae3ec9",
    "#9c36b5",
    "#862e9c"
  ],
  violet: [
    "#f3f0ff",
    "#e5dbff",
    "#d0bfff",
    "#b197fc",
    "#9775fa",
    "#845ef7",
    "#7950f2",
    "#7048e8",
    "#6741d9",
    "#5f3dc4"
  ],
  indigo: [
    "#edf2ff",
    "#dbe4ff",
    "#bac8ff",
    "#91a7ff",
    "#748ffc",
    "#5c7cfa",
    "#4c6ef5",
    "#4263eb",
    "#3b5bdb",
    "#364fc7"
  ],
  blue: [
    "#e7f5ff",
    "#d0ebff",
    "#a5d8ff",
    "#74c0fc",
    "#4dabf7",
    "#339af0",
    "#228be6",
    "#1c7ed6",
    "#1971c2",
    "#1864ab"
  ],
  cyan: [
    "#e3fafc",
    "#c5f6fa",
    "#99e9f2",
    "#66d9e8",
    "#3bc9db",
    "#22b8cf",
    "#15aabf",
    "#1098ad",
    "#0c8599",
    "#0b7285"
  ],
  teal: [
    "#e6fcf5",
    "#c3fae8",
    "#96f2d7",
    "#63e6be",
    "#38d9a9",
    "#20c997",
    "#12b886",
    "#0ca678",
    "#099268",
    "#087f5b"
  ],
  green: [
    "#ebfbee",
    "#d3f9d8",
    "#b2f2bb",
    "#8ce99a",
    "#69db7c",
    "#51cf66",
    "#40c057",
    "#37b24d",
    "#2f9e44",
    "#2b8a3e"
  ],
  lime: [
    "#f4fce3",
    "#e9fac8",
    "#d8f5a2",
    "#c0eb75",
    "#a9e34b",
    "#94d82d",
    "#82c91e",
    "#74b816",
    "#66a80f",
    "#5c940d"
  ],
  yellow: [
    "#fff9db",
    "#fff3bf",
    "#ffec99",
    "#ffe066",
    "#ffd43b",
    "#fcc419",
    "#fab005",
    "#f59f00",
    "#f08c00",
    "#e67700"
  ],
  orange: [
    "#fff4e6",
    "#ffe8cc",
    "#ffd8a8",
    "#ffc078",
    "#ffa94d",
    "#ff922b",
    "#fd7e14",
    "#f76707",
    "#e8590c",
    "#d9480f"
  ]
}, Ws = "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji", Un = {
  scale: 1,
  fontSmoothing: !0,
  focusRing: "auto",
  white: "#fff",
  black: "#000",
  colors: Od,
  primaryShade: { light: 6, dark: 8 },
  primaryColor: "blue",
  variantColorResolver: Id,
  autoContrast: !1,
  luminanceThreshold: 0.3,
  fontFamily: Ws,
  fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
  respectReducedMotion: !1,
  cursorType: "default",
  defaultGradient: { from: "blue", to: "cyan", deg: 45 },
  defaultRadius: "sm",
  activeClassName: "mantine-active",
  focusClassName: "",
  headings: {
    fontFamily: Ws,
    fontWeight: "700",
    textWrap: "wrap",
    sizes: {
      h1: { fontSize: E(34), lineHeight: "1.3" },
      h2: { fontSize: E(26), lineHeight: "1.35" },
      h3: { fontSize: E(22), lineHeight: "1.4" },
      h4: { fontSize: E(18), lineHeight: "1.45" },
      h5: { fontSize: E(16), lineHeight: "1.5" },
      h6: { fontSize: E(14), lineHeight: "1.5" }
    }
  },
  fontSizes: {
    xs: E(12),
    sm: E(14),
    md: E(16),
    lg: E(18),
    xl: E(20)
  },
  lineHeights: {
    xs: "1.4",
    sm: "1.45",
    md: "1.55",
    lg: "1.6",
    xl: "1.65"
  },
  radius: {
    xs: E(2),
    sm: E(4),
    md: E(8),
    lg: E(16),
    xl: E(32)
  },
  spacing: {
    xs: E(10),
    sm: E(12),
    md: E(16),
    lg: E(20),
    xl: E(32)
  },
  breakpoints: {
    xs: "36em",
    sm: "48em",
    md: "62em",
    lg: "75em",
    xl: "88em"
  },
  shadows: {
    xs: `0 ${E(1)} ${E(3)} rgba(0, 0, 0, 0.05), 0 ${E(1)} ${E(2)} rgba(0, 0, 0, 0.1)`,
    sm: `0 ${E(1)} ${E(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${E(10)} ${E(
      15
    )} ${E(-5)}, rgba(0, 0, 0, 0.04) 0 ${E(7)} ${E(7)} ${E(-5)}`,
    md: `0 ${E(1)} ${E(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${E(20)} ${E(
      25
    )} ${E(-5)}, rgba(0, 0, 0, 0.04) 0 ${E(10)} ${E(10)} ${E(-5)}`,
    lg: `0 ${E(1)} ${E(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${E(28)} ${E(
      23
    )} ${E(-7)}, rgba(0, 0, 0, 0.04) 0 ${E(12)} ${E(12)} ${E(-7)}`,
    xl: `0 ${E(1)} ${E(3)} rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 ${E(36)} ${E(
      28
    )} ${E(-7)}, rgba(0, 0, 0, 0.04) 0 ${E(17)} ${E(17)} ${E(-7)}`
  },
  other: {},
  components: {}
};
function js(e) {
  return e === "auto" || e === "dark" || e === "light";
}
function Ld({
  key: e = "mantine-color-scheme-value"
} = {}) {
  let t;
  return {
    get: (n) => {
      if (typeof window > "u")
        return n;
      try {
        const o = window.localStorage.getItem(e);
        return js(o) ? o : n;
      } catch {
        return n;
      }
    },
    set: (n) => {
      try {
        window.localStorage.setItem(e, n);
      } catch (o) {
        console.warn(
          "[@mantine/core] Local storage color scheme manager was unable to save color scheme.",
          o
        );
      }
    },
    subscribe: (n) => {
      t = (o) => {
        o.storageArea === window.localStorage && o.key === e && js(o.newValue) && n(o.newValue);
      }, window.addEventListener("storage", t);
    },
    unsubscribe: () => {
      window.removeEventListener("storage", t);
    },
    clear: () => {
      window.localStorage.removeItem(e);
    }
  };
}
const zd = "[@mantine/core] MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color", Gs = "[@mantine/core] MantineProvider: Invalid theme.primaryShade, it accepts only 0-9 integers or an object { light: 0-9, dark: 0-9 }";
function Oo(e) {
  return e < 0 || e > 9 ? !1 : parseInt(e.toString(), 10) === e;
}
function Ys(e) {
  if (!(e.primaryColor in e.colors))
    throw new Error(zd);
  if (typeof e.primaryShade == "object" && (!Oo(e.primaryShade.dark) || !Oo(e.primaryShade.light)))
    throw new Error(Gs);
  if (typeof e.primaryShade == "number" && !Oo(e.primaryShade))
    throw new Error(Gs);
}
function fi(e, t) {
  if (!t)
    return Ys(e), e;
  const n = mr(e, t);
  return t.fontFamily && !t.headings?.fontFamily && (n.headings.fontFamily = t.fontFamily), Ys(n), n;
}
const br = Kt(null), Bd = () => gt(br) || Un;
function ye() {
  const e = gt(br);
  if (!e)
    throw new Error(
      "@mantine/core: MantineProvider was not found in component tree, make sure you have it in your app"
    );
  return e;
}
function pi({
  theme: e,
  children: t,
  inherit: n = !0
}) {
  const o = Bd(), r = Nt(
    () => fi(n ? o : Un, e),
    [e, o, n]
  );
  return /* @__PURE__ */ v(br.Provider, { value: r, children: t });
}
pi.displayName = "@mantine/core/MantineThemeProvider";
function Fd() {
  const e = ye(), t = Xn(), n = ce(e.breakpoints).reduce((o, r) => {
    const s = e.breakpoints[r].includes("px"), a = cn(e.breakpoints[r]), i = s ? `${a - 0.1}px` : Qo(a - 0.1), c = s ? `${a}px` : Qo(a);
    return `${o}@media (max-width: ${i}) {.mantine-visible-from-${r} {display: none !important;}}@media (min-width: ${c}) {.mantine-hidden-from-${r} {display: none !important;}}`;
  }, "");
  return /* @__PURE__ */ v(
    "style",
    {
      "data-mantine-styles": "classes",
      nonce: t?.(),
      dangerouslySetInnerHTML: { __html: n }
    }
  );
}
function Lo(e) {
  return Object.entries(e).map(([t, n]) => `${t}: ${n};`).join("");
}
function on(e, t) {
  return (Array.isArray(e) ? e : [e]).reduce((o, r) => `${r}{${o}}`, t);
}
function Hd(e, t) {
  const n = Lo(e.variables), o = n ? on(t, n) : "", r = Lo(e.dark), s = Lo(e.light), a = r ? on(t === ":host" ? `${t}([data-mantine-color-scheme="dark"])` : `${t}[data-mantine-color-scheme="dark"]`, r) : "", i = s ? on(t === ":host" ? `${t}([data-mantine-color-scheme="light"])` : `${t}[data-mantine-color-scheme="light"]`, s) : "";
  return `${o}${a}${i}`;
}
function wr({ color: e, theme: t, autoContrast: n }) {
  return (typeof n == "boolean" ? n : t.autoContrast) && Et({ color: e || t.primaryColor, theme: t }).isLight ? "var(--mantine-color-black)" : "var(--mantine-color-white)";
}
function Ks(e, t) {
  return wr({
    color: e.colors[e.primaryColor][dn(e, t)],
    theme: e,
    autoContrast: null
  });
}
function Tn({
  theme: e,
  color: t,
  colorScheme: n,
  name: o = t,
  withColorValues: r = !0
}) {
  if (!e.colors[t])
    return {};
  if (n === "light") {
    const i = dn(e, "light"), c = {
      [`--mantine-color-${o}-text`]: `var(--mantine-color-${o}-filled)`,
      [`--mantine-color-${o}-filled`]: `var(--mantine-color-${o}-${i})`,
      [`--mantine-color-${o}-filled-hover`]: `var(--mantine-color-${o}-${i === 9 ? 8 : i + 1})`,
      [`--mantine-color-${o}-light`]: Ot(e.colors[t][i], 0.1),
      [`--mantine-color-${o}-light-hover`]: Ot(e.colors[t][i], 0.12),
      [`--mantine-color-${o}-light-color`]: `var(--mantine-color-${o}-${i})`,
      [`--mantine-color-${o}-outline`]: `var(--mantine-color-${o}-${i})`,
      [`--mantine-color-${o}-outline-hover`]: Ot(e.colors[t][i], 0.05)
    };
    return r ? {
      [`--mantine-color-${o}-0`]: e.colors[t][0],
      [`--mantine-color-${o}-1`]: e.colors[t][1],
      [`--mantine-color-${o}-2`]: e.colors[t][2],
      [`--mantine-color-${o}-3`]: e.colors[t][3],
      [`--mantine-color-${o}-4`]: e.colors[t][4],
      [`--mantine-color-${o}-5`]: e.colors[t][5],
      [`--mantine-color-${o}-6`]: e.colors[t][6],
      [`--mantine-color-${o}-7`]: e.colors[t][7],
      [`--mantine-color-${o}-8`]: e.colors[t][8],
      [`--mantine-color-${o}-9`]: e.colors[t][9],
      ...c
    } : c;
  }
  const s = dn(e, "dark"), a = {
    [`--mantine-color-${o}-text`]: `var(--mantine-color-${o}-4)`,
    [`--mantine-color-${o}-filled`]: `var(--mantine-color-${o}-${s})`,
    [`--mantine-color-${o}-filled-hover`]: `var(--mantine-color-${o}-${s === 9 ? 8 : s + 1})`,
    [`--mantine-color-${o}-light`]: Ot(
      e.colors[t][Math.max(0, s - 2)],
      0.15
    ),
    [`--mantine-color-${o}-light-hover`]: Ot(
      e.colors[t][Math.max(0, s - 2)],
      0.2
    ),
    [`--mantine-color-${o}-light-color`]: `var(--mantine-color-${o}-${Math.max(s - 5, 0)})`,
    [`--mantine-color-${o}-outline`]: `var(--mantine-color-${o}-${Math.max(s - 4, 0)})`,
    [`--mantine-color-${o}-outline-hover`]: Ot(
      e.colors[t][Math.max(s - 4, 0)],
      0.05
    )
  };
  return r ? {
    [`--mantine-color-${o}-0`]: e.colors[t][0],
    [`--mantine-color-${o}-1`]: e.colors[t][1],
    [`--mantine-color-${o}-2`]: e.colors[t][2],
    [`--mantine-color-${o}-3`]: e.colors[t][3],
    [`--mantine-color-${o}-4`]: e.colors[t][4],
    [`--mantine-color-${o}-5`]: e.colors[t][5],
    [`--mantine-color-${o}-6`]: e.colors[t][6],
    [`--mantine-color-${o}-7`]: e.colors[t][7],
    [`--mantine-color-${o}-8`]: e.colors[t][8],
    [`--mantine-color-${o}-9`]: e.colors[t][9],
    ...a
  } : a;
}
function Vd(e) {
  return !!e && typeof e == "object" && "mantine-virtual-color" in e;
}
function Lt(e, t, n) {
  ce(t).forEach(
    (o) => Object.assign(e, { [`--mantine-${n}-${o}`]: t[o] })
  );
}
const mi = (e) => {
  const t = dn(e, "light"), n = e.defaultRadius in e.radius ? e.radius[e.defaultRadius] : E(e.defaultRadius), o = {
    variables: {
      "--mantine-scale": e.scale.toString(),
      "--mantine-cursor-type": e.cursorType,
      "--mantine-color-scheme": "light dark",
      "--mantine-webkit-font-smoothing": e.fontSmoothing ? "antialiased" : "unset",
      "--mantine-moz-font-smoothing": e.fontSmoothing ? "grayscale" : "unset",
      "--mantine-color-white": e.white,
      "--mantine-color-black": e.black,
      "--mantine-line-height": e.lineHeights.md,
      "--mantine-font-family": e.fontFamily,
      "--mantine-font-family-monospace": e.fontFamilyMonospace,
      "--mantine-font-family-headings": e.headings.fontFamily,
      "--mantine-heading-font-weight": e.headings.fontWeight,
      "--mantine-heading-text-wrap": e.headings.textWrap,
      "--mantine-radius-default": n,
      // Primary colors
      "--mantine-primary-color-filled": `var(--mantine-color-${e.primaryColor}-filled)`,
      "--mantine-primary-color-filled-hover": `var(--mantine-color-${e.primaryColor}-filled-hover)`,
      "--mantine-primary-color-light": `var(--mantine-color-${e.primaryColor}-light)`,
      "--mantine-primary-color-light-hover": `var(--mantine-color-${e.primaryColor}-light-hover)`,
      "--mantine-primary-color-light-color": `var(--mantine-color-${e.primaryColor}-light-color)`
    },
    light: {
      "--mantine-primary-color-contrast": Ks(e, "light"),
      "--mantine-color-bright": "var(--mantine-color-black)",
      "--mantine-color-text": e.black,
      "--mantine-color-body": e.white,
      "--mantine-color-error": "var(--mantine-color-red-6)",
      "--mantine-color-placeholder": "var(--mantine-color-gray-5)",
      "--mantine-color-anchor": `var(--mantine-color-${e.primaryColor}-${t})`,
      "--mantine-color-default": "var(--mantine-color-white)",
      "--mantine-color-default-hover": "var(--mantine-color-gray-0)",
      "--mantine-color-default-color": "var(--mantine-color-black)",
      "--mantine-color-default-border": "var(--mantine-color-gray-4)",
      "--mantine-color-dimmed": "var(--mantine-color-gray-6)"
    },
    dark: {
      "--mantine-primary-color-contrast": Ks(e, "dark"),
      "--mantine-color-bright": "var(--mantine-color-white)",
      "--mantine-color-text": "var(--mantine-color-dark-0)",
      "--mantine-color-body": "var(--mantine-color-dark-7)",
      "--mantine-color-error": "var(--mantine-color-red-8)",
      "--mantine-color-placeholder": "var(--mantine-color-dark-3)",
      "--mantine-color-anchor": `var(--mantine-color-${e.primaryColor}-4)`,
      "--mantine-color-default": "var(--mantine-color-dark-6)",
      "--mantine-color-default-hover": "var(--mantine-color-dark-5)",
      "--mantine-color-default-color": "var(--mantine-color-white)",
      "--mantine-color-default-border": "var(--mantine-color-dark-4)",
      "--mantine-color-dimmed": "var(--mantine-color-dark-2)"
    }
  };
  Lt(o.variables, e.breakpoints, "breakpoint"), Lt(o.variables, e.spacing, "spacing"), Lt(o.variables, e.fontSizes, "font-size"), Lt(o.variables, e.lineHeights, "line-height"), Lt(o.variables, e.shadows, "shadow"), Lt(o.variables, e.radius, "radius"), e.colors[e.primaryColor].forEach((s, a) => {
    o.variables[`--mantine-primary-color-${a}`] = `var(--mantine-color-${e.primaryColor}-${a})`;
  }), ce(e.colors).forEach((s) => {
    const a = e.colors[s];
    if (Vd(a)) {
      Object.assign(
        o.light,
        Tn({
          theme: e,
          name: a.name,
          color: a.light,
          colorScheme: "light",
          withColorValues: !0
        })
      ), Object.assign(
        o.dark,
        Tn({
          theme: e,
          name: a.name,
          color: a.dark,
          colorScheme: "dark",
          withColorValues: !0
        })
      );
      return;
    }
    a.forEach((i, c) => {
      o.variables[`--mantine-color-${s}-${c}`] = i;
    }), Object.assign(
      o.light,
      Tn({
        theme: e,
        color: s,
        colorScheme: "light",
        withColorValues: !1
      })
    ), Object.assign(
      o.dark,
      Tn({
        theme: e,
        color: s,
        colorScheme: "dark",
        withColorValues: !1
      })
    );
  });
  const r = e.headings.sizes;
  return ce(r).forEach((s) => {
    o.variables[`--mantine-${s}-font-size`] = r[s].fontSize, o.variables[`--mantine-${s}-line-height`] = r[s].lineHeight, o.variables[`--mantine-${s}-font-weight`] = r[s].fontWeight || e.headings.fontWeight;
  }), o;
};
function Wd({ theme: e, generator: t }) {
  const n = mi(e), o = t?.(e);
  return o ? mr(n, o) : n;
}
const zo = mi(Un);
function jd(e) {
  const t = {
    variables: {},
    light: {},
    dark: {}
  };
  return ce(e.variables).forEach((n) => {
    zo.variables[n] !== e.variables[n] && (t.variables[n] = e.variables[n]);
  }), ce(e.light).forEach((n) => {
    zo.light[n] !== e.light[n] && (t.light[n] = e.light[n]);
  }), ce(e.dark).forEach((n) => {
    zo.dark[n] !== e.dark[n] && (t.dark[n] = e.dark[n]);
  }), t;
}
function Gd(e) {
  return `
  ${e}[data-mantine-color-scheme="dark"] { --mantine-color-scheme: dark; }
  ${e}[data-mantine-color-scheme="light"] { --mantine-color-scheme: light; }
`;
}
function hi({
  cssVariablesSelector: e,
  deduplicateCssVariables: t
}) {
  const n = ye(), o = Xn(), r = Cd(), s = Wd({ theme: n, generator: r }), a = e === ":root" && t, i = a ? jd(s) : s, c = Hd(i, e);
  return c ? /* @__PURE__ */ v(
    "style",
    {
      "data-mantine-styles": !0,
      nonce: o?.(),
      dangerouslySetInnerHTML: {
        __html: `${c}${a ? "" : Gd(e)}`
      }
    }
  ) : null;
}
hi.displayName = "@mantine/CssVariables";
function Yd() {
  const e = console.error;
  console.error = (...t) => {
    t.length > 1 && typeof t[0] == "string" && t[0].toLowerCase().includes("extra attributes from the server") && typeof t[1] == "string" && t[1].toLowerCase().includes("data-mantine-color-scheme") || e(...t);
  };
}
function zt(e, t) {
  const n = typeof window < "u" && "matchMedia" in window && window.matchMedia("(prefers-color-scheme: dark)")?.matches, o = e !== "auto" ? e : n ? "dark" : "light";
  t()?.setAttribute("data-mantine-color-scheme", o);
}
function Kd({
  manager: e,
  defaultColorScheme: t,
  getRootElement: n,
  forceColorScheme: o
}) {
  const r = G(null), [s, a] = W(() => e.get(t)), i = o || s, c = Y(
    (u) => {
      o || (zt(u, n), a(u), e.set(u));
    },
    [e.set, i, o]
  ), l = Y(() => {
    a(t), zt(t, n), e.clear();
  }, [e.clear, t]);
  return U(() => (e.subscribe(c), e.unsubscribe), [e.subscribe, e.unsubscribe]), hn(() => {
    zt(e.get(t), n);
  }, []), U(() => {
    if (o)
      return zt(o, n), () => {
      };
    o === void 0 && zt(s, n), typeof window < "u" && "matchMedia" in window && (r.current = window.matchMedia("(prefers-color-scheme: dark)"));
    const u = (d) => {
      s === "auto" && zt(d.matches ? "dark" : "light", n);
    };
    return r.current?.addEventListener("change", u), () => r.current?.removeEventListener("change", u);
  }, [s, o]), { colorScheme: i, setColorScheme: c, clearColorScheme: l };
}
function Xd({
  respectReducedMotion: e,
  getRootElement: t
}) {
  hn(() => {
    e && t()?.setAttribute("data-respect-reduced-motion", "true");
  }, [e]);
}
Yd();
function Ud({
  theme: e,
  children: t,
  getStyleNonce: n,
  withStaticClasses: o = !0,
  withGlobalClasses: r = !0,
  deduplicateCssVariables: s = !0,
  withCssVariables: a = !0,
  cssVariablesSelector: i = ":root",
  classNamesPrefix: c = "mantine",
  colorSchemeManager: l = Ld(),
  defaultColorScheme: u = "light",
  getRootElement: d = () => document.documentElement,
  cssVariablesResolver: p,
  forceColorScheme: f,
  stylesTransform: h,
  env: m
}) {
  const { colorScheme: g, setColorScheme: b, clearColorScheme: w } = Kd({
    defaultColorScheme: u,
    forceColorScheme: f,
    manager: l,
    getRootElement: d
  });
  return Xd({
    respectReducedMotion: e?.respectReducedMotion || !1,
    getRootElement: d
  }), /* @__PURE__ */ v(
    gr.Provider,
    {
      value: {
        colorScheme: g,
        setColorScheme: b,
        clearColorScheme: w,
        getRootElement: d,
        classNamesPrefix: c,
        getStyleNonce: n,
        cssVariablesResolver: p,
        cssVariablesSelector: i,
        withStaticClasses: o,
        stylesTransform: h,
        env: m
      },
      children: /* @__PURE__ */ Z(pi, { theme: e, children: [
        a && /* @__PURE__ */ v(
          hi,
          {
            cssVariablesSelector: i,
            deduplicateCssVariables: s
          }
        ),
        r && /* @__PURE__ */ v(Fd, {}),
        t
      ] })
    }
  );
}
Ud.displayName = "@mantine/core/MantineProvider";
function qn({
  classNames: e,
  styles: t,
  props: n,
  stylesCtx: o
}) {
  const r = ye();
  return {
    resolvedClassNames: Kn({
      theme: r,
      classNames: e,
      props: n,
      stylesCtx: o || void 0
    }),
    resolvedStyles: Ln({
      theme: r,
      styles: t,
      props: n,
      stylesCtx: o || void 0
    })
  };
}
const qd = {
  always: "mantine-focus-always",
  auto: "mantine-focus-auto",
  never: "mantine-focus-never"
};
function Zd({ theme: e, options: t, unstyled: n }) {
  return ve(
    t?.focusable && !n && (e.focusClassName || qd[e.focusRing]),
    t?.active && !n && e.activeClassName
  );
}
function Jd({
  selector: e,
  stylesCtx: t,
  options: n,
  props: o,
  theme: r
}) {
  return Kn({
    theme: r,
    classNames: n?.classNames,
    props: n?.props || o,
    stylesCtx: t
  })[e];
}
function Xs({
  selector: e,
  stylesCtx: t,
  theme: n,
  classNames: o,
  props: r
}) {
  return Kn({ theme: n, classNames: o, props: r, stylesCtx: t })[e];
}
function Qd({ rootSelector: e, selector: t, className: n }) {
  return e === t ? n : void 0;
}
function ef({ selector: e, classes: t, unstyled: n }) {
  return n ? void 0 : t[e];
}
function tf({
  themeName: e,
  classNamesPrefix: t,
  selector: n,
  withStaticClass: o
}) {
  return o === !1 ? [] : e.map((r) => `${t}-${r}-${n}`);
}
function nf({
  themeName: e,
  theme: t,
  selector: n,
  props: o,
  stylesCtx: r
}) {
  return e.map(
    (s) => Kn({
      theme: t,
      classNames: t.components[s]?.classNames,
      props: o,
      stylesCtx: r
    })?.[n]
  );
}
function of({
  options: e,
  classes: t,
  selector: n,
  unstyled: o
}) {
  return e?.variant && !o ? t[`${n}--${e.variant}`] : void 0;
}
function rf({
  theme: e,
  options: t,
  themeName: n,
  selector: o,
  classNamesPrefix: r,
  classNames: s,
  classes: a,
  unstyled: i,
  className: c,
  rootSelector: l,
  props: u,
  stylesCtx: d,
  withStaticClasses: p,
  headless: f,
  transformedStyles: h
}) {
  return ve(
    Zd({ theme: e, options: t, unstyled: i || f }),
    nf({ theme: e, themeName: n, selector: o, props: u, stylesCtx: d }),
    of({ options: t, classes: a, selector: o, unstyled: i }),
    Xs({ selector: o, stylesCtx: d, theme: e, classNames: s, props: u }),
    Xs({ selector: o, stylesCtx: d, theme: e, classNames: h, props: u }),
    Jd({ selector: o, stylesCtx: d, options: t, props: u, theme: e }),
    Qd({ rootSelector: l, selector: o, className: c }),
    ef({ selector: o, classes: a, unstyled: i || f }),
    p && !f && tf({
      themeName: n,
      classNamesPrefix: r,
      selector: o,
      withStaticClass: t?.withStaticClass
    }),
    t?.className
  );
}
function sf({
  theme: e,
  themeName: t,
  props: n,
  stylesCtx: o,
  selector: r
}) {
  return t.map(
    (s) => Ln({
      theme: e,
      styles: e.components[s]?.styles,
      props: n,
      stylesCtx: o
    })[r]
  ).reduce((s, a) => ({ ...s, ...a }), {});
}
function or({ style: e, theme: t }) {
  return Array.isArray(e) ? [...e].reduce(
    (n, o) => ({ ...n, ...or({ style: o, theme: t }) }),
    {}
  ) : typeof e == "function" ? e(t) : e ?? {};
}
function af(e) {
  return e.reduce((t, n) => (n && Object.keys(n).forEach((o) => {
    t[o] = { ...t[o], ...yt(n[o]) };
  }), t), {});
}
function lf({
  vars: e,
  varsResolver: t,
  theme: n,
  props: o,
  stylesCtx: r,
  selector: s,
  themeName: a,
  headless: i
}) {
  return af([
    i ? {} : t?.(n, o, r),
    ...a.map((c) => n.components?.[c]?.vars?.(n, o, r)),
    e?.(n, o, r)
  ])?.[s];
}
function cf({
  theme: e,
  themeName: t,
  selector: n,
  options: o,
  props: r,
  stylesCtx: s,
  rootSelector: a,
  styles: i,
  style: c,
  vars: l,
  varsResolver: u,
  headless: d,
  withStylesTransform: p
}) {
  return {
    ...!p && sf({ theme: e, themeName: t, props: r, stylesCtx: s, selector: n }),
    ...!p && Ln({ theme: e, styles: i, props: r, stylesCtx: s })[n],
    ...!p && Ln({ theme: e, styles: o?.styles, props: o?.props || r, stylesCtx: s })[n],
    ...lf({ theme: e, props: r, stylesCtx: s, vars: l, varsResolver: u, selector: n, themeName: t, headless: d }),
    ...a === n ? or({ style: c, theme: e }) : null,
    ...or({ style: o?.style, theme: e })
  };
}
function uf({ props: e, stylesCtx: t, themeName: n }) {
  const o = ye(), r = Nd()?.();
  return {
    getTransformedStyles: (a) => r ? [
      ...a.map(
        (c) => r(c, { props: e, theme: o, ctx: t })
      ),
      ...n.map(
        (c) => r(o.components[c]?.styles, { props: e, theme: o, ctx: t })
      )
    ].filter(Boolean) : [],
    withStylesTransform: !!r
  };
}
function K({
  name: e,
  classes: t,
  props: n,
  stylesCtx: o,
  className: r,
  style: s,
  rootSelector: a = "root",
  unstyled: i,
  classNames: c,
  styles: l,
  vars: u,
  varsResolver: d
}) {
  const p = ye(), f = $d(), h = Pd(), m = _d(), g = (Array.isArray(e) ? e : [e]).filter((y) => y), { withStylesTransform: b, getTransformedStyles: w } = uf({
    props: n,
    stylesCtx: o,
    themeName: g
  });
  return (y, S) => ({
    className: rf({
      theme: p,
      options: S,
      themeName: g,
      selector: y,
      classNamesPrefix: f,
      classNames: c,
      classes: t,
      unstyled: i,
      className: r,
      rootSelector: a,
      props: n,
      stylesCtx: o,
      withStaticClasses: h,
      headless: m,
      transformedStyles: w([S?.styles, l])
    }),
    style: cf({
      theme: p,
      themeName: g,
      selector: y,
      options: S,
      props: n,
      stylesCtx: o,
      rootSelector: a,
      styles: l,
      style: s,
      vars: u,
      varsResolver: d,
      headless: m,
      withStylesTransform: b
    })
  });
}
function df(e, t) {
  return typeof e == "boolean" ? e : t.autoContrast;
}
function Us(e) {
  const t = document.createElement("style");
  return t.setAttribute("data-mantine-styles", "inline"), t.innerHTML = "*, *::before, *::after {transition: none !important;}", t.setAttribute("data-mantine-disable-transition", "true"), e && t.setAttribute("nonce", e), document.head.appendChild(t), () => document.querySelectorAll("[data-mantine-disable-transition]").forEach((o) => o.remove());
}
function ff({ keepTransitions: e } = {}) {
  const t = G(Ja), n = G(-1), o = gt(gr), r = Xn(), s = G(r?.());
  if (!o)
    throw new Error("[@mantine/core] MantineProvider was not found in tree");
  const a = (d) => {
    o.setColorScheme(d), t.current = e ? () => {
    } : Us(s.current), window.clearTimeout(n.current), n.current = window.setTimeout(() => {
      t.current?.();
    }, 10);
  }, i = () => {
    o.clearColorScheme(), t.current = e ? () => {
    } : Us(s.current), window.clearTimeout(n.current), n.current = window.setTimeout(() => {
      t.current?.();
    }, 10);
  }, c = ti("light", { getInitialValueInEffect: !1 }), l = o.colorScheme === "auto" ? c : o.colorScheme, u = Y(
    () => a(l === "light" ? "dark" : "light"),
    [a, l]
  );
  return U(
    () => () => {
      t.current?.(), window.clearTimeout(n.current);
    },
    []
  ), {
    colorScheme: o.colorScheme,
    setColorScheme: a,
    clearColorScheme: i,
    toggleColorScheme: u
  };
}
function bb(e, t = { getInitialValueInEffect: !0 }) {
  const n = ti(e, t), { colorScheme: o } = ff();
  return o === "auto" ? n : o;
}
function T(e, t, n) {
  const o = ye(), r = o.components[e]?.defaultProps, s = typeof r == "function" ? r(o) : r;
  return { ...t, ...s, ...yt(n) };
}
function wb(e) {
  return e;
}
function Bo(e) {
  return ce(e).reduce(
    (t, n) => e[n] !== void 0 ? `${t}${Au(n)}:${e[n]};` : t,
    ""
  ).trim();
}
function pf({ selector: e, styles: t, media: n, container: o }) {
  const r = t ? Bo(t) : "", s = Array.isArray(n) ? n.map((i) => `@media${i.query}{${e}{${Bo(i.styles)}}}`) : [], a = Array.isArray(o) ? o.map(
    (i) => `@container ${i.query}{${e}{${Bo(i.styles)}}}`
  ) : [];
  return `${r ? `${e}{${r}}` : ""}${s.join("")}${a.join("")}`.trim();
}
function Xt(e) {
  const t = Xn();
  return /* @__PURE__ */ v(
    "style",
    {
      "data-mantine-styles": "inline",
      nonce: t?.(),
      dangerouslySetInnerHTML: { __html: pf(e) }
    }
  );
}
function Sr(e) {
  const {
    m: t,
    mx: n,
    my: o,
    mt: r,
    mb: s,
    ml: a,
    mr: i,
    me: c,
    ms: l,
    p: u,
    px: d,
    py: p,
    pt: f,
    pb: h,
    pl: m,
    pr: g,
    pe: b,
    ps: w,
    bd: y,
    bg: S,
    c: x,
    opacity: C,
    ff: R,
    fz: P,
    fw: M,
    lts: I,
    ta: H,
    lh: z,
    fs: j,
    tt: B,
    td: V,
    w: O,
    miw: L,
    maw: N,
    h: $,
    mih: k,
    mah: A,
    bgsz: q,
    bgp: ee,
    bgr: se,
    bga: ne,
    pos: X,
    top: te,
    left: ge,
    bottom: le,
    right: de,
    inset: ke,
    display: nt,
    flex: Ge,
    hiddenFrom: fe,
    visibleFrom: ae,
    lightHidden: pe,
    darkHidden: pt,
    sx: Ct,
    ...Ye
  } = e;
  return { styleProps: yt({
    m: t,
    mx: n,
    my: o,
    mt: r,
    mb: s,
    ml: a,
    mr: i,
    me: c,
    ms: l,
    p: u,
    px: d,
    py: p,
    pt: f,
    pb: h,
    pl: m,
    pr: g,
    pe: b,
    ps: w,
    bd: y,
    bg: S,
    c: x,
    opacity: C,
    ff: R,
    fz: P,
    fw: M,
    lts: I,
    ta: H,
    lh: z,
    fs: j,
    tt: B,
    td: V,
    w: O,
    miw: L,
    maw: N,
    h: $,
    mih: k,
    mah: A,
    bgsz: q,
    bgp: ee,
    bgr: se,
    bga: ne,
    pos: X,
    top: te,
    left: ge,
    bottom: le,
    right: de,
    inset: ke,
    display: nt,
    flex: Ge,
    hiddenFrom: fe,
    visibleFrom: ae,
    lightHidden: pe,
    darkHidden: pt,
    sx: Ct
  }), rest: Ye };
}
const mf = {
  m: { type: "spacing", property: "margin" },
  mt: { type: "spacing", property: "marginTop" },
  mb: { type: "spacing", property: "marginBottom" },
  ml: { type: "spacing", property: "marginLeft" },
  mr: { type: "spacing", property: "marginRight" },
  ms: { type: "spacing", property: "marginInlineStart" },
  me: { type: "spacing", property: "marginInlineEnd" },
  mx: { type: "spacing", property: "marginInline" },
  my: { type: "spacing", property: "marginBlock" },
  p: { type: "spacing", property: "padding" },
  pt: { type: "spacing", property: "paddingTop" },
  pb: { type: "spacing", property: "paddingBottom" },
  pl: { type: "spacing", property: "paddingLeft" },
  pr: { type: "spacing", property: "paddingRight" },
  ps: { type: "spacing", property: "paddingInlineStart" },
  pe: { type: "spacing", property: "paddingInlineEnd" },
  px: { type: "spacing", property: "paddingInline" },
  py: { type: "spacing", property: "paddingBlock" },
  bd: { type: "border", property: "border" },
  bg: { type: "color", property: "background" },
  c: { type: "textColor", property: "color" },
  opacity: { type: "identity", property: "opacity" },
  ff: { type: "fontFamily", property: "fontFamily" },
  fz: { type: "fontSize", property: "fontSize" },
  fw: { type: "identity", property: "fontWeight" },
  lts: { type: "size", property: "letterSpacing" },
  ta: { type: "identity", property: "textAlign" },
  lh: { type: "lineHeight", property: "lineHeight" },
  fs: { type: "identity", property: "fontStyle" },
  tt: { type: "identity", property: "textTransform" },
  td: { type: "identity", property: "textDecoration" },
  w: { type: "spacing", property: "width" },
  miw: { type: "spacing", property: "minWidth" },
  maw: { type: "spacing", property: "maxWidth" },
  h: { type: "spacing", property: "height" },
  mih: { type: "spacing", property: "minHeight" },
  mah: { type: "spacing", property: "maxHeight" },
  bgsz: { type: "size", property: "backgroundSize" },
  bgp: { type: "identity", property: "backgroundPosition" },
  bgr: { type: "identity", property: "backgroundRepeat" },
  bga: { type: "identity", property: "backgroundAttachment" },
  pos: { type: "identity", property: "position" },
  top: { type: "size", property: "top" },
  left: { type: "size", property: "left" },
  bottom: { type: "size", property: "bottom" },
  right: { type: "size", property: "right" },
  inset: { type: "size", property: "inset" },
  display: { type: "identity", property: "display" },
  flex: { type: "identity", property: "flex" }
};
function xr(e, t) {
  const n = Et({ color: e, theme: t });
  return n.color === "dimmed" ? "var(--mantine-color-dimmed)" : n.color === "bright" ? "var(--mantine-color-bright)" : n.variable ? `var(${n.variable})` : n.color;
}
function hf(e, t) {
  const n = Et({ color: e, theme: t });
  return n.isThemeColor && n.shade === void 0 ? `var(--mantine-color-${n.color}-text)` : xr(e, t);
}
function vf(e, t) {
  if (typeof e == "number")
    return E(e);
  if (typeof e == "string") {
    const [n, o, ...r] = e.split(" ").filter((a) => a.trim() !== "");
    let s = `${E(n)}`;
    return o && (s += ` ${o}`), r.length > 0 && (s += ` ${xr(r.join(" "), t)}`), s.trim();
  }
  return e;
}
const qs = {
  text: "var(--mantine-font-family)",
  mono: "var(--mantine-font-family-monospace)",
  monospace: "var(--mantine-font-family-monospace)",
  heading: "var(--mantine-font-family-headings)",
  headings: "var(--mantine-font-family-headings)"
};
function gf(e) {
  return typeof e == "string" && e in qs ? qs[e] : e;
}
const yf = ["h1", "h2", "h3", "h4", "h5", "h6"];
function bf(e, t) {
  return typeof e == "string" && e in t.fontSizes ? `var(--mantine-font-size-${e})` : typeof e == "string" && yf.includes(e) ? `var(--mantine-${e}-font-size)` : typeof e == "number" || typeof e == "string" ? E(e) : e;
}
function wf(e) {
  return e;
}
const Sf = ["h1", "h2", "h3", "h4", "h5", "h6"];
function xf(e, t) {
  return typeof e == "string" && e in t.lineHeights ? `var(--mantine-line-height-${e})` : typeof e == "string" && Sf.includes(e) ? `var(--mantine-${e}-line-height)` : e;
}
function Cf(e) {
  return typeof e == "number" ? E(e) : e;
}
function $f(e, t) {
  if (typeof e == "number")
    return E(e);
  if (typeof e == "string") {
    const n = e.replace("-", "");
    if (!(n in t.spacing))
      return E(e);
    const o = `--mantine-spacing-${n}`;
    return e.startsWith("-") ? `calc(var(${o}) * -1)` : `var(${o})`;
  }
  return e;
}
const Fo = {
  color: xr,
  textColor: hf,
  fontSize: bf,
  spacing: $f,
  identity: wf,
  size: Cf,
  lineHeight: xf,
  fontFamily: gf,
  border: vf
};
function Zs(e) {
  return e.replace("(min-width: ", "").replace("em)", "");
}
function Pf({
  media: e,
  ...t
}) {
  const o = Object.keys(e).sort((r, s) => Number(Zs(r)) - Number(Zs(s))).map((r) => ({ query: r, styles: e[r] }));
  return { ...t, media: o };
}
function _f(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.keys(e);
  return !(t.length === 1 && t[0] === "base");
}
function Rf(e) {
  return typeof e == "object" && e !== null ? "base" in e ? e.base : void 0 : e;
}
function Nf(e) {
  return typeof e == "object" && e !== null ? ce(e).filter((t) => t !== "base") : [];
}
function Tf(e, t) {
  return typeof e == "object" && e !== null && t in e ? e[t] : e;
}
function vi({
  styleProps: e,
  data: t,
  theme: n
}) {
  return Pf(
    ce(e).reduce(
      (o, r) => {
        if (r === "hiddenFrom" || r === "visibleFrom" || r === "sx")
          return o;
        const s = t[r], a = Array.isArray(s.property) ? s.property : [s.property], i = Rf(e[r]);
        if (!_f(e[r]))
          return a.forEach((l) => {
            o.inlineStyles[l] = Fo[s.type](i, n);
          }), o;
        o.hasResponsiveStyles = !0;
        const c = Nf(e[r]);
        return a.forEach((l) => {
          i && (o.styles[l] = Fo[s.type](i, n)), c.forEach((u) => {
            const d = `(min-width: ${n.breakpoints[u]})`;
            o.media[d] = {
              ...o.media[d],
              [l]: Fo[s.type](
                Tf(e[r], u),
                n
              )
            };
          });
        }), o;
      },
      {
        hasResponsiveStyles: !1,
        styles: {},
        inlineStyles: {},
        media: {}
      }
    )
  );
}
function vn() {
  return `__m__-${Ba().replace(/:/g, "")}`;
}
function gi(e, t) {
  return Array.isArray(e) ? [...e].reduce(
    (n, o) => ({ ...n, ...gi(o, t) }),
    {}
  ) : typeof e == "function" ? e(t) : e ?? {};
}
function Sb(e) {
  return e;
}
function yi(e) {
  return e.startsWith("data-") ? e : `data-${e}`;
}
function Ef(e) {
  return Object.keys(e).reduce((t, n) => {
    const o = e[n];
    return o === void 0 || o === "" || o === !1 || o === null || (t[yi(n)] = e[n]), t;
  }, {});
}
function bi(e) {
  return e ? typeof e == "string" ? { [yi(e)]: !0 } : Array.isArray(e) ? [...e].reduce(
    (t, n) => ({ ...t, ...bi(n) }),
    {}
  ) : Ef(e) : null;
}
function rr(e, t) {
  return Array.isArray(e) ? [...e].reduce(
    (n, o) => ({ ...n, ...rr(o, t) }),
    {}
  ) : typeof e == "function" ? e(t) : e ?? {};
}
function kf({
  theme: e,
  style: t,
  vars: n,
  styleProps: o
}) {
  const r = rr(t, e), s = rr(n, e);
  return { ...r, ...s, ...o };
}
const wi = J(
  ({
    component: e,
    style: t,
    __vars: n,
    className: o,
    variant: r,
    mod: s,
    size: a,
    hiddenFrom: i,
    visibleFrom: c,
    lightHidden: l,
    darkHidden: u,
    renderRoot: d,
    __size: p,
    ...f
  }, h) => {
    const m = ye(), g = e || "div", { styleProps: b, rest: w } = Sr(f), S = Rd()?.()?.(b.sx), x = vn(), C = vi({
      styleProps: b,
      theme: m,
      data: mf
    }), R = {
      ref: h,
      style: kf({
        theme: m,
        style: t,
        vars: n,
        styleProps: C.inlineStyles
      }),
      className: ve(o, S, {
        [x]: C.hasResponsiveStyles,
        "mantine-light-hidden": l,
        "mantine-dark-hidden": u,
        [`mantine-hidden-from-${i}`]: i,
        [`mantine-visible-from-${c}`]: c
      }),
      "data-variant": r,
      "data-size": qa(a) ? void 0 : a || void 0,
      size: p,
      ...bi(s),
      ...w
    };
    return /* @__PURE__ */ Z(Ce, { children: [
      C.hasResponsiveStyles && /* @__PURE__ */ v(
        Xt,
        {
          selector: `.${x}`,
          styles: C.styles,
          media: C.media
        }
      ),
      typeof d == "function" ? d(R) : /* @__PURE__ */ v(g, { ...R })
    ] });
  }
);
wi.displayName = "@mantine/core/Box";
const D = wi;
function Si(e) {
  return e;
}
function F(e) {
  const t = J(e);
  return t.extend = Si, t.withProps = (n) => {
    const o = J((r, s) => /* @__PURE__ */ v(t, { ...n, ...r, ref: s }));
    return o.extend = t.extend, o.displayName = `WithProps(${t.displayName})`, o;
  }, t;
}
function he(e) {
  const t = J(e);
  return t.withProps = (n) => {
    const o = J((r, s) => /* @__PURE__ */ v(t, { ...n, ...r, ref: s }));
    return o.extend = t.extend, o.displayName = `WithProps(${t.displayName})`, o;
  }, t.extend = Si, t;
}
const Mf = Kt({
  dir: "ltr",
  toggleDirection: () => {
  },
  setDirection: () => {
  }
});
function wt() {
  return gt(Mf);
}
const [Af, Ie] = Ee(
  "ScrollArea.Root component was not found in tree"
);
function Wt(e, t) {
  const n = $t(t);
  hn(() => {
    let o = 0;
    if (e) {
      const r = new ResizeObserver(() => {
        cancelAnimationFrame(o), o = window.requestAnimationFrame(n);
      });
      return r.observe(e), () => {
        window.cancelAnimationFrame(o), r.unobserve(e);
      };
    }
  }, [e, n]);
}
const Df = J((e, t) => {
  const { style: n, ...o } = e, r = Ie(), [s, a] = W(0), [i, c] = W(0), l = !!(s && i);
  return Wt(r.scrollbarX, () => {
    const u = r.scrollbarX?.offsetHeight || 0;
    r.onCornerHeightChange(u), c(u);
  }), Wt(r.scrollbarY, () => {
    const u = r.scrollbarY?.offsetWidth || 0;
    r.onCornerWidthChange(u), a(u);
  }), l ? /* @__PURE__ */ v("div", { ...o, ref: t, style: { ...n, width: s, height: i } }) : null;
}), If = J((e, t) => {
  const n = Ie(), o = !!(n.scrollbarX && n.scrollbarY);
  return n.type !== "scroll" && o ? /* @__PURE__ */ v(Df, { ...e, ref: t }) : null;
}), Of = {
  scrollHideDelay: 1e3,
  type: "hover"
}, xi = J((e, t) => {
  const n = T("ScrollAreaRoot", Of, e), { type: o, scrollHideDelay: r, scrollbars: s, ...a } = n, [i, c] = W(null), [l, u] = W(null), [d, p] = W(null), [f, h] = W(null), [m, g] = W(null), [b, w] = W(0), [y, S] = W(0), [x, C] = W(!1), [R, P] = W(!1), M = ue(t, (I) => c(I));
  return /* @__PURE__ */ v(
    Af,
    {
      value: {
        type: o,
        scrollHideDelay: r,
        scrollArea: i,
        viewport: l,
        onViewportChange: u,
        content: d,
        onContentChange: p,
        scrollbarX: f,
        onScrollbarXChange: h,
        scrollbarXEnabled: x,
        onScrollbarXEnabledChange: C,
        scrollbarY: m,
        onScrollbarYChange: g,
        scrollbarYEnabled: R,
        onScrollbarYEnabledChange: P,
        onCornerWidthChange: w,
        onCornerHeightChange: S
      },
      children: /* @__PURE__ */ v(
        D,
        {
          ...a,
          ref: M,
          __vars: {
            "--sa-corner-width": s !== "xy" ? "0px" : `${b}px`,
            "--sa-corner-height": s !== "xy" ? "0px" : `${y}px`
          }
        }
      )
    }
  );
});
xi.displayName = "@mantine/core/ScrollAreaRoot";
function Ci(e, t) {
  const n = e / t;
  return Number.isNaN(n) ? 0 : n;
}
function Zn(e) {
  const t = Ci(e.viewport, e.content), n = e.scrollbar.paddingStart + e.scrollbar.paddingEnd, o = (e.scrollbar.size - n) * t;
  return Math.max(o, 18);
}
function $i(e, t) {
  return (n) => {
    if (e[0] === e[1] || t[0] === t[1])
      return t[0];
    const o = (t[1] - t[0]) / (e[1] - e[0]);
    return t[0] + o * (n - e[0]);
  };
}
function Lf(e, [t, n]) {
  return Math.min(n, Math.max(t, e));
}
function Js(e, t, n = "ltr") {
  const o = Zn(t), r = t.scrollbar.paddingStart + t.scrollbar.paddingEnd, s = t.scrollbar.size - r, a = t.content - t.viewport, i = s - o, c = n === "ltr" ? [0, a] : [a * -1, 0], l = Lf(e, c);
  return $i([0, a], [0, i])(l);
}
function zf(e, t, n, o = "ltr") {
  const r = Zn(n), s = r / 2, a = t || s, i = r - a, c = n.scrollbar.paddingStart + a, l = n.scrollbar.size - n.scrollbar.paddingEnd - i, u = n.content - n.viewport, d = o === "ltr" ? [0, u] : [u * -1, 0];
  return $i([c, l], d)(e);
}
function Pi(e, t) {
  return e > 0 && e < t;
}
function mt(e) {
  return e ? parseInt(e, 10) : 0;
}
function Rt(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return (o) => {
    e?.(o), (n === !1 || !o.defaultPrevented) && t?.(o);
  };
}
const [Bf, _i] = Ee(
  "ScrollAreaScrollbar was not found in tree"
), Ri = J((e, t) => {
  const {
    sizes: n,
    hasThumb: o,
    onThumbChange: r,
    onThumbPointerUp: s,
    onThumbPointerDown: a,
    onThumbPositionChange: i,
    onDragScroll: c,
    onWheelScroll: l,
    onResize: u,
    ...d
  } = e, p = Ie(), [f, h] = W(null), m = ue(t, (P) => h(P)), g = G(null), b = G(""), { viewport: w } = p, y = n.content - n.viewport, S = $t(l), x = $t(i), C = Gn(u, 10), R = (P) => {
    if (g.current) {
      const M = P.clientX - g.current.left, I = P.clientY - g.current.top;
      c({ x: M, y: I });
    }
  };
  return U(() => {
    const P = (M) => {
      const I = M.target;
      f?.contains(I) && S(M, y);
    };
    return document.addEventListener("wheel", P, { passive: !1 }), () => document.removeEventListener("wheel", P, { passive: !1 });
  }, [w, f, y, S]), U(x, [n, x]), Wt(f, C), Wt(p.content, C), /* @__PURE__ */ v(
    Bf,
    {
      value: {
        scrollbar: f,
        hasThumb: o,
        onThumbChange: $t(r),
        onThumbPointerUp: $t(s),
        onThumbPositionChange: x,
        onThumbPointerDown: $t(a)
      },
      children: /* @__PURE__ */ v(
        "div",
        {
          ...d,
          ref: m,
          "data-mantine-scrollbar": !0,
          style: { position: "absolute", ...d.style },
          onPointerDown: Rt(e.onPointerDown, (P) => {
            P.preventDefault(), P.button === 0 && (P.target.setPointerCapture(P.pointerId), g.current = f.getBoundingClientRect(), b.current = document.body.style.webkitUserSelect, document.body.style.webkitUserSelect = "none", R(P));
          }),
          onPointerMove: Rt(e.onPointerMove, R),
          onPointerUp: Rt(e.onPointerUp, (P) => {
            const M = P.target;
            M.hasPointerCapture(P.pointerId) && (P.preventDefault(), M.releasePointerCapture(P.pointerId));
          }),
          onLostPointerCapture: () => {
            document.body.style.webkitUserSelect = b.current, g.current = null;
          }
        }
      )
    }
  );
}), Ni = J(
  (e, t) => {
    const { sizes: n, onSizesChange: o, style: r, ...s } = e, a = Ie(), [i, c] = W(), l = G(null), u = ue(t, l, a.onScrollbarXChange);
    return U(() => {
      l.current && c(getComputedStyle(l.current));
    }, [l]), /* @__PURE__ */ v(
      Ri,
      {
        "data-orientation": "horizontal",
        ...s,
        ref: u,
        sizes: n,
        style: {
          ...r,
          "--sa-thumb-width": `${Zn(n)}px`
        },
        onThumbPointerDown: (d) => e.onThumbPointerDown(d.x),
        onDragScroll: (d) => e.onDragScroll(d.x),
        onWheelScroll: (d, p) => {
          if (a.viewport) {
            const f = a.viewport.scrollLeft + d.deltaX;
            e.onWheelScroll(f), Pi(f, p) && d.preventDefault();
          }
        },
        onResize: () => {
          l.current && a.viewport && i && o({
            content: a.viewport.scrollWidth,
            viewport: a.viewport.offsetWidth,
            scrollbar: {
              size: l.current.clientWidth,
              paddingStart: mt(i.paddingLeft),
              paddingEnd: mt(i.paddingRight)
            }
          });
        }
      }
    );
  }
);
Ni.displayName = "@mantine/core/ScrollAreaScrollbarX";
const Ti = J(
  (e, t) => {
    const { sizes: n, onSizesChange: o, style: r, ...s } = e, a = Ie(), [i, c] = W(), l = G(null), u = ue(t, l, a.onScrollbarYChange);
    return U(() => {
      l.current && c(window.getComputedStyle(l.current));
    }, []), /* @__PURE__ */ v(
      Ri,
      {
        ...s,
        "data-orientation": "vertical",
        ref: u,
        sizes: n,
        style: {
          "--sa-thumb-height": `${Zn(n)}px`,
          ...r
        },
        onThumbPointerDown: (d) => e.onThumbPointerDown(d.y),
        onDragScroll: (d) => e.onDragScroll(d.y),
        onWheelScroll: (d, p) => {
          if (a.viewport) {
            const f = a.viewport.scrollTop + d.deltaY;
            e.onWheelScroll(f), Pi(f, p) && d.preventDefault();
          }
        },
        onResize: () => {
          l.current && a.viewport && i && o({
            content: a.viewport.scrollHeight,
            viewport: a.viewport.offsetHeight,
            scrollbar: {
              size: l.current.clientHeight,
              paddingStart: mt(i.paddingTop),
              paddingEnd: mt(i.paddingBottom)
            }
          });
        }
      }
    );
  }
);
Ti.displayName = "@mantine/core/ScrollAreaScrollbarY";
const Jn = J((e, t) => {
  const { orientation: n = "vertical", ...o } = e, { dir: r } = wt(), s = Ie(), a = G(null), i = G(0), [c, l] = W({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  }), u = Ci(c.viewport, c.content), d = {
    ...o,
    sizes: c,
    onSizesChange: l,
    hasThumb: u > 0 && u < 1,
    onThumbChange: (f) => {
      a.current = f;
    },
    onThumbPointerUp: () => {
      i.current = 0;
    },
    onThumbPointerDown: (f) => {
      i.current = f;
    }
  }, p = (f, h) => zf(f, i.current, c, h);
  return n === "horizontal" ? /* @__PURE__ */ v(
    Ni,
    {
      ...d,
      ref: t,
      onThumbPositionChange: () => {
        if (s.viewport && a.current) {
          const f = s.viewport.scrollLeft, h = Js(f, c, r);
          a.current.style.transform = `translate3d(${h}px, 0, 0)`;
        }
      },
      onWheelScroll: (f) => {
        s.viewport && (s.viewport.scrollLeft = f);
      },
      onDragScroll: (f) => {
        s.viewport && (s.viewport.scrollLeft = p(f, r));
      }
    }
  ) : n === "vertical" ? /* @__PURE__ */ v(
    Ti,
    {
      ...d,
      ref: t,
      onThumbPositionChange: () => {
        if (s.viewport && a.current) {
          const f = s.viewport.scrollTop, h = Js(f, c);
          c.scrollbar.size === 0 ? a.current.style.setProperty("--thumb-opacity", "0") : a.current.style.setProperty("--thumb-opacity", "1"), a.current.style.transform = `translate3d(0, ${h}px, 0)`;
        }
      },
      onWheelScroll: (f) => {
        s.viewport && (s.viewport.scrollTop = f);
      },
      onDragScroll: (f) => {
        s.viewport && (s.viewport.scrollTop = p(f));
      }
    }
  ) : null;
});
Jn.displayName = "@mantine/core/ScrollAreaScrollbarVisible";
const Cr = J(
  (e, t) => {
    const n = Ie(), { forceMount: o, ...r } = e, [s, a] = W(!1), i = e.orientation === "horizontal", c = Gn(() => {
      if (n.viewport) {
        const l = n.viewport.offsetWidth < n.viewport.scrollWidth, u = n.viewport.offsetHeight < n.viewport.scrollHeight;
        a(i ? l : u);
      }
    }, 10);
    return Wt(n.viewport, c), Wt(n.content, c), o || s ? /* @__PURE__ */ v(
      Jn,
      {
        "data-state": s ? "visible" : "hidden",
        ...r,
        ref: t
      }
    ) : null;
  }
);
Cr.displayName = "@mantine/core/ScrollAreaScrollbarAuto";
const Ei = J(
  (e, t) => {
    const { forceMount: n, ...o } = e, r = Ie(), [s, a] = W(!1);
    return U(() => {
      const { scrollArea: i } = r;
      let c = 0;
      if (i) {
        const l = () => {
          window.clearTimeout(c), a(!0);
        }, u = () => {
          c = window.setTimeout(() => a(!1), r.scrollHideDelay);
        };
        return i.addEventListener("pointerenter", l), i.addEventListener("pointerleave", u), () => {
          window.clearTimeout(c), i.removeEventListener("pointerenter", l), i.removeEventListener("pointerleave", u);
        };
      }
    }, [r.scrollArea, r.scrollHideDelay]), n || s ? /* @__PURE__ */ v(
      Cr,
      {
        "data-state": s ? "visible" : "hidden",
        ...o,
        ref: t
      }
    ) : null;
  }
);
Ei.displayName = "@mantine/core/ScrollAreaScrollbarHover";
const Ff = J(
  (e, t) => {
    const { forceMount: n, ...o } = e, r = Ie(), s = e.orientation === "horizontal", [a, i] = W("hidden"), c = Gn(() => i("idle"), 100);
    return U(() => {
      if (a === "idle") {
        const l = window.setTimeout(() => i("hidden"), r.scrollHideDelay);
        return () => window.clearTimeout(l);
      }
    }, [a, r.scrollHideDelay]), U(() => {
      const { viewport: l } = r, u = s ? "scrollLeft" : "scrollTop";
      if (l) {
        let d = l[u];
        const p = () => {
          const f = l[u];
          d !== f && (i("scrolling"), c()), d = f;
        };
        return l.addEventListener("scroll", p), () => l.removeEventListener("scroll", p);
      }
    }, [r.viewport, s, c]), n || a !== "hidden" ? /* @__PURE__ */ v(
      Jn,
      {
        "data-state": a === "hidden" ? "hidden" : "visible",
        ...o,
        ref: t,
        onPointerEnter: Rt(e.onPointerEnter, () => i("interacting")),
        onPointerLeave: Rt(e.onPointerLeave, () => i("idle"))
      }
    ) : null;
  }
), sr = J(
  (e, t) => {
    const { forceMount: n, ...o } = e, r = Ie(), { onScrollbarXEnabledChange: s, onScrollbarYEnabledChange: a } = r, i = e.orientation === "horizontal";
    return U(() => (i ? s(!0) : a(!0), () => {
      i ? s(!1) : a(!1);
    }), [i, s, a]), r.type === "hover" ? /* @__PURE__ */ v(Ei, { ...o, ref: t, forceMount: n }) : r.type === "scroll" ? /* @__PURE__ */ v(Ff, { ...o, ref: t, forceMount: n }) : r.type === "auto" ? /* @__PURE__ */ v(Cr, { ...o, ref: t, forceMount: n }) : r.type === "always" ? /* @__PURE__ */ v(Jn, { ...o, ref: t }) : null;
  }
);
sr.displayName = "@mantine/core/ScrollAreaScrollbar";
function Hf(e, t = () => {
}) {
  let n = { left: e.scrollLeft, top: e.scrollTop }, o = 0;
  return function r() {
    const s = { left: e.scrollLeft, top: e.scrollTop }, a = n.left !== s.left, i = n.top !== s.top;
    (a || i) && t(), n = s, o = window.requestAnimationFrame(r);
  }(), () => window.cancelAnimationFrame(o);
}
const ki = J((e, t) => {
  const { style: n, ...o } = e, r = Ie(), s = _i(), { onThumbPositionChange: a } = s, i = ue(t, (u) => s.onThumbChange(u)), c = G(void 0), l = Gn(() => {
    c.current && (c.current(), c.current = void 0);
  }, 100);
  return U(() => {
    const { viewport: u } = r;
    if (u) {
      const d = () => {
        if (l(), !c.current) {
          const p = Hf(u, a);
          c.current = p, a();
        }
      };
      return a(), u.addEventListener("scroll", d), () => u.removeEventListener("scroll", d);
    }
  }, [r.viewport, l, a]), /* @__PURE__ */ v(
    "div",
    {
      "data-state": s.hasThumb ? "visible" : "hidden",
      ...o,
      ref: i,
      style: {
        width: "var(--sa-thumb-width)",
        height: "var(--sa-thumb-height)",
        ...n
      },
      onPointerDownCapture: Rt(e.onPointerDownCapture, (u) => {
        const p = u.target.getBoundingClientRect(), f = u.clientX - p.left, h = u.clientY - p.top;
        s.onThumbPointerDown({ x: f, y: h });
      }),
      onPointerUp: Rt(e.onPointerUp, s.onThumbPointerUp)
    }
  );
});
ki.displayName = "@mantine/core/ScrollAreaThumb";
const ar = J(
  (e, t) => {
    const { forceMount: n, ...o } = e, r = _i();
    return n || r.hasThumb ? /* @__PURE__ */ v(ki, { ref: t, ...o }) : null;
  }
);
ar.displayName = "@mantine/core/ScrollAreaThumb";
const Mi = J(
  ({ children: e, style: t, ...n }, o) => {
    const r = Ie(), s = ue(o, r.onViewportChange);
    return /* @__PURE__ */ v(
      D,
      {
        ...n,
        ref: s,
        style: {
          overflowX: r.scrollbarXEnabled ? "scroll" : "hidden",
          overflowY: r.scrollbarYEnabled ? "scroll" : "hidden",
          ...t
        },
        children: /* @__PURE__ */ v("div", { style: { minWidth: "100%", display: "table" }, ref: r.onContentChange, children: e })
      }
    );
  }
);
Mi.displayName = "@mantine/core/ScrollAreaViewport";
var Vf = { root: "m_d57069b5", viewport: "m_c0783ff9", viewportInner: "m_f8f631dd", scrollbar: "m_c44ba933", thumb: "m_d8b5e363", corner: "m_21657268" };
const $r = Vf, Ai = {
  scrollHideDelay: 1e3,
  type: "hover",
  scrollbars: "xy"
}, Wf = (e, { scrollbarSize: t, overscrollBehavior: n }) => ({
  root: {
    "--scrollarea-scrollbar-size": E(t),
    "--scrollarea-over-scroll-behavior": n
  }
}), gn = F((e, t) => {
  const n = T("ScrollArea", Ai, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    scrollbarSize: c,
    vars: l,
    type: u,
    scrollHideDelay: d,
    viewportProps: p,
    viewportRef: f,
    onScrollPositionChange: h,
    children: m,
    offsetScrollbars: g,
    scrollbars: b,
    onBottomReached: w,
    onTopReached: y,
    overscrollBehavior: S,
    ...x
  } = n, [C, R] = W(!1), P = K({
    name: "ScrollArea",
    props: n,
    classes: $r,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: l,
    varsResolver: Wf
  });
  return /* @__PURE__ */ Z(
    xi,
    {
      type: u === "never" ? "always" : u,
      scrollHideDelay: d,
      ref: t,
      scrollbars: b,
      ...P("root"),
      ...x,
      children: [
        /* @__PURE__ */ v(
          Mi,
          {
            ...p,
            ...P("viewport", { style: p?.style }),
            ref: f,
            "data-offset-scrollbars": g === !0 ? "xy" : g || void 0,
            "data-scrollbars": b || void 0,
            onScroll: (M) => {
              p?.onScroll?.(M), h?.({ x: M.currentTarget.scrollLeft, y: M.currentTarget.scrollTop });
              const { scrollTop: I, scrollHeight: H, clientHeight: z } = M.currentTarget;
              I - (H - z) >= 0 && w?.(), I === 0 && y?.();
            },
            children: m
          }
        ),
        (b === "xy" || b === "x") && /* @__PURE__ */ v(
          sr,
          {
            ...P("scrollbar"),
            orientation: "horizontal",
            "data-hidden": u === "never" || void 0,
            forceMount: !0,
            onMouseEnter: () => R(!0),
            onMouseLeave: () => R(!1),
            children: /* @__PURE__ */ v(ar, { ...P("thumb") })
          }
        ),
        (b === "xy" || b === "y") && /* @__PURE__ */ v(
          sr,
          {
            ...P("scrollbar"),
            orientation: "vertical",
            "data-hidden": u === "never" || void 0,
            forceMount: !0,
            onMouseEnter: () => R(!0),
            onMouseLeave: () => R(!1),
            children: /* @__PURE__ */ v(ar, { ...P("thumb") })
          }
        ),
        /* @__PURE__ */ v(
          If,
          {
            ...P("corner"),
            "data-hovered": C || void 0,
            "data-hidden": u === "never" || void 0
          }
        )
      ]
    }
  );
});
gn.displayName = "@mantine/core/ScrollArea";
const Pr = F((e, t) => {
  const {
    children: n,
    classNames: o,
    styles: r,
    scrollbarSize: s,
    scrollHideDelay: a,
    type: i,
    dir: c,
    offsetScrollbars: l,
    viewportRef: u,
    onScrollPositionChange: d,
    unstyled: p,
    variant: f,
    viewportProps: h,
    scrollbars: m,
    style: g,
    vars: b,
    onBottomReached: w,
    onTopReached: y,
    ...S
  } = T("ScrollAreaAutosize", Ai, e);
  return /* @__PURE__ */ v(D, { ...S, ref: t, style: [{ display: "flex", overflow: "auto" }, g], children: /* @__PURE__ */ v(D, { style: { display: "flex", flexDirection: "column", flex: 1 }, children: /* @__PURE__ */ v(
    gn,
    {
      classNames: o,
      styles: r,
      scrollHideDelay: a,
      scrollbarSize: s,
      type: i,
      dir: c,
      offsetScrollbars: l,
      viewportRef: u,
      onScrollPositionChange: d,
      unstyled: p,
      variant: f,
      viewportProps: h,
      vars: b,
      scrollbars: m,
      onBottomReached: w,
      onTopReached: y,
      children: n
    }
  ) }) });
});
gn.classes = $r;
Pr.displayName = "@mantine/core/ScrollAreaAutosize";
Pr.classes = $r;
gn.Autosize = Pr;
var jf = { root: "m_87cf2631" };
const Di = jf, Gf = {
  __staticSelector: "UnstyledButton"
}, St = he(
  (e, t) => {
    const n = T("UnstyledButton", Gf, e), {
      className: o,
      component: r = "button",
      __staticSelector: s,
      unstyled: a,
      classNames: i,
      styles: c,
      style: l,
      ...u
    } = n, d = K({
      name: s,
      props: n,
      classes: Di,
      className: o,
      style: l,
      classNames: i,
      styles: c,
      unstyled: a
    });
    return /* @__PURE__ */ v(
      D,
      {
        ...d("root", { focusable: !0 }),
        component: r,
        ref: t,
        type: r === "button" ? "button" : void 0,
        ...u
      }
    );
  }
);
St.classes = Di;
St.displayName = "@mantine/core/UnstyledButton";
var Yf = { root: "m_515a97f8" };
const Ii = Yf, Kf = {}, _r = F((e, t) => {
  const n = T("VisuallyHidden", Kf, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, ...l } = n, u = K({
    name: "VisuallyHidden",
    classes: Ii,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i
  });
  return /* @__PURE__ */ v(D, { component: "span", ref: t, ...u("root"), ...l });
});
_r.classes = Ii;
_r.displayName = "@mantine/core/VisuallyHidden";
var Xf = { root: "m_1b7284a3" };
const Oi = Xf, Uf = {}, qf = (e, { radius: t, shadow: n }) => ({
  root: {
    "--paper-radius": t === void 0 ? void 0 : ie(t),
    "--paper-shadow": hr(n)
  }
}), Qn = he((e, t) => {
  const n = T("Paper", Uf, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    withBorder: c,
    vars: l,
    radius: u,
    shadow: d,
    variant: p,
    mod: f,
    ...h
  } = n, m = K({
    name: "Paper",
    props: n,
    classes: Oi,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: l,
    varsResolver: qf
  });
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      mod: [{ "data-with-border": c }, f],
      ...m("root"),
      variant: p,
      ...h
    }
  );
});
Qn.classes = Oi;
Qn.displayName = "@mantine/core/Paper";
function eo() {
  return typeof window < "u";
}
function Ut(e) {
  return Li(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Pe(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Qe(e) {
  var t;
  return (t = (Li(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Li(e) {
  return eo() ? e instanceof Node || e instanceof Pe(e).Node : !1;
}
function re(e) {
  return eo() ? e instanceof Element || e instanceof Pe(e).Element : !1;
}
function Te(e) {
  return eo() ? e instanceof HTMLElement || e instanceof Pe(e).HTMLElement : !1;
}
function ir(e) {
  return !eo() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof Pe(e).ShadowRoot;
}
function yn(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: r
  } = De(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !["inline", "contents"].includes(r);
}
function Zf(e) {
  return ["table", "td", "th"].includes(Ut(e));
}
function to(e) {
  return [":popover-open", ":modal"].some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function Rr(e) {
  const t = no(), n = re(e) ? De(e) : e;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((o) => (n.willChange || "").includes(o)) || ["paint", "layout", "strict", "content"].some((o) => (n.contain || "").includes(o));
}
function Jf(e) {
  let t = at(e);
  for (; Te(t) && !vt(t); ) {
    if (Rr(t))
      return t;
    if (to(t))
      return null;
    t = at(t);
  }
  return null;
}
function no() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function vt(e) {
  return ["html", "body", "#document"].includes(Ut(e));
}
function De(e) {
  return Pe(e).getComputedStyle(e);
}
function oo(e) {
  return re(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function at(e) {
  if (Ut(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    ir(e) && e.host || // Fallback.
    Qe(e)
  );
  return ir(t) ? t.host : t;
}
function zi(e) {
  const t = at(e);
  return vt(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Te(t) && yn(t) ? t : zi(t);
}
function rt(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = zi(e), s = r === ((o = e.ownerDocument) == null ? void 0 : o.body), a = Pe(r);
  if (s) {
    const i = lr(a);
    return t.concat(a, a.visualViewport || [], yn(r) ? r : [], i && n ? rt(i) : []);
  }
  return t.concat(r, rt(r, [], n));
}
function lr(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
function Qs(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (n = n.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
    var n;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function fn(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode == null ? void 0 : t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && ir(n)) {
    let o = t;
    for (; o; ) {
      if (e === o)
        return !0;
      o = o.parentNode || o.host;
    }
  }
  return !1;
}
function Bi() {
  const e = navigator.userAgentData;
  return e != null && e.platform ? e.platform : navigator.platform;
}
function Fi() {
  const e = navigator.userAgentData;
  return e && Array.isArray(e.brands) ? e.brands.map((t) => {
    let {
      brand: n,
      version: o
    } = t;
    return n + "/" + o;
  }).join(" ") : navigator.userAgent;
}
function Qf(e) {
  return np() ? !1 : !ea() && e.width === 0 && e.height === 0 || ea() && e.width === 1 && e.height === 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "mouse" || // iOS VoiceOver returns 0.333• for width/height.
  e.width < 1 && e.height < 1 && e.pressure === 0 && e.detail === 0 && e.pointerType === "touch";
}
function ep() {
  return /apple/i.test(navigator.vendor);
}
function ea() {
  const e = /android/i;
  return e.test(Bi()) || e.test(Fi());
}
function tp() {
  return Bi().toLowerCase().startsWith("mac") && !navigator.maxTouchPoints;
}
function np() {
  return Fi().includes("jsdom/");
}
function cr(e, t) {
  const n = ["mouse", "pen"];
  return n.push("", void 0), n.includes(e);
}
function op(e) {
  return "nativeEvent" in e;
}
function rp(e) {
  return e.matches("html,body");
}
function Pt(e) {
  return e?.ownerDocument || document;
}
function Ho(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function Bt(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
const sp = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function ap(e) {
  return Te(e) && e.matches(sp);
}
const Ve = Math.min, be = Math.max, zn = Math.round, En = Math.floor, qe = (e) => ({
  x: e,
  y: e
}), ip = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, lp = {
  start: "end",
  end: "start"
};
function ur(e, t, n) {
  return be(e, Ve(t, n));
}
function it(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function We(e) {
  return e.split("-")[0];
}
function qt(e) {
  return e.split("-")[1];
}
function Nr(e) {
  return e === "x" ? "y" : "x";
}
function Tr(e) {
  return e === "y" ? "height" : "width";
}
function lt(e) {
  return ["top", "bottom"].includes(We(e)) ? "y" : "x";
}
function Er(e) {
  return Nr(lt(e));
}
function cp(e, t, n) {
  n === void 0 && (n = !1);
  const o = qt(e), r = Er(e), s = Tr(r);
  let a = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[s] > t.floating[s] && (a = Bn(a)), [a, Bn(a)];
}
function up(e) {
  const t = Bn(e);
  return [dr(e), t, dr(t)];
}
function dr(e) {
  return e.replace(/start|end/g, (t) => lp[t]);
}
function dp(e, t, n) {
  const o = ["left", "right"], r = ["right", "left"], s = ["top", "bottom"], a = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? r : o : t ? o : r;
    case "left":
    case "right":
      return t ? s : a;
    default:
      return [];
  }
}
function fp(e, t, n, o) {
  const r = qt(e);
  let s = dp(We(e), n === "start", o);
  return r && (s = s.map((a) => a + "-" + r), t && (s = s.concat(s.map(dr)))), s;
}
function Bn(e) {
  return e.replace(/left|right|bottom|top/g, (t) => ip[t]);
}
function pp(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function kr(e) {
  return typeof e != "number" ? pp(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function jt(e) {
  const {
    x: t,
    y: n,
    width: o,
    height: r
  } = e;
  return {
    width: o,
    height: r,
    top: n,
    left: t,
    right: t + o,
    bottom: n + r,
    x: t,
    y: n
  };
}
function ta(e, t, n) {
  let {
    reference: o,
    floating: r
  } = e;
  const s = lt(t), a = Er(t), i = Tr(a), c = We(t), l = s === "y", u = o.x + o.width / 2 - r.width / 2, d = o.y + o.height / 2 - r.height / 2, p = o[i] / 2 - r[i] / 2;
  let f;
  switch (c) {
    case "top":
      f = {
        x: u,
        y: o.y - r.height
      };
      break;
    case "bottom":
      f = {
        x: u,
        y: o.y + o.height
      };
      break;
    case "right":
      f = {
        x: o.x + o.width,
        y: d
      };
      break;
    case "left":
      f = {
        x: o.x - r.width,
        y: d
      };
      break;
    default:
      f = {
        x: o.x,
        y: o.y
      };
  }
  switch (qt(t)) {
    case "start":
      f[a] -= p * (n && l ? -1 : 1);
      break;
    case "end":
      f[a] += p * (n && l ? -1 : 1);
      break;
  }
  return f;
}
const mp = async (e, t, n) => {
  const {
    placement: o = "bottom",
    strategy: r = "absolute",
    middleware: s = [],
    platform: a
  } = n, i = s.filter(Boolean), c = await (a.isRTL == null ? void 0 : a.isRTL(t));
  let l = await a.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: u,
    y: d
  } = ta(l, o, c), p = o, f = {}, h = 0;
  for (let m = 0; m < i.length; m++) {
    const {
      name: g,
      fn: b
    } = i[m], {
      x: w,
      y,
      data: S,
      reset: x
    } = await b({
      x: u,
      y: d,
      initialPlacement: o,
      placement: p,
      strategy: r,
      middlewareData: f,
      rects: l,
      platform: a,
      elements: {
        reference: e,
        floating: t
      }
    });
    u = w ?? u, d = y ?? d, f = {
      ...f,
      [g]: {
        ...f[g],
        ...S
      }
    }, x && h <= 50 && (h++, typeof x == "object" && (x.placement && (p = x.placement), x.rects && (l = x.rects === !0 ? await a.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : x.rects), {
      x: u,
      y: d
    } = ta(l, p, c)), m = -1);
  }
  return {
    x: u,
    y: d,
    placement: p,
    strategy: r,
    middlewareData: f
  };
};
async function Mr(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: r,
    platform: s,
    rects: a,
    elements: i,
    strategy: c
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: f = 0
  } = it(t, e), h = kr(f), g = i[p ? d === "floating" ? "reference" : "floating" : d], b = jt(await s.getClippingRect({
    element: (n = await (s.isElement == null ? void 0 : s.isElement(g))) == null || n ? g : g.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(i.floating)),
    boundary: l,
    rootBoundary: u,
    strategy: c
  })), w = d === "floating" ? {
    x: o,
    y: r,
    width: a.floating.width,
    height: a.floating.height
  } : a.reference, y = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(i.floating)), S = await (s.isElement == null ? void 0 : s.isElement(y)) ? await (s.getScale == null ? void 0 : s.getScale(y)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, x = jt(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: i,
    rect: w,
    offsetParent: y,
    strategy: c
  }) : w);
  return {
    top: (b.top - x.top + h.top) / S.y,
    bottom: (x.bottom - b.bottom + h.bottom) / S.y,
    left: (b.left - x.left + h.left) / S.x,
    right: (x.right - b.right + h.right) / S.x
  };
}
const hp = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: o,
      placement: r,
      rects: s,
      platform: a,
      elements: i,
      middlewareData: c
    } = t, {
      element: l,
      padding: u = 0
    } = it(e, t) || {};
    if (l == null)
      return {};
    const d = kr(u), p = {
      x: n,
      y: o
    }, f = Er(r), h = Tr(f), m = await a.getDimensions(l), g = f === "y", b = g ? "top" : "left", w = g ? "bottom" : "right", y = g ? "clientHeight" : "clientWidth", S = s.reference[h] + s.reference[f] - p[f] - s.floating[h], x = p[f] - s.reference[f], C = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(l));
    let R = C ? C[y] : 0;
    (!R || !await (a.isElement == null ? void 0 : a.isElement(C))) && (R = i.floating[y] || s.floating[h]);
    const P = S / 2 - x / 2, M = R / 2 - m[h] / 2 - 1, I = Ve(d[b], M), H = Ve(d[w], M), z = I, j = R - m[h] - H, B = R / 2 - m[h] / 2 + P, V = ur(z, B, j), O = !c.arrow && qt(r) != null && B !== V && s.reference[h] / 2 - (B < z ? I : H) - m[h] / 2 < 0, L = O ? B < z ? B - z : B - j : 0;
    return {
      [f]: p[f] + L,
      data: {
        [f]: V,
        centerOffset: B - V - L,
        ...O && {
          alignmentOffset: L
        }
      },
      reset: O
    };
  }
}), vp = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: r,
        middlewareData: s,
        rects: a,
        initialPlacement: i,
        platform: c,
        elements: l
      } = t, {
        mainAxis: u = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: f = "bestFit",
        fallbackAxisSideDirection: h = "none",
        flipAlignment: m = !0,
        ...g
      } = it(e, t);
      if ((n = s.arrow) != null && n.alignmentOffset)
        return {};
      const b = We(r), w = lt(i), y = We(i) === i, S = await (c.isRTL == null ? void 0 : c.isRTL(l.floating)), x = p || (y || !m ? [Bn(i)] : up(i)), C = h !== "none";
      !p && C && x.push(...fp(i, m, h, S));
      const R = [i, ...x], P = await Mr(t, g), M = [];
      let I = ((o = s.flip) == null ? void 0 : o.overflows) || [];
      if (u && M.push(P[b]), d) {
        const B = cp(r, a, S);
        M.push(P[B[0]], P[B[1]]);
      }
      if (I = [...I, {
        placement: r,
        overflows: M
      }], !M.every((B) => B <= 0)) {
        var H, z;
        const B = (((H = s.flip) == null ? void 0 : H.index) || 0) + 1, V = R[B];
        if (V)
          return {
            data: {
              index: B,
              overflows: I
            },
            reset: {
              placement: V
            }
          };
        let O = (z = I.filter((L) => L.overflows[0] <= 0).sort((L, N) => L.overflows[1] - N.overflows[1])[0]) == null ? void 0 : z.placement;
        if (!O)
          switch (f) {
            case "bestFit": {
              var j;
              const L = (j = I.filter((N) => {
                if (C) {
                  const $ = lt(N.placement);
                  return $ === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  $ === "y";
                }
                return !0;
              }).map((N) => [N.placement, N.overflows.filter(($) => $ > 0).reduce(($, k) => $ + k, 0)]).sort((N, $) => N[1] - $[1])[0]) == null ? void 0 : j[0];
              L && (O = L);
              break;
            }
            case "initialPlacement":
              O = i;
              break;
          }
        if (r !== O)
          return {
            reset: {
              placement: O
            }
          };
      }
      return {};
    }
  };
};
function Hi(e) {
  const t = Ve(...e.map((s) => s.left)), n = Ve(...e.map((s) => s.top)), o = be(...e.map((s) => s.right)), r = be(...e.map((s) => s.bottom));
  return {
    x: t,
    y: n,
    width: o - t,
    height: r - n
  };
}
function gp(e) {
  const t = e.slice().sort((r, s) => r.y - s.y), n = [];
  let o = null;
  for (let r = 0; r < t.length; r++) {
    const s = t[r];
    !o || s.y - o.y > o.height / 2 ? n.push([s]) : n[n.length - 1].push(s), o = s;
  }
  return n.map((r) => jt(Hi(r)));
}
const yp = function(e) {
  return e === void 0 && (e = {}), {
    name: "inline",
    options: e,
    async fn(t) {
      const {
        placement: n,
        elements: o,
        rects: r,
        platform: s,
        strategy: a
      } = t, {
        padding: i = 2,
        x: c,
        y: l
      } = it(e, t), u = Array.from(await (s.getClientRects == null ? void 0 : s.getClientRects(o.reference)) || []), d = gp(u), p = jt(Hi(u)), f = kr(i);
      function h() {
        if (d.length === 2 && d[0].left > d[1].right && c != null && l != null)
          return d.find((g) => c > g.left - f.left && c < g.right + f.right && l > g.top - f.top && l < g.bottom + f.bottom) || p;
        if (d.length >= 2) {
          if (lt(n) === "y") {
            const I = d[0], H = d[d.length - 1], z = We(n) === "top", j = I.top, B = H.bottom, V = z ? I.left : H.left, O = z ? I.right : H.right, L = O - V, N = B - j;
            return {
              top: j,
              bottom: B,
              left: V,
              right: O,
              width: L,
              height: N,
              x: V,
              y: j
            };
          }
          const g = We(n) === "left", b = be(...d.map((I) => I.right)), w = Ve(...d.map((I) => I.left)), y = d.filter((I) => g ? I.left === w : I.right === b), S = y[0].top, x = y[y.length - 1].bottom, C = w, R = b, P = R - C, M = x - S;
          return {
            top: S,
            bottom: x,
            left: C,
            right: R,
            width: P,
            height: M,
            x: C,
            y: S
          };
        }
        return p;
      }
      const m = await s.getElementRects({
        reference: {
          getBoundingClientRect: h
        },
        floating: o.floating,
        strategy: a
      });
      return r.reference.x !== m.reference.x || r.reference.y !== m.reference.y || r.reference.width !== m.reference.width || r.reference.height !== m.reference.height ? {
        reset: {
          rects: m
        }
      } : {};
    }
  };
};
async function bp(e, t) {
  const {
    placement: n,
    platform: o,
    elements: r
  } = e, s = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), a = We(n), i = qt(n), c = lt(n) === "y", l = ["left", "top"].includes(a) ? -1 : 1, u = s && c ? -1 : 1, d = it(t, e);
  let {
    mainAxis: p,
    crossAxis: f,
    alignmentAxis: h
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: d.mainAxis || 0,
    crossAxis: d.crossAxis || 0,
    alignmentAxis: d.alignmentAxis
  };
  return i && typeof h == "number" && (f = i === "end" ? h * -1 : h), c ? {
    x: f * u,
    y: p * l
  } : {
    x: p * l,
    y: f * u
  };
}
const wp = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, o;
      const {
        x: r,
        y: s,
        placement: a,
        middlewareData: i
      } = t, c = await bp(t, e);
      return a === ((n = i.offset) == null ? void 0 : n.placement) && (o = i.arrow) != null && o.alignmentOffset ? {} : {
        x: r + c.x,
        y: s + c.y,
        data: {
          ...c,
          placement: a
        }
      };
    }
  };
}, Sp = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: r
      } = t, {
        mainAxis: s = !0,
        crossAxis: a = !1,
        limiter: i = {
          fn: (g) => {
            let {
              x: b,
              y: w
            } = g;
            return {
              x: b,
              y: w
            };
          }
        },
        ...c
      } = it(e, t), l = {
        x: n,
        y: o
      }, u = await Mr(t, c), d = lt(We(r)), p = Nr(d);
      let f = l[p], h = l[d];
      if (s) {
        const g = p === "y" ? "top" : "left", b = p === "y" ? "bottom" : "right", w = f + u[g], y = f - u[b];
        f = ur(w, f, y);
      }
      if (a) {
        const g = d === "y" ? "top" : "left", b = d === "y" ? "bottom" : "right", w = h + u[g], y = h - u[b];
        h = ur(w, h, y);
      }
      const m = i.fn({
        ...t,
        [p]: f,
        [d]: h
      });
      return {
        ...m,
        data: {
          x: m.x - n,
          y: m.y - o,
          enabled: {
            [p]: s,
            [d]: a
          }
        }
      };
    }
  };
}, xp = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: o,
        placement: r,
        rects: s,
        middlewareData: a
      } = t, {
        offset: i = 0,
        mainAxis: c = !0,
        crossAxis: l = !0
      } = it(e, t), u = {
        x: n,
        y: o
      }, d = lt(r), p = Nr(d);
      let f = u[p], h = u[d];
      const m = it(i, t), g = typeof m == "number" ? {
        mainAxis: m,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...m
      };
      if (c) {
        const y = p === "y" ? "height" : "width", S = s.reference[p] - s.floating[y] + g.mainAxis, x = s.reference[p] + s.reference[y] - g.mainAxis;
        f < S ? f = S : f > x && (f = x);
      }
      if (l) {
        var b, w;
        const y = p === "y" ? "width" : "height", S = ["top", "left"].includes(We(r)), x = s.reference[d] - s.floating[y] + (S && ((b = a.offset) == null ? void 0 : b[d]) || 0) + (S ? 0 : g.crossAxis), C = s.reference[d] + s.reference[y] + (S ? 0 : ((w = a.offset) == null ? void 0 : w[d]) || 0) - (S ? g.crossAxis : 0);
        h < x ? h = x : h > C && (h = C);
      }
      return {
        [p]: f,
        [d]: h
      };
    }
  };
}, Cp = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: r,
        rects: s,
        platform: a,
        elements: i
      } = t, {
        apply: c = () => {
        },
        ...l
      } = it(e, t), u = await Mr(t, l), d = We(r), p = qt(r), f = lt(r) === "y", {
        width: h,
        height: m
      } = s.floating;
      let g, b;
      d === "top" || d === "bottom" ? (g = d, b = p === (await (a.isRTL == null ? void 0 : a.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (b = d, g = p === "end" ? "top" : "bottom");
      const w = m - u.top - u.bottom, y = h - u.left - u.right, S = Ve(m - u[g], w), x = Ve(h - u[b], y), C = !t.middlewareData.shift;
      let R = S, P = x;
      if ((n = t.middlewareData.shift) != null && n.enabled.x && (P = y), (o = t.middlewareData.shift) != null && o.enabled.y && (R = w), C && !p) {
        const I = be(u.left, 0), H = be(u.right, 0), z = be(u.top, 0), j = be(u.bottom, 0);
        f ? P = h - 2 * (I !== 0 || H !== 0 ? I + H : be(u.left, u.right)) : R = m - 2 * (z !== 0 || j !== 0 ? z + j : be(u.top, u.bottom));
      }
      await c({
        ...t,
        availableWidth: P,
        availableHeight: R
      });
      const M = await a.getDimensions(i.floating);
      return h !== M.width || m !== M.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function Vi(e) {
  const t = De(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const r = Te(e), s = r ? e.offsetWidth : n, a = r ? e.offsetHeight : o, i = zn(n) !== s || zn(o) !== a;
  return i && (n = s, o = a), {
    width: n,
    height: o,
    $: i
  };
}
function Ar(e) {
  return re(e) ? e : e.contextElement;
}
function Ht(e) {
  const t = Ar(e);
  if (!Te(t))
    return qe(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: r,
    $: s
  } = Vi(t);
  let a = (s ? zn(n.width) : n.width) / o, i = (s ? zn(n.height) : n.height) / r;
  return (!a || !Number.isFinite(a)) && (a = 1), (!i || !Number.isFinite(i)) && (i = 1), {
    x: a,
    y: i
  };
}
const $p = /* @__PURE__ */ qe(0);
function Wi(e) {
  const t = Pe(e);
  return !no() || !t.visualViewport ? $p : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Pp(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== Pe(e) ? !1 : t;
}
function Tt(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), s = Ar(e);
  let a = qe(1);
  t && (o ? re(o) && (a = Ht(o)) : a = Ht(e));
  const i = Pp(s, n, o) ? Wi(s) : qe(0);
  let c = (r.left + i.x) / a.x, l = (r.top + i.y) / a.y, u = r.width / a.x, d = r.height / a.y;
  if (s) {
    const p = Pe(s), f = o && re(o) ? Pe(o) : o;
    let h = p, m = lr(h);
    for (; m && o && f !== h; ) {
      const g = Ht(m), b = m.getBoundingClientRect(), w = De(m), y = b.left + (m.clientLeft + parseFloat(w.paddingLeft)) * g.x, S = b.top + (m.clientTop + parseFloat(w.paddingTop)) * g.y;
      c *= g.x, l *= g.y, u *= g.x, d *= g.y, c += y, l += S, h = Pe(m), m = lr(h);
    }
  }
  return jt({
    width: u,
    height: d,
    x: c,
    y: l
  });
}
function Dr(e, t) {
  const n = oo(e).scrollLeft;
  return t ? t.left + n : Tt(Qe(e)).left + n;
}
function ji(e, t, n) {
  n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), r = o.left + t.scrollLeft - (n ? 0 : (
    // RTL <body> scrollbar.
    Dr(e, o)
  )), s = o.top + t.scrollTop;
  return {
    x: r,
    y: s
  };
}
function _p(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: r
  } = e;
  const s = r === "fixed", a = Qe(o), i = t ? to(t.floating) : !1;
  if (o === a || i && s)
    return n;
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = qe(1);
  const u = qe(0), d = Te(o);
  if ((d || !d && !s) && ((Ut(o) !== "body" || yn(a)) && (c = oo(o)), Te(o))) {
    const f = Tt(o);
    l = Ht(o), u.x = f.x + o.clientLeft, u.y = f.y + o.clientTop;
  }
  const p = a && !d && !s ? ji(a, c, !0) : qe(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - c.scrollLeft * l.x + u.x + p.x,
    y: n.y * l.y - c.scrollTop * l.y + u.y + p.y
  };
}
function Rp(e) {
  return Array.from(e.getClientRects());
}
function Np(e) {
  const t = Qe(e), n = oo(e), o = e.ownerDocument.body, r = be(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), s = be(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let a = -n.scrollLeft + Dr(e);
  const i = -n.scrollTop;
  return De(o).direction === "rtl" && (a += be(t.clientWidth, o.clientWidth) - r), {
    width: r,
    height: s,
    x: a,
    y: i
  };
}
function Tp(e, t) {
  const n = Pe(e), o = Qe(e), r = n.visualViewport;
  let s = o.clientWidth, a = o.clientHeight, i = 0, c = 0;
  if (r) {
    s = r.width, a = r.height;
    const l = no();
    (!l || l && t === "fixed") && (i = r.offsetLeft, c = r.offsetTop);
  }
  return {
    width: s,
    height: a,
    x: i,
    y: c
  };
}
function Ep(e, t) {
  const n = Tt(e, !0, t === "fixed"), o = n.top + e.clientTop, r = n.left + e.clientLeft, s = Te(e) ? Ht(e) : qe(1), a = e.clientWidth * s.x, i = e.clientHeight * s.y, c = r * s.x, l = o * s.y;
  return {
    width: a,
    height: i,
    x: c,
    y: l
  };
}
function na(e, t, n) {
  let o;
  if (t === "viewport")
    o = Tp(e, n);
  else if (t === "document")
    o = Np(Qe(e));
  else if (re(t))
    o = Ep(t, n);
  else {
    const r = Wi(e);
    o = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return jt(o);
}
function Gi(e, t) {
  const n = at(e);
  return n === t || !re(n) || vt(n) ? !1 : De(n).position === "fixed" || Gi(n, t);
}
function kp(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = rt(e, [], !1).filter((i) => re(i) && Ut(i) !== "body"), r = null;
  const s = De(e).position === "fixed";
  let a = s ? at(e) : e;
  for (; re(a) && !vt(a); ) {
    const i = De(a), c = Rr(a);
    !c && i.position === "fixed" && (r = null), (s ? !c && !r : !c && i.position === "static" && !!r && ["absolute", "fixed"].includes(r.position) || yn(a) && !c && Gi(e, a)) ? o = o.filter((u) => u !== a) : r = i, a = at(a);
  }
  return t.set(e, o), o;
}
function Mp(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: r
  } = e;
  const a = [...n === "clippingAncestors" ? to(t) ? [] : kp(t, this._c) : [].concat(n), o], i = a[0], c = a.reduce((l, u) => {
    const d = na(t, u, r);
    return l.top = be(d.top, l.top), l.right = Ve(d.right, l.right), l.bottom = Ve(d.bottom, l.bottom), l.left = be(d.left, l.left), l;
  }, na(t, i, r));
  return {
    width: c.right - c.left,
    height: c.bottom - c.top,
    x: c.left,
    y: c.top
  };
}
function Ap(e) {
  const {
    width: t,
    height: n
  } = Vi(e);
  return {
    width: t,
    height: n
  };
}
function Dp(e, t, n) {
  const o = Te(t), r = Qe(t), s = n === "fixed", a = Tt(e, !0, s, t);
  let i = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const c = qe(0);
  if (o || !o && !s)
    if ((Ut(t) !== "body" || yn(r)) && (i = oo(t)), o) {
      const p = Tt(t, !0, s, t);
      c.x = p.x + t.clientLeft, c.y = p.y + t.clientTop;
    } else r && (c.x = Dr(r));
  const l = r && !o && !s ? ji(r, i) : qe(0), u = a.left + i.scrollLeft - c.x - l.x, d = a.top + i.scrollTop - c.y - l.y;
  return {
    x: u,
    y: d,
    width: a.width,
    height: a.height
  };
}
function Vo(e) {
  return De(e).position === "static";
}
function oa(e, t) {
  if (!Te(e) || De(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return Qe(e) === n && (n = n.ownerDocument.body), n;
}
function Yi(e, t) {
  const n = Pe(e);
  if (to(e))
    return n;
  if (!Te(e)) {
    let r = at(e);
    for (; r && !vt(r); ) {
      if (re(r) && !Vo(r))
        return r;
      r = at(r);
    }
    return n;
  }
  let o = oa(e, t);
  for (; o && Zf(o) && Vo(o); )
    o = oa(o, t);
  return o && vt(o) && Vo(o) && !Rr(o) ? n : o || Jf(e) || n;
}
const Ip = async function(e) {
  const t = this.getOffsetParent || Yi, n = this.getDimensions, o = await n(e.floating);
  return {
    reference: Dp(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function Op(e) {
  return De(e).direction === "rtl";
}
const Lp = {
  convertOffsetParentRelativeRectToViewportRelativeRect: _p,
  getDocumentElement: Qe,
  getClippingRect: Mp,
  getOffsetParent: Yi,
  getElementRects: Ip,
  getClientRects: Rp,
  getDimensions: Ap,
  getScale: Ht,
  isElement: re,
  isRTL: Op
};
function Ki(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function zp(e, t) {
  let n = null, o;
  const r = Qe(e);
  function s() {
    var i;
    clearTimeout(o), (i = n) == null || i.disconnect(), n = null;
  }
  function a(i, c) {
    i === void 0 && (i = !1), c === void 0 && (c = 1), s();
    const l = e.getBoundingClientRect(), {
      left: u,
      top: d,
      width: p,
      height: f
    } = l;
    if (i || t(), !p || !f)
      return;
    const h = En(d), m = En(r.clientWidth - (u + p)), g = En(r.clientHeight - (d + f)), b = En(u), y = {
      rootMargin: -h + "px " + -m + "px " + -g + "px " + -b + "px",
      threshold: be(0, Ve(1, c)) || 1
    };
    let S = !0;
    function x(C) {
      const R = C[0].intersectionRatio;
      if (R !== c) {
        if (!S)
          return a();
        R ? a(!1, R) : o = setTimeout(() => {
          a(!1, 1e-7);
        }, 1e3);
      }
      R === 1 && !Ki(l, e.getBoundingClientRect()) && a(), S = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...y,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, y);
    }
    n.observe(e);
  }
  return a(!0), s;
}
function Bp(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: s = !0,
    elementResize: a = typeof ResizeObserver == "function",
    layoutShift: i = typeof IntersectionObserver == "function",
    animationFrame: c = !1
  } = o, l = Ar(e), u = r || s ? [...l ? rt(l) : [], ...rt(t)] : [];
  u.forEach((b) => {
    r && b.addEventListener("scroll", n, {
      passive: !0
    }), s && b.addEventListener("resize", n);
  });
  const d = l && i ? zp(l, n) : null;
  let p = -1, f = null;
  a && (f = new ResizeObserver((b) => {
    let [w] = b;
    w && w.target === l && f && (f.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var y;
      (y = f) == null || y.observe(t);
    })), n();
  }), l && !c && f.observe(l), f.observe(t));
  let h, m = c ? Tt(e) : null;
  c && g();
  function g() {
    const b = Tt(e);
    m && !Ki(m, b) && n(), m = b, h = requestAnimationFrame(g);
  }
  return n(), () => {
    var b;
    u.forEach((w) => {
      r && w.removeEventListener("scroll", n), s && w.removeEventListener("resize", n);
    }), d?.(), (b = f) == null || b.disconnect(), f = null, c && cancelAnimationFrame(h);
  };
}
const Fp = wp, Hp = Sp, Vp = vp, Wp = Cp, ra = hp, jp = yp, Gp = xp, Yp = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), r = {
    platform: Lp,
    ...n
  }, s = {
    ...r.platform,
    _c: o
  };
  return mp(e, t, {
    ...r,
    platform: s
  });
};
var In = typeof document < "u" ? Wn : U;
function Fn(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, o, r;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (o = n; o-- !== 0; )
        if (!Fn(e[o], t[o]))
          return !1;
      return !0;
    }
    if (r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!{}.hasOwnProperty.call(t, r[o]))
        return !1;
    for (o = n; o-- !== 0; ) {
      const s = r[o];
      if (!(s === "_owner" && e.$$typeof) && !Fn(e[s], t[s]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Xi(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function sa(e, t) {
  const n = Xi(e);
  return Math.round(t * n) / n;
}
function Wo(e) {
  const t = _.useRef(e);
  return In(() => {
    t.current = e;
  }), t;
}
function Kp(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: r,
    elements: {
      reference: s,
      floating: a
    } = {},
    transform: i = !0,
    whileElementsMounted: c,
    open: l
  } = e, [u, d] = _.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, f] = _.useState(o);
  Fn(p, o) || f(o);
  const [h, m] = _.useState(null), [g, b] = _.useState(null), w = _.useCallback((N) => {
    N !== C.current && (C.current = N, m(N));
  }, []), y = _.useCallback((N) => {
    N !== R.current && (R.current = N, b(N));
  }, []), S = s || h, x = a || g, C = _.useRef(null), R = _.useRef(null), P = _.useRef(u), M = c != null, I = Wo(c), H = Wo(r), z = Wo(l), j = _.useCallback(() => {
    if (!C.current || !R.current)
      return;
    const N = {
      placement: t,
      strategy: n,
      middleware: p
    };
    H.current && (N.platform = H.current), Yp(C.current, R.current, N).then(($) => {
      const k = {
        ...$,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: z.current !== !1
      };
      B.current && !Fn(P.current, k) && (P.current = k, Kc.flushSync(() => {
        d(k);
      }));
    });
  }, [p, t, n, H, z]);
  In(() => {
    l === !1 && P.current.isPositioned && (P.current.isPositioned = !1, d((N) => ({
      ...N,
      isPositioned: !1
    })));
  }, [l]);
  const B = _.useRef(!1);
  In(() => (B.current = !0, () => {
    B.current = !1;
  }), []), In(() => {
    if (S && (C.current = S), x && (R.current = x), S && x) {
      if (I.current)
        return I.current(S, x, j);
      j();
    }
  }, [S, x, j, I, M]);
  const V = _.useMemo(() => ({
    reference: C,
    floating: R,
    setReference: w,
    setFloating: y
  }), [w, y]), O = _.useMemo(() => ({
    reference: S,
    floating: x
  }), [S, x]), L = _.useMemo(() => {
    const N = {
      position: n,
      left: 0,
      top: 0
    };
    if (!O.floating)
      return N;
    const $ = sa(O.floating, u.x), k = sa(O.floating, u.y);
    return i ? {
      ...N,
      transform: "translate(" + $ + "px, " + k + "px)",
      ...Xi(O.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: $,
      top: k
    };
  }, [n, i, O.floating, u.x, u.y]);
  return _.useMemo(() => ({
    ...u,
    update: j,
    refs: V,
    elements: O,
    floatingStyles: L
  }), [u, j, V, O, L]);
}
const Xp = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: o,
        padding: r
      } = typeof e == "function" ? e(n) : e;
      return o && t(o) ? o.current != null ? ra({
        element: o.current,
        padding: r
      }).fn(n) : {} : o ? ra({
        element: o,
        padding: r
      }).fn(n) : {};
    }
  };
}, Ui = (e, t) => ({
  ...Fp(e),
  options: [e, t]
}), Ir = (e, t) => ({
  ...Hp(e),
  options: [e, t]
}), aa = (e, t) => ({
  ...Gp(e),
  options: [e, t]
}), Hn = (e, t) => ({
  ...Vp(e),
  options: [e, t]
}), Up = (e, t) => ({
  ...Wp(e),
  options: [e, t]
}), ln = (e, t) => ({
  ...jp(e),
  options: [e, t]
}), qi = (e, t) => ({
  ...Xp(e),
  options: [e, t]
}), Zi = {
  ..._
}, qp = Zi.useInsertionEffect, Zp = qp || ((e) => e());
function ot(e) {
  const t = _.useRef(() => {
  });
  return Zp(() => {
    t.current = e;
  }), _.useCallback(function() {
    for (var n = arguments.length, o = new Array(n), r = 0; r < n; r++)
      o[r] = arguments[r];
    return t.current == null ? void 0 : t.current(...o);
  }, []);
}
var Ze = typeof document < "u" ? Wn : U;
let ia = !1, Jp = 0;
const la = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + Jp++
);
function Qp() {
  const [e, t] = _.useState(() => ia ? la() : void 0);
  return Ze(() => {
    e == null && t(la());
  }, []), _.useEffect(() => {
    ia = !0;
  }, []), e;
}
const em = Zi.useId, Ji = em || Qp;
function tm() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var o;
      (o = e.get(t)) == null || o.forEach((r) => r(n));
    },
    on(t, n) {
      e.set(t, [...e.get(t) || [], n]);
    },
    off(t, n) {
      var o;
      e.set(t, ((o = e.get(t)) == null ? void 0 : o.filter((r) => r !== n)) || []);
    }
  };
}
const nm = /* @__PURE__ */ _.createContext(null), om = /* @__PURE__ */ _.createContext(null), Or = () => {
  var e;
  return ((e = _.useContext(nm)) == null ? void 0 : e.id) || null;
}, Lr = () => _.useContext(om);
function zr(e) {
  return "data-floating-ui-" + e;
}
function jo(e) {
  const t = G(e);
  return Ze(() => {
    t.current = e;
  }), t;
}
const ca = /* @__PURE__ */ zr("safe-polygon");
function On(e, t, n) {
  return n && !cr(n) ? 0 : typeof e == "number" ? e : e?.[t];
}
function rm(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: o,
    dataRef: r,
    events: s,
    elements: a
  } = e, {
    enabled: i = !0,
    delay: c = 0,
    handleClose: l = null,
    mouseOnly: u = !1,
    restMs: d = 0,
    move: p = !0
  } = t, f = Lr(), h = Or(), m = jo(l), g = jo(c), b = jo(n), w = _.useRef(), y = _.useRef(-1), S = _.useRef(), x = _.useRef(-1), C = _.useRef(!0), R = _.useRef(!1), P = _.useRef(() => {
  }), M = _.useRef(!1), I = _.useCallback(() => {
    var L;
    const N = (L = r.current.openEvent) == null ? void 0 : L.type;
    return N?.includes("mouse") && N !== "mousedown";
  }, [r]);
  _.useEffect(() => {
    if (!i) return;
    function L(N) {
      let {
        open: $
      } = N;
      $ || (clearTimeout(y.current), clearTimeout(x.current), C.current = !0, M.current = !1);
    }
    return s.on("openchange", L), () => {
      s.off("openchange", L);
    };
  }, [i, s]), _.useEffect(() => {
    if (!i || !m.current || !n) return;
    function L($) {
      I() && o(!1, $, "hover");
    }
    const N = Pt(a.floating).documentElement;
    return N.addEventListener("mouseleave", L), () => {
      N.removeEventListener("mouseleave", L);
    };
  }, [a.floating, n, o, i, m, I]);
  const H = _.useCallback(function(L, N, $) {
    N === void 0 && (N = !0), $ === void 0 && ($ = "hover");
    const k = On(g.current, "close", w.current);
    k && !S.current ? (clearTimeout(y.current), y.current = window.setTimeout(() => o(!1, L, $), k)) : N && (clearTimeout(y.current), o(!1, L, $));
  }, [g, o]), z = ot(() => {
    P.current(), S.current = void 0;
  }), j = ot(() => {
    if (R.current) {
      const L = Pt(a.floating).body;
      L.style.pointerEvents = "", L.removeAttribute(ca), R.current = !1;
    }
  }), B = ot(() => r.current.openEvent ? ["click", "mousedown"].includes(r.current.openEvent.type) : !1);
  _.useEffect(() => {
    if (!i) return;
    function L(A) {
      if (clearTimeout(y.current), C.current = !1, u && !cr(w.current) || d > 0 && !On(g.current, "open"))
        return;
      const q = On(g.current, "open", w.current);
      q ? y.current = window.setTimeout(() => {
        b.current || o(!0, A, "hover");
      }, q) : n || o(!0, A, "hover");
    }
    function N(A) {
      if (B()) return;
      P.current();
      const q = Pt(a.floating);
      if (clearTimeout(x.current), M.current = !1, m.current && r.current.floatingContext) {
        n || clearTimeout(y.current), S.current = m.current({
          ...r.current.floatingContext,
          tree: f,
          x: A.clientX,
          y: A.clientY,
          onClose() {
            j(), z(), B() || H(A, !0, "safe-polygon");
          }
        });
        const se = S.current;
        q.addEventListener("mousemove", se), P.current = () => {
          q.removeEventListener("mousemove", se);
        };
        return;
      }
      (w.current === "touch" ? !fn(a.floating, A.relatedTarget) : !0) && H(A);
    }
    function $(A) {
      B() || r.current.floatingContext && (m.current == null || m.current({
        ...r.current.floatingContext,
        tree: f,
        x: A.clientX,
        y: A.clientY,
        onClose() {
          j(), z(), B() || H(A);
        }
      })(A));
    }
    if (re(a.domReference)) {
      var k;
      const A = a.domReference;
      return n && A.addEventListener("mouseleave", $), (k = a.floating) == null || k.addEventListener("mouseleave", $), p && A.addEventListener("mousemove", L, {
        once: !0
      }), A.addEventListener("mouseenter", L), A.addEventListener("mouseleave", N), () => {
        var q;
        n && A.removeEventListener("mouseleave", $), (q = a.floating) == null || q.removeEventListener("mouseleave", $), p && A.removeEventListener("mousemove", L), A.removeEventListener("mouseenter", L), A.removeEventListener("mouseleave", N);
      };
    }
  }, [a, i, e, u, d, p, H, z, j, o, n, b, f, g, m, r, B]), Ze(() => {
    var L;
    if (i && n && (L = m.current) != null && L.__options.blockPointerEvents && I()) {
      R.current = !0;
      const $ = a.floating;
      if (re(a.domReference) && $) {
        var N;
        const k = Pt(a.floating).body;
        k.setAttribute(ca, "");
        const A = a.domReference, q = f == null || (N = f.nodesRef.current.find((ee) => ee.id === h)) == null || (N = N.context) == null ? void 0 : N.elements.floating;
        return q && (q.style.pointerEvents = ""), k.style.pointerEvents = "none", A.style.pointerEvents = "auto", $.style.pointerEvents = "auto", () => {
          k.style.pointerEvents = "", A.style.pointerEvents = "", $.style.pointerEvents = "";
        };
      }
    }
  }, [i, n, h, a, f, m, I]), Ze(() => {
    n || (w.current = void 0, M.current = !1, z(), j());
  }, [n, z, j]), _.useEffect(() => () => {
    z(), clearTimeout(y.current), clearTimeout(x.current), j();
  }, [i, a.domReference, z, j]);
  const V = _.useMemo(() => {
    function L(N) {
      w.current = N.pointerType;
    }
    return {
      onPointerDown: L,
      onPointerEnter: L,
      onMouseMove(N) {
        const {
          nativeEvent: $
        } = N;
        function k() {
          !C.current && !b.current && o(!0, $, "hover");
        }
        u && !cr(w.current) || n || d === 0 || M.current && N.movementX ** 2 + N.movementY ** 2 < 2 || (clearTimeout(x.current), w.current === "touch" ? k() : (M.current = !0, x.current = window.setTimeout(k, d)));
      }
    };
  }, [u, o, n, b, d]), O = _.useMemo(() => ({
    onMouseEnter() {
      clearTimeout(y.current);
    },
    onMouseLeave(L) {
      B() || H(L.nativeEvent, !1);
    }
  }), [H, B]);
  return _.useMemo(() => i ? {
    reference: V,
    floating: O
  } : {}, [i, V, O]);
}
const fr = () => {
}, Qi = /* @__PURE__ */ _.createContext({
  delay: 0,
  initialDelay: 0,
  timeoutMs: 0,
  currentId: null,
  setCurrentId: fr,
  setState: fr,
  isInstantPhase: !1
}), sm = () => _.useContext(Qi);
function am(e) {
  const {
    children: t,
    delay: n,
    timeoutMs: o = 0
  } = e, [r, s] = _.useReducer((c, l) => ({
    ...c,
    ...l
  }), {
    delay: n,
    timeoutMs: o,
    initialDelay: n,
    currentId: null,
    isInstantPhase: !1
  }), a = _.useRef(null), i = _.useCallback((c) => {
    s({
      currentId: c
    });
  }, []);
  return Ze(() => {
    r.currentId ? a.current === null ? a.current = r.currentId : r.isInstantPhase || s({
      isInstantPhase: !0
    }) : (r.isInstantPhase && s({
      isInstantPhase: !1
    }), a.current = null);
  }, [r.currentId, r.isInstantPhase]), /* @__PURE__ */ _.createElement(Qi.Provider, {
    value: _.useMemo(() => ({
      ...r,
      setState: s,
      setCurrentId: i
    }), [r, i])
  }, t);
}
function im(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: o,
    floatingId: r
  } = e, {
    id: s,
    enabled: a = !0
  } = t, i = s ?? r, c = sm(), {
    currentId: l,
    setCurrentId: u,
    initialDelay: d,
    setState: p,
    timeoutMs: f
  } = c;
  return Ze(() => {
    a && l && (p({
      delay: {
        open: 1,
        close: On(d, "close")
      }
    }), l !== i && o(!1));
  }, [a, i, o, p, l, d]), Ze(() => {
    function h() {
      o(!1), p({
        delay: d,
        currentId: null
      });
    }
    if (a && l && !n && l === i) {
      if (f) {
        const m = window.setTimeout(h, f);
        return () => {
          clearTimeout(m);
        };
      }
      h();
    }
  }, [a, n, p, l, i, o, d, f]), Ze(() => {
    a && (u === fr || !n || u(i));
  }, [a, n, u, i]), c;
}
function Go(e, t) {
  let n = e.filter((r) => {
    var s;
    return r.parentId === t && ((s = r.context) == null ? void 0 : s.open);
  }), o = n;
  for (; o.length; )
    o = e.filter((r) => {
      var s;
      return (s = o) == null ? void 0 : s.some((a) => {
        var i;
        return r.parentId === a.id && ((i = r.context) == null ? void 0 : i.open);
      });
    }), n = n.concat(o);
  return n;
}
const lm = "data-floating-ui-focusable", cm = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, um = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, ua = (e) => {
  var t, n;
  return {
    escapeKey: typeof e == "boolean" ? e : (t = e?.escapeKey) != null ? t : !1,
    outsidePress: typeof e == "boolean" ? e : (n = e?.outsidePress) != null ? n : !0
  };
};
function dm(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: o,
    elements: r,
    dataRef: s
  } = e, {
    enabled: a = !0,
    escapeKey: i = !0,
    outsidePress: c = !0,
    outsidePressEvent: l = "pointerdown",
    referencePress: u = !1,
    referencePressEvent: d = "pointerdown",
    ancestorScroll: p = !1,
    bubbles: f,
    capture: h
  } = t, m = Lr(), g = ot(typeof c == "function" ? c : () => !1), b = typeof c == "function" ? g : c, w = _.useRef(!1), y = _.useRef(!1), {
    escapeKey: S,
    outsidePress: x
  } = ua(f), {
    escapeKey: C,
    outsidePress: R
  } = ua(h), P = _.useRef(!1), M = ot((V) => {
    var O;
    if (!n || !a || !i || V.key !== "Escape" || P.current)
      return;
    const L = (O = s.current.floatingContext) == null ? void 0 : O.nodeId, N = m ? Go(m.nodesRef.current, L) : [];
    if (!S && (V.stopPropagation(), N.length > 0)) {
      let $ = !0;
      if (N.forEach((k) => {
        var A;
        if ((A = k.context) != null && A.open && !k.context.dataRef.current.__escapeKeyBubbles) {
          $ = !1;
          return;
        }
      }), !$)
        return;
    }
    o(!1, op(V) ? V.nativeEvent : V, "escape-key");
  }), I = ot((V) => {
    var O;
    const L = () => {
      var N;
      M(V), (N = Bt(V)) == null || N.removeEventListener("keydown", L);
    };
    (O = Bt(V)) == null || O.addEventListener("keydown", L);
  }), H = ot((V) => {
    var O;
    const L = w.current;
    w.current = !1;
    const N = y.current;
    if (y.current = !1, l === "click" && N || L || typeof b == "function" && !b(V))
      return;
    const $ = Bt(V), k = "[" + zr("inert") + "]", A = Pt(r.floating).querySelectorAll(k);
    let q = re($) ? $ : null;
    for (; q && !vt(q); ) {
      const X = at(q);
      if (vt(X) || !re(X))
        break;
      q = X;
    }
    if (A.length && re($) && !rp($) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !fn($, r.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(A).every((X) => !fn(q, X)))
      return;
    if (Te($) && B) {
      const X = $.clientWidth > 0 && $.scrollWidth > $.clientWidth, te = $.clientHeight > 0 && $.scrollHeight > $.clientHeight;
      let ge = te && V.offsetX > $.clientWidth;
      if (te && De($).direction === "rtl" && (ge = V.offsetX <= $.offsetWidth - $.clientWidth), ge || X && V.offsetY > $.clientHeight)
        return;
    }
    const ee = (O = s.current.floatingContext) == null ? void 0 : O.nodeId, se = m && Go(m.nodesRef.current, ee).some((X) => {
      var te;
      return Ho(V, (te = X.context) == null ? void 0 : te.elements.floating);
    });
    if (Ho(V, r.floating) || Ho(V, r.domReference) || se)
      return;
    const ne = m ? Go(m.nodesRef.current, ee) : [];
    if (ne.length > 0) {
      let X = !0;
      if (ne.forEach((te) => {
        var ge;
        if ((ge = te.context) != null && ge.open && !te.context.dataRef.current.__outsidePressBubbles) {
          X = !1;
          return;
        }
      }), !X)
        return;
    }
    o(!1, V, "outside-press");
  }), z = ot((V) => {
    var O;
    const L = () => {
      var N;
      H(V), (N = Bt(V)) == null || N.removeEventListener(l, L);
    };
    (O = Bt(V)) == null || O.addEventListener(l, L);
  });
  _.useEffect(() => {
    if (!n || !a)
      return;
    s.current.__escapeKeyBubbles = S, s.current.__outsidePressBubbles = x;
    let V = -1;
    function O(A) {
      o(!1, A, "ancestor-scroll");
    }
    function L() {
      window.clearTimeout(V), P.current = !0;
    }
    function N() {
      V = window.setTimeout(
        () => {
          P.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        no() ? 5 : 0
      );
    }
    const $ = Pt(r.floating);
    i && ($.addEventListener("keydown", C ? I : M, C), $.addEventListener("compositionstart", L), $.addEventListener("compositionend", N)), b && $.addEventListener(l, R ? z : H, R);
    let k = [];
    return p && (re(r.domReference) && (k = rt(r.domReference)), re(r.floating) && (k = k.concat(rt(r.floating))), !re(r.reference) && r.reference && r.reference.contextElement && (k = k.concat(rt(r.reference.contextElement)))), k = k.filter((A) => {
      var q;
      return A !== ((q = $.defaultView) == null ? void 0 : q.visualViewport);
    }), k.forEach((A) => {
      A.addEventListener("scroll", O, {
        passive: !0
      });
    }), () => {
      i && ($.removeEventListener("keydown", C ? I : M, C), $.removeEventListener("compositionstart", L), $.removeEventListener("compositionend", N)), b && $.removeEventListener(l, R ? z : H, R), k.forEach((A) => {
        A.removeEventListener("scroll", O);
      }), window.clearTimeout(V);
    };
  }, [s, r, i, b, l, n, o, p, a, S, x, M, C, I, H, R, z]), _.useEffect(() => {
    w.current = !1;
  }, [b, l]);
  const j = _.useMemo(() => ({
    onKeyDown: M,
    [cm[d]]: (V) => {
      u && o(!1, V.nativeEvent, "reference-press");
    }
  }), [M, o, u, d]), B = _.useMemo(() => ({
    onKeyDown: M,
    onMouseDown() {
      y.current = !0;
    },
    onMouseUp() {
      y.current = !0;
    },
    [um[l]]: () => {
      w.current = !0;
    }
  }), [M, l]);
  return _.useMemo(() => a ? {
    reference: j,
    floating: B
  } : {}, [a, j, B]);
}
function fm(e) {
  const {
    open: t = !1,
    onOpenChange: n,
    elements: o
  } = e, r = Ji(), s = _.useRef({}), [a] = _.useState(() => tm()), i = Or() != null, [c, l] = _.useState(o.reference), u = ot((f, h, m) => {
    s.current.openEvent = f ? h : void 0, a.emit("openchange", {
      open: f,
      event: h,
      reason: m,
      nested: i
    }), n?.(f, h, m);
  }), d = _.useMemo(() => ({
    setPositionReference: l
  }), []), p = _.useMemo(() => ({
    reference: c || o.reference || null,
    floating: o.floating || null,
    domReference: o.reference
  }), [c, o.reference, o.floating]);
  return _.useMemo(() => ({
    dataRef: s,
    open: t,
    onOpenChange: u,
    elements: p,
    events: a,
    floatingId: r,
    refs: d
  }), [t, u, p, a, r, d]);
}
function Br(e) {
  e === void 0 && (e = {});
  const {
    nodeId: t
  } = e, n = fm({
    ...e,
    elements: {
      reference: null,
      floating: null,
      ...e.elements
    }
  }), o = e.rootContext || n, r = o.elements, [s, a] = _.useState(null), [i, c] = _.useState(null), u = r?.domReference || s, d = _.useRef(null), p = Lr();
  Ze(() => {
    u && (d.current = u);
  }, [u]);
  const f = Kp({
    ...e,
    elements: {
      ...r,
      ...i && {
        reference: i
      }
    }
  }), h = _.useCallback((y) => {
    const S = re(y) ? {
      getBoundingClientRect: () => y.getBoundingClientRect(),
      contextElement: y
    } : y;
    c(S), f.refs.setReference(S);
  }, [f.refs]), m = _.useCallback((y) => {
    (re(y) || y === null) && (d.current = y, a(y)), (re(f.refs.reference.current) || f.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    y !== null && !re(y)) && f.refs.setReference(y);
  }, [f.refs]), g = _.useMemo(() => ({
    ...f.refs,
    setReference: m,
    setPositionReference: h,
    domReference: d
  }), [f.refs, m, h]), b = _.useMemo(() => ({
    ...f.elements,
    domReference: u
  }), [f.elements, u]), w = _.useMemo(() => ({
    ...f,
    ...o,
    refs: g,
    elements: b,
    nodeId: t
  }), [f, g, b, t, o]);
  return Ze(() => {
    o.dataRef.current.floatingContext = w;
    const y = p?.nodesRef.current.find((S) => S.id === t);
    y && (y.context = w);
  }), _.useMemo(() => ({
    ...f,
    context: w,
    refs: g,
    elements: b
  }), [f, g, b, w]);
}
function pm(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: o,
    events: r,
    dataRef: s,
    elements: a
  } = e, {
    enabled: i = !0,
    visibleOnly: c = !0
  } = t, l = _.useRef(!1), u = _.useRef(), d = _.useRef(!0);
  _.useEffect(() => {
    if (!i) return;
    const f = Pe(a.domReference);
    function h() {
      !n && Te(a.domReference) && a.domReference === Qs(Pt(a.domReference)) && (l.current = !0);
    }
    function m() {
      d.current = !0;
    }
    return f.addEventListener("blur", h), f.addEventListener("keydown", m, !0), () => {
      f.removeEventListener("blur", h), f.removeEventListener("keydown", m, !0);
    };
  }, [a.domReference, n, i]), _.useEffect(() => {
    if (!i) return;
    function f(h) {
      let {
        reason: m
      } = h;
      (m === "reference-press" || m === "escape-key") && (l.current = !0);
    }
    return r.on("openchange", f), () => {
      r.off("openchange", f);
    };
  }, [r, i]), _.useEffect(() => () => {
    clearTimeout(u.current);
  }, []);
  const p = _.useMemo(() => ({
    onPointerDown(f) {
      Qf(f.nativeEvent) || (d.current = !1);
    },
    onMouseLeave() {
      l.current = !1;
    },
    onFocus(f) {
      if (l.current) return;
      const h = Bt(f.nativeEvent);
      if (c && re(h))
        try {
          if (ep() && tp()) throw Error();
          if (!h.matches(":focus-visible")) return;
        } catch {
          if (!d.current && !ap(h))
            return;
        }
      o(!0, f.nativeEvent, "focus");
    },
    onBlur(f) {
      l.current = !1;
      const h = f.relatedTarget, m = f.nativeEvent, g = re(h) && h.hasAttribute(zr("focus-guard")) && h.getAttribute("data-type") === "outside";
      u.current = window.setTimeout(() => {
        var b;
        const w = Qs(a.domReference ? a.domReference.ownerDocument : document);
        !h && w === a.domReference || fn((b = s.current.floatingContext) == null ? void 0 : b.refs.floating.current, w) || fn(a.domReference, w) || g || o(!1, m, "focus");
      });
    }
  }), [s, a.domReference, o, c]);
  return _.useMemo(() => i ? {
    reference: p
  } : {}, [i, p]);
}
const da = "active", fa = "selected";
function Yo(e, t, n) {
  const o = /* @__PURE__ */ new Map(), r = n === "item";
  let s = e;
  if (r && e) {
    const {
      [da]: a,
      [fa]: i,
      ...c
    } = e;
    s = c;
  }
  return {
    ...n === "floating" && {
      tabIndex: -1,
      [lm]: ""
    },
    ...s,
    ...t.map((a) => {
      const i = a ? a[n] : null;
      return typeof i == "function" ? e ? i(e) : null : i;
    }).concat(e).reduce((a, i) => (i && Object.entries(i).forEach((c) => {
      let [l, u] = c;
      if (!(r && [da, fa].includes(l)))
        if (l.indexOf("on") === 0) {
          if (o.has(l) || o.set(l, []), typeof u == "function") {
            var d;
            (d = o.get(l)) == null || d.push(u), a[l] = function() {
              for (var p, f = arguments.length, h = new Array(f), m = 0; m < f; m++)
                h[m] = arguments[m];
              return (p = o.get(l)) == null ? void 0 : p.map((g) => g(...h)).find((g) => g !== void 0);
            };
          }
        } else
          a[l] = u;
    }), a), {})
  };
}
function mm(e) {
  e === void 0 && (e = []);
  const t = e.map((i) => i?.reference), n = e.map((i) => i?.floating), o = e.map((i) => i?.item), r = _.useCallback(
    (i) => Yo(i, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), s = _.useCallback(
    (i) => Yo(i, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n
  ), a = _.useCallback(
    (i) => Yo(i, e, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    o
  );
  return _.useMemo(() => ({
    getReferenceProps: r,
    getFloatingProps: s,
    getItemProps: a
  }), [r, s, a]);
}
const hm = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function vm(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    open: o,
    floatingId: r
  } = e, {
    enabled: s = !0,
    role: a = "dialog"
  } = t, i = (n = hm.get(a)) != null ? n : a, c = Ji(), u = Or() != null, d = _.useMemo(() => i === "tooltip" || a === "label" ? {
    ["aria-" + (a === "label" ? "labelledby" : "describedby")]: o ? r : void 0
  } : {
    "aria-expanded": o ? "true" : "false",
    "aria-haspopup": i === "alertdialog" ? "dialog" : i,
    "aria-controls": o ? r : void 0,
    ...i === "listbox" && {
      role: "combobox"
    },
    ...i === "menu" && {
      id: c
    },
    ...i === "menu" && u && {
      role: "menuitem"
    },
    ...a === "select" && {
      "aria-autocomplete": "none"
    },
    ...a === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [i, r, u, o, c, a]), p = _.useMemo(() => {
    const h = {
      id: r,
      ...i && {
        role: i
      }
    };
    return i === "tooltip" || a === "label" ? h : {
      ...h,
      ...i === "menu" && {
        "aria-labelledby": c
      }
    };
  }, [i, r, c, a]), f = _.useCallback((h) => {
    let {
      active: m,
      selected: g
    } = h;
    const b = {
      role: "option",
      ...m && {
        id: r + "-option"
      }
    };
    switch (a) {
      case "select":
        return {
          ...b,
          "aria-selected": m && g
        };
      case "combobox":
        return {
          ...b,
          ...m && {
            "aria-selected": !0
          }
        };
    }
    return {};
  }, [r, a]);
  return _.useMemo(() => s ? {
    reference: d,
    floating: p,
    item: f
  } : {}, [s, d, p, f]);
}
function el(e, t) {
  if (e === "rtl" && (t.includes("right") || t.includes("left"))) {
    const [n, o] = t.split("-"), r = n === "right" ? "left" : "right";
    return o === void 0 ? r : `${r}-${o}`;
  }
  return t;
}
function pa(e, t, n, o) {
  return e === "center" || o === "center" ? { top: t } : e === "end" ? { bottom: n } : e === "start" ? { top: n } : {};
}
function ma(e, t, n, o, r) {
  return e === "center" || o === "center" ? { left: t } : e === "end" ? { [r === "ltr" ? "right" : "left"]: n } : e === "start" ? { [r === "ltr" ? "left" : "right"]: n } : {};
}
const gm = {
  bottom: "borderTopLeftRadius",
  left: "borderTopRightRadius",
  right: "borderBottomLeftRadius",
  top: "borderBottomRightRadius"
};
function ym({
  position: e,
  arrowSize: t,
  arrowOffset: n,
  arrowRadius: o,
  arrowPosition: r,
  arrowX: s,
  arrowY: a,
  dir: i
}) {
  const [c, l = "center"] = e.split("-"), u = {
    width: t,
    height: t,
    transform: "rotate(45deg)",
    position: "absolute",
    [gm[c]]: o
  }, d = -t / 2;
  return c === "left" ? {
    ...u,
    ...pa(l, a, n, r),
    right: d,
    borderLeftColor: "transparent",
    borderBottomColor: "transparent",
    clipPath: "polygon(100% 0, 0 0, 100% 100%)"
  } : c === "right" ? {
    ...u,
    ...pa(l, a, n, r),
    left: d,
    borderRightColor: "transparent",
    borderTopColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 100%)"
  } : c === "top" ? {
    ...u,
    ...ma(l, s, n, r, i),
    bottom: d,
    borderTopColor: "transparent",
    borderLeftColor: "transparent",
    clipPath: "polygon(0 100%, 100% 100%, 100% 0)"
  } : c === "bottom" ? {
    ...u,
    ...ma(l, s, n, r, i),
    top: d,
    borderBottomColor: "transparent",
    borderRightColor: "transparent",
    clipPath: "polygon(0 100%, 0 0, 100% 0)"
  } : {};
}
const Fr = J(
  ({
    position: e,
    arrowSize: t,
    arrowOffset: n,
    arrowRadius: o,
    arrowPosition: r,
    visible: s,
    arrowX: a,
    arrowY: i,
    style: c,
    ...l
  }, u) => {
    const { dir: d } = wt();
    return s ? /* @__PURE__ */ v(
      "div",
      {
        ...l,
        ref: u,
        style: {
          ...c,
          ...ym({
            position: e,
            arrowSize: t,
            arrowOffset: n,
            arrowRadius: o,
            arrowPosition: r,
            dir: d,
            arrowX: a,
            arrowY: i
          })
        }
      }
    ) : null;
  }
);
Fr.displayName = "@mantine/core/FloatingArrow";
var bm = { root: "m_9814e45f" };
const tl = bm, wm = {
  zIndex: je("modal")
}, Sm = (e, { gradient: t, color: n, backgroundOpacity: o, blur: r, radius: s, zIndex: a }) => ({
  root: {
    "--overlay-bg": t || (n !== void 0 || o !== void 0) && Xe(n || "#000", o ?? 0.6) || void 0,
    "--overlay-filter": r ? `blur(${E(r)})` : void 0,
    "--overlay-radius": s === void 0 ? void 0 : ie(s),
    "--overlay-z-index": a?.toString()
  }
}), Gt = he((e, t) => {
  const n = T("Overlay", wm, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    fixed: l,
    center: u,
    children: d,
    radius: p,
    zIndex: f,
    gradient: h,
    blur: m,
    color: g,
    backgroundOpacity: b,
    mod: w,
    ...y
  } = n, S = K({
    name: "Overlay",
    props: n,
    classes: tl,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Sm
  });
  return /* @__PURE__ */ v(D, { ref: t, ...S("root"), mod: [{ center: u, fixed: l }, w], ...y, children: d });
});
Gt.classes = tl;
Gt.displayName = "@mantine/core/Overlay";
function Ko(e) {
  const t = document.createElement("div");
  return t.setAttribute("data-portal", "true"), typeof e.className == "string" && t.classList.add(...e.className.split(" ").filter(Boolean)), typeof e.style == "object" && Object.assign(t.style, e.style), typeof e.id == "string" && t.setAttribute("id", e.id), t;
}
function xm({
  target: e,
  reuseTargetNode: t,
  ...n
}) {
  if (e)
    return typeof e == "string" ? document.querySelector(e) || Ko(n) : e;
  if (t) {
    const o = document.querySelector("[data-mantine-shared-portal-node]");
    if (o)
      return o;
    const r = Ko(n);
    return r.setAttribute("data-mantine-shared-portal-node", "true"), document.body.appendChild(r), r;
  }
  return Ko(n);
}
const Cm = {}, nl = F((e, t) => {
  const { children: n, target: o, reuseTargetNode: r, ...s } = T("Portal", Cm, e), [a, i] = W(!1), c = G(null);
  return hn(() => (i(!0), c.current = xm({ target: o, reuseTargetNode: r, ...s }), tr(t, c.current), !o && !r && c.current && document.body.appendChild(c.current), () => {
    !o && !r && c.current && document.body.removeChild(c.current);
  }), [o]), !a || !c.current ? null : Uc(/* @__PURE__ */ v(Ce, { children: n }), c.current);
});
nl.displayName = "@mantine/core/Portal";
const Zt = F(
  ({ withinPortal: e = !0, children: t, ...n }, o) => di() === "test" || !e ? /* @__PURE__ */ v(Ce, { children: t }) : /* @__PURE__ */ v(nl, { ref: o, ...n, children: t })
);
Zt.displayName = "@mantine/core/OptionalPortal";
const rn = (e) => ({
  in: { opacity: 1, transform: "scale(1)" },
  out: { opacity: 0, transform: `scale(.9) translateY(${e === "bottom" ? 10 : -10}px)` },
  transitionProperty: "transform, opacity"
}), kn = {
  fade: {
    in: { opacity: 1 },
    out: { opacity: 0 },
    transitionProperty: "opacity"
  },
  "fade-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(30px)" },
    transitionProperty: "opacity, transform"
  },
  "fade-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-30px)" },
    transitionProperty: "opacity, transform"
  },
  scale: {
    in: { opacity: 1, transform: "scale(1)" },
    out: { opacity: 0, transform: "scale(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-y": {
    in: { opacity: 1, transform: "scaleY(1)" },
    out: { opacity: 0, transform: "scaleY(0)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "scale-x": {
    in: { opacity: 1, transform: "scaleX(1)" },
    out: { opacity: 0, transform: "scaleX(0)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "skew-up": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(-20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "skew-down": {
    in: { opacity: 1, transform: "translateY(0) skew(0deg, 0deg)" },
    out: { opacity: 0, transform: "translateY(20px) skew(-10deg, -5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-left": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(-5deg)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "rotate-right": {
    in: { opacity: 1, transform: "translateY(0) rotate(0deg)" },
    out: { opacity: 0, transform: "translateY(20px) rotate(5deg)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-down": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(-100%)" },
    common: { transformOrigin: "top" },
    transitionProperty: "transform, opacity"
  },
  "slide-up": {
    in: { opacity: 1, transform: "translateY(0)" },
    out: { opacity: 0, transform: "translateY(100%)" },
    common: { transformOrigin: "bottom" },
    transitionProperty: "transform, opacity"
  },
  "slide-left": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(100%)" },
    common: { transformOrigin: "left" },
    transitionProperty: "transform, opacity"
  },
  "slide-right": {
    in: { opacity: 1, transform: "translateX(0)" },
    out: { opacity: 0, transform: "translateX(-100%)" },
    common: { transformOrigin: "right" },
    transitionProperty: "transform, opacity"
  },
  pop: {
    ...rn("bottom"),
    common: { transformOrigin: "center center" }
  },
  "pop-bottom-left": {
    ...rn("bottom"),
    common: { transformOrigin: "bottom left" }
  },
  "pop-bottom-right": {
    ...rn("bottom"),
    common: { transformOrigin: "bottom right" }
  },
  "pop-top-left": {
    ...rn("top"),
    common: { transformOrigin: "top left" }
  },
  "pop-top-right": {
    ...rn("top"),
    common: { transformOrigin: "top right" }
  }
}, ha = {
  entering: "in",
  entered: "in",
  exiting: "out",
  exited: "out",
  "pre-exiting": "out",
  "pre-entering": "out"
};
function $m({
  transition: e,
  state: t,
  duration: n,
  timingFunction: o
}) {
  const r = {
    transitionDuration: `${n}ms`,
    transitionTimingFunction: o
  };
  return typeof e == "string" ? e in kn ? {
    transitionProperty: kn[e].transitionProperty,
    ...r,
    ...kn[e].common,
    ...kn[e][ha[t]]
  } : {} : {
    transitionProperty: e.transitionProperty,
    ...r,
    ...e.common,
    ...e[ha[t]]
  };
}
function Pm({
  duration: e,
  exitDuration: t,
  timingFunction: n,
  mounted: o,
  onEnter: r,
  onExit: s,
  onEntered: a,
  onExited: i,
  enterDelay: c,
  exitDelay: l
}) {
  const u = ye(), d = ii(), p = u.respectReducedMotion ? d : !1, [f, h] = W(p ? 0 : e), [m, g] = W(o ? "entered" : "exited"), b = G(-1), w = G(-1), y = G(-1), S = (C) => {
    const R = C ? r : s, P = C ? a : i;
    window.clearTimeout(b.current);
    const M = p ? 0 : C ? e : t;
    h(M), M === 0 ? (typeof R == "function" && R(), typeof P == "function" && P(), g(C ? "entered" : "exited")) : y.current = requestAnimationFrame(() => {
      Xc.flushSync(() => {
        g(C ? "pre-entering" : "pre-exiting");
      }), y.current = requestAnimationFrame(() => {
        typeof R == "function" && R(), g(C ? "entering" : "exiting"), b.current = window.setTimeout(() => {
          typeof P == "function" && P(), g(C ? "entered" : "exited");
        }, M);
      });
    });
  }, x = (C) => {
    if (window.clearTimeout(w.current), typeof (C ? c : l) != "number") {
      S(C);
      return;
    }
    w.current = window.setTimeout(
      () => {
        S(C);
      },
      C ? c : l
    );
  };
  return ht(() => {
    x(o);
  }, [o]), U(
    () => () => {
      window.clearTimeout(b.current), cancelAnimationFrame(y.current);
    },
    []
  ), {
    transitionDuration: f,
    transitionStatus: m,
    transitionTimingFunction: n || "ease"
  };
}
function et({
  keepMounted: e,
  transition: t = "fade",
  duration: n = 250,
  exitDuration: o = n,
  mounted: r,
  children: s,
  timingFunction: a = "ease",
  onExit: i,
  onEntered: c,
  onEnter: l,
  onExited: u,
  enterDelay: d,
  exitDelay: p
}) {
  const f = di(), { transitionDuration: h, transitionStatus: m, transitionTimingFunction: g } = Pm({
    mounted: r,
    exitDuration: o,
    duration: n,
    timingFunction: a,
    onExit: i,
    onEntered: c,
    onEnter: l,
    onExited: u,
    enterDelay: d,
    exitDelay: p
  });
  return h === 0 || f === "test" ? r ? /* @__PURE__ */ v(Ce, { children: s({}) }) : e ? s({ display: "none" }) : null : m === "exited" ? e ? s({ display: "none" }) : null : /* @__PURE__ */ v(Ce, { children: s(
    $m({
      transition: t,
      duration: h,
      state: m,
      timingFunction: g
    })
  ) });
}
et.displayName = "@mantine/core/Transition";
const [_m, ol] = Ee(
  "Popover component was not found in the tree"
);
function ro({
  children: e,
  active: t = !0,
  refProp: n = "ref",
  innerRef: o
}) {
  const r = ed(t), s = ue(r, o);
  return ut(e) ? ct(e, { [n]: s }) : e;
}
function rl(e) {
  return /* @__PURE__ */ v(_r, { tabIndex: -1, "data-autofocus": !0, ...e });
}
ro.displayName = "@mantine/core/FocusTrap";
rl.displayName = "@mantine/core/FocusTrapInitialFocus";
ro.InitialFocus = rl;
var Rm = { dropdown: "m_38a85659", arrow: "m_a31dc6c1", overlay: "m_3d7bc908" };
const sl = Rm, Nm = {}, Hr = F((e, t) => {
  const n = T("PopoverDropdown", Nm, e), {
    className: o,
    style: r,
    vars: s,
    children: a,
    onKeyDownCapture: i,
    variant: c,
    classNames: l,
    styles: u,
    ...d
  } = n, p = ol(), f = ni({
    opened: p.opened,
    shouldReturnFocus: p.returnFocus
  }), h = p.withRoles ? {
    "aria-labelledby": p.getTargetId(),
    id: p.getDropdownId(),
    role: "dialog",
    tabIndex: -1
  } : {}, m = ue(t, p.floating);
  return p.disabled ? null : /* @__PURE__ */ v(Zt, { ...p.portalProps, withinPortal: p.withinPortal, children: /* @__PURE__ */ v(
    et,
    {
      mounted: p.opened,
      ...p.transitionProps,
      transition: p.transitionProps?.transition || "fade",
      duration: p.transitionProps?.duration ?? 150,
      keepMounted: p.keepMounted,
      exitDuration: typeof p.transitionProps?.exitDuration == "number" ? p.transitionProps.exitDuration : p.transitionProps?.duration,
      children: (g) => /* @__PURE__ */ v(ro, { active: p.trapFocus && p.opened, innerRef: m, children: /* @__PURE__ */ Z(
        D,
        {
          ...h,
          ...d,
          variant: c,
          onKeyDownCapture: Bu(
            () => {
              p.onClose?.(), p.onDismiss?.();
            },
            {
              active: p.closeOnEscape,
              onTrigger: f,
              onKeyDown: i
            }
          ),
          "data-position": p.placement,
          "data-fixed": p.floatingStrategy === "fixed" || void 0,
          ...p.getStyles("dropdown", {
            className: o,
            props: n,
            classNames: l,
            styles: u,
            style: [
              {
                ...g,
                zIndex: p.zIndex,
                top: p.y ?? 0,
                left: p.x ?? 0,
                width: p.width === "target" ? void 0 : E(p.width)
              },
              p.resolvedStyles.dropdown,
              u?.dropdown,
              r
            ]
          }),
          children: [
            a,
            /* @__PURE__ */ v(
              Fr,
              {
                ref: p.arrowRef,
                arrowX: p.arrowX,
                arrowY: p.arrowY,
                visible: p.withArrow,
                position: p.placement,
                arrowSize: p.arrowSize,
                arrowRadius: p.arrowRadius,
                arrowOffset: p.arrowOffset,
                arrowPosition: p.arrowPosition,
                ...p.getStyles("arrow", {
                  props: n,
                  classNames: l,
                  styles: u
                })
              }
            )
          ]
        }
      ) })
    }
  ) });
});
Hr.classes = sl;
Hr.displayName = "@mantine/core/PopoverDropdown";
const Tm = {
  refProp: "ref",
  popupType: "dialog"
}, al = F((e, t) => {
  const { children: n, refProp: o, popupType: r, ...s } = T(
    "PopoverTarget",
    Tm,
    e
  );
  if (!ut(n))
    throw new Error(
      "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const a = s, i = ol(), c = ue(i.reference, Yn(n), t), l = i.withRoles ? {
    "aria-haspopup": r,
    "aria-expanded": i.opened,
    "aria-controls": i.getDropdownId(),
    id: i.getTargetId()
  } : {};
  return ct(n, {
    ...a,
    ...l,
    ...i.targetProps,
    className: ve(
      i.targetProps.className,
      a.className,
      n.props.className
    ),
    [o]: c,
    ...i.controlled ? null : { onClick: i.onToggle }
  });
});
al.displayName = "@mantine/core/PopoverTarget";
function il({
  opened: e,
  floating: t,
  position: n,
  positionDependencies: o
}) {
  const [r, s] = W(0);
  U(() => {
    if (t.refs.reference.current && t.refs.floating.current && e)
      return Bp(
        t.refs.reference.current,
        t.refs.floating.current,
        t.update
      );
  }, [
    t.refs.reference.current,
    t.refs.floating.current,
    e,
    r,
    n
  ]), ht(() => {
    t.update();
  }, o), ht(() => {
    s((a) => a + 1);
  }, [e]);
}
function Em(e) {
  if (e === void 0)
    return { shift: !0, flip: !0 };
  const t = { ...e };
  return e.shift === void 0 && (t.shift = !0), e.flip === void 0 && (t.flip = !0), t;
}
function km(e, t) {
  const n = Em(e.middlewares), o = [Ui(e.offset)];
  return n.shift && o.push(
    Ir(
      typeof n.shift == "boolean" ? { limiter: aa(), padding: 5 } : { limiter: aa(), padding: 5, ...n.shift }
    )
  ), n.flip && o.push(
    typeof n.flip == "boolean" ? Hn() : Hn(n.flip)
  ), n.inline && o.push(
    typeof n.inline == "boolean" ? ln() : ln(n.inline)
  ), o.push(qi({ element: e.arrowRef, padding: e.arrowOffset })), (n.size || e.width === "target") && o.push(
    Up({
      ...typeof n.size == "boolean" ? {} : n.size,
      apply({ rects: r, availableWidth: s, availableHeight: a, ...i }) {
        const l = t().refs.floating.current?.style ?? {};
        n.size && (typeof n.size == "object" && n.size.apply ? n.size.apply({ rects: r, availableWidth: s, availableHeight: a, ...i }) : Object.assign(l, {
          maxWidth: `${s}px`,
          maxHeight: `${a}px`
        })), e.width === "target" && Object.assign(l, {
          width: `${r.reference.width}px`
        });
      }
    })
  ), o;
}
function Mm(e) {
  const [t, n] = st({
    value: e.opened,
    defaultValue: e.defaultOpened,
    finalValue: !1,
    onChange: e.onChange
  }), o = G(t), r = () => {
    t && n(!1);
  }, s = () => n(!t), a = Br({
    strategy: e.strategy,
    placement: e.position,
    middleware: km(e, () => a)
  });
  return il({
    opened: t,
    position: e.position,
    positionDependencies: e.positionDependencies || [],
    floating: a
  }), ht(() => {
    e.onPositionChange?.(a.placement);
  }, [a.placement]), ht(() => {
    t !== o.current && (t ? e.onOpen?.() : e.onClose?.()), o.current = t;
  }, [t, e.onClose, e.onOpen]), {
    floating: a,
    controlled: typeof e.opened == "boolean",
    opened: t,
    onClose: r,
    onToggle: s
  };
}
const Am = {
  position: "bottom",
  offset: 8,
  positionDependencies: [],
  transitionProps: { transition: "fade", duration: 150 },
  middlewares: { flip: !0, shift: !0, inline: !1 },
  arrowSize: 7,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  closeOnClickOutside: !0,
  withinPortal: !0,
  closeOnEscape: !0,
  trapFocus: !1,
  withRoles: !0,
  returnFocus: !1,
  withOverlay: !1,
  clickOutsideEvents: ["mousedown", "touchstart"],
  zIndex: je("popover"),
  __staticSelector: "Popover",
  width: "max-content"
}, Dm = (e, { radius: t, shadow: n }) => ({
  dropdown: {
    "--popover-radius": t === void 0 ? void 0 : ie(t),
    "--popover-shadow": hr(n)
  }
});
function Ne(e) {
  const t = T("Popover", Am, e), {
    children: n,
    position: o,
    offset: r,
    onPositionChange: s,
    positionDependencies: a,
    opened: i,
    transitionProps: c,
    onExitTransitionEnd: l,
    onEnterTransitionEnd: u,
    width: d,
    middlewares: p,
    withArrow: f,
    arrowSize: h,
    arrowOffset: m,
    arrowRadius: g,
    arrowPosition: b,
    unstyled: w,
    classNames: y,
    styles: S,
    closeOnClickOutside: x,
    withinPortal: C,
    portalProps: R,
    closeOnEscape: P,
    clickOutsideEvents: M,
    trapFocus: I,
    onClose: H,
    onDismiss: z,
    onOpen: j,
    onChange: B,
    zIndex: V,
    radius: O,
    shadow: L,
    id: N,
    defaultOpened: $,
    __staticSelector: k,
    withRoles: A,
    disabled: q,
    returnFocus: ee,
    variant: se,
    keepMounted: ne,
    vars: X,
    floatingStrategy: te,
    withOverlay: ge,
    overlayProps: le,
    ...de
  } = t, ke = K({
    name: k,
    props: t,
    classes: sl,
    classNames: y,
    styles: S,
    unstyled: w,
    rootSelector: "dropdown",
    vars: X,
    varsResolver: Dm
  }), { resolvedStyles: nt } = qn({ classNames: y, styles: S, props: t }), Ge = G(null), [fe, ae] = W(null), [pe, pt] = W(null), { dir: Ct } = wt(), Ye = Je(N), me = Mm({
    middlewares: p,
    width: d,
    position: el(Ct, o),
    offset: typeof r == "number" ? r + (f ? h / 2 : 0) : r,
    arrowRef: Ge,
    arrowOffset: m,
    onPositionChange: s,
    positionDependencies: a,
    opened: i,
    defaultOpened: $,
    onChange: B,
    onOpen: j,
    onClose: H,
    onDismiss: z,
    strategy: te
  });
  Qa(
    () => {
      x && (me.onClose(), z?.());
    },
    M,
    [fe, pe]
  );
  const Me = Y(
    (Ke) => {
      ae(Ke), me.floating.refs.setReference(Ke);
    },
    [me.floating.refs.setReference]
  ), $n = Y(
    (Ke) => {
      pt(Ke), me.floating.refs.setFloating(Ke);
    },
    [me.floating.refs.setFloating]
  ), Ro = Y(() => {
    c?.onExited?.(), l?.();
  }, [c?.onExited, l]), ze = Y(() => {
    c?.onEntered?.(), u?.();
  }, [c?.onEntered, u]);
  return /* @__PURE__ */ Z(
    _m,
    {
      value: {
        returnFocus: ee,
        disabled: q,
        controlled: me.controlled,
        reference: Me,
        floating: $n,
        x: me.floating.x,
        y: me.floating.y,
        arrowX: me.floating?.middlewareData?.arrow?.x,
        arrowY: me.floating?.middlewareData?.arrow?.y,
        opened: me.opened,
        arrowRef: Ge,
        transitionProps: { ...c, onExited: Ro, onEntered: ze },
        width: d,
        withArrow: f,
        arrowSize: h,
        arrowOffset: m,
        arrowRadius: g,
        arrowPosition: b,
        placement: me.floating.placement,
        trapFocus: I,
        withinPortal: C,
        portalProps: R,
        zIndex: V,
        radius: O,
        shadow: L,
        closeOnEscape: P,
        onDismiss: z,
        onClose: me.onClose,
        onToggle: me.onToggle,
        getTargetId: () => `${Ye}-target`,
        getDropdownId: () => `${Ye}-dropdown`,
        withRoles: A,
        targetProps: de,
        __staticSelector: k,
        classNames: y,
        styles: S,
        unstyled: w,
        variant: se,
        keepMounted: ne,
        getStyles: ke,
        resolvedStyles: nt,
        floatingStrategy: te
      },
      children: [
        n,
        ge && /* @__PURE__ */ v(
          et,
          {
            transition: "fade",
            mounted: me.opened,
            duration: c?.duration || 250,
            exitDuration: c?.exitDuration || 250,
            children: (Ke) => /* @__PURE__ */ v(Zt, { withinPortal: C, children: /* @__PURE__ */ v(
              Gt,
              {
                ...le,
                ...ke("overlay", {
                  className: le?.className,
                  style: [Ke, le?.style]
                })
              }
            ) })
          }
        )
      ]
    }
  );
}
Ne.Target = al;
Ne.Dropdown = Hr;
Ne.displayName = "@mantine/core/Popover";
Ne.extend = (e) => e;
var Im = { root: "m_5ae2e3c", barsLoader: "m_7a2bd4cd", bar: "m_870bb79", "bars-loader-animation": "m_5d2b3b9d", dotsLoader: "m_4e3f22d7", dot: "m_870c4af", "loader-dots-animation": "m_aac34a1", ovalLoader: "m_b34414df", "oval-loader-animation": "m_f8e89c4b" };
const He = Im, ll = J(({ className: e, ...t }, n) => /* @__PURE__ */ Z(D, { component: "span", className: ve(He.barsLoader, e), ...t, ref: n, children: [
  /* @__PURE__ */ v("span", { className: He.bar }),
  /* @__PURE__ */ v("span", { className: He.bar }),
  /* @__PURE__ */ v("span", { className: He.bar })
] }));
ll.displayName = "@mantine/core/Bars";
const cl = J(({ className: e, ...t }, n) => /* @__PURE__ */ Z(D, { component: "span", className: ve(He.dotsLoader, e), ...t, ref: n, children: [
  /* @__PURE__ */ v("span", { className: He.dot }),
  /* @__PURE__ */ v("span", { className: He.dot }),
  /* @__PURE__ */ v("span", { className: He.dot })
] }));
cl.displayName = "@mantine/core/Dots";
const ul = J(({ className: e, ...t }, n) => /* @__PURE__ */ v(D, { component: "span", className: ve(He.ovalLoader, e), ...t, ref: n }));
ul.displayName = "@mantine/core/Oval";
const dl = {
  bars: ll,
  oval: ul,
  dots: cl
}, Om = {
  loaders: dl,
  type: "oval"
}, Lm = (e, { size: t, color: n }) => ({
  root: {
    "--loader-size": Q(t, "loader-size"),
    "--loader-color": n ? xe(n, e) : void 0
  }
}), kt = F((e, t) => {
  const n = T("Loader", Om, e), {
    size: o,
    color: r,
    type: s,
    vars: a,
    className: i,
    style: c,
    classNames: l,
    styles: u,
    unstyled: d,
    loaders: p,
    variant: f,
    children: h,
    ...m
  } = n, g = K({
    name: "Loader",
    props: n,
    classes: He,
    className: i,
    style: c,
    classNames: l,
    styles: u,
    unstyled: d,
    vars: a,
    varsResolver: Lm
  });
  return h ? /* @__PURE__ */ v(D, { ...g("root"), ref: t, ...m, children: h }) : /* @__PURE__ */ v(
    D,
    {
      ...g("root"),
      ref: t,
      component: p[s],
      variant: f,
      size: o,
      ...m
    }
  );
});
kt.defaultLoaders = dl;
kt.classes = He;
kt.displayName = "@mantine/core/Loader";
var zm = { root: "m_8d3f4000", icon: "m_8d3afb97", loader: "m_302b9fb1", group: "m_1a0f1b21", groupSection: "m_437b6484" };
const Jt = zm, va = {
  orientation: "horizontal"
}, Bm = (e, { borderWidth: t }) => ({
  group: { "--ai-border-width": E(t) }
}), Vr = F((e, t) => {
  const n = T("ActionIconGroup", va, e), {
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    orientation: c,
    vars: l,
    borderWidth: u,
    variant: d,
    mod: p,
    ...f
  } = T("ActionIconGroup", va, e), h = K({
    name: "ActionIconGroup",
    props: n,
    classes: Jt,
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    vars: l,
    varsResolver: Bm,
    rootSelector: "group"
  });
  return /* @__PURE__ */ v(
    D,
    {
      ...h("group"),
      ref: t,
      variant: d,
      mod: [{ "data-orientation": c }, p],
      role: "group",
      ...f
    }
  );
});
Vr.classes = Jt;
Vr.displayName = "@mantine/core/ActionIconGroup";
const ga = {}, Fm = (e, { radius: t, color: n, gradient: o, variant: r, autoContrast: s, size: a }) => {
  const i = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: o,
    variant: r || "filled",
    autoContrast: s
  });
  return {
    groupSection: {
      "--section-height": Q(a, "section-height"),
      "--section-padding-x": Q(a, "section-padding-x"),
      "--section-fz": Se(a),
      "--section-radius": t === void 0 ? void 0 : ie(t),
      "--section-bg": n || r ? i.background : void 0,
      "--section-color": i.color,
      "--section-bd": n || r ? i.border : void 0
    }
  };
}, Wr = F((e, t) => {
  const n = T("ActionIconGroupSection", ga, e), {
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    vars: c,
    variant: l,
    gradient: u,
    radius: d,
    autoContrast: p,
    ...f
  } = T("ActionIconGroupSection", ga, e), h = K({
    name: "ActionIconGroupSection",
    props: n,
    classes: Jt,
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Fm,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ v(D, { ...h("groupSection"), ref: t, variant: l, ...f });
});
Wr.classes = Jt;
Wr.displayName = "@mantine/core/ActionIconGroupSection";
const Hm = {}, Vm = (e, { size: t, radius: n, variant: o, gradient: r, color: s, autoContrast: a }) => {
  const i = e.variantColorResolver({
    color: s || e.primaryColor,
    theme: e,
    gradient: r,
    variant: o || "filled",
    autoContrast: a
  });
  return {
    root: {
      "--ai-size": Q(t, "ai-size"),
      "--ai-radius": n === void 0 ? void 0 : ie(n),
      "--ai-bg": s || o ? i.background : void 0,
      "--ai-hover": s || o ? i.hover : void 0,
      "--ai-hover-color": s || o ? i.hoverColor : void 0,
      "--ai-color": i.color,
      "--ai-bd": s || o ? i.border : void 0
    }
  };
}, so = he((e, t) => {
  const n = T("ActionIcon", Hm, e), {
    className: o,
    unstyled: r,
    variant: s,
    classNames: a,
    styles: i,
    style: c,
    loading: l,
    loaderProps: u,
    size: d,
    color: p,
    radius: f,
    __staticSelector: h,
    gradient: m,
    vars: g,
    children: b,
    disabled: w,
    "data-disabled": y,
    autoContrast: S,
    mod: x,
    ...C
  } = n, R = K({
    name: ["ActionIcon", h],
    props: n,
    className: o,
    style: c,
    classes: Jt,
    classNames: a,
    styles: i,
    unstyled: r,
    vars: g,
    varsResolver: Vm
  });
  return /* @__PURE__ */ Z(
    St,
    {
      ...R("root", { active: !w && !l && !y }),
      ...C,
      unstyled: r,
      variant: s,
      size: d,
      disabled: w || l,
      ref: t,
      mod: [{ loading: l, disabled: w || y }, x],
      children: [
        /* @__PURE__ */ v(et, { mounted: !!l, transition: "slide-down", duration: 150, children: (P) => /* @__PURE__ */ v(D, { component: "span", ...R("loader", { style: P }), "aria-hidden": !0, children: /* @__PURE__ */ v(kt, { color: "var(--ai-color)", size: "calc(var(--ai-size) * 0.55)", ...u }) }) }),
        /* @__PURE__ */ v(D, { component: "span", mod: { loading: l }, ...R("icon"), children: b })
      ]
    }
  );
});
so.classes = Jt;
so.displayName = "@mantine/core/ActionIcon";
so.Group = Vr;
so.GroupSection = Wr;
const fl = J(
  ({ size: e = "var(--cb-icon-size, 70%)", style: t, ...n }, o) => /* @__PURE__ */ v(
    "svg",
    {
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: { ...t, width: e, height: e },
      ref: o,
      ...n,
      children: /* @__PURE__ */ v(
        "path",
        {
          d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  )
);
fl.displayName = "@mantine/core/CloseIcon";
var Wm = { root: "m_86a44da5", "root--subtle": "m_220c80f2" };
const pl = Wm, jm = {
  variant: "subtle"
}, Gm = (e, { size: t, radius: n, iconSize: o }) => ({
  root: {
    "--cb-size": Q(t, "cb-size"),
    "--cb-radius": n === void 0 ? void 0 : ie(n),
    "--cb-icon-size": E(o)
  }
}), Mt = he((e, t) => {
  const n = T("CloseButton", jm, e), {
    iconSize: o,
    children: r,
    vars: s,
    radius: a,
    className: i,
    classNames: c,
    style: l,
    styles: u,
    unstyled: d,
    "data-disabled": p,
    disabled: f,
    variant: h,
    icon: m,
    mod: g,
    __staticSelector: b,
    ...w
  } = n, y = K({
    name: b || "CloseButton",
    props: n,
    className: i,
    style: l,
    classes: pl,
    classNames: c,
    styles: u,
    unstyled: d,
    vars: s,
    varsResolver: Gm
  });
  return /* @__PURE__ */ Z(
    St,
    {
      ref: t,
      ...w,
      unstyled: d,
      variant: h,
      disabled: f,
      mod: [{ disabled: f || p }, g],
      ...y("root", { variant: h, active: !f && !p }),
      children: [
        m || /* @__PURE__ */ v(fl, {}),
        r
      ]
    }
  );
});
Mt.classes = pl;
Mt.displayName = "@mantine/core/CloseButton";
function Ym(e) {
  return Fa.toArray(e).filter(Boolean);
}
var Km = { root: "m_4081bf90" };
const ml = Km, Xm = {
  preventGrowOverflow: !0,
  gap: "md",
  align: "center",
  justify: "flex-start",
  wrap: "wrap"
}, Um = (e, { grow: t, preventGrowOverflow: n, gap: o, align: r, justify: s, wrap: a }, { childWidth: i }) => ({
  root: {
    "--group-child-width": t && n ? i : void 0,
    "--group-gap": we(o),
    "--group-align": r,
    "--group-justify": s,
    "--group-wrap": a
  }
}), hl = F((e, t) => {
  const n = T("Group", Xm, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    children: c,
    gap: l,
    align: u,
    justify: d,
    wrap: p,
    grow: f,
    preventGrowOverflow: h,
    vars: m,
    variant: g,
    __size: b,
    mod: w,
    ...y
  } = n, S = Ym(c), x = S.length, C = we(l ?? "md"), P = { childWidth: `calc(${100 / x}% - (${C} - ${C} / ${x}))` }, M = K({
    name: "Group",
    props: n,
    stylesCtx: P,
    className: r,
    style: s,
    classes: ml,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: m,
    varsResolver: Um
  });
  return /* @__PURE__ */ v(
    D,
    {
      ...M("root"),
      ref: t,
      variant: g,
      mod: [{ grow: f }, w],
      size: b,
      ...y,
      children: S
    }
  );
});
hl.classes = ml;
hl.displayName = "@mantine/core/Group";
const [qm, dt] = Ee(
  "ModalBase component was not found in tree"
);
function Zm({ opened: e, transitionDuration: t }) {
  const [n, o] = W(e), r = G(-1), a = ii() ? 0 : t;
  return U(() => (e ? (o(!0), window.clearTimeout(r.current)) : a === 0 ? o(!1) : r.current = window.setTimeout(() => o(!1), a), () => window.clearTimeout(r.current)), [e, a]), n;
}
function Jm({
  id: e,
  transitionProps: t,
  opened: n,
  trapFocus: o,
  closeOnEscape: r,
  onClose: s,
  returnFocus: a
}) {
  const i = Je(e), [c, l] = W(!1), [u, d] = W(!1), p = typeof t?.duration == "number" ? t?.duration : 200, f = Zm({ opened: n, transitionDuration: p });
  return un(
    "keydown",
    (h) => {
      h.key === "Escape" && r && n && h.target?.getAttribute("data-mantine-stop-propagation") !== "true" && s();
    },
    { capture: !0 }
  ), ni({ opened: n, shouldReturnFocus: o && a }), {
    _id: i,
    titleMounted: c,
    bodyMounted: u,
    shouldLockScroll: f,
    setTitleMounted: l,
    setBodyMounted: d
  };
}
const jr = J(
  ({
    keepMounted: e,
    opened: t,
    onClose: n,
    id: o,
    transitionProps: r,
    onExitTransitionEnd: s,
    onEnterTransitionEnd: a,
    trapFocus: i,
    closeOnEscape: c,
    returnFocus: l,
    closeOnClickOutside: u,
    withinPortal: d,
    portalProps: p,
    lockScroll: f,
    children: h,
    zIndex: m,
    shadow: g,
    padding: b,
    __vars: w,
    unstyled: y,
    removeScrollProps: S,
    ...x
  }, C) => {
    const { _id: R, titleMounted: P, bodyMounted: M, shouldLockScroll: I, setTitleMounted: H, setBodyMounted: z } = Jm({ id: o, transitionProps: r, opened: t, trapFocus: i, closeOnEscape: c, onClose: n, returnFocus: l }), { key: j, ...B } = S || {};
    return /* @__PURE__ */ v(Zt, { ...p, withinPortal: d, children: /* @__PURE__ */ v(
      qm,
      {
        value: {
          opened: t,
          onClose: n,
          closeOnClickOutside: u,
          onExitTransitionEnd: s,
          onEnterTransitionEnd: a,
          transitionProps: { ...r, keepMounted: e },
          getTitleId: () => `${R}-title`,
          getBodyId: () => `${R}-body`,
          titleMounted: P,
          bodyMounted: M,
          setTitleMounted: H,
          setBodyMounted: z,
          trapFocus: i,
          closeOnEscape: c,
          zIndex: m,
          unstyled: y
        },
        children: /* @__PURE__ */ v(
          Mu,
          {
            enabled: I && f,
            ...B,
            children: /* @__PURE__ */ v(
              D,
              {
                ref: C,
                ...x,
                __vars: {
                  ...w,
                  "--mb-z-index": (m || je("modal")).toString(),
                  "--mb-shadow": hr(g),
                  "--mb-padding": we(b)
                },
                children: h
              }
            )
          },
          j
        )
      }
    ) });
  }
);
jr.displayName = "@mantine/core/ModalBase";
function Qm() {
  const e = dt();
  return U(() => (e.setBodyMounted(!0), () => e.setBodyMounted(!1)), []), e.getBodyId();
}
var eh = { title: "m_615af6c9", header: "m_b5489c3c", inner: "m_60c222c7", content: "m_fd1ab0aa", close: "m_606cb269", body: "m_5df29311" };
const Yt = eh, Gr = J(
  ({ className: e, ...t }, n) => {
    const o = Qm(), r = dt();
    return /* @__PURE__ */ v(
      D,
      {
        ref: n,
        ...t,
        id: o,
        className: ve({ [Yt.body]: !r.unstyled }, e)
      }
    );
  }
);
Gr.displayName = "@mantine/core/ModalBaseBody";
const vl = J(
  ({ className: e, onClick: t, ...n }, o) => {
    const r = dt();
    return /* @__PURE__ */ v(
      Mt,
      {
        ref: o,
        ...n,
        onClick: (s) => {
          r.onClose(), t?.(s);
        },
        className: ve({ [Yt.close]: !r.unstyled }, e),
        unstyled: r.unstyled
      }
    );
  }
);
vl.displayName = "@mantine/core/ModalBaseCloseButton";
const Yr = J(
  ({ transitionProps: e, className: t, innerProps: n, onKeyDown: o, style: r, ...s }, a) => {
    const i = dt();
    return /* @__PURE__ */ v(
      et,
      {
        mounted: i.opened,
        transition: "pop",
        ...i.transitionProps,
        onExited: () => {
          i.onExitTransitionEnd?.(), i.transitionProps?.onExited?.();
        },
        onEntered: () => {
          i.onEnterTransitionEnd?.(), i.transitionProps?.onEntered?.();
        },
        ...e,
        children: (c) => /* @__PURE__ */ v(
          "div",
          {
            ...n,
            className: ve({ [Yt.inner]: !i.unstyled }, n.className),
            children: /* @__PURE__ */ v(ro, { active: i.opened && i.trapFocus, innerRef: a, children: /* @__PURE__ */ v(
              Qn,
              {
                ...s,
                component: "section",
                role: "dialog",
                tabIndex: -1,
                "aria-modal": !0,
                "aria-describedby": i.bodyMounted ? i.getBodyId() : void 0,
                "aria-labelledby": i.titleMounted ? i.getTitleId() : void 0,
                style: [r, c],
                className: ve({ [Yt.content]: !i.unstyled }, t),
                unstyled: i.unstyled,
                children: s.children
              }
            ) })
          }
        )
      }
    );
  }
);
Yr.displayName = "@mantine/core/ModalBaseContent";
const gl = J(
  ({ className: e, ...t }, n) => {
    const o = dt();
    return /* @__PURE__ */ v(
      D,
      {
        component: "header",
        ref: n,
        className: ve({ [Yt.header]: !o.unstyled }, e),
        ...t
      }
    );
  }
);
gl.displayName = "@mantine/core/ModalBaseHeader";
const th = {
  duration: 200,
  timingFunction: "ease",
  transition: "fade"
};
function nh(e) {
  const t = dt();
  return { ...th, ...t.transitionProps, ...e };
}
const Kr = J(
  ({ onClick: e, transitionProps: t, style: n, visible: o, ...r }, s) => {
    const a = dt(), i = nh(t);
    return /* @__PURE__ */ v(
      et,
      {
        mounted: o !== void 0 ? o : a.opened,
        ...i,
        transition: "fade",
        children: (c) => /* @__PURE__ */ v(
          Gt,
          {
            ref: s,
            fixed: !0,
            style: [n, c],
            zIndex: a.zIndex,
            unstyled: a.unstyled,
            onClick: (l) => {
              e?.(l), a.closeOnClickOutside && a.onClose();
            },
            ...r
          }
        )
      }
    );
  }
);
Kr.displayName = "@mantine/core/ModalBaseOverlay";
function oh() {
  const e = dt();
  return U(() => (e.setTitleMounted(!0), () => e.setTitleMounted(!1)), []), e.getTitleId();
}
const yl = J(
  ({ className: e, ...t }, n) => {
    const o = oh(), r = dt();
    return /* @__PURE__ */ v(
      D,
      {
        component: "h2",
        ref: n,
        className: ve({ [Yt.title]: !r.unstyled }, e),
        ...t,
        id: o
      }
    );
  }
);
yl.displayName = "@mantine/core/ModalBaseTitle";
function bl({ children: e }) {
  return /* @__PURE__ */ v(Ce, { children: e });
}
const [rh, sh] = mn({
  size: "sm"
}), ah = {}, wl = F((e, t) => {
  const n = T("InputClearButton", ah, e), { size: o, variant: r, vars: s, classNames: a, styles: i, ...c } = n, l = sh(), { resolvedClassNames: u, resolvedStyles: d } = qn({
    classNames: a,
    styles: i,
    props: n
  });
  return /* @__PURE__ */ v(
    Mt,
    {
      variant: r || "transparent",
      ref: t,
      size: o || l?.size || "sm",
      classNames: u,
      styles: d,
      __staticSelector: "InputClearButton",
      ...c
    }
  );
});
wl.displayName = "@mantine/core/InputClearButton";
const [ih, ao] = mn({
  offsetBottom: !1,
  offsetTop: !1,
  describedBy: void 0,
  getStyles: null,
  inputId: void 0,
  labelId: void 0
});
var lh = { wrapper: "m_6c018570", input: "m_8fb7ebe7", section: "m_82577fc2", placeholder: "m_88bacfd0", root: "m_46b77525", label: "m_8fdc1311", required: "m_78a94662", error: "m_8f816625", description: "m_fe47ce59" };
const Oe = lh, ya = {}, ch = (e, { size: t }) => ({
  description: {
    "--input-description-size": t === void 0 ? void 0 : `calc(${Se(t)} - ${E(2)})`
  }
}), io = F((e, t) => {
  const n = T("InputDescription", ya, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    size: l,
    __staticSelector: u,
    __inheritStyles: d = !0,
    variant: p,
    ...f
  } = T("InputDescription", ya, n), h = ao(), m = K({
    name: ["InputWrapper", u],
    props: n,
    classes: Oe,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    rootSelector: "description",
    vars: c,
    varsResolver: ch
  }), g = d && h?.getStyles || m;
  return /* @__PURE__ */ v(
    D,
    {
      component: "p",
      ref: t,
      variant: p,
      size: l,
      ...g("description", h?.getStyles ? { className: r, style: s } : void 0),
      ...f
    }
  );
});
io.classes = Oe;
io.displayName = "@mantine/core/InputDescription";
const uh = {}, dh = (e, { size: t }) => ({
  error: {
    "--input-error-size": t === void 0 ? void 0 : `calc(${Se(t)} - ${E(2)})`
  }
}), lo = F((e, t) => {
  const n = T("InputError", uh, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    size: l,
    __staticSelector: u,
    __inheritStyles: d = !0,
    variant: p,
    ...f
  } = n, h = K({
    name: ["InputWrapper", u],
    props: n,
    classes: Oe,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    rootSelector: "error",
    vars: c,
    varsResolver: dh
  }), m = ao(), g = d && m?.getStyles || h;
  return /* @__PURE__ */ v(
    D,
    {
      component: "p",
      ref: t,
      variant: p,
      size: l,
      ...g("error", m?.getStyles ? { className: r, style: s } : void 0),
      ...f
    }
  );
});
lo.classes = Oe;
lo.displayName = "@mantine/core/InputError";
const ba = {
  labelElement: "label"
}, fh = (e, { size: t }) => ({
  label: {
    "--input-label-size": Se(t),
    "--input-asterisk-color": void 0
  }
}), co = F((e, t) => {
  const n = T("InputLabel", ba, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    labelElement: l,
    size: u,
    required: d,
    htmlFor: p,
    onMouseDown: f,
    children: h,
    __staticSelector: m,
    variant: g,
    mod: b,
    ...w
  } = T("InputLabel", ba, n), y = K({
    name: ["InputWrapper", m],
    props: n,
    classes: Oe,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    rootSelector: "label",
    vars: c,
    varsResolver: fh
  }), S = ao(), x = S?.getStyles || y;
  return /* @__PURE__ */ Z(
    D,
    {
      ...x("label", S?.getStyles ? { className: r, style: s } : void 0),
      component: l,
      variant: g,
      size: u,
      ref: t,
      htmlFor: l === "label" ? p : void 0,
      mod: [{ required: d }, b],
      onMouseDown: (C) => {
        f?.(C), !C.defaultPrevented && C.detail > 1 && C.preventDefault();
      },
      ...w,
      children: [
        h,
        d && /* @__PURE__ */ v("span", { ...x("required"), "aria-hidden": !0, children: " *" })
      ]
    }
  );
});
co.classes = Oe;
co.displayName = "@mantine/core/InputLabel";
const wa = {}, Xr = F((e, t) => {
  const n = T("InputPlaceholder", wa, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    __staticSelector: l,
    variant: u,
    error: d,
    mod: p,
    ...f
  } = T("InputPlaceholder", wa, n), h = K({
    name: ["InputPlaceholder", l],
    props: n,
    classes: Oe,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    rootSelector: "placeholder"
  });
  return /* @__PURE__ */ v(
    D,
    {
      ...h("placeholder"),
      mod: [{ error: !!d }, p],
      component: "span",
      variant: u,
      ref: t,
      ...f
    }
  );
});
Xr.classes = Oe;
Xr.displayName = "@mantine/core/InputPlaceholder";
function ph(e, { hasDescription: t, hasError: n }) {
  const o = e.findIndex((c) => c === "input"), r = e.slice(0, o), s = e.slice(o + 1), a = t && r.includes("description") || n && r.includes("error");
  return { offsetBottom: t && s.includes("description") || n && s.includes("error"), offsetTop: a };
}
const mh = {
  labelElement: "label",
  inputContainer: (e) => e,
  inputWrapperOrder: ["label", "description", "input", "error"]
}, hh = (e, { size: t }) => ({
  label: {
    "--input-label-size": Se(t),
    "--input-asterisk-color": void 0
  },
  error: {
    "--input-error-size": t === void 0 ? void 0 : `calc(${Se(t)} - ${E(2)})`
  },
  description: {
    "--input-description-size": t === void 0 ? void 0 : `calc(${Se(t)} - ${E(2)})`
  }
}), Ur = F((e, t) => {
  const n = T("InputWrapper", mh, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    size: l,
    variant: u,
    __staticSelector: d,
    inputContainer: p,
    inputWrapperOrder: f,
    label: h,
    error: m,
    description: g,
    labelProps: b,
    descriptionProps: w,
    errorProps: y,
    labelElement: S,
    children: x,
    withAsterisk: C,
    id: R,
    required: P,
    __stylesApiProps: M,
    mod: I,
    ...H
  } = n, z = K({
    name: ["InputWrapper", d],
    props: M || n,
    classes: Oe,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: hh
  }), j = {
    size: l,
    variant: u,
    __staticSelector: d
  }, B = Je(R), V = typeof C == "boolean" ? C : P, O = y?.id || `${B}-error`, L = w?.id || `${B}-description`, N = B, $ = !!m && typeof m != "boolean", k = !!g, A = `${$ ? O : ""} ${k ? L : ""}`, q = A.trim().length > 0 ? A.trim() : void 0, ee = b?.id || `${B}-label`, se = h && /* @__PURE__ */ v(
    co,
    {
      labelElement: S,
      id: ee,
      htmlFor: N,
      required: V,
      ...j,
      ...b,
      children: h
    },
    "label"
  ), ne = k && /* @__PURE__ */ v(
    io,
    {
      ...w,
      ...j,
      size: w?.size || j.size,
      id: w?.id || L,
      children: g
    },
    "description"
  ), X = /* @__PURE__ */ v(za, { children: p(x) }, "input"), te = $ && /* @__PURE__ */ an(
    lo,
    {
      ...y,
      ...j,
      size: y?.size || j.size,
      key: "error",
      id: y?.id || O
    },
    m
  ), ge = f.map((le) => {
    switch (le) {
      case "label":
        return se;
      case "input":
        return X;
      case "description":
        return ne;
      case "error":
        return te;
      default:
        return null;
    }
  });
  return /* @__PURE__ */ v(
    ih,
    {
      value: {
        getStyles: z,
        describedBy: q,
        inputId: N,
        labelId: ee,
        ...ph(f, { hasDescription: k, hasError: $ })
      },
      children: /* @__PURE__ */ v(
        D,
        {
          ref: t,
          variant: u,
          size: l,
          mod: [{ error: !!m }, I],
          ...z("root"),
          ...H,
          children: ge
        }
      )
    }
  );
});
Ur.classes = Oe;
Ur.displayName = "@mantine/core/InputWrapper";
const vh = {
  variant: "default",
  leftSectionPointerEvents: "none",
  rightSectionPointerEvents: "none",
  withAria: !0,
  withErrorStyles: !0
}, gh = (e, t, n) => ({
  wrapper: {
    "--input-margin-top": n.offsetTop ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-margin-bottom": n.offsetBottom ? "calc(var(--mantine-spacing-xs) / 2)" : void 0,
    "--input-height": Q(t.size, "input-height"),
    "--input-fz": Se(t.size),
    "--input-radius": t.radius === void 0 ? void 0 : ie(t.radius),
    "--input-left-section-width": t.leftSectionWidth !== void 0 ? E(t.leftSectionWidth) : void 0,
    "--input-right-section-width": t.rightSectionWidth !== void 0 ? E(t.rightSectionWidth) : void 0,
    "--input-padding-y": t.multiline ? Q(t.size, "input-padding-y") : void 0,
    "--input-left-section-pointer-events": t.leftSectionPointerEvents,
    "--input-right-section-pointer-events": t.rightSectionPointerEvents
  }
}), _e = he((e, t) => {
  const n = T("Input", vh, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    required: c,
    __staticSelector: l,
    __stylesApiProps: u,
    size: d,
    wrapperProps: p,
    error: f,
    disabled: h,
    leftSection: m,
    leftSectionProps: g,
    leftSectionWidth: b,
    rightSection: w,
    rightSectionProps: y,
    rightSectionWidth: S,
    rightSectionPointerEvents: x,
    leftSectionPointerEvents: C,
    variant: R,
    vars: P,
    pointer: M,
    multiline: I,
    radius: H,
    id: z,
    withAria: j,
    withErrorStyles: B,
    mod: V,
    inputSize: O,
    __clearSection: L,
    __clearable: N,
    __defaultRightSection: $,
    ...k
  } = n, { styleProps: A, rest: q } = Sr(k), ee = ao(), se = { offsetBottom: ee?.offsetBottom, offsetTop: ee?.offsetTop }, ne = K({
    name: ["Input", l],
    props: u || n,
    classes: Oe,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    stylesCtx: se,
    rootSelector: "wrapper",
    vars: P,
    varsResolver: gh
  }), X = j ? {
    required: c,
    disabled: h,
    "aria-invalid": !!f,
    "aria-describedby": ee?.describedBy,
    id: ee?.inputId || z
  } : {}, te = w || N && L || $;
  return /* @__PURE__ */ v(rh, { value: { size: d || "sm" }, children: /* @__PURE__ */ Z(
    D,
    {
      ...ne("wrapper"),
      ...A,
      ...p,
      mod: [
        {
          error: !!f && B,
          pointer: M,
          disabled: h,
          multiline: I,
          "data-with-right-section": !!te,
          "data-with-left-section": !!m
        },
        V
      ],
      variant: R,
      size: d,
      children: [
        m && /* @__PURE__ */ v(
          "div",
          {
            ...g,
            "data-position": "left",
            ...ne("section", {
              className: g?.className,
              style: g?.style
            }),
            children: m
          }
        ),
        /* @__PURE__ */ v(
          D,
          {
            component: "input",
            ...q,
            ...X,
            ref: t,
            required: c,
            mod: { disabled: h, error: !!f && B },
            variant: R,
            __size: O,
            ...ne("input")
          }
        ),
        te && /* @__PURE__ */ v(
          "div",
          {
            ...y,
            "data-position": "right",
            ...ne("section", {
              className: y?.className,
              style: y?.style
            }),
            children: te
          }
        )
      ]
    }
  ) });
});
_e.classes = Oe;
_e.Wrapper = Ur;
_e.Label = co;
_e.Error = lo;
_e.Description = io;
_e.Placeholder = Xr;
_e.ClearButton = wl;
_e.displayName = "@mantine/core/Input";
function yh(e, t, n) {
  const o = T(e, t, n), {
    label: r,
    description: s,
    error: a,
    required: i,
    classNames: c,
    styles: l,
    className: u,
    unstyled: d,
    __staticSelector: p,
    __stylesApiProps: f,
    errorProps: h,
    labelProps: m,
    descriptionProps: g,
    wrapperProps: b,
    id: w,
    size: y,
    style: S,
    inputContainer: x,
    inputWrapperOrder: C,
    withAsterisk: R,
    variant: P,
    vars: M,
    mod: I,
    ...H
  } = o, { styleProps: z, rest: j } = Sr(H), B = {
    label: r,
    description: s,
    error: a,
    required: i,
    classNames: c,
    className: u,
    __staticSelector: p,
    __stylesApiProps: f || o,
    errorProps: h,
    labelProps: m,
    descriptionProps: g,
    unstyled: d,
    styles: l,
    size: y,
    style: S,
    inputContainer: x,
    inputWrapperOrder: C,
    withAsterisk: R,
    variant: P,
    id: w,
    mod: I,
    ...b
  };
  return {
    ...j,
    classNames: c,
    styles: l,
    unstyled: d,
    wrapperProps: { ...B, ...z },
    inputProps: {
      required: i,
      classNames: c,
      styles: l,
      unstyled: d,
      size: y,
      __staticSelector: p,
      __stylesApiProps: f || o,
      error: a,
      variant: P,
      id: w
    }
  };
}
const bh = {
  __staticSelector: "InputBase",
  withAria: !0
}, uo = he((e, t) => {
  const { inputProps: n, wrapperProps: o, ...r } = yh("InputBase", bh, e);
  return /* @__PURE__ */ v(_e.Wrapper, { ...o, children: /* @__PURE__ */ v(_e, { ...n, ...r, ref: t }) });
});
uo.classes = { ..._e.classes, ..._e.Wrapper.classes };
uo.displayName = "@mantine/core/InputBase";
const wh = {
  gap: { type: "spacing", property: "gap" },
  rowGap: { type: "spacing", property: "rowGap" },
  columnGap: { type: "spacing", property: "columnGap" },
  align: { type: "identity", property: "alignItems" },
  justify: { type: "identity", property: "justifyContent" },
  wrap: { type: "identity", property: "flexWrap" },
  direction: { type: "identity", property: "flexDirection" }
};
var Sh = { root: "m_8bffd616" };
const Sl = Sh, xh = {}, xl = he((e, t) => {
  const n = T("Flex", xh, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    gap: l,
    rowGap: u,
    columnGap: d,
    align: p,
    justify: f,
    wrap: h,
    direction: m,
    ...g
  } = n, b = K({
    name: "Flex",
    classes: Sl,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c
  }), w = ye(), y = vn(), S = vi({
    styleProps: { gap: l, rowGap: u, columnGap: d, align: p, justify: f, wrap: h, direction: m },
    theme: w,
    data: wh
  });
  return /* @__PURE__ */ Z(Ce, { children: [
    S.hasResponsiveStyles && /* @__PURE__ */ v(
      Xt,
      {
        selector: `.${y}`,
        styles: S.styles,
        media: S.media
      }
    ),
    /* @__PURE__ */ v(
      D,
      {
        ref: t,
        ...b("root", {
          className: y,
          style: yt(S.inlineStyles)
        }),
        ...g
      }
    )
  ] });
});
xl.classes = Sl;
xl.displayName = "@mantine/core/Flex";
function Ch(e, t) {
  if (!t || !e)
    return !1;
  let n = t.parentNode;
  for (; n != null; ) {
    if (n === e)
      return !0;
    n = n.parentNode;
  }
  return !1;
}
function $h({
  target: e,
  parent: t,
  ref: n,
  displayAfterTransitionEnd: o
}) {
  const r = G(-1), [s, a] = W(!1), [i, c] = W(
    typeof o == "boolean" ? o : !1
  ), l = () => {
    if (!e || !t || !n.current)
      return;
    const f = e.getBoundingClientRect(), h = t.getBoundingClientRect(), m = window.getComputedStyle(e), g = window.getComputedStyle(t), b = mt(m.borderTopWidth) + mt(g.borderTopWidth), w = mt(m.borderLeftWidth) + mt(g.borderLeftWidth), y = {
      top: f.top - h.top - b,
      left: f.left - h.left - w,
      width: f.width,
      height: f.height
    };
    n.current.style.transform = `translateY(${y.top}px) translateX(${y.left}px)`, n.current.style.width = `${y.width}px`, n.current.style.height = `${y.height}px`;
  }, u = () => {
    window.clearTimeout(r.current), n.current && (n.current.style.transitionDuration = "0ms"), l(), r.current = window.setTimeout(() => {
      n.current && (n.current.style.transitionDuration = "");
    }, 30);
  }, d = G(null), p = G(null);
  return U(() => {
    if (l(), e)
      return d.current = new ResizeObserver(u), d.current.observe(e), t && (p.current = new ResizeObserver(u), p.current.observe(t)), () => {
        d.current?.disconnect(), p.current?.disconnect();
      };
  }, [t, e]), U(() => {
    if (t) {
      const f = (h) => {
        Ch(h.target, t) && (u(), c(!1));
      };
      return t.addEventListener("transitionend", f), () => {
        t.removeEventListener("transitionend", f);
      };
    }
  }, [t]), vd(
    () => {
      wd() !== "test" && a(!0);
    },
    20,
    { autoInvoke: !0 }
  ), yd(
    (f) => {
      f.forEach((h) => {
        h.type === "attributes" && h.attributeName === "dir" && u();
      });
    },
    { attributes: !0, attributeFilter: ["dir"] },
    () => document.documentElement
  ), { initialized: s, hidden: i };
}
var Ph = { root: "m_96b553a6" };
const Cl = Ph, _h = {}, Rh = (e, { transitionDuration: t }) => ({
  root: {
    "--transition-duration": typeof t == "number" ? `${t}ms` : t
  }
}), qr = F((e, t) => {
  const n = T("FloatingIndicator", _h, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    target: l,
    parent: u,
    transitionDuration: d,
    mod: p,
    displayAfterTransitionEnd: f,
    ...h
  } = n, m = K({
    name: "FloatingIndicator",
    classes: Cl,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Rh
  }), g = G(null), { initialized: b, hidden: w } = $h({
    target: l,
    parent: u,
    ref: g,
    displayAfterTransitionEnd: f
  }), y = ue(t, g);
  return !l || !u ? null : /* @__PURE__ */ v(D, { ref: y, mod: [{ initialized: b, hidden: w }, p], ...m("root"), ...h });
});
qr.displayName = "@mantine/core/FloatingIndicator";
qr.classes = Cl;
var Nh = { root: "m_66836ed3", wrapper: "m_a5d60502", body: "m_667c2793", title: "m_6a03f287", label: "m_698f4f23", icon: "m_667f2a6a", message: "m_7fa78076", closeButton: "m_87f54839" };
const $l = Nh, Th = {}, Eh = (e, { radius: t, color: n, variant: o, autoContrast: r }) => {
  const s = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    variant: o || "light",
    autoContrast: r
  });
  return {
    root: {
      "--alert-radius": t === void 0 ? void 0 : ie(t),
      "--alert-bg": n || o ? s.background : void 0,
      "--alert-color": s.color,
      "--alert-bd": n || o ? s.border : void 0
    }
  };
}, Pl = F((e, t) => {
  const n = T("Alert", Th, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    radius: l,
    color: u,
    title: d,
    children: p,
    id: f,
    icon: h,
    withCloseButton: m,
    onClose: g,
    closeButtonLabel: b,
    variant: w,
    autoContrast: y,
    ...S
  } = n, x = K({
    name: "Alert",
    classes: $l,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Eh
  }), C = Je(f), R = d && `${C}-title` || void 0, P = `${C}-body`;
  return /* @__PURE__ */ v(
    D,
    {
      id: C,
      ...x("root", { variant: w }),
      variant: w,
      ref: t,
      ...S,
      role: "alert",
      "aria-describedby": P,
      "aria-labelledby": R,
      children: /* @__PURE__ */ Z("div", { ...x("wrapper"), children: [
        h && /* @__PURE__ */ v("div", { ...x("icon"), children: h }),
        /* @__PURE__ */ Z("div", { ...x("body"), children: [
          d && /* @__PURE__ */ v("div", { ...x("title"), "data-with-close-button": m || void 0, children: /* @__PURE__ */ v("span", { id: R, ...x("label"), children: d }) }),
          p && /* @__PURE__ */ v("div", { id: P, ...x("message"), "data-variant": w, children: p })
        ] }),
        m && /* @__PURE__ */ v(
          Mt,
          {
            ...x("closeButton"),
            onClick: g,
            variant: "transparent",
            size: 16,
            iconSize: 16,
            "aria-label": b,
            unstyled: i
          }
        )
      ] })
    }
  );
});
Pl.classes = $l;
Pl.displayName = "@mantine/core/Alert";
var kh = { root: "m_b6d8b162" };
const _l = kh;
function Mh(e) {
  if (e === "start")
    return "start";
  if (e === "end" || e)
    return "end";
}
const Ah = {
  inherit: !1
}, Dh = (e, { variant: t, lineClamp: n, gradient: o, size: r, color: s }) => ({
  root: {
    "--text-fz": Se(r),
    "--text-lh": Fu(r),
    "--text-gradient": t === "gradient" ? nr(o, e) : void 0,
    "--text-line-clamp": typeof n == "number" ? n.toString() : void 0,
    "--text-color": s ? xe(s, e) : void 0
  }
}), bn = he((e, t) => {
  const n = T("Text", Ah, e), {
    lineClamp: o,
    truncate: r,
    inline: s,
    inherit: a,
    gradient: i,
    span: c,
    __staticSelector: l,
    vars: u,
    className: d,
    style: p,
    classNames: f,
    styles: h,
    unstyled: m,
    variant: g,
    mod: b,
    size: w,
    ...y
  } = n, S = K({
    name: ["Text", l],
    props: n,
    classes: _l,
    className: d,
    style: p,
    classNames: f,
    styles: h,
    unstyled: m,
    vars: u,
    varsResolver: Dh
  });
  return /* @__PURE__ */ v(
    D,
    {
      ...S("root", { focusable: !0 }),
      ref: t,
      component: c ? "span" : "p",
      variant: g,
      mod: [
        {
          "data-truncate": Mh(r),
          "data-line-clamp": typeof o == "number",
          "data-inline": s,
          "data-inherit": a
        },
        b
      ],
      size: w,
      ...y
    }
  );
});
bn.classes = _l;
bn.displayName = "@mantine/core/Text";
var Ih = { root: "m_849cf0da" };
const Rl = Ih, Oh = {
  underline: "hover"
}, Zr = he((e, t) => {
  const { underline: n, className: o, unstyled: r, mod: s, ...a } = T(
    "Anchor",
    Oh,
    e
  );
  return /* @__PURE__ */ v(
    bn,
    {
      component: "a",
      ref: t,
      className: ve({ [Rl.root]: !r }, o),
      ...a,
      mod: [{ underline: n }, s],
      __staticSelector: "Anchor",
      unstyled: r
    }
  );
});
Zr.classes = Rl;
Zr.displayName = "@mantine/core/Anchor";
function Nl(e) {
  return typeof e == "string" ? { value: e, label: e } : "value" in e && !("label" in e) ? { value: e.value, label: e.value, disabled: e.disabled } : typeof e == "number" ? { value: e.toString(), label: e.toString() } : "group" in e ? {
    group: e.group,
    items: e.items.map((t) => Nl(t))
  } : e;
}
function Lh(e) {
  return e ? e.map((t) => Nl(t)) : [];
}
function Tl(e) {
  return e.reduce((t, n) => "group" in n ? { ...t, ...Tl(n.items) } : (t[n.value] = n, t), {});
}
var zh = { dropdown: "m_88b62a41", search: "m_985517d8", options: "m_b2821a6e", option: "m_92253aa5", empty: "m_2530cd1d", header: "m_858f94bd", footer: "m_82b967cb", group: "m_254f3e4f", groupLabel: "m_2bb2e9e5", chevron: "m_2943220b", optionsDropdownOption: "m_390b5f4", optionsDropdownCheckIcon: "m_8ee53fc2" };
const Re = zh, Bh = {
  error: null
}, Fh = (e, { size: t, color: n }) => ({
  chevron: {
    "--combobox-chevron-size": Q(t, "combobox-chevron-size"),
    "--combobox-chevron-color": n ? xe(n, e) : void 0
  }
}), Jr = F((e, t) => {
  const n = T("ComboboxChevron", Bh, e), { size: o, error: r, style: s, className: a, classNames: i, styles: c, unstyled: l, vars: u, mod: d, ...p } = n, f = K({
    name: "ComboboxChevron",
    classes: Re,
    props: n,
    style: s,
    className: a,
    classNames: i,
    styles: c,
    unstyled: l,
    vars: u,
    varsResolver: Fh,
    rootSelector: "chevron"
  });
  return /* @__PURE__ */ v(
    D,
    {
      component: "svg",
      ...p,
      ...f("chevron"),
      size: o,
      viewBox: "0 0 15 15",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      mod: ["combobox-chevron", { error: r }, d],
      ref: t,
      children: /* @__PURE__ */ v(
        "path",
        {
          d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
});
Jr.classes = Re;
Jr.displayName = "@mantine/core/ComboboxChevron";
const [Hh, Le] = Ee(
  "Combobox component was not found in tree"
), El = J(
  ({ size: e, onMouseDown: t, onClick: n, onClear: o, ...r }, s) => /* @__PURE__ */ v(
    _e.ClearButton,
    {
      ref: s,
      tabIndex: -1,
      "aria-hidden": !0,
      ...r,
      onMouseDown: (a) => {
        a.preventDefault(), t?.(a);
      },
      onClick: (a) => {
        o(), n?.(a);
      }
    }
  )
);
El.displayName = "@mantine/core/ComboboxClearButton";
const Vh = {}, Qr = F((e, t) => {
  const { classNames: n, styles: o, className: r, style: s, hidden: a, ...i } = T(
    "ComboboxDropdown",
    Vh,
    e
  ), c = Le();
  return /* @__PURE__ */ v(
    Ne.Dropdown,
    {
      ...i,
      ref: t,
      role: "presentation",
      "data-hidden": a || void 0,
      ...c.getStyles("dropdown", { className: r, style: s, classNames: n, styles: o })
    }
  );
});
Qr.classes = Re;
Qr.displayName = "@mantine/core/ComboboxDropdown";
const Wh = {
  refProp: "ref"
}, kl = F((e, t) => {
  const { children: n, refProp: o } = T("ComboboxDropdownTarget", Wh, e);
  if (Le(), !ut(n))
    throw new Error(
      "Combobox.DropdownTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  return /* @__PURE__ */ v(Ne.Target, { ref: t, refProp: o, children: n });
});
kl.displayName = "@mantine/core/ComboboxDropdownTarget";
const jh = {}, es = F((e, t) => {
  const { classNames: n, className: o, style: r, styles: s, vars: a, ...i } = T(
    "ComboboxEmpty",
    jh,
    e
  ), c = Le();
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      ...c.getStyles("empty", { className: o, classNames: n, styles: s, style: r }),
      ...i
    }
  );
});
es.classes = Re;
es.displayName = "@mantine/core/ComboboxEmpty";
function ts({
  onKeyDown: e,
  withKeyboardNavigation: t,
  withAriaAttributes: n,
  withExpandedAttribute: o,
  targetType: r,
  autoComplete: s
}) {
  const a = Le(), [i, c] = W(null), l = (d) => {
    if (e?.(d), !a.readOnly && t) {
      if (d.nativeEvent.isComposing)
        return;
      if (d.nativeEvent.code === "ArrowDown" && (d.preventDefault(), a.store.dropdownOpened ? c(a.store.selectNextOption()) : (a.store.openDropdown("keyboard"), c(a.store.selectActiveOption()), a.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), d.nativeEvent.code === "ArrowUp" && (d.preventDefault(), a.store.dropdownOpened ? c(a.store.selectPreviousOption()) : (a.store.openDropdown("keyboard"), c(a.store.selectActiveOption()), a.store.updateSelectedOptionIndex("selected", { scrollIntoView: !0 }))), d.nativeEvent.code === "Enter" || d.nativeEvent.code === "NumpadEnter") {
        if (d.nativeEvent.keyCode === 229)
          return;
        const p = a.store.getSelectedOptionIndex();
        a.store.dropdownOpened && p !== -1 ? (d.preventDefault(), a.store.clickSelectedOption()) : r === "button" && (d.preventDefault(), a.store.openDropdown("keyboard"));
      }
      d.key === "Escape" && a.store.closeDropdown("keyboard"), d.nativeEvent.code === "Space" && r === "button" && (d.preventDefault(), a.store.toggleDropdown("keyboard"));
    }
  };
  return {
    ...n ? {
      "aria-haspopup": "listbox",
      "aria-expanded": o && !!(a.store.listId && a.store.dropdownOpened) || void 0,
      "aria-controls": a.store.dropdownOpened ? a.store.listId : void 0,
      "aria-activedescendant": a.store.dropdownOpened && i || void 0,
      autoComplete: s,
      "data-expanded": a.store.dropdownOpened || void 0,
      "data-mantine-stop-propagation": a.store.dropdownOpened || void 0
    } : {},
    onKeyDown: l
  };
}
const Gh = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, Ml = F((e, t) => {
  const {
    children: n,
    refProp: o,
    withKeyboardNavigation: r,
    withAriaAttributes: s,
    withExpandedAttribute: a,
    targetType: i,
    autoComplete: c,
    ...l
  } = T("ComboboxEventsTarget", Gh, e);
  if (!ut(n))
    throw new Error(
      "Combobox.EventsTarget component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const u = Le(), d = ts({
    targetType: i,
    withAriaAttributes: s,
    withKeyboardNavigation: r,
    withExpandedAttribute: a,
    onKeyDown: n.props.onKeyDown,
    autoComplete: c
  });
  return ct(n, {
    ...d,
    ...l,
    [o]: ue(t, u.store.targetRef, Yn(n))
  });
});
Ml.displayName = "@mantine/core/ComboboxEventsTarget";
const Yh = {}, ns = F((e, t) => {
  const { classNames: n, className: o, style: r, styles: s, vars: a, ...i } = T(
    "ComboboxFooter",
    Yh,
    e
  ), c = Le();
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      ...c.getStyles("footer", { className: o, classNames: n, style: r, styles: s }),
      ...i,
      onMouseDown: (l) => {
        l.preventDefault();
      }
    }
  );
});
ns.classes = Re;
ns.displayName = "@mantine/core/ComboboxFooter";
const Kh = {}, os = F((e, t) => {
  const { classNames: n, className: o, style: r, styles: s, vars: a, children: i, label: c, ...l } = T(
    "ComboboxGroup",
    Kh,
    e
  ), u = Le();
  return /* @__PURE__ */ Z(
    D,
    {
      ref: t,
      ...u.getStyles("group", { className: o, classNames: n, style: r, styles: s }),
      ...l,
      children: [
        c && /* @__PURE__ */ v("div", { ...u.getStyles("groupLabel", { classNames: n, styles: s }), children: c }),
        i
      ]
    }
  );
});
os.classes = Re;
os.displayName = "@mantine/core/ComboboxGroup";
const Xh = {}, rs = F((e, t) => {
  const { classNames: n, className: o, style: r, styles: s, vars: a, ...i } = T(
    "ComboboxHeader",
    Xh,
    e
  ), c = Le();
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      ...c.getStyles("header", { className: o, classNames: n, style: r, styles: s }),
      ...i,
      onMouseDown: (l) => {
        l.preventDefault();
      }
    }
  );
});
rs.classes = Re;
rs.displayName = "@mantine/core/ComboboxHeader";
function Al({
  value: e,
  valuesDivider: t = ",",
  ...n
}) {
  return /* @__PURE__ */ v(
    "input",
    {
      type: "hidden",
      value: Array.isArray(e) ? e.join(t) : e || "",
      ...n
    }
  );
}
Al.displayName = "@mantine/core/ComboboxHiddenInput";
const Uh = {}, ss = F((e, t) => {
  const n = T("ComboboxOption", Uh, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    vars: i,
    onClick: c,
    id: l,
    active: u,
    onMouseDown: d,
    onMouseOver: p,
    disabled: f,
    selected: h,
    mod: m,
    ...g
  } = n, b = Le(), w = Ba(), y = l || w;
  return /* @__PURE__ */ v(
    D,
    {
      ...b.getStyles("option", { className: r, classNames: o, styles: a, style: s }),
      ...g,
      ref: t,
      id: y,
      mod: [
        "combobox-option",
        { "combobox-active": u, "combobox-disabled": f, "combobox-selected": h },
        m
      ],
      role: "option",
      onClick: (S) => {
        f ? S.preventDefault() : (b.onOptionSubmit?.(n.value, n), c?.(S));
      },
      onMouseDown: (S) => {
        S.preventDefault(), d?.(S);
      },
      onMouseOver: (S) => {
        b.resetSelectionOnOptionHover && b.store.resetSelectedOption(), p?.(S);
      }
    }
  );
});
ss.classes = Re;
ss.displayName = "@mantine/core/ComboboxOption";
const qh = {}, as = F((e, t) => {
  const n = T("ComboboxOptions", qh, e), { classNames: o, className: r, style: s, styles: a, id: i, onMouseDown: c, labelledBy: l, ...u } = n, d = Le(), p = Je(i);
  return U(() => {
    d.store.setListId(p);
  }, [p]), /* @__PURE__ */ v(
    D,
    {
      ref: t,
      ...d.getStyles("options", { className: r, style: s, classNames: o, styles: a }),
      ...u,
      id: p,
      role: "listbox",
      "aria-labelledby": l,
      onMouseDown: (f) => {
        f.preventDefault(), c?.(f);
      }
    }
  );
});
as.classes = Re;
as.displayName = "@mantine/core/ComboboxOptions";
const Zh = {
  withAriaAttributes: !0,
  withKeyboardNavigation: !0
}, is = F((e, t) => {
  const n = T("ComboboxSearch", Zh, e), {
    classNames: o,
    styles: r,
    unstyled: s,
    vars: a,
    withAriaAttributes: i,
    onKeyDown: c,
    withKeyboardNavigation: l,
    size: u,
    ...d
  } = n, p = Le(), f = p.getStyles("search"), h = ts({
    targetType: "input",
    withAriaAttributes: i,
    withKeyboardNavigation: l,
    withExpandedAttribute: !1,
    onKeyDown: c,
    autoComplete: "off"
  });
  return /* @__PURE__ */ v(
    _e,
    {
      ref: ue(t, p.store.searchRef),
      classNames: [{ input: f.className }, o],
      styles: [{ input: f.style }, r],
      size: u || p.size,
      ...h,
      ...d,
      __staticSelector: "Combobox"
    }
  );
});
is.classes = Re;
is.displayName = "@mantine/core/ComboboxSearch";
const Jh = {
  refProp: "ref",
  targetType: "input",
  withKeyboardNavigation: !0,
  withAriaAttributes: !0,
  withExpandedAttribute: !1,
  autoComplete: "off"
}, Dl = F((e, t) => {
  const {
    children: n,
    refProp: o,
    withKeyboardNavigation: r,
    withAriaAttributes: s,
    withExpandedAttribute: a,
    targetType: i,
    autoComplete: c,
    ...l
  } = T("ComboboxTarget", Jh, e);
  if (!ut(n))
    throw new Error(
      "Combobox.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const u = Le(), d = ts({
    targetType: i,
    withAriaAttributes: s,
    withKeyboardNavigation: r,
    withExpandedAttribute: a,
    onKeyDown: n.props.onKeyDown,
    autoComplete: c
  }), p = ct(n, {
    ...d,
    ...l
  });
  return /* @__PURE__ */ v(Ne.Target, { ref: ue(t, u.store.targetRef), children: p });
});
Dl.displayName = "@mantine/core/ComboboxTarget";
function Qh(e, t, n) {
  for (let o = e - 1; o >= 0; o -= 1)
    if (!t[o].hasAttribute("data-combobox-disabled"))
      return o;
  if (n) {
    for (let o = t.length - 1; o > -1; o -= 1)
      if (!t[o].hasAttribute("data-combobox-disabled"))
        return o;
  }
  return e;
}
function ev(e, t, n) {
  for (let o = e + 1; o < t.length; o += 1)
    if (!t[o].hasAttribute("data-combobox-disabled"))
      return o;
  if (n) {
    for (let o = 0; o < t.length; o += 1)
      if (!t[o].hasAttribute("data-combobox-disabled"))
        return o;
  }
  return e;
}
function tv(e) {
  for (let t = 0; t < e.length; t += 1)
    if (!e[t].hasAttribute("data-combobox-disabled"))
      return t;
  return -1;
}
function Il({
  defaultOpened: e,
  opened: t,
  onOpenedChange: n,
  onDropdownClose: o,
  onDropdownOpen: r,
  loop: s = !0,
  scrollBehavior: a = "instant"
} = {}) {
  const [i, c] = st({
    value: t,
    defaultValue: e,
    finalValue: !1,
    onChange: n
  }), l = G(null), u = G(-1), d = G(null), p = G(null), f = G(-1), h = G(-1), m = G(-1), g = Y(
    (O = "unknown") => {
      i || (c(!0), r?.(O));
    },
    [c, r, i]
  ), b = Y(
    (O = "unknown") => {
      i && (c(!1), o?.(O));
    },
    [c, o, i]
  ), w = Y(
    (O = "unknown") => {
      i ? b(O) : g(O);
    },
    [b, g, i]
  ), y = Y(() => {
    const O = document.querySelector(`#${l.current} [data-combobox-selected]`);
    O?.removeAttribute("data-combobox-selected"), O?.removeAttribute("aria-selected");
  }, []), S = Y(
    (O) => {
      const N = document.getElementById(l.current)?.querySelectorAll("[data-combobox-option]");
      if (!N)
        return null;
      const $ = O >= N.length ? 0 : O < 0 ? N.length - 1 : O;
      return u.current = $, N?.[$] && !N[$].hasAttribute("data-combobox-disabled") ? (y(), N[$].setAttribute("data-combobox-selected", "true"), N[$].setAttribute("aria-selected", "true"), N[$].scrollIntoView({ block: "nearest", behavior: a }), N[$].id) : null;
    },
    [a, y]
  ), x = Y(() => {
    const O = document.querySelector(
      `#${l.current} [data-combobox-active]`
    );
    if (O) {
      const L = document.querySelectorAll(
        `#${l.current} [data-combobox-option]`
      ), N = Array.from(L).findIndex(($) => $ === O);
      return S(N);
    }
    return S(0);
  }, [S]), C = Y(
    () => S(
      ev(
        u.current,
        document.querySelectorAll(`#${l.current} [data-combobox-option]`),
        s
      )
    ),
    [S, s]
  ), R = Y(
    () => S(
      Qh(
        u.current,
        document.querySelectorAll(`#${l.current} [data-combobox-option]`),
        s
      )
    ),
    [S, s]
  ), P = Y(
    () => S(
      tv(
        document.querySelectorAll(`#${l.current} [data-combobox-option]`)
      )
    ),
    [S]
  ), M = Y(
    (O = "selected", L) => {
      m.current = window.setTimeout(() => {
        const N = document.querySelectorAll(
          `#${l.current} [data-combobox-option]`
        ), $ = Array.from(N).findIndex(
          (k) => k.hasAttribute(`data-combobox-${O}`)
        );
        u.current = $, L?.scrollIntoView && N[$]?.scrollIntoView({ block: "nearest", behavior: a });
      }, 0);
    },
    []
  ), I = Y(() => {
    u.current = -1, y();
  }, [y]), H = Y(() => {
    document.querySelectorAll(
      `#${l.current} [data-combobox-option]`
    )?.[u.current]?.click();
  }, []), z = Y((O) => {
    l.current = O;
  }, []), j = Y(() => {
    f.current = window.setTimeout(() => d.current.focus(), 0);
  }, []), B = Y(() => {
    h.current = window.setTimeout(() => p.current.focus(), 0);
  }, []), V = Y(() => u.current, []);
  return U(
    () => () => {
      window.clearTimeout(f.current), window.clearTimeout(h.current), window.clearTimeout(m.current);
    },
    []
  ), {
    dropdownOpened: i,
    openDropdown: g,
    closeDropdown: b,
    toggleDropdown: w,
    selectedOptionIndex: u.current,
    getSelectedOptionIndex: V,
    selectOption: S,
    selectFirstOption: P,
    selectActiveOption: x,
    selectNextOption: C,
    selectPreviousOption: R,
    resetSelectedOption: I,
    updateSelectedOptionIndex: M,
    listId: l.current,
    setListId: z,
    clickSelectedOption: H,
    searchRef: d,
    focusSearchInput: j,
    targetRef: p,
    focusTarget: B
  };
}
const nv = {
  keepMounted: !0,
  withinPortal: !0,
  resetSelectionOnOptionHover: !1,
  width: "target",
  transitionProps: { transition: "fade", duration: 0 }
}, ov = (e, { size: t, dropdownPadding: n }) => ({
  options: {
    "--combobox-option-fz": Se(t),
    "--combobox-option-padding": Q(t, "combobox-option-padding")
  },
  dropdown: {
    "--combobox-padding": n === void 0 ? void 0 : E(n),
    "--combobox-option-fz": Se(t),
    "--combobox-option-padding": Q(t, "combobox-option-padding")
  }
});
function oe(e) {
  const t = T("Combobox", nv, e), {
    classNames: n,
    styles: o,
    unstyled: r,
    children: s,
    store: a,
    vars: i,
    onOptionSubmit: c,
    onClose: l,
    size: u,
    dropdownPadding: d,
    resetSelectionOnOptionHover: p,
    __staticSelector: f,
    readOnly: h,
    ...m
  } = t, g = Il(), b = a || g, w = K({
    name: f || "Combobox",
    classes: Re,
    props: t,
    classNames: n,
    styles: o,
    unstyled: r,
    vars: i,
    varsResolver: ov
  }), y = () => {
    l?.(), b.closeDropdown();
  };
  return /* @__PURE__ */ v(
    Hh,
    {
      value: {
        getStyles: w,
        store: b,
        onOptionSubmit: c,
        size: u,
        resetSelectionOnOptionHover: p,
        readOnly: h
      },
      children: /* @__PURE__ */ v(
        Ne,
        {
          opened: b.dropdownOpened,
          ...m,
          onChange: (S) => !S && y(),
          withRoles: !1,
          unstyled: r,
          children: s
        }
      )
    }
  );
}
const rv = (e) => e;
oe.extend = rv;
oe.classes = Re;
oe.displayName = "@mantine/core/Combobox";
oe.Target = Dl;
oe.Dropdown = Qr;
oe.Options = as;
oe.Option = ss;
oe.Search = is;
oe.Empty = es;
oe.Chevron = Jr;
oe.Footer = ns;
oe.Header = rs;
oe.EventsTarget = Ml;
oe.DropdownTarget = kl;
oe.Group = os;
oe.ClearButton = El;
oe.HiddenInput = Al;
function sv({ size: e, style: t, ...n }) {
  const o = e !== void 0 ? { width: E(e), height: E(e), ...t } : t;
  return /* @__PURE__ */ v(
    "svg",
    {
      viewBox: "0 0 10 7",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      style: o,
      "aria-hidden": !0,
      ...n,
      children: /* @__PURE__ */ v(
        "path",
        {
          d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
          fill: "currentColor",
          fillRule: "evenodd",
          clipRule: "evenodd"
        }
      )
    }
  );
}
function pn(e) {
  return "group" in e;
}
function Ol({
  options: e,
  search: t,
  limit: n
}) {
  const o = t.trim().toLowerCase(), r = [];
  for (let s = 0; s < e.length; s += 1) {
    const a = e[s];
    if (r.length === n)
      return r;
    pn(a) && r.push({
      group: a.group,
      items: Ol({
        options: a.items,
        search: t,
        limit: n - r.length
      })
    }), pn(a) || a.label.toLowerCase().includes(o) && r.push(a);
  }
  return r;
}
function av(e) {
  if (e.length === 0)
    return !0;
  for (const t of e)
    if (!("group" in t) || t.items.length > 0)
      return !1;
  return !0;
}
function Ll(e, t = /* @__PURE__ */ new Set()) {
  if (Array.isArray(e))
    for (const n of e)
      if (pn(n))
        Ll(n.items, t);
      else {
        if (typeof n.value > "u")
          throw new Error("[@mantine/core] Each option must have value property");
        if (typeof n.value != "string")
          throw new Error(
            `[@mantine/core] Option value must be a string, other data formats are not supported, got ${typeof n.value}`
          );
        if (t.has(n.value))
          throw new Error(
            `[@mantine/core] Duplicate options are not supported. Option with value "${n.value}" was provided more than once`
          );
        t.add(n.value);
      }
}
function iv(e, t) {
  return Array.isArray(e) ? e.includes(t) : e === t;
}
function zl({
  data: e,
  withCheckIcon: t,
  value: n,
  checkIconPosition: o,
  unstyled: r,
  renderOption: s
}) {
  if (!pn(e)) {
    const i = iv(n, e.value), c = t && i && /* @__PURE__ */ v(sv, { className: Re.optionsDropdownCheckIcon }), l = /* @__PURE__ */ Z(Ce, { children: [
      o === "left" && c,
      /* @__PURE__ */ v("span", { children: e.label }),
      o === "right" && c
    ] });
    return /* @__PURE__ */ v(
      oe.Option,
      {
        value: e.value,
        disabled: e.disabled,
        className: ve({ [Re.optionsDropdownOption]: !r }),
        "data-reverse": o === "right" || void 0,
        "data-checked": i || void 0,
        "aria-selected": i,
        active: i,
        children: typeof s == "function" ? s({ option: e, checked: i }) : l
      }
    );
  }
  const a = e.items.map((i) => /* @__PURE__ */ v(
    zl,
    {
      data: i,
      value: n,
      unstyled: r,
      withCheckIcon: t,
      checkIconPosition: o,
      renderOption: s
    },
    i.value
  ));
  return /* @__PURE__ */ v(oe.Group, { label: e.group, children: a });
}
function lv({
  data: e,
  hidden: t,
  hiddenWhenEmpty: n,
  filter: o,
  search: r,
  limit: s,
  maxDropdownHeight: a,
  withScrollArea: i = !0,
  filterOptions: c = !0,
  withCheckIcon: l = !1,
  value: u,
  checkIconPosition: d,
  nothingFoundMessage: p,
  unstyled: f,
  labelId: h,
  renderOption: m,
  scrollAreaProps: g,
  "aria-label": b
}) {
  Ll(e);
  const y = typeof r == "string" ? (o || Ol)({
    options: e,
    search: c ? r : "",
    limit: s ?? 1 / 0
  }) : e, S = av(y), x = y.map((C) => /* @__PURE__ */ v(
    zl,
    {
      data: C,
      withCheckIcon: l,
      value: u,
      checkIconPosition: d,
      unstyled: f,
      renderOption: m
    },
    pn(C) ? C.group : C.value
  ));
  return /* @__PURE__ */ v(oe.Dropdown, { hidden: t || n && S, "data-composed": !0, children: /* @__PURE__ */ Z(oe.Options, { labelledBy: h, "aria-label": b, children: [
    i ? /* @__PURE__ */ v(
      gn.Autosize,
      {
        mah: a ?? 220,
        type: "scroll",
        scrollbarSize: "var(--combobox-padding)",
        offsetScrollbars: "y",
        ...g,
        children: x
      }
    ) : x,
    S && p && /* @__PURE__ */ v(oe.Empty, { children: p })
  ] }) });
}
var cv = { root: "m_347db0ec", "root--dot": "m_fbd81e3d", label: "m_5add502a", section: "m_91fdda9b" };
const Bl = cv, uv = {}, dv = (e, { radius: t, color: n, gradient: o, variant: r, size: s, autoContrast: a }) => {
  const i = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: o,
    variant: r || "filled",
    autoContrast: a
  });
  return {
    root: {
      "--badge-height": Q(s, "badge-height"),
      "--badge-padding-x": Q(s, "badge-padding-x"),
      "--badge-fz": Q(s, "badge-fz"),
      "--badge-radius": t === void 0 ? void 0 : ie(t),
      "--badge-bg": n || r ? i.background : void 0,
      "--badge-color": n || r ? i.color : void 0,
      "--badge-bd": n || r ? i.border : void 0,
      "--badge-dot-color": r === "dot" ? xe(n, e) : void 0
    }
  };
}, Fl = he((e, t) => {
  const n = T("Badge", uv, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    radius: l,
    color: u,
    gradient: d,
    leftSection: p,
    rightSection: f,
    children: h,
    variant: m,
    fullWidth: g,
    autoContrast: b,
    circle: w,
    mod: y,
    ...S
  } = n, x = K({
    name: "Badge",
    props: n,
    classes: Bl,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: dv
  });
  return /* @__PURE__ */ Z(
    D,
    {
      variant: m,
      mod: [
        {
          block: g,
          circle: w,
          "with-right-section": !!f,
          "with-left-section": !!p
        },
        y
      ],
      ...x("root", { variant: m }),
      ref: t,
      ...S,
      children: [
        p && /* @__PURE__ */ v("span", { ...x("section"), "data-position": "left", children: p }),
        /* @__PURE__ */ v("span", { ...x("label"), children: h }),
        f && /* @__PURE__ */ v("span", { ...x("section"), "data-position": "right", children: f })
      ]
    }
  );
});
Fl.classes = Bl;
Fl.displayName = "@mantine/core/Badge";
var fv = { root: "m_fea6bf1a", burger: "m_d4fb9cad" };
const Hl = fv, pv = {}, mv = (e, { color: t, size: n, lineSize: o, transitionDuration: r, transitionTimingFunction: s }) => ({
  root: {
    "--burger-color": t ? xe(t, e) : void 0,
    "--burger-size": Q(n, "burger-size"),
    "--burger-line-size": o ? E(o) : void 0,
    "--burger-transition-duration": r === void 0 ? void 0 : `${r}ms`,
    "--burger-transition-timing-function": s
  }
}), Vl = F((e, t) => {
  const n = T("Burger", pv, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    opened: l,
    children: u,
    transitionDuration: d,
    transitionTimingFunction: p,
    lineSize: f,
    ...h
  } = n, m = K({
    name: "Burger",
    classes: Hl,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: mv
  });
  return /* @__PURE__ */ Z(St, { ...m("root"), ref: t, ...h, children: [
    /* @__PURE__ */ v(D, { mod: ["reduce-motion", { opened: l }], ...m("burger") }),
    u
  ] });
});
Vl.classes = Hl;
Vl.displayName = "@mantine/core/Burger";
var hv = { root: "m_77c9d27d", inner: "m_80f1301b", label: "m_811560b9", section: "m_a74036a", loader: "m_a25b86ee", group: "m_80d6d844", groupSection: "m_70be2a01" };
const Qt = hv, Sa = {
  orientation: "horizontal"
}, vv = (e, { borderWidth: t }) => ({
  group: { "--button-border-width": E(t) }
}), ls = F((e, t) => {
  const n = T("ButtonGroup", Sa, e), {
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    orientation: c,
    vars: l,
    borderWidth: u,
    variant: d,
    mod: p,
    ...f
  } = T("ButtonGroup", Sa, e), h = K({
    name: "ButtonGroup",
    props: n,
    classes: Qt,
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    vars: l,
    varsResolver: vv,
    rootSelector: "group"
  });
  return /* @__PURE__ */ v(
    D,
    {
      ...h("group"),
      ref: t,
      variant: d,
      mod: [{ "data-orientation": c }, p],
      role: "group",
      ...f
    }
  );
});
ls.classes = Qt;
ls.displayName = "@mantine/core/ButtonGroup";
const xa = {}, gv = (e, { radius: t, color: n, gradient: o, variant: r, autoContrast: s, size: a }) => {
  const i = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: o,
    variant: r || "filled",
    autoContrast: s
  });
  return {
    groupSection: {
      "--section-height": Q(a, "section-height"),
      "--section-padding-x": Q(a, "section-padding-x"),
      "--section-fz": a?.includes("compact") ? Se(a.replace("compact-", "")) : Se(a),
      "--section-radius": t === void 0 ? void 0 : ie(t),
      "--section-bg": n || r ? i.background : void 0,
      "--section-color": i.color,
      "--section-bd": n || r ? i.border : void 0
    }
  };
}, cs = F((e, t) => {
  const n = T("ButtonGroupSection", xa, e), {
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    vars: c,
    variant: l,
    gradient: u,
    radius: d,
    autoContrast: p,
    ...f
  } = T("ButtonGroupSection", xa, e), h = K({
    name: "ButtonGroupSection",
    props: n,
    classes: Qt,
    className: o,
    style: r,
    classNames: s,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: gv,
    rootSelector: "groupSection"
  });
  return /* @__PURE__ */ v(D, { ...h("groupSection"), ref: t, variant: l, ...f });
});
cs.classes = Qt;
cs.displayName = "@mantine/core/ButtonGroupSection";
const yv = {
  in: { opacity: 1, transform: `translate(-50%, calc(-50% + ${E(1)}))` },
  out: { opacity: 0, transform: "translate(-50%, -200%)" },
  common: { transformOrigin: "center" },
  transitionProperty: "transform, opacity"
}, bv = {}, wv = (e, { radius: t, color: n, gradient: o, variant: r, size: s, justify: a, autoContrast: i }) => {
  const c = e.variantColorResolver({
    color: n || e.primaryColor,
    theme: e,
    gradient: o,
    variant: r || "filled",
    autoContrast: i
  });
  return {
    root: {
      "--button-justify": a,
      "--button-height": Q(s, "button-height"),
      "--button-padding-x": Q(s, "button-padding-x"),
      "--button-fz": s?.includes("compact") ? Se(s.replace("compact-", "")) : Se(s),
      "--button-radius": t === void 0 ? void 0 : ie(t),
      "--button-bg": n || r ? c.background : void 0,
      "--button-hover": n || r ? c.hover : void 0,
      "--button-color": c.color,
      "--button-bd": n || r ? c.border : void 0,
      "--button-hover-color": n || r ? c.hoverColor : void 0
    }
  };
}, fo = he((e, t) => {
  const n = T("Button", bv, e), {
    style: o,
    vars: r,
    className: s,
    color: a,
    disabled: i,
    children: c,
    leftSection: l,
    rightSection: u,
    fullWidth: d,
    variant: p,
    radius: f,
    loading: h,
    loaderProps: m,
    gradient: g,
    classNames: b,
    styles: w,
    unstyled: y,
    "data-disabled": S,
    autoContrast: x,
    mod: C,
    ...R
  } = n, P = K({
    name: "Button",
    props: n,
    classes: Qt,
    className: s,
    style: o,
    classNames: b,
    styles: w,
    unstyled: y,
    vars: r,
    varsResolver: wv
  }), M = !!l, I = !!u;
  return /* @__PURE__ */ Z(
    St,
    {
      ref: t,
      ...P("root", { active: !i && !h && !S }),
      unstyled: y,
      variant: p,
      disabled: i || h,
      mod: [
        {
          disabled: i || S,
          loading: h,
          block: d,
          "with-left-section": M,
          "with-right-section": I
        },
        C
      ],
      ...R,
      children: [
        /* @__PURE__ */ v(et, { mounted: !!h, transition: yv, duration: 150, children: (H) => /* @__PURE__ */ v(D, { component: "span", ...P("loader", { style: H }), "aria-hidden": !0, children: /* @__PURE__ */ v(
          kt,
          {
            color: "var(--button-color)",
            size: "calc(var(--button-height) / 1.8)",
            ...m
          }
        ) }) }),
        /* @__PURE__ */ Z("span", { ...P("inner"), children: [
          l && /* @__PURE__ */ v(D, { component: "span", ...P("section"), mod: { position: "left" }, children: l }),
          /* @__PURE__ */ v(D, { component: "span", mod: { loading: h }, ...P("label"), children: c }),
          u && /* @__PURE__ */ v(D, { component: "span", ...P("section"), mod: { position: "right" }, children: u })
        ] })
      ]
    }
  );
});
fo.classes = Qt;
fo.displayName = "@mantine/core/Button";
fo.Group = ls;
fo.GroupSection = cs;
const [Sv, xv] = Ee(
  "Card component was not found in tree"
);
var Cv = { root: "m_e615b15f", section: "m_599a2148" };
const us = Cv, $v = {}, po = he((e, t) => {
  const n = T("CardSection", $v, e), { classNames: o, className: r, style: s, styles: a, vars: i, withBorder: c, inheritPadding: l, mod: u, ...d } = n, p = xv();
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      mod: [{ "with-border": c, "inherit-padding": l }, u],
      ...p.getStyles("section", { className: r, style: s, styles: a, classNames: o }),
      ...d
    }
  );
});
po.classes = us;
po.displayName = "@mantine/core/CardSection";
const Pv = {}, _v = (e, { padding: t }) => ({
  root: {
    "--card-padding": we(t)
  }
}), ds = he((e, t) => {
  const n = T("Card", Pv, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, children: l, padding: u, ...d } = n, p = K({
    name: "Card",
    props: n,
    classes: us,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: _v
  }), f = Fa.toArray(l), h = f.map((m, g) => typeof m == "object" && m && "type" in m && m.type === po ? ct(m, {
    "data-first-section": g === 0 || void 0,
    "data-last-section": g === f.length - 1 || void 0
  }) : m);
  return /* @__PURE__ */ v(Sv, { value: { getStyles: p }, children: /* @__PURE__ */ v(Qn, { ref: t, unstyled: i, ...p("root"), ...d, children: h }) });
});
ds.classes = us;
ds.displayName = "@mantine/core/Card";
ds.Section = po;
var Rv = { root: "m_4451eb3a" };
const Wl = Rv, Nv = {}, jl = he((e, t) => {
  const n = T("Center", Nv, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, inline: l, mod: u, ...d } = n, p = K({
    name: "Center",
    props: n,
    classes: Wl,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c
  });
  return /* @__PURE__ */ v(D, { ref: t, mod: [{ inline: l }, u], ...p("root"), ...d });
});
jl.classes = Wl;
jl.displayName = "@mantine/core/Center";
var Tv = { root: "m_b183c0a2" };
const Gl = Tv, Ev = {}, kv = (e, { color: t }) => ({
  root: {
    "--code-bg": t ? xe(t, e) : void 0
  }
}), Yl = F((e, t) => {
  const n = T("Code", Ev, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    color: l,
    block: u,
    variant: d,
    mod: p,
    ...f
  } = n, h = K({
    name: "Code",
    props: n,
    classes: Gl,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: kv
  });
  return /* @__PURE__ */ v(
    D,
    {
      component: u ? "pre" : "code",
      variant: d,
      ref: t,
      mod: [{ block: u }, p],
      ...h("root"),
      ...f,
      dir: "ltr"
    }
  );
});
Yl.classes = Gl;
Yl.displayName = "@mantine/core/Code";
var Mv = { root: "m_de3d2490", colorOverlay: "m_862f3d1b", shadowOverlay: "m_98ae7f22", alphaOverlay: "m_95709ac0", childrenOverlay: "m_93e74e3" };
const Kl = Mv, Ca = {
  withShadow: !0
}, Av = (e, { radius: t, size: n }) => ({
  root: {
    "--cs-radius": t === void 0 ? void 0 : ie(t),
    "--cs-size": E(n)
  }
}), Xl = he((e, t) => {
  const n = T("ColorSwatch", Ca, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    color: l,
    size: u,
    radius: d,
    withShadow: p,
    children: f,
    variant: h,
    ...m
  } = T("ColorSwatch", Ca, n), g = K({
    name: "ColorSwatch",
    props: n,
    classes: Kl,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Av
  });
  return /* @__PURE__ */ Z(
    D,
    {
      ref: t,
      variant: h,
      size: u,
      ...g("root", { focusable: !0 }),
      ...m,
      children: [
        /* @__PURE__ */ v("span", { ...g("alphaOverlay") }),
        p && /* @__PURE__ */ v("span", { ...g("shadowOverlay") }),
        /* @__PURE__ */ v("span", { ...g("colorOverlay", { style: { backgroundColor: l } }) }),
        /* @__PURE__ */ v("span", { ...g("childrenOverlay"), children: f })
      ]
    }
  );
});
Xl.classes = Kl;
Xl.displayName = "@mantine/core/ColorSwatch";
var Dv = { root: "m_7485cace" };
const Ul = Dv, Iv = {}, Ov = (e, { size: t, fluid: n }) => ({
  root: {
    "--container-size": n ? void 0 : Q(t, "container-size")
  }
}), ql = F((e, t) => {
  const n = T("Container", Iv, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, fluid: l, mod: u, ...d } = n, p = K({
    name: "Container",
    classes: Ul,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Ov
  });
  return /* @__PURE__ */ v(D, { ref: t, mod: [{ fluid: l }, u], ...p("root"), ...d });
});
ql.classes = Ul;
ql.displayName = "@mantine/core/Container";
const Lv = {
  timeout: 1e3
};
function zv(e) {
  const { children: t, timeout: n, value: o, ...r } = T("CopyButton", Lv, e), s = Yu({ timeout: n });
  return /* @__PURE__ */ v(Ce, { children: t({ copy: () => s.copy(o), copied: s.copied, ...r }) });
}
zv.displayName = "@mantine/core/CopyButton";
var Bv = { root: "m_3eebeb36", label: "m_9e365f20" };
const Zl = Bv, Fv = {
  orientation: "horizontal"
}, Hv = (e, { color: t, variant: n, size: o }) => ({
  root: {
    "--divider-color": t ? xe(t, e) : void 0,
    "--divider-border-style": n,
    "--divider-size": Q(o, "divider-size")
  }
}), Jl = F((e, t) => {
  const n = T("Divider", Fv, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    color: l,
    orientation: u,
    label: d,
    labelPosition: p,
    mod: f,
    ...h
  } = n, m = K({
    name: "Divider",
    classes: Zl,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Hv
  });
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      mod: [{ orientation: u, "with-label": !!d }, f],
      ...m("root"),
      ...h,
      role: "separator",
      children: d && /* @__PURE__ */ v(D, { component: "span", mod: { position: p }, ...m("label"), children: d })
    }
  );
});
Jl.classes = Zl;
Jl.displayName = "@mantine/core/Divider";
const [Vv, en] = Ee(
  "Drawer component was not found in tree"
);
var Wv = { root: "m_f11b401e", header: "m_5a7c2c9", content: "m_b8a05bbd", inner: "m_31cd769a" };
const ft = Wv, jv = {}, mo = F((e, t) => {
  const n = T("DrawerBody", jv, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = en();
  return /* @__PURE__ */ v(
    Gr,
    {
      ref: t,
      ...l.getStyles("body", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
mo.classes = ft;
mo.displayName = "@mantine/core/DrawerBody";
const Gv = {}, ho = F((e, t) => {
  const n = T("DrawerCloseButton", Gv, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = en();
  return /* @__PURE__ */ v(
    vl,
    {
      ref: t,
      ...l.getStyles("close", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
ho.classes = ft;
ho.displayName = "@mantine/core/DrawerCloseButton";
const Yv = {}, vo = F((e, t) => {
  const n = T("DrawerContent", Yv, e), { classNames: o, className: r, style: s, styles: a, vars: i, children: c, radius: l, __hidden: u, ...d } = n, p = en(), f = p.scrollAreaComponent || bl;
  return /* @__PURE__ */ v(
    Yr,
    {
      ...p.getStyles("content", { className: r, style: s, styles: a, classNames: o }),
      innerProps: p.getStyles("inner", { className: r, style: s, styles: a, classNames: o }),
      ref: t,
      ...d,
      radius: l || p.radius || 0,
      "data-hidden": u || void 0,
      children: /* @__PURE__ */ v(f, { style: { height: "calc(100vh - var(--drawer-offset) * 2)" }, children: c })
    }
  );
});
vo.classes = ft;
vo.displayName = "@mantine/core/DrawerContent";
const Kv = {}, go = F((e, t) => {
  const n = T("DrawerHeader", Kv, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = en();
  return /* @__PURE__ */ v(
    gl,
    {
      ref: t,
      ...l.getStyles("header", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
go.classes = ft;
go.displayName = "@mantine/core/DrawerHeader";
const Xv = {}, yo = F((e, t) => {
  const n = T("DrawerOverlay", Xv, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = en();
  return /* @__PURE__ */ v(
    Kr,
    {
      ref: t,
      ...l.getStyles("overlay", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
yo.classes = ft;
yo.displayName = "@mantine/core/DrawerOverlay";
function Uv(e) {
  switch (e) {
    case "top":
      return "flex-start";
    case "bottom":
      return "flex-end";
    default:
      return;
  }
}
function qv(e) {
  if (e === "top" || e === "bottom")
    return "0 0 calc(100% - var(--drawer-offset, 0rem) * 2)";
}
const Zv = {
  top: "slide-down",
  bottom: "slide-up",
  left: "slide-right",
  right: "slide-left"
}, Jv = {
  top: "slide-down",
  bottom: "slide-up",
  right: "slide-right",
  left: "slide-left"
}, Qv = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: je("modal"),
  position: "left"
}, eg = (e, { position: t, size: n, offset: o }) => ({
  root: {
    "--drawer-size": Q(n, "drawer-size"),
    "--drawer-flex": qv(t),
    "--drawer-height": t === "left" || t === "right" ? void 0 : "var(--drawer-size)",
    "--drawer-align": Uv(t),
    "--drawer-justify": t === "right" ? "flex-end" : void 0,
    "--drawer-offset": E(o)
  }
}), bo = F((e, t) => {
  const n = T("DrawerRoot", Qv, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    scrollAreaComponent: l,
    position: u,
    transitionProps: d,
    radius: p,
    ...f
  } = n, { dir: h } = wt(), m = K({
    name: "Drawer",
    classes: ft,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: eg
  }), g = (h === "rtl" ? Jv : Zv)[u];
  return /* @__PURE__ */ v(Vv, { value: { scrollAreaComponent: l, getStyles: m, radius: p }, children: /* @__PURE__ */ v(
    jr,
    {
      ref: t,
      ...m("root"),
      transitionProps: { transition: g, ...d },
      unstyled: i,
      ...f
    }
  ) });
});
bo.classes = ft;
bo.displayName = "@mantine/core/DrawerRoot";
const [tg, ng] = mn();
function Ql({ children: e }) {
  const [t, n] = W([]), [o, r] = W(je("modal"));
  return /* @__PURE__ */ v(
    tg,
    {
      value: {
        stack: t,
        addModal: (s, a) => {
          n((i) => [.../* @__PURE__ */ new Set([...i, s])]), r(
            (i) => typeof a == "number" && typeof i == "number" ? Math.max(i, a) : i
          );
        },
        removeModal: (s) => n((a) => a.filter((i) => i !== s)),
        getZIndex: (s) => `calc(${o} + ${t.indexOf(s)} + 1)`,
        currentId: t[t.length - 1],
        maxZIndex: o
      },
      children: e
    }
  );
}
Ql.displayName = "@mantine/core/DrawerStack";
const og = {}, wo = F((e, t) => {
  const n = T("DrawerTitle", og, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = en();
  return /* @__PURE__ */ v(
    yl,
    {
      ref: t,
      ...l.getStyles("title", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
wo.classes = ft;
wo.displayName = "@mantine/core/DrawerTitle";
const rg = {
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: je("modal"),
  withOverlay: !0,
  withCloseButton: !0
}, tt = F((e, t) => {
  const {
    title: n,
    withOverlay: o,
    overlayProps: r,
    withCloseButton: s,
    closeButtonProps: a,
    children: i,
    opened: c,
    stackId: l,
    zIndex: u,
    ...d
  } = T("Drawer", rg, e), p = ng(), f = !!n || s, h = p && l ? {
    closeOnEscape: p.currentId === l,
    trapFocus: p.currentId === l,
    zIndex: p.getZIndex(l)
  } : {}, m = o === !1 ? !1 : l && p ? p.currentId === l : c;
  return U(() => {
    p && l && (c ? p.addModal(l, u || je("modal")) : p.removeModal(l));
  }, [c, l, u]), /* @__PURE__ */ Z(
    bo,
    {
      ref: t,
      opened: c,
      zIndex: p && l ? p.getZIndex(l) : u,
      ...d,
      ...h,
      children: [
        o && /* @__PURE__ */ v(
          yo,
          {
            visible: m,
            transitionProps: p && l ? { duration: 0 } : void 0,
            ...r
          }
        ),
        /* @__PURE__ */ Z(vo, { __hidden: p && l && c ? l !== p.currentId : !1, children: [
          f && /* @__PURE__ */ Z(go, { children: [
            n && /* @__PURE__ */ v(wo, { children: n }),
            s && /* @__PURE__ */ v(ho, { ...a })
          ] }),
          /* @__PURE__ */ v(mo, { children: i })
        ] })
      ]
    }
  );
});
tt.classes = ft;
tt.displayName = "@mantine/core/Drawer";
tt.Root = bo;
tt.Overlay = yo;
tt.Content = vo;
tt.Body = mo;
tt.Header = go;
tt.Title = wo;
tt.CloseButton = ho;
tt.Stack = Ql;
function ec({ open: e, close: t, openDelay: n, closeDelay: o }) {
  const r = G(-1), s = G(-1), a = () => {
    window.clearTimeout(r.current), window.clearTimeout(s.current);
  }, i = () => {
    a(), n === 0 || n === void 0 ? e() : r.current = window.setTimeout(e, n);
  }, c = () => {
    a(), o === 0 || o === void 0 ? t() : s.current = window.setTimeout(t, o);
  };
  return U(() => a, []), { openDropdown: i, closeDropdown: c };
}
const [$a, tc] = Ee(
  "Grid component was not found in tree"
), pr = (e, t) => e === "content" ? "auto" : e === "auto" ? "0rem" : e ? `${100 / (t / e)}%` : void 0, Pa = (e, t, n) => n || e === "auto" ? "100%" : e === "content" ? "unset" : pr(e, t), _a = (e, t) => {
  if (e)
    return e === "auto" || t ? "1" : "auto";
}, Ra = (e, t) => e === 0 ? "0" : e ? `${100 / (t / e)}%` : void 0;
function sg({ span: e, order: t, offset: n, selector: o }) {
  const r = ye(), s = tc(), a = s.breakpoints || r.breakpoints, c = Fe(e) === void 0 ? 12 : Fe(e), l = yt({
    "--col-order": Fe(t)?.toString(),
    "--col-flex-grow": _a(c, s.grow),
    "--col-flex-basis": pr(c, s.columns),
    "--col-width": c === "content" ? "auto" : void 0,
    "--col-max-width": Pa(c, s.columns, s.grow),
    "--col-offset": Ra(Fe(n), s.columns)
  }), u = ce(a).reduce(
    (f, h) => (f[h] || (f[h] = {}), typeof t == "object" && t[h] !== void 0 && (f[h]["--col-order"] = t[h]?.toString()), typeof e == "object" && e[h] !== void 0 && (f[h]["--col-flex-grow"] = _a(e[h], s.grow), f[h]["--col-flex-basis"] = pr(e[h], s.columns), f[h]["--col-width"] = e[h] === "content" ? "auto" : void 0, f[h]["--col-max-width"] = Pa(
      e[h],
      s.columns,
      s.grow
    )), typeof n == "object" && n[h] !== void 0 && (f[h]["--col-offset"] = Ra(n[h], s.columns)), f),
    {}
  ), p = vr(ce(u), a).filter(
    (f) => ce(u[f.value]).length > 0
  ).map((f) => ({
    query: s.type === "container" ? `mantine-grid (min-width: ${a[f.value]})` : `(min-width: ${a[f.value]})`,
    styles: u[f.value]
  }));
  return /* @__PURE__ */ v(
    Xt,
    {
      styles: l,
      media: s.type === "container" ? void 0 : p,
      container: s.type === "container" ? p : void 0,
      selector: o
    }
  );
}
var ag = { container: "m_8478a6da", root: "m_410352e9", inner: "m_dee7bd2f", col: "m_96bdd299" };
const fs = ag, ig = {
  span: 12
}, ps = F((e, t) => {
  const n = T("GridCol", ig, e), { classNames: o, className: r, style: s, styles: a, vars: i, span: c, order: l, offset: u, ...d } = n, p = tc(), f = vn();
  return /* @__PURE__ */ Z(Ce, { children: [
    /* @__PURE__ */ v(
      sg,
      {
        selector: `.${f}`,
        span: c,
        order: l,
        offset: u
      }
    ),
    /* @__PURE__ */ v(
      D,
      {
        ref: t,
        ...p.getStyles("col", {
          className: ve(r, f),
          style: s,
          classNames: o,
          styles: a
        }),
        ...d
      }
    )
  ] });
});
ps.classes = fs;
ps.displayName = "@mantine/core/GridCol";
function Na({ gutter: e, selector: t, breakpoints: n, type: o }) {
  const r = ye(), s = n || r.breakpoints, a = yt({
    "--grid-gutter": we(Fe(e))
  }), i = ce(s).reduce(
    (u, d) => (u[d] || (u[d] = {}), typeof e == "object" && e[d] !== void 0 && (u[d]["--grid-gutter"] = we(e[d])), u),
    {}
  ), l = vr(ce(i), s).filter(
    (u) => ce(i[u.value]).length > 0
  ).map((u) => ({
    query: o === "container" ? `mantine-grid (min-width: ${s[u.value]})` : `(min-width: ${s[u.value]})`,
    styles: i[u.value]
  }));
  return /* @__PURE__ */ v(
    Xt,
    {
      styles: a,
      media: o === "container" ? void 0 : l,
      container: o === "container" ? l : void 0,
      selector: t
    }
  );
}
const lg = {
  gutter: "md",
  grow: !1,
  columns: 12
}, cg = (e, { justify: t, align: n, overflow: o }) => ({
  root: {
    "--grid-justify": t,
    "--grid-align": n,
    "--grid-overflow": o
  }
}), ms = F((e, t) => {
  const n = T("Grid", lg, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    grow: l,
    gutter: u,
    columns: d,
    align: p,
    justify: f,
    children: h,
    breakpoints: m,
    type: g,
    ...b
  } = n, w = K({
    name: "Grid",
    classes: fs,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: cg
  }), y = vn();
  return g === "container" && m ? /* @__PURE__ */ Z($a, { value: { getStyles: w, grow: l, columns: d || 12, breakpoints: m, type: g }, children: [
    /* @__PURE__ */ v(Na, { selector: `.${y}`, ...n }),
    /* @__PURE__ */ v("div", { ...w("container"), children: /* @__PURE__ */ v(D, { ref: t, ...w("root", { className: y }), ...b, children: /* @__PURE__ */ v("div", { ...w("inner"), children: h }) }) })
  ] }) : /* @__PURE__ */ Z($a, { value: { getStyles: w, grow: l, columns: d || 12, breakpoints: m, type: g }, children: [
    /* @__PURE__ */ v(Na, { selector: `.${y}`, ...n }),
    /* @__PURE__ */ v(D, { ref: t, ...w("root", { className: y }), ...b, children: /* @__PURE__ */ v("div", { ...w("inner"), children: h }) })
  ] });
});
ms.classes = fs;
ms.displayName = "@mantine/core/Grid";
ms.Col = ps;
function Ta({ color: e, theme: t, defaultShade: n }) {
  const o = Et({ color: e, theme: t });
  return o.isThemeColor ? o.shade === void 0 ? `var(--mantine-color-${o.color}-${n})` : `var(${o.variable})` : e;
}
var ug = { root: "m_bcb3f3c2" };
const nc = ug, dg = {
  color: "yellow"
}, fg = (e, { color: t }) => ({
  root: {
    "--mark-bg-dark": Ta({ color: t, theme: e, defaultShade: 5 }),
    "--mark-bg-light": Ta({ color: t, theme: e, defaultShade: 2 })
  }
}), hs = F((e, t) => {
  const n = T("Mark", dg, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, color: l, variant: u, ...d } = n, p = K({
    name: "Mark",
    props: n,
    className: r,
    style: s,
    classes: nc,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: fg
  });
  return /* @__PURE__ */ v(D, { component: "mark", ref: t, variant: u, ...p("root"), ...d });
});
hs.classes = nc;
hs.displayName = "@mantine/core/Mark";
function Ea(e) {
  return e.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
}
function pg(e, t) {
  if (t == null)
    return [{ chunk: e, highlighted: !1 }];
  const n = Array.isArray(t) ? t.map(Ea) : Ea(t);
  if (!(Array.isArray(n) ? n.filter((i) => i.trim().length > 0).length > 0 : n.trim() !== ""))
    return [{ chunk: e, highlighted: !1 }];
  const r = typeof n == "string" ? n.trim() : n.filter((i) => i.trim().length !== 0).map((i) => i.trim()).sort((i, c) => c.length - i.length).join("|"), s = new RegExp(`(${r})`, "gi");
  return e.split(s).map((i) => ({ chunk: i, highlighted: s.test(i) })).filter(({ chunk: i }) => i);
}
const mg = {}, oc = he((e, t) => {
  const { unstyled: n, children: o, highlight: r, highlightStyles: s, color: a, ...i } = T(
    "Highlight",
    mg,
    e
  ), c = pg(o, r);
  return /* @__PURE__ */ v(bn, { unstyled: n, ref: t, ...i, __staticSelector: "Highlight", children: c.map(
    ({ chunk: l, highlighted: u }, d) => u ? /* @__PURE__ */ v(
      hs,
      {
        unstyled: n,
        color: a,
        style: s,
        "data-highlight": l,
        children: l
      },
      d
    ) : /* @__PURE__ */ v("span", { children: l }, d)
  ) });
});
oc.classes = bn.classes;
oc.displayName = "@mantine/core/Highlight";
const [hg, rc] = Ee(
  "HoverCard component was not found in the tree"
), vg = {};
function sc(e) {
  const { children: t, onMouseEnter: n, onMouseLeave: o, ...r } = T(
    "HoverCardDropdown",
    vg,
    e
  ), s = rc(), a = $e(n, s.openDropdown), i = $e(o, s.closeDropdown);
  return /* @__PURE__ */ v(Ne.Dropdown, { onMouseEnter: a, onMouseLeave: i, ...r, children: t });
}
sc.displayName = "@mantine/core/HoverCardDropdown";
const gg = {
  refProp: "ref"
}, ac = J((e, t) => {
  const { children: n, refProp: o, eventPropsWrapperName: r, ...s } = T(
    "HoverCardTarget",
    gg,
    e
  );
  if (!ut(n))
    throw new Error(
      "HoverCard.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const a = rc(), i = $e(n.props.onMouseEnter, a.openDropdown), c = $e(n.props.onMouseLeave, a.closeDropdown), l = { onMouseEnter: i, onMouseLeave: c };
  return /* @__PURE__ */ v(Ne.Target, { refProp: o, ref: t, ...s, children: ct(
    n,
    r ? { [r]: l } : l
  ) });
});
ac.displayName = "@mantine/core/HoverCardTarget";
const yg = {
  openDelay: 0,
  closeDelay: 150,
  initiallyOpened: !1
};
function So(e) {
  const { children: t, onOpen: n, onClose: o, openDelay: r, closeDelay: s, initiallyOpened: a, ...i } = T(
    "HoverCard",
    yg,
    e
  ), [c, { open: l, close: u }] = md(a, { onClose: o, onOpen: n }), { openDropdown: d, closeDropdown: p } = ec({ open: l, close: u, openDelay: r, closeDelay: s });
  return /* @__PURE__ */ v(hg, { value: { openDropdown: d, closeDropdown: p }, children: /* @__PURE__ */ v(Ne, { ...i, opened: c, __staticSelector: "HoverCard", children: t }) });
}
So.displayName = "@mantine/core/HoverCard";
So.Target = ac;
So.Dropdown = sc;
So.extend = (e) => e;
var bg = { root: "m_9e117634" };
const ic = bg, wg = {}, Sg = (e, { radius: t, fit: n }) => ({
  root: {
    "--image-radius": t === void 0 ? void 0 : ie(t),
    "--image-object-fit": n
  }
}), lc = he((e, t) => {
  const n = T("Image", wg, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    onError: l,
    src: u,
    radius: d,
    fit: p,
    fallbackSrc: f,
    mod: h,
    ...m
  } = n, [g, b] = W(!u);
  U(() => b(!u), [u]);
  const w = K({
    name: "Image",
    classes: ic,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Sg
  });
  return g && f ? /* @__PURE__ */ v(
    D,
    {
      component: "img",
      ref: t,
      src: f,
      ...w("root"),
      onError: l,
      mod: ["fallback", h],
      ...m
    }
  ) : /* @__PURE__ */ v(
    D,
    {
      component: "img",
      ref: t,
      ...w("root"),
      src: u,
      onError: (y) => {
        l?.(y), b(!0);
      },
      mod: h,
      ...m
    }
  );
});
lc.classes = ic;
lc.displayName = "@mantine/core/Image";
var xb = Wn, xg = { root: "m_6e45937b", loader: "m_e8eb006c", overlay: "m_df587f17" };
const cc = xg, ka = {
  transitionProps: { transition: "fade", duration: 0 },
  overlayProps: { backgroundOpacity: 0.75 },
  zIndex: je("overlay")
}, Cg = (e, { zIndex: t }) => ({
  root: {
    "--lo-z-index": t?.toString()
  }
}), uc = F((e, t) => {
  const n = T("LoadingOverlay", ka, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    transitionProps: l,
    loaderProps: u,
    overlayProps: d,
    visible: p,
    zIndex: f,
    ...h
  } = n, m = ye(), g = K({
    name: "LoadingOverlay",
    classes: cc,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Cg
  }), b = { ...ka.overlayProps, ...d };
  return /* @__PURE__ */ v(et, { transition: "fade", ...l, mounted: !!p, children: (w) => /* @__PURE__ */ Z(D, { ...g("root", { style: w }), ref: t, ...h, children: [
    /* @__PURE__ */ v(kt, { ...g("loader"), unstyled: i, ...u }),
    /* @__PURE__ */ v(
      Gt,
      {
        ...b,
        ...g("overlay"),
        darkHidden: !0,
        unstyled: i,
        color: d?.color || m.white
      }
    ),
    /* @__PURE__ */ v(
      Gt,
      {
        ...b,
        ...g("overlay"),
        lightHidden: !0,
        unstyled: i,
        color: d?.color || m.colors.dark[5]
      }
    )
  ] }) });
});
uc.classes = cc;
uc.displayName = "@mantine/core/LoadingOverlay";
const [$g, wn] = Ee(
  "Menu component was not found in the tree"
);
var Pg = { dropdown: "m_dc9b7c9f", label: "m_9bfac126", divider: "m_efdf90cb", item: "m_99ac2aa1", itemLabel: "m_5476e0d3", itemSection: "m_8b75e504" };
const tn = Pg, _g = {}, vs = F((e, t) => {
  const { classNames: n, className: o, style: r, styles: s, vars: a, ...i } = T(
    "MenuDivider",
    _g,
    e
  ), c = wn();
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      ...c.getStyles("divider", { className: o, style: r, styles: s, classNames: n }),
      ...i
    }
  );
});
vs.classes = tn;
vs.displayName = "@mantine/core/MenuDivider";
const Rg = {}, gs = F((e, t) => {
  const {
    classNames: n,
    className: o,
    style: r,
    styles: s,
    vars: a,
    onMouseEnter: i,
    onMouseLeave: c,
    onKeyDown: l,
    children: u,
    ...d
  } = T("MenuDropdown", Rg, e), p = G(null), f = wn(), h = $e(l, (b) => {
    (b.key === "ArrowUp" || b.key === "ArrowDown") && (b.preventDefault(), p.current?.querySelectorAll("[data-menu-item]:not(:disabled)")[0]?.focus());
  }), m = $e(
    i,
    () => (f.trigger === "hover" || f.trigger === "click-hover") && f.openDropdown()
  ), g = $e(
    c,
    () => (f.trigger === "hover" || f.trigger === "click-hover") && f.closeDropdown()
  );
  return /* @__PURE__ */ Z(
    Ne.Dropdown,
    {
      ...d,
      onMouseEnter: m,
      onMouseLeave: g,
      role: "menu",
      "aria-orientation": "vertical",
      ref: ue(t, p),
      ...f.getStyles("dropdown", {
        className: o,
        style: r,
        styles: s,
        classNames: n,
        withStaticClass: !1
      }),
      tabIndex: -1,
      "data-menu-dropdown": !0,
      onKeyDown: h,
      children: [
        f.withInitialFocusPlaceholder && /* @__PURE__ */ v("div", { tabIndex: -1, "data-autofocus": !0, "data-mantine-stop-propagation": !0, style: { outline: 0 } }),
        u
      ]
    }
  );
});
gs.classes = tn;
gs.displayName = "@mantine/core/MenuDropdown";
const Ng = {}, ys = he((e, t) => {
  const {
    classNames: n,
    className: o,
    style: r,
    styles: s,
    vars: a,
    color: i,
    closeMenuOnClick: c,
    leftSection: l,
    rightSection: u,
    children: d,
    disabled: p,
    "data-disabled": f,
    ...h
  } = T("MenuItem", Ng, e), m = wn(), g = ye(), { dir: b } = wt(), w = G(null), y = m.getItemIndex(w.current), S = h, x = $e(S.onMouseLeave, () => m.setHovered(-1)), C = $e(
    S.onMouseEnter,
    () => m.setHovered(m.getItemIndex(w.current))
  ), R = $e(S.onClick, () => {
    f || (typeof c == "boolean" ? c && m.closeDropdownImmediately() : m.closeOnItemClick && m.closeDropdownImmediately());
  }), P = $e(
    S.onFocus,
    () => m.setHovered(m.getItemIndex(w.current))
  ), M = i ? g.variantColorResolver({ color: i, theme: g, variant: "light" }) : void 0, I = i ? Et({ color: i, theme: g }) : null;
  return /* @__PURE__ */ Z(
    St,
    {
      ...h,
      unstyled: m.unstyled,
      tabIndex: m.menuItemTabIndex,
      onFocus: P,
      ...m.getStyles("item", { className: o, style: r, styles: s, classNames: n }),
      ref: ue(w, t),
      role: "menuitem",
      disabled: p,
      "data-menu-item": !0,
      "data-disabled": p || f || void 0,
      "data-hovered": m.hovered === y ? !0 : void 0,
      "data-mantine-stop-propagation": !0,
      onMouseEnter: C,
      onMouseLeave: x,
      onClick: R,
      onKeyDown: Za({
        siblingSelector: "[data-menu-item]:not([data-disabled])",
        parentSelector: "[data-menu-dropdown]",
        activateOnFocus: !1,
        loop: m.loop,
        dir: b,
        orientation: "vertical",
        onKeyDown: S.onKeyDown
      }),
      __vars: {
        "--menu-item-color": I?.isThemeColor && I?.shade === void 0 ? `var(--mantine-color-${I.color}-6)` : M?.color,
        "--menu-item-hover": M?.hover
      },
      children: [
        l && /* @__PURE__ */ v("div", { ...m.getStyles("itemSection", { styles: s, classNames: n }), "data-position": "left", children: l }),
        d && /* @__PURE__ */ v("div", { ...m.getStyles("itemLabel", { styles: s, classNames: n }), children: d }),
        u && /* @__PURE__ */ v("div", { ...m.getStyles("itemSection", { styles: s, classNames: n }), "data-position": "right", children: u })
      ]
    }
  );
});
ys.classes = tn;
ys.displayName = "@mantine/core/MenuItem";
const Tg = {}, bs = F((e, t) => {
  const { classNames: n, className: o, style: r, styles: s, vars: a, ...i } = T(
    "MenuLabel",
    Tg,
    e
  ), c = wn();
  return /* @__PURE__ */ v(
    D,
    {
      ref: t,
      ...c.getStyles("label", { className: o, style: r, styles: s, classNames: n }),
      ...i
    }
  );
});
bs.classes = tn;
bs.displayName = "@mantine/core/MenuLabel";
const Eg = {
  refProp: "ref"
}, dc = J((e, t) => {
  const { children: n, refProp: o, ...r } = T("MenuTarget", Eg, e);
  if (!ut(n))
    throw new Error(
      "Menu.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
    );
  const s = wn(), a = n.props, i = $e(a.onClick, () => {
    s.trigger === "click" ? s.toggleDropdown() : s.trigger === "click-hover" && (s.setOpenedViaClick(!0), s.opened || s.openDropdown());
  }), c = $e(
    a.onMouseEnter,
    () => (s.trigger === "hover" || s.trigger === "click-hover") && s.openDropdown()
  ), l = $e(a.onMouseLeave, () => {
    (s.trigger === "hover" || s.trigger === "click-hover" && !s.openedViaClick) && s.closeDropdown();
  });
  return /* @__PURE__ */ v(Ne.Target, { refProp: o, popupType: "menu", ref: t, ...r, children: ct(n, {
    onClick: i,
    onMouseEnter: c,
    onMouseLeave: l,
    "data-expanded": s.opened ? !0 : void 0
  }) });
});
dc.displayName = "@mantine/core/MenuTarget";
const kg = {
  trapFocus: !0,
  closeOnItemClick: !0,
  withInitialFocusPlaceholder: !0,
  clickOutsideEvents: ["mousedown", "touchstart", "keydown"],
  loop: !0,
  trigger: "click",
  openDelay: 0,
  closeDelay: 100,
  menuItemTabIndex: -1
};
function xt(e) {
  const t = T("Menu", kg, e), {
    children: n,
    onOpen: o,
    onClose: r,
    opened: s,
    defaultOpened: a,
    trapFocus: i,
    onChange: c,
    closeOnItemClick: l,
    loop: u,
    closeOnEscape: d,
    trigger: p,
    openDelay: f,
    closeDelay: h,
    classNames: m,
    styles: g,
    unstyled: b,
    variant: w,
    vars: y,
    menuItemTabIndex: S,
    keepMounted: x,
    withInitialFocusPlaceholder: C,
    ...R
  } = t, P = K({
    name: "Menu",
    classes: tn,
    props: t,
    classNames: m,
    styles: g,
    unstyled: b
  }), [M, { setHovered: I, resetHovered: H }] = Wu(), [z, j] = st({
    value: s,
    defaultValue: a,
    finalValue: !1,
    onChange: c
  }), [B, V] = W(!1), O = () => {
    j(!1), V(!1), z && r?.();
  }, L = () => {
    j(!0), !z && o?.();
  }, N = () => {
    z ? O() : L();
  }, { openDropdown: $, closeDropdown: k } = ec({ open: L, close: O, closeDelay: h, openDelay: f }), A = (se) => Vu("[data-menu-item]", "[data-menu-dropdown]", se), { resolvedClassNames: q, resolvedStyles: ee } = qn({
    classNames: m,
    styles: g,
    props: t
  });
  return ht(() => {
    H();
  }, [z]), /* @__PURE__ */ v(
    $g,
    {
      value: {
        getStyles: P,
        opened: z,
        toggleDropdown: N,
        getItemIndex: A,
        hovered: M,
        setHovered: I,
        openedViaClick: B,
        setOpenedViaClick: V,
        closeOnItemClick: l,
        closeDropdown: p === "click" ? O : k,
        openDropdown: p === "click" ? L : $,
        closeDropdownImmediately: O,
        loop: u,
        trigger: p,
        unstyled: b,
        menuItemTabIndex: S,
        withInitialFocusPlaceholder: C
      },
      children: /* @__PURE__ */ v(
        Ne,
        {
          ...R,
          opened: z,
          onChange: N,
          defaultOpened: a,
          trapFocus: x ? !1 : i,
          closeOnEscape: d,
          __staticSelector: "Menu",
          classNames: q,
          styles: ee,
          unstyled: b,
          variant: w,
          keepMounted: x,
          children: n
        }
      )
    }
  );
}
xt.extend = (e) => e;
xt.classes = tn;
xt.displayName = "@mantine/core/Menu";
xt.Item = ys;
xt.Label = bs;
xt.Dropdown = gs;
xt.Target = dc;
xt.Divider = vs;
const [Mg, ws] = Ee(
  "Modal component was not found in tree"
);
var Ag = { root: "m_9df02822", content: "m_54c44539", inner: "m_1f958f16", header: "m_d0e2b9cd" };
const Sn = Ag, Dg = {}, fc = F((e, t) => {
  const n = T("ModalBody", Dg, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = ws();
  return /* @__PURE__ */ v(
    Gr,
    {
      ref: t,
      ...l.getStyles("body", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
fc.classes = Sn;
fc.displayName = "@mantine/core/ModalBody";
const Ig = {}, pc = F((e, t) => {
  const n = T("ModalContent", Ig, e), { classNames: o, className: r, style: s, styles: a, vars: i, children: c, __hidden: l, ...u } = n, d = ws(), p = d.scrollAreaComponent || bl;
  return /* @__PURE__ */ v(
    Yr,
    {
      ...d.getStyles("content", { className: r, style: s, styles: a, classNames: o }),
      innerProps: d.getStyles("inner", { className: r, style: s, styles: a, classNames: o }),
      "data-full-screen": d.fullScreen || void 0,
      "data-modal-content": !0,
      "data-hidden": l || void 0,
      ref: t,
      ...u,
      children: /* @__PURE__ */ v(
        p,
        {
          style: {
            maxHeight: d.fullScreen ? "100dvh" : `calc(100dvh - (${E(d.yOffset)} * 2))`
          },
          children: c
        }
      )
    }
  );
});
pc.classes = Sn;
pc.displayName = "@mantine/core/ModalContent";
const Og = {}, mc = F((e, t) => {
  const n = T("ModalOverlay", Og, e), { classNames: o, className: r, style: s, styles: a, vars: i, ...c } = n, l = ws();
  return /* @__PURE__ */ v(
    Kr,
    {
      ref: t,
      ...l.getStyles("overlay", { classNames: o, style: s, styles: a, className: r }),
      ...c
    }
  );
});
mc.classes = Sn;
mc.displayName = "@mantine/core/ModalOverlay";
const Lg = {
  __staticSelector: "Modal",
  closeOnClickOutside: !0,
  withinPortal: !0,
  lockScroll: !0,
  trapFocus: !0,
  returnFocus: !0,
  closeOnEscape: !0,
  keepMounted: !1,
  zIndex: je("modal"),
  transitionProps: { duration: 200, transition: "fade-down" },
  yOffset: "5dvh"
}, zg = (e, { radius: t, size: n, yOffset: o, xOffset: r }) => ({
  root: {
    "--modal-radius": t === void 0 ? void 0 : ie(t),
    "--modal-size": Q(n, "modal-size"),
    "--modal-y-offset": E(o),
    "--modal-x-offset": E(r)
  }
}), hc = F((e, t) => {
  const n = T("ModalRoot", Lg, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    yOffset: l,
    scrollAreaComponent: u,
    radius: d,
    fullScreen: p,
    centered: f,
    xOffset: h,
    __staticSelector: m,
    ...g
  } = n, b = K({
    name: m,
    classes: Sn,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: zg
  });
  return /* @__PURE__ */ v(Mg, { value: { yOffset: l, scrollAreaComponent: u, getStyles: b, fullScreen: p }, children: /* @__PURE__ */ v(
    jr,
    {
      ref: t,
      ...b("root"),
      "data-full-screen": p || void 0,
      "data-centered": f || void 0,
      unstyled: i,
      ...g
    }
  ) });
});
hc.classes = Sn;
hc.displayName = "@mantine/core/ModalRoot";
const [Cb, vc] = mn(), [Bg, Fg] = mn();
var Hg = { root: "m_7cda1cd6", "root--default": "m_44da308b", "root--contrast": "m_e3a01f8", label: "m_1e0e6180", remove: "m_ae386778", group: "m_1dcfd90b" };
const xo = Hg, Vg = {}, Wg = (e, { gap: t }, { size: n }) => ({
  group: {
    "--pg-gap": t !== void 0 ? Q(t) : Q(n, "pg-gap")
  }
}), Ss = F((e, t) => {
  const n = T("PillGroup", Vg, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, size: l, disabled: u, ...d } = n, f = vc()?.size || l || void 0, h = K({
    name: "PillGroup",
    classes: xo,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Wg,
    stylesCtx: { size: f },
    rootSelector: "group"
  });
  return /* @__PURE__ */ v(Bg, { value: { size: f, disabled: u }, children: /* @__PURE__ */ v(D, { ref: t, size: f, ...h("group"), ...d }) });
});
Ss.classes = xo;
Ss.displayName = "@mantine/core/PillGroup";
const jg = {
  variant: "default"
}, Gg = (e, { radius: t }, { size: n }) => ({
  root: {
    "--pill-fz": Q(n, "pill-fz"),
    "--pill-height": Q(n, "pill-height"),
    "--pill-radius": t === void 0 ? void 0 : ie(t)
  }
}), xs = F((e, t) => {
  const n = T("Pill", jg, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    variant: l,
    children: u,
    withRemoveButton: d,
    onRemove: p,
    removeButtonProps: f,
    radius: h,
    size: m,
    disabled: g,
    mod: b,
    ...w
  } = n, y = Fg(), S = vc(), x = m || y?.size || void 0, C = S?.variant === "filled" ? "contrast" : l || "default", R = K({
    name: "Pill",
    classes: xo,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Gg,
    stylesCtx: { size: x }
  });
  return /* @__PURE__ */ Z(
    D,
    {
      component: "span",
      ref: t,
      variant: C,
      size: x,
      ...R("root", { variant: C }),
      mod: [
        { "with-remove": d && !g, disabled: g || y?.disabled },
        b
      ],
      ...w,
      children: [
        /* @__PURE__ */ v("span", { ...R("label"), children: u }),
        d && /* @__PURE__ */ v(
          Mt,
          {
            variant: "transparent",
            radius: h,
            tabIndex: -1,
            "aria-hidden": !0,
            unstyled: i,
            ...f,
            ...R("remove", {
              className: f?.className,
              style: f?.style
            }),
            onMouseDown: (P) => {
              P.preventDefault(), P.stopPropagation(), f?.onMouseDown?.(P);
            },
            onClick: (P) => {
              P.stopPropagation(), p?.(), f?.onClick?.(P);
            }
          }
        )
      ]
    }
  );
});
xs.classes = xo;
xs.displayName = "@mantine/core/Pill";
xs.Group = Ss;
var Yg = { root: "m_a513464", icon: "m_a4ceffb", loader: "m_b0920b15", body: "m_a49ed24", title: "m_3feedf16", description: "m_3d733a3a", closeButton: "m_919a4d88" };
const gc = Yg, Kg = {
  withCloseButton: !0
}, Xg = (e, { radius: t, color: n }) => ({
  root: {
    "--notification-radius": t === void 0 ? void 0 : ie(t),
    "--notification-color": n ? xe(n, e) : void 0
  }
}), yc = F((e, t) => {
  const n = T("Notification", Kg, e), {
    className: o,
    color: r,
    radius: s,
    loading: a,
    withCloseButton: i,
    withBorder: c,
    title: l,
    icon: u,
    children: d,
    onClose: p,
    closeButtonProps: f,
    classNames: h,
    style: m,
    styles: g,
    unstyled: b,
    variant: w,
    vars: y,
    mod: S,
    ...x
  } = n, C = K({
    name: "Notification",
    classes: gc,
    props: n,
    className: o,
    style: m,
    classNames: h,
    styles: g,
    unstyled: b,
    vars: y,
    varsResolver: Xg
  });
  return /* @__PURE__ */ Z(
    D,
    {
      ...C("root"),
      mod: [{ "data-with-icon": !!u || a, "data-with-border": c }, S],
      ref: t,
      variant: w,
      ...x,
      role: "alert",
      children: [
        u && !a && /* @__PURE__ */ v("div", { ...C("icon"), children: u }),
        a && /* @__PURE__ */ v(kt, { size: 28, color: r, ...C("loader") }),
        /* @__PURE__ */ Z("div", { ...C("body"), children: [
          l && /* @__PURE__ */ v("div", { ...C("title"), children: l }),
          /* @__PURE__ */ v(D, { ...C("description"), mod: { "data-with-title": !!l }, children: d })
        ] }),
        i && /* @__PURE__ */ v(
          Mt,
          {
            iconSize: 16,
            color: "gray",
            ...f,
            unstyled: b,
            onClick: p,
            ...C("closeButton")
          }
        )
      ]
    }
  );
});
yc.classes = gc;
yc.displayName = "@mantine/core/Notification";
const Ug = {
  duration: 100,
  transition: "fade"
};
function qg(e, t) {
  return { ...Ug, ...t, ...e };
}
function Zg({
  offset: e,
  position: t,
  defaultOpened: n
}) {
  const [o, r] = W(n), s = G(null), { x: a, y: i, elements: c, refs: l, update: u, placement: d } = Br({
    placement: t,
    middleware: [
      Ir({
        crossAxis: !0,
        padding: 5,
        rootBoundary: "document"
      })
    ]
  }), p = d.includes("right") ? e : t.includes("left") ? e * -1 : 0, f = d.includes("bottom") ? e : t.includes("top") ? e * -1 : 0, h = Y(
    ({ clientX: m, clientY: g }) => {
      l.setPositionReference({
        getBoundingClientRect() {
          return {
            width: 0,
            height: 0,
            x: m,
            y: g,
            left: m + p,
            top: g + f,
            right: m,
            bottom: g
          };
        }
      });
    },
    [c.reference]
  );
  return U(() => {
    if (l.floating.current) {
      const m = s.current;
      m.addEventListener("mousemove", h);
      const g = rt(l.floating.current);
      return g.forEach((b) => {
        b.addEventListener("scroll", u);
      }), () => {
        m.removeEventListener("mousemove", h), g.forEach((b) => {
          b.removeEventListener("scroll", u);
        });
      };
    }
  }, [c.reference, l.floating.current, u, h, o]), { handleMouseMove: h, x: a, y: i, opened: o, setOpened: r, boundaryRef: s, floating: l.setFloating };
}
var Jg = { tooltip: "m_1b3c8819", arrow: "m_f898399f" };
const Co = Jg, Qg = {
  refProp: "ref",
  withinPortal: !0,
  offset: 10,
  defaultOpened: !1,
  position: "right",
  zIndex: je("popover")
}, ey = (e, { radius: t, color: n }) => ({
  tooltip: {
    "--tooltip-radius": t === void 0 ? void 0 : ie(t),
    "--tooltip-bg": n ? xe(n, e) : void 0,
    "--tooltip-color": n ? "var(--mantine-color-white)" : void 0
  }
}), Cs = F((e, t) => {
  const n = T("TooltipFloating", Qg, e), {
    children: o,
    refProp: r,
    withinPortal: s,
    style: a,
    className: i,
    classNames: c,
    styles: l,
    unstyled: u,
    radius: d,
    color: p,
    label: f,
    offset: h,
    position: m,
    multiline: g,
    zIndex: b,
    disabled: w,
    defaultOpened: y,
    variant: S,
    vars: x,
    portalProps: C,
    ...R
  } = n, P = ye(), M = K({
    name: "TooltipFloating",
    props: n,
    classes: Co,
    className: i,
    style: a,
    classNames: c,
    styles: l,
    unstyled: u,
    rootSelector: "tooltip",
    vars: x,
    varsResolver: ey
  }), { handleMouseMove: I, x: H, y: z, opened: j, boundaryRef: B, floating: V, setOpened: O } = Zg({
    offset: h,
    position: m,
    defaultOpened: y
  });
  if (!ut(o))
    throw new Error(
      "[@mantine/core] Tooltip.Floating component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const L = ue(B, Yn(o), t), N = o.props, $ = (A) => {
    N.onMouseEnter?.(A), I(A), O(!0);
  }, k = (A) => {
    N.onMouseLeave?.(A), O(!1);
  };
  return /* @__PURE__ */ Z(Ce, { children: [
    /* @__PURE__ */ v(Zt, { ...C, withinPortal: s, children: /* @__PURE__ */ v(
      D,
      {
        ...R,
        ...M("tooltip", {
          style: {
            ...gi(a, P),
            zIndex: b,
            display: !w && j ? "block" : "none",
            top: (z && Math.round(z)) ?? "",
            left: (H && Math.round(H)) ?? ""
          }
        }),
        variant: S,
        ref: V,
        mod: { multiline: g },
        children: f
      }
    ) }),
    ct(o, {
      ...N,
      [r]: L,
      onMouseEnter: $,
      onMouseLeave: k
    })
  ] });
});
Cs.classes = Co;
Cs.displayName = "@mantine/core/TooltipFloating";
const bc = Kt(!1), ty = bc.Provider, ny = () => gt(bc), oy = {
  openDelay: 0,
  closeDelay: 0
};
function $s(e) {
  const { openDelay: t, closeDelay: n, children: o } = T("TooltipGroup", oy, e);
  return /* @__PURE__ */ v(ty, { value: !0, children: /* @__PURE__ */ v(am, { delay: { open: t, close: n }, children: o }) });
}
$s.displayName = "@mantine/core/TooltipGroup";
$s.extend = (e) => e;
function ry(e) {
  if (e === void 0)
    return { shift: !0, flip: !0 };
  const t = { ...e };
  return e.shift === void 0 && (t.shift = !0), e.flip === void 0 && (t.flip = !0), t;
}
function sy(e) {
  const t = ry(e.middlewares), n = [Ui(e.offset)];
  return t.shift && n.push(
    Ir(
      typeof t.shift == "boolean" ? { padding: 8 } : { padding: 8, ...t.shift }
    )
  ), t.flip && n.push(
    typeof t.flip == "boolean" ? Hn() : Hn(t.flip)
  ), n.push(qi({ element: e.arrowRef, padding: e.arrowOffset })), t.inline ? n.push(
    typeof t.inline == "boolean" ? ln() : ln(t.inline)
  ) : e.inline && n.push(ln()), n;
}
function ay(e) {
  const [t, n] = W(e.defaultOpened), r = typeof e.opened == "boolean" ? e.opened : t, s = ny(), a = Je(), i = Y(
    (C) => {
      n(C), C && w(a);
    },
    [a]
  ), {
    x: c,
    y: l,
    context: u,
    refs: d,
    update: p,
    placement: f,
    middlewareData: { arrow: { x: h, y: m } = {} }
  } = Br({
    strategy: e.strategy,
    placement: e.position,
    open: r,
    onOpenChange: i,
    middleware: sy(e)
  }), { delay: g, currentId: b, setCurrentId: w } = im(u, { id: a }), { getReferenceProps: y, getFloatingProps: S } = mm([
    rm(u, {
      enabled: e.events?.hover,
      delay: s ? g : { open: e.openDelay, close: e.closeDelay },
      mouseOnly: !e.events?.touch
    }),
    pm(u, { enabled: e.events?.focus, visibleOnly: !0 }),
    vm(u, { role: "tooltip" }),
    // Cannot be used with controlled tooltip, page jumps
    dm(u, { enabled: typeof e.opened > "u" })
  ]);
  il({
    opened: r,
    position: e.position,
    positionDependencies: e.positionDependencies,
    floating: { refs: d, update: p }
  }), ht(() => {
    e.onPositionChange?.(f);
  }, [f]);
  const x = r && b && b !== a;
  return {
    x: c,
    y: l,
    arrowX: h,
    arrowY: m,
    reference: d.setReference,
    floating: d.setFloating,
    getFloatingProps: S,
    getReferenceProps: y,
    isGroupPhase: x,
    opened: r,
    placement: f
  };
}
const Ma = {
  position: "top",
  refProp: "ref",
  withinPortal: !0,
  inline: !1,
  defaultOpened: !1,
  arrowSize: 4,
  arrowOffset: 5,
  arrowRadius: 0,
  arrowPosition: "side",
  offset: 5,
  transitionProps: { duration: 100, transition: "fade" },
  events: { hover: !0, focus: !1, touch: !1 },
  zIndex: je("popover"),
  positionDependencies: [],
  middlewares: { flip: !0, shift: !0, inline: !1 }
}, iy = (e, { radius: t, color: n }) => ({
  tooltip: {
    "--tooltip-radius": t === void 0 ? void 0 : ie(t),
    "--tooltip-bg": n ? xe(n, e) : void 0,
    "--tooltip-color": n ? "var(--mantine-color-white)" : void 0
  }
}), $o = F((e, t) => {
  const n = T("Tooltip", Ma, e), {
    children: o,
    position: r,
    refProp: s,
    label: a,
    openDelay: i,
    closeDelay: c,
    onPositionChange: l,
    opened: u,
    defaultOpened: d,
    withinPortal: p,
    radius: f,
    color: h,
    classNames: m,
    styles: g,
    unstyled: b,
    style: w,
    className: y,
    withArrow: S,
    arrowSize: x,
    arrowOffset: C,
    arrowRadius: R,
    arrowPosition: P,
    offset: M,
    transitionProps: I,
    multiline: H,
    events: z,
    zIndex: j,
    disabled: B,
    positionDependencies: V,
    onClick: O,
    onMouseEnter: L,
    onMouseLeave: N,
    inline: $,
    variant: k,
    keepMounted: A,
    vars: q,
    portalProps: ee,
    mod: se,
    floatingStrategy: ne,
    middlewares: X,
    ...te
  } = T("Tooltip", Ma, n), { dir: ge } = wt(), le = G(null), de = ay({
    position: el(ge, r),
    closeDelay: c,
    openDelay: i,
    onPositionChange: l,
    opened: u,
    defaultOpened: d,
    events: z,
    arrowRef: le,
    arrowOffset: C,
    offset: typeof M == "number" ? M + (S ? x / 2 : 0) : M,
    positionDependencies: [...V, o],
    inline: $,
    strategy: ne,
    middlewares: X
  }), ke = K({
    name: "Tooltip",
    props: n,
    classes: Co,
    className: y,
    style: w,
    classNames: m,
    styles: g,
    unstyled: b,
    rootSelector: "tooltip",
    vars: q,
    varsResolver: iy
  });
  if (!ut(o))
    throw new Error(
      "[@mantine/core] Tooltip component children should be an element or a component that accepts ref, fragments, strings, numbers and other primitive values are not supported"
    );
  const nt = ue(de.reference, Yn(o), t), Ge = qg(I, { duration: 100, transition: "fade" }), fe = o.props;
  return /* @__PURE__ */ Z(Ce, { children: [
    /* @__PURE__ */ v(Zt, { ...ee, withinPortal: p, children: /* @__PURE__ */ v(
      et,
      {
        ...Ge,
        keepMounted: A,
        mounted: !B && !!de.opened,
        duration: de.isGroupPhase ? 10 : Ge.duration,
        children: (ae) => /* @__PURE__ */ Z(
          D,
          {
            ...te,
            "data-fixed": ne === "fixed" || void 0,
            variant: k,
            mod: [{ multiline: H }, se],
            ...de.getFloatingProps({
              ref: de.floating,
              className: ke("tooltip").className,
              style: {
                ...ke("tooltip").style,
                ...ae,
                zIndex: j,
                top: de.y ?? 0,
                left: de.x ?? 0
              }
            }),
            children: [
              a,
              /* @__PURE__ */ v(
                Fr,
                {
                  ref: le,
                  arrowX: de.arrowX,
                  arrowY: de.arrowY,
                  visible: S,
                  position: de.placement,
                  arrowSize: x,
                  arrowOffset: C,
                  arrowRadius: R,
                  arrowPosition: P,
                  ...ke("arrow")
                }
              )
            ]
          }
        )
      }
    ) }),
    ct(
      o,
      de.getReferenceProps({
        onClick: O,
        onMouseEnter: L,
        onMouseLeave: N,
        onMouseMove: n.onMouseMove,
        onPointerDown: n.onPointerDown,
        onPointerEnter: n.onPointerEnter,
        [s]: nt,
        className: ve(y, fe.className),
        ...fe
      })
    )
  ] });
});
$o.classes = Co;
$o.displayName = "@mantine/core/Tooltip";
$o.Floating = Cs;
$o.Group = $s;
var ly = { root: "m_cf365364", indicator: "m_9e182ccd", label: "m_1738fcb2", input: "m_1714d588", control: "m_69686b9b", innerLabel: "m_78882f40" };
const wc = ly, cy = {
  withItemsBorders: !0
}, uy = (e, { radius: t, color: n, transitionDuration: o, size: r, transitionTimingFunction: s }) => ({
  root: {
    "--sc-radius": t === void 0 ? void 0 : ie(t),
    "--sc-color": n ? xe(n, e) : void 0,
    "--sc-shadow": n ? void 0 : "var(--mantine-shadow-xs)",
    "--sc-transition-duration": o === void 0 ? void 0 : `${o}ms`,
    "--sc-transition-timing-function": s,
    "--sc-padding": Q(r, "sc-padding"),
    "--sc-font-size": Se(r)
  }
}), Sc = F((e, t) => {
  const n = T("SegmentedControl", cy, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    data: l,
    value: u,
    defaultValue: d,
    onChange: p,
    size: f,
    name: h,
    disabled: m,
    readOnly: g,
    fullWidth: b,
    orientation: w,
    radius: y,
    color: S,
    transitionDuration: x,
    transitionTimingFunction: C,
    variant: R,
    autoContrast: P,
    withItemsBorders: M,
    mod: I,
    ...H
  } = n, z = K({
    name: "SegmentedControl",
    props: n,
    classes: wc,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: uy
  }), j = ye(), B = l.map(
    (X) => typeof X == "string" ? { label: X, value: X } : X
  ), V = bd(), [O, L] = W(null), [N, $] = W({}), k = (X, te) => {
    N[te] = X, $(N);
  }, [A, q] = st({
    value: u,
    defaultValue: d,
    finalValue: Array.isArray(l) ? B.find((X) => !X.disabled)?.value ?? l[0]?.value ?? null : null,
    onChange: p
  }), ee = Je(h), se = B.map((X) => /* @__PURE__ */ an(
    D,
    {
      ...z("control"),
      mod: { active: A === X.value, orientation: w },
      key: X.value
    },
    /* @__PURE__ */ an(
      "input",
      {
        ...z("input"),
        disabled: m || X.disabled,
        type: "radio",
        name: ee,
        value: X.value,
        id: `${ee}-${X.value}`,
        checked: A === X.value,
        onChange: () => !g && q(X.value),
        "data-focus-ring": j.focusRing,
        key: `${X.value}-input`
      }
    ),
    /* @__PURE__ */ an(
      D,
      {
        component: "label",
        ...z("label"),
        mod: {
          active: A === X.value && !(m || X.disabled),
          disabled: m || X.disabled,
          "read-only": g
        },
        htmlFor: `${ee}-${X.value}`,
        ref: (te) => k(te, X.value),
        __vars: {
          "--sc-label-color": S !== void 0 ? wr({ color: S, theme: j, autoContrast: P }) : void 0
        },
        key: `${X.value}-label`
      },
      /* @__PURE__ */ v("span", { ...z("innerLabel"), children: X.label })
    )
  )), ne = ue(t, (X) => L(X));
  return l.length === 0 ? null : /* @__PURE__ */ Z(
    D,
    {
      ...z("root"),
      variant: R,
      size: f,
      ref: ne,
      mod: [
        {
          "full-width": b,
          orientation: w,
          initialized: V,
          "with-items-borders": M
        },
        I
      ],
      ...H,
      role: "radiogroup",
      "data-disabled": m,
      children: [
        typeof A == "string" && /* @__PURE__ */ v(
          qr,
          {
            target: N[A],
            parent: O,
            component: "span",
            transitionDuration: "var(--sc-transition-duration)",
            ...z("indicator")
          }
        ),
        se
      ]
    }
  );
});
Sc.classes = wc;
Sc.displayName = "@mantine/core/SegmentedControl";
const dy = {
  searchable: !1,
  withCheckIcon: !0,
  allowDeselect: !0,
  checkIconPosition: "left"
}, xc = F((e, t) => {
  const n = T("Select", dy, e), {
    classNames: o,
    styles: r,
    unstyled: s,
    vars: a,
    dropdownOpened: i,
    defaultDropdownOpened: c,
    onDropdownClose: l,
    onDropdownOpen: u,
    onFocus: d,
    onBlur: p,
    onClick: f,
    onChange: h,
    data: m,
    value: g,
    defaultValue: b,
    selectFirstOptionOnChange: w,
    onOptionSubmit: y,
    comboboxProps: S,
    readOnly: x,
    disabled: C,
    filter: R,
    limit: P,
    withScrollArea: M,
    maxDropdownHeight: I,
    size: H,
    searchable: z,
    rightSection: j,
    checkIconPosition: B,
    withCheckIcon: V,
    nothingFoundMessage: O,
    name: L,
    form: N,
    searchValue: $,
    defaultSearchValue: k,
    onSearchChange: A,
    allowDeselect: q,
    error: ee,
    rightSectionPointerEvents: se,
    id: ne,
    clearable: X,
    clearButtonProps: te,
    hiddenInputProps: ge,
    renderOption: le,
    onClear: de,
    autoComplete: ke,
    scrollAreaProps: nt,
    __defaultRightSection: Ge,
    __clearSection: fe,
    __clearable: ae,
    chevronColor: pe,
    ...pt
  } = n, Ct = Nt(() => Lh(m), [m]), Ye = Nt(() => Tl(Ct), [Ct]), me = Je(ne), [Me, $n, Ro] = st({
    value: g,
    defaultValue: b,
    finalValue: null,
    onChange: h
  }), ze = typeof Me == "string" ? Ye[Me] : void 0, Ke = gd(ze), [No, At] = st({
    value: $,
    defaultValue: k,
    finalValue: ze ? ze.label : "",
    onChange: A
  }), Be = Il({
    opened: i,
    defaultOpened: c,
    onDropdownOpen: () => {
      u?.(), Be.updateSelectedOptionIndex("active", { scrollIntoView: !0 });
    },
    onDropdownClose: () => {
      l?.(), Be.resetSelectedOption();
    }
  }), { resolvedClassNames: Es, resolvedStyles: ks } = qn({
    props: n,
    styles: r,
    classNames: o
  });
  U(() => {
    w && Be.selectFirstOption();
  }, [w, Me]), U(() => {
    g === null && At(""), typeof g == "string" && ze && (Ke?.value !== ze.value || Ke?.label !== ze.label) && At(ze.label);
  }, [g, ze]);
  const Yc = /* @__PURE__ */ v(
    oe.ClearButton,
    {
      ...te,
      onClear: () => {
        $n(null, null), At(""), de?.();
      }
    }
  ), Ms = X && !!Me && !C && !x;
  return /* @__PURE__ */ Z(Ce, { children: [
    /* @__PURE__ */ Z(
      oe,
      {
        store: Be,
        __staticSelector: "Select",
        classNames: Es,
        styles: ks,
        unstyled: s,
        readOnly: x,
        onOptionSubmit: (Ae) => {
          y?.(Ae);
          const Pn = q && Ye[Ae].value === Me ? null : Ye[Ae], To = Pn ? Pn.value : null;
          To !== Me && $n(To, Pn), !Ro && At(typeof To == "string" && Pn?.label || ""), Be.closeDropdown();
        },
        size: H,
        ...S,
        children: [
          /* @__PURE__ */ v(oe.Target, { targetType: z ? "input" : "button", autoComplete: ke, children: /* @__PURE__ */ v(
            uo,
            {
              id: me,
              ref: t,
              __defaultRightSection: /* @__PURE__ */ v(
                oe.Chevron,
                {
                  size: H,
                  error: ee,
                  unstyled: s,
                  color: pe
                }
              ),
              __clearSection: Yc,
              __clearable: Ms,
              rightSection: j,
              rightSectionPointerEvents: se || (Ms ? "all" : "none"),
              ...pt,
              size: H,
              __staticSelector: "Select",
              disabled: C,
              readOnly: x || !z,
              value: No,
              onChange: (Ae) => {
                At(Ae.currentTarget.value), Be.openDropdown(), w && Be.selectFirstOption();
              },
              onFocus: (Ae) => {
                z && Be.openDropdown(), d?.(Ae);
              },
              onBlur: (Ae) => {
                z && Be.closeDropdown(), At(Me != null && Ye[Me]?.label || ""), p?.(Ae);
              },
              onClick: (Ae) => {
                z ? Be.openDropdown() : Be.toggleDropdown(), f?.(Ae);
              },
              classNames: Es,
              styles: ks,
              unstyled: s,
              pointer: !z,
              error: ee
            }
          ) }),
          /* @__PURE__ */ v(
            lv,
            {
              data: Ct,
              hidden: x || C,
              filter: R,
              search: No,
              limit: P,
              hiddenWhenEmpty: !O,
              withScrollArea: M,
              maxDropdownHeight: I,
              filterOptions: z && ze?.label !== No,
              value: Me,
              checkIconPosition: B,
              withCheckIcon: V,
              nothingFoundMessage: O,
              unstyled: s,
              labelId: pt.label ? `${me}-label` : void 0,
              "aria-label": pt.label ? void 0 : pt["aria-label"],
              renderOption: le,
              scrollAreaProps: nt
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ v(
      oe.HiddenInput,
      {
        value: Me,
        name: L,
        form: N,
        disabled: C,
        ...ge
      }
    )
  ] });
});
xc.classes = { ...uo.classes, ...oe.classes };
xc.displayName = "@mantine/core/Select";
function fy({
  spacing: e,
  verticalSpacing: t,
  cols: n,
  selector: o
}) {
  const r = ye(), s = t === void 0 ? e : t, a = yt({
    "--sg-spacing-x": we(Fe(e)),
    "--sg-spacing-y": we(Fe(s)),
    "--sg-cols": Fe(n)?.toString()
  }), i = ce(r.breakpoints).reduce(
    (u, d) => (u[d] || (u[d] = {}), typeof e == "object" && e[d] !== void 0 && (u[d]["--sg-spacing-x"] = we(e[d])), typeof s == "object" && s[d] !== void 0 && (u[d]["--sg-spacing-y"] = we(s[d])), typeof n == "object" && n[d] !== void 0 && (u[d]["--sg-cols"] = n[d]), u),
    {}
  ), l = vr(ce(i), r.breakpoints).filter(
    (u) => ce(i[u.value]).length > 0
  ).map((u) => ({
    query: `(min-width: ${r.breakpoints[u.value]})`,
    styles: i[u.value]
  }));
  return /* @__PURE__ */ v(Xt, { styles: a, media: l, selector: o });
}
function Xo(e) {
  return typeof e == "object" && e !== null ? ce(e) : [];
}
function py(e) {
  return e.sort((t, n) => cn(t) - cn(n));
}
function my({
  spacing: e,
  verticalSpacing: t,
  cols: n
}) {
  const o = Array.from(
    /* @__PURE__ */ new Set([
      ...Xo(e),
      ...Xo(t),
      ...Xo(n)
    ])
  );
  return py(o);
}
function hy({
  spacing: e,
  verticalSpacing: t,
  cols: n,
  selector: o
}) {
  const r = t === void 0 ? e : t, s = yt({
    "--sg-spacing-x": we(Fe(e)),
    "--sg-spacing-y": we(Fe(r)),
    "--sg-cols": Fe(n)?.toString()
  }), a = my({ spacing: e, verticalSpacing: t, cols: n }), i = a.reduce(
    (l, u) => (l[u] || (l[u] = {}), typeof e == "object" && e[u] !== void 0 && (l[u]["--sg-spacing-x"] = we(e[u])), typeof r == "object" && r[u] !== void 0 && (l[u]["--sg-spacing-y"] = we(r[u])), typeof n == "object" && n[u] !== void 0 && (l[u]["--sg-cols"] = n[u]), l),
    {}
  ), c = a.map((l) => ({
    query: `simple-grid (min-width: ${l})`,
    styles: i[l]
  }));
  return /* @__PURE__ */ v(Xt, { styles: s, container: c, selector: o });
}
var vy = { container: "m_925c2d2c", root: "m_2415a157" };
const Cc = vy, gy = {
  cols: 1,
  spacing: "md",
  type: "media"
}, $c = F((e, t) => {
  const n = T("SimpleGrid", gy, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    cols: l,
    verticalSpacing: u,
    spacing: d,
    type: p,
    ...f
  } = n, h = K({
    name: "SimpleGrid",
    classes: Cc,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c
  }), m = vn();
  return p === "container" ? /* @__PURE__ */ Z(Ce, { children: [
    /* @__PURE__ */ v(hy, { ...n, selector: `.${m}` }),
    /* @__PURE__ */ v("div", { ...h("container"), children: /* @__PURE__ */ v(D, { ref: t, ...h("root", { className: m }), ...f }) })
  ] }) : /* @__PURE__ */ Z(Ce, { children: [
    /* @__PURE__ */ v(fy, { ...n, selector: `.${m}` }),
    /* @__PURE__ */ v(D, { ref: t, ...h("root", { className: m }), ...f })
  ] });
});
$c.classes = Cc;
$c.displayName = "@mantine/core/SimpleGrid";
const [yy, Po] = Ee(
  "SliderProvider was not found in tree"
), Pc = J(
  ({ size: e, disabled: t, variant: n, color: o, thumbSize: r, radius: s, ...a }, i) => {
    const { getStyles: c } = Po();
    return /* @__PURE__ */ v(
      D,
      {
        tabIndex: -1,
        variant: n,
        size: e,
        ref: i,
        ...c("root"),
        ...a
      }
    );
  }
);
Pc.displayName = "@mantine/core/SliderRoot";
const _c = J(
  ({
    max: e,
    min: t,
    value: n,
    position: o,
    label: r,
    dragging: s,
    onMouseDown: a,
    onKeyDownCapture: i,
    labelTransitionProps: c,
    labelAlwaysOn: l,
    thumbLabel: u,
    onFocus: d,
    onBlur: p,
    showLabelOnHover: f,
    isHovered: h,
    children: m = null,
    disabled: g
  }, b) => {
    const { getStyles: w } = Po(), [y, S] = W(!1), x = l || s || y || f && h;
    return /* @__PURE__ */ Z(
      D,
      {
        tabIndex: 0,
        role: "slider",
        "aria-label": u,
        "aria-valuemax": e,
        "aria-valuemin": t,
        "aria-valuenow": n,
        ref: b,
        __vars: { "--slider-thumb-offset": `${o}%` },
        ...w("thumb", { focusable: !0 }),
        mod: { dragging: s, disabled: g },
        onFocus: (C) => {
          S(!0), typeof d == "function" && d(C);
        },
        onBlur: (C) => {
          S(!1), typeof p == "function" && p(C);
        },
        onTouchStart: a,
        onMouseDown: a,
        onKeyDownCapture: i,
        onClick: (C) => C.stopPropagation(),
        children: [
          m,
          /* @__PURE__ */ v(
            et,
            {
              mounted: r != null && !!x,
              transition: "fade",
              duration: 0,
              ...c,
              children: (C) => /* @__PURE__ */ v("div", { ...w("label", { style: C }), children: r })
            }
          )
        ]
      }
    );
  }
);
_c.displayName = "@mantine/core/SliderThumb";
function Rc({ value: e, min: t, max: n }) {
  const o = (e - t) / (n - t) * 100;
  return Math.min(Math.max(o, 0), 100);
}
function by({ mark: e, offset: t, value: n, inverted: o = !1 }) {
  return o ? typeof t == "number" && e.value <= t || e.value >= n : typeof t == "number" ? e.value >= t && e.value <= n : e.value <= n;
}
function Nc({ marks: e, min: t, max: n, disabled: o, value: r, offset: s, inverted: a }) {
  const { getStyles: i } = Po();
  if (!e)
    return null;
  const c = e.map((l, u) => /* @__PURE__ */ an(
    D,
    {
      ...i("markWrapper"),
      __vars: { "--mark-offset": `${Rc({ value: l.value, min: t, max: n })}%` },
      key: u
    },
    /* @__PURE__ */ v(
      D,
      {
        ...i("mark"),
        mod: { filled: by({ mark: l, value: r, offset: s, inverted: a }), disabled: o }
      }
    ),
    l.label && /* @__PURE__ */ v("div", { ...i("markLabel"), children: l.label })
  ));
  return /* @__PURE__ */ v("div", { children: c });
}
Nc.displayName = "@mantine/core/SliderMarks";
function Tc({
  filled: e,
  children: t,
  offset: n,
  disabled: o,
  marksOffset: r,
  inverted: s,
  containerProps: a,
  ...i
}) {
  const { getStyles: c } = Po();
  return /* @__PURE__ */ v(D, { ...c("trackContainer"), mod: { disabled: o }, ...a, children: /* @__PURE__ */ Z(D, { ...c("track"), mod: { inverted: s, disabled: o }, children: [
    /* @__PURE__ */ v(
      D,
      {
        mod: { inverted: s, disabled: o },
        __vars: {
          "--slider-bar-width": `calc(${e}% + var(--slider-size))`,
          "--slider-bar-offset": `calc(${n}% - var(--slider-size))`
        },
        ...c("bar")
      }
    ),
    t,
    /* @__PURE__ */ v(Nc, { ...i, offset: r, disabled: o, inverted: s })
  ] }) });
}
Tc.displayName = "@mantine/core/SliderTrack";
function wy({
  value: e,
  containerWidth: t,
  min: n,
  max: o,
  step: r,
  precision: s
}) {
  const i = (t ? Math.min(Math.max(e, 0), t) / t : e) * (o - n), c = (i !== 0 ? Math.round(i / r) * r : 0) + n, l = Math.max(c, n);
  return s !== void 0 ? Number(l.toFixed(s)) : l;
}
function Mn(e, t) {
  return parseFloat(e.toFixed(t));
}
function Sy(e) {
  if (!e)
    return 0;
  const t = e.toString().split(".");
  return t.length > 1 ? t[1].length : 0;
}
function Uo(e, t) {
  const o = [...t].sort((r, s) => r.value - s.value).find((r) => r.value > e);
  return o ? o.value : e;
}
function qo(e, t) {
  const o = [...t].sort((r, s) => s.value - r.value).find((r) => r.value < e);
  return o ? o.value : e;
}
function Aa(e) {
  const t = [...e].sort((n, o) => n.value - o.value);
  return t.length > 0 ? t[0].value : 0;
}
function Da(e) {
  const t = [...e].sort((n, o) => n.value - o.value);
  return t.length > 0 ? t[t.length - 1].value : 100;
}
var xy = { root: "m_dd36362e", label: "m_c9357328", thumb: "m_c9a9a60a", trackContainer: "m_a8645c2", track: "m_c9ade57f", bar: "m_38aeed47", markWrapper: "m_b7b0423a", mark: "m_dd33bc19", markLabel: "m_68c77a5b" };
const Ec = xy, Cy = {
  radius: "xl",
  min: 0,
  max: 100,
  step: 1,
  marks: [],
  label: (e) => e,
  labelTransitionProps: { transition: "fade", duration: 0 },
  labelAlwaysOn: !1,
  thumbLabel: "",
  showLabelOnHover: !0,
  disabled: !1,
  scale: (e) => e
}, $y = (e, { size: t, color: n, thumbSize: o, radius: r }) => ({
  root: {
    "--slider-size": Q(t, "slider-size"),
    "--slider-color": n ? xe(n, e) : void 0,
    "--slider-radius": r === void 0 ? void 0 : ie(r),
    "--slider-thumb-size": o !== void 0 ? E(o) : "calc(var(--slider-size) * 2)"
  }
}), kc = F((e, t) => {
  const n = T("Slider", Cy, e), {
    classNames: o,
    styles: r,
    value: s,
    onChange: a,
    onChangeEnd: i,
    size: c,
    min: l,
    max: u,
    step: d,
    precision: p,
    defaultValue: f,
    name: h,
    marks: m,
    label: g,
    labelTransitionProps: b,
    labelAlwaysOn: w,
    thumbLabel: y,
    showLabelOnHover: S,
    thumbChildren: x,
    disabled: C,
    unstyled: R,
    scale: P,
    inverted: M,
    className: I,
    style: H,
    vars: z,
    hiddenInputProps: j,
    restrictToMarks: B,
    thumbProps: V,
    ...O
  } = n, L = K({
    name: "Slider",
    props: n,
    classes: Ec,
    classNames: o,
    className: I,
    styles: r,
    style: H,
    vars: z,
    varsResolver: $y,
    unstyled: R
  }), { dir: N } = wt(), [$, k] = W(!1), [A, q] = st({
    value: typeof s == "number" ? _t(s, l, u) : s,
    defaultValue: typeof f == "number" ? _t(f, l, u) : f,
    finalValue: _t(0, l, u),
    onChange: a
  }), ee = G(A), se = G(null), ne = G(null), X = Rc({ value: A, min: l, max: u }), te = P(A), ge = typeof g == "function" ? g(te) : g, le = p ?? Sy(d), de = Y(
    ({ x: fe }) => {
      if (!C) {
        const ae = wy({
          value: fe,
          min: l,
          max: u,
          step: d,
          precision: le
        });
        q(
          B && m?.length ? Vs(
            ae,
            m.map((pe) => pe.value)
          ) : ae
        ), ee.current = ae;
      }
    },
    [C, l, u, d, le, q, m, B]
  ), { ref: ke, active: nt } = id(
    de,
    {
      onScrubEnd: () => !C && i?.(
        B && m?.length ? Vs(
          ee.current,
          m.map((fe) => fe.value)
        ) : ee.current
      )
    },
    N
  ), Ge = (fe) => {
    if (!C)
      switch (fe.key) {
        case "ArrowUp": {
          if (fe.preventDefault(), ne.current?.focus(), B && m) {
            const pe = Uo(A, m);
            q(pe), i?.(pe);
            break;
          }
          const ae = Mn(
            Math.min(Math.max(A + d, l), u),
            le
          );
          q(ae), i?.(ae);
          break;
        }
        case "ArrowRight": {
          if (fe.preventDefault(), ne.current?.focus(), B && m) {
            const pe = N === "rtl" ? qo(A, m) : Uo(A, m);
            q(pe), i?.(pe);
            break;
          }
          const ae = Mn(
            Math.min(Math.max(N === "rtl" ? A - d : A + d, l), u),
            le
          );
          q(ae), i?.(ae);
          break;
        }
        case "ArrowDown": {
          if (fe.preventDefault(), ne.current?.focus(), B && m) {
            const pe = qo(A, m);
            q(pe), i?.(pe);
            break;
          }
          const ae = Mn(
            Math.min(Math.max(A - d, l), u),
            le
          );
          q(ae), i?.(ae);
          break;
        }
        case "ArrowLeft": {
          if (fe.preventDefault(), ne.current?.focus(), B && m) {
            const pe = N === "rtl" ? Uo(A, m) : qo(A, m);
            q(pe), i?.(pe);
            break;
          }
          const ae = Mn(
            Math.min(Math.max(N === "rtl" ? A + d : A - d, l), u),
            le
          );
          q(ae), i?.(ae);
          break;
        }
        case "Home": {
          if (fe.preventDefault(), ne.current?.focus(), B && m) {
            q(Aa(m)), i?.(Aa(m));
            break;
          }
          q(l), i?.(l);
          break;
        }
        case "End": {
          if (fe.preventDefault(), ne.current?.focus(), B && m) {
            q(Da(m)), i?.(Da(m));
            break;
          }
          q(u), i?.(u);
          break;
        }
      }
  };
  return /* @__PURE__ */ v(yy, { value: { getStyles: L }, children: /* @__PURE__ */ Z(
    Pc,
    {
      ...O,
      ref: ue(t, se),
      onKeyDownCapture: Ge,
      onMouseDownCapture: () => se.current?.focus(),
      size: c,
      disabled: C,
      children: [
        /* @__PURE__ */ v(
          Tc,
          {
            inverted: M,
            offset: 0,
            filled: X,
            marks: m,
            min: l,
            max: u,
            value: te,
            disabled: C,
            containerProps: {
              ref: ke,
              onMouseEnter: S ? () => k(!0) : void 0,
              onMouseLeave: S ? () => k(!1) : void 0
            },
            children: /* @__PURE__ */ v(
              _c,
              {
                max: u,
                min: l,
                value: te,
                position: X,
                dragging: nt,
                label: ge,
                ref: ne,
                labelTransitionProps: b,
                labelAlwaysOn: w,
                thumbLabel: y,
                showLabelOnHover: S,
                isHovered: $,
                disabled: C,
                ...V,
                children: x
              }
            )
          }
        ),
        /* @__PURE__ */ v("input", { type: "hidden", name: h, value: te, ...j })
      ]
    }
  ) });
});
kc.classes = Ec;
kc.displayName = "@mantine/core/Slider";
const Py = {}, _y = F((e, t) => {
  const { w: n, h: o, miw: r, mih: s, ...a } = T("Space", Py, e);
  return /* @__PURE__ */ v(D, { ref: t, ...a, w: n, miw: r ?? n, h: o, mih: s ?? o });
});
_y.displayName = "@mantine/core/Space";
var Ry = { root: "m_559cce2d", content: "m_b912df4e", control: "m_b9131032" };
const Mc = Ry, Ny = {
  maxHeight: 100,
  initialState: !1
}, Ty = (e, { transitionDuration: t }) => ({
  root: {
    "--spoiler-transition-duration": t !== void 0 ? `${t}ms` : void 0
  }
}), Ac = F((e, t) => {
  const n = T("Spoiler", Ny, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    initialState: l,
    maxHeight: u,
    hideLabel: d,
    showLabel: p,
    children: f,
    controlRef: h,
    transitionDuration: m,
    id: g,
    expanded: b,
    onExpandedChange: w,
    ...y
  } = n, S = K({
    name: "Spoiler",
    classes: Mc,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Ty
  }), x = Je(g), C = `${x}-region`, [R, P] = st({
    value: b,
    defaultValue: l,
    finalValue: !1,
    onChange: w
  }), { ref: M, height: I } = ud(), H = R ? d : p, z = H !== null && u < I;
  return /* @__PURE__ */ Z(
    D,
    {
      ...S("root"),
      id: x,
      ref: t,
      "data-has-spoiler": z || void 0,
      ...y,
      children: [
        z && /* @__PURE__ */ v(
          Zr,
          {
            component: "button",
            type: "button",
            ref: h,
            onClick: () => P(!R),
            "aria-expanded": R,
            "aria-controls": C,
            ...S("control"),
            children: H
          }
        ),
        /* @__PURE__ */ v(
          "div",
          {
            ...S("content", {
              style: { maxHeight: R ? I ? E(I) : void 0 : E(u) }
            }),
            "data-reduce-motion": !0,
            role: "region",
            id: C,
            children: /* @__PURE__ */ v("div", { ref: M, children: f })
          }
        )
      ]
    }
  );
});
Ac.classes = Mc;
Ac.displayName = "@mantine/core/Spoiler";
var Ey = { root: "m_6d731127" };
const Dc = Ey, ky = {
  gap: "md",
  align: "stretch",
  justify: "flex-start"
}, My = (e, { gap: t, align: n, justify: o }) => ({
  root: {
    "--stack-gap": we(t),
    "--stack-align": n,
    "--stack-justify": o
  }
}), Ic = F((e, t) => {
  const n = T("Stack", ky, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    align: l,
    justify: u,
    gap: d,
    variant: p,
    ...f
  } = n, h = K({
    name: "Stack",
    props: n,
    classes: Dc,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: My
  });
  return /* @__PURE__ */ v(D, { ref: t, ...h("root"), variant: p, ...f });
});
Ic.classes = Dc;
Ic.displayName = "@mantine/core/Stack";
const [Ay, Ps] = Ee(
  "Tabs component was not found in the tree"
);
var Dy = { root: "m_89d60db1", "list--default": "m_576c9d4", list: "m_89d33d6d", panel: "m_b0c91715", tab: "m_4ec4dce6", tabSection: "m_fc420b1f", "tab--default": "m_539e827b", "list--outline": "m_6772fbd5", "tab--outline": "m_b59ab47c", "tab--pills": "m_c3381914" };
const xn = Dy, Iy = {}, _s = F((e, t) => {
  const n = T("TabsList", Iy, e), { children: o, className: r, grow: s, justify: a, classNames: i, styles: c, style: l, mod: u, ...d } = n, p = Ps();
  return /* @__PURE__ */ v(
    D,
    {
      ...d,
      ...p.getStyles("list", {
        className: r,
        style: l,
        classNames: i,
        styles: c,
        props: n,
        variant: p.variant
      }),
      ref: t,
      role: "tablist",
      variant: p.variant,
      mod: [
        {
          grow: s,
          orientation: p.orientation,
          placement: p.orientation === "vertical" && p.placement,
          inverted: p.inverted
        },
        u
      ],
      "aria-orientation": p.orientation,
      __vars: { "--tabs-justify": a },
      children: o
    }
  );
});
_s.classes = xn;
_s.displayName = "@mantine/core/TabsList";
const Oy = {}, Rs = F((e, t) => {
  const n = T("TabsPanel", Oy, e), { children: o, className: r, value: s, classNames: a, styles: i, style: c, mod: l, keepMounted: u, ...d } = n, p = Ps(), f = p.value === s, h = p.keepMounted || u || f ? o : null;
  return /* @__PURE__ */ v(
    D,
    {
      ...d,
      ...p.getStyles("panel", {
        className: r,
        classNames: a,
        styles: i,
        style: [c, f ? void 0 : { display: "none" }],
        props: n
      }),
      ref: t,
      mod: [{ orientation: p.orientation }, l],
      role: "tabpanel",
      id: p.getPanelId(s),
      "aria-labelledby": p.getTabId(s),
      children: h
    }
  );
});
Rs.classes = xn;
Rs.displayName = "@mantine/core/TabsPanel";
const Ly = {}, Ns = F((e, t) => {
  const n = T("TabsTab", Ly, e), {
    className: o,
    children: r,
    rightSection: s,
    leftSection: a,
    value: i,
    onClick: c,
    onKeyDown: l,
    disabled: u,
    color: d,
    style: p,
    classNames: f,
    styles: h,
    vars: m,
    mod: g,
    tabIndex: b,
    ...w
  } = n, y = ye(), { dir: S } = wt(), x = Ps(), C = i === x.value, R = (M) => {
    x.onChange(x.allowTabDeactivation && i === x.value ? null : i), c?.(M);
  }, P = { classNames: f, styles: h, props: n };
  return /* @__PURE__ */ Z(
    St,
    {
      ...w,
      ...x.getStyles("tab", { className: o, style: p, variant: x.variant, ...P }),
      disabled: u,
      unstyled: x.unstyled,
      variant: x.variant,
      mod: [
        {
          active: C,
          disabled: u,
          orientation: x.orientation,
          inverted: x.inverted,
          placement: x.orientation === "vertical" && x.placement
        },
        g
      ],
      ref: t,
      role: "tab",
      id: x.getTabId(i),
      "aria-selected": C,
      tabIndex: b !== void 0 ? b : C || x.value === null ? 0 : -1,
      "aria-controls": x.getPanelId(i),
      onClick: R,
      __vars: { "--tabs-color": d ? xe(d, y) : void 0 },
      onKeyDown: Za({
        siblingSelector: '[role="tab"]',
        parentSelector: '[role="tablist"]',
        activateOnFocus: x.activateTabWithKeyboard,
        loop: x.loop,
        orientation: x.orientation || "horizontal",
        dir: S,
        onKeyDown: l
      }),
      children: [
        a && /* @__PURE__ */ v("span", { ...x.getStyles("tabSection", P), "data-position": "left", children: a }),
        r && /* @__PURE__ */ v("span", { ...x.getStyles("tabLabel", P), children: r }),
        s && /* @__PURE__ */ v("span", { ...x.getStyles("tabSection", P), "data-position": "right", children: s })
      ]
    }
  );
});
Ns.classes = xn;
Ns.displayName = "@mantine/core/TabsTab";
const Ia = "Tabs.Tab or Tabs.Panel component was rendered with invalid value or without value", zy = {
  keepMounted: !0,
  orientation: "horizontal",
  loop: !0,
  activateTabWithKeyboard: !0,
  allowTabDeactivation: !1,
  unstyled: !1,
  inverted: !1,
  variant: "default",
  placement: "left"
}, By = (e, { radius: t, color: n, autoContrast: o }) => ({
  root: {
    "--tabs-radius": ie(t),
    "--tabs-color": xe(n, e),
    "--tabs-text-color": df(o, e) ? wr({ color: n, theme: e, autoContrast: o }) : void 0
  }
}), Cn = F((e, t) => {
  const n = T("Tabs", zy, e), {
    defaultValue: o,
    value: r,
    onChange: s,
    orientation: a,
    children: i,
    loop: c,
    id: l,
    activateTabWithKeyboard: u,
    allowTabDeactivation: d,
    variant: p,
    color: f,
    radius: h,
    inverted: m,
    placement: g,
    keepMounted: b,
    classNames: w,
    styles: y,
    unstyled: S,
    className: x,
    style: C,
    vars: R,
    autoContrast: P,
    mod: M,
    ...I
  } = n, H = Je(l), [z, j] = st({
    value: r,
    defaultValue: o,
    finalValue: null,
    onChange: s
  }), B = K({
    name: "Tabs",
    props: n,
    classes: xn,
    className: x,
    style: C,
    classNames: w,
    styles: y,
    unstyled: S,
    vars: R,
    varsResolver: By
  });
  return /* @__PURE__ */ v(
    Ay,
    {
      value: {
        placement: g,
        value: z,
        orientation: a,
        id: H,
        loop: c,
        activateTabWithKeyboard: u,
        getTabId: Bs(`${H}-tab`, Ia),
        getPanelId: Bs(`${H}-panel`, Ia),
        onChange: j,
        allowTabDeactivation: d,
        variant: p,
        color: f,
        radius: h,
        inverted: m,
        keepMounted: b,
        unstyled: S,
        getStyles: B
      },
      children: /* @__PURE__ */ v(
        D,
        {
          ref: t,
          id: H,
          variant: p,
          mod: [
            {
              orientation: a,
              inverted: a === "horizontal" && m,
              placement: a === "vertical" && g
            },
            M
          ],
          ...B("root"),
          ...I,
          children: i
        }
      )
    }
  );
});
Cn.classes = xn;
Cn.displayName = "@mantine/core/Tabs";
Cn.Tab = Ns;
Cn.Panel = Rs;
Cn.List = _s;
var Fy = { root: "m_7341320d" };
const Oc = Fy, Hy = {}, Vy = (e, { size: t, radius: n, variant: o, gradient: r, color: s, autoContrast: a }) => {
  const i = e.variantColorResolver({
    color: s || e.primaryColor,
    theme: e,
    gradient: r,
    variant: o || "filled",
    autoContrast: a
  });
  return {
    root: {
      "--ti-size": Q(t, "ti-size"),
      "--ti-radius": n === void 0 ? void 0 : ie(n),
      "--ti-bg": s || o ? i.background : void 0,
      "--ti-color": s || o ? i.color : void 0,
      "--ti-bd": s || o ? i.border : void 0
    }
  };
}, Lc = F((e, t) => {
  const n = T("ThemeIcon", Hy, e), { classNames: o, className: r, style: s, styles: a, unstyled: i, vars: c, autoContrast: l, ...u } = n, d = K({
    name: "ThemeIcon",
    classes: Oc,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: Vy
  });
  return /* @__PURE__ */ v(D, { ref: t, ...d("root"), ...u });
});
Lc.classes = Oc;
Lc.displayName = "@mantine/core/ThemeIcon";
const Wy = ["h1", "h2", "h3", "h4", "h5", "h6"], jy = ["xs", "sm", "md", "lg", "xl"];
function Gy(e, t) {
  const n = t !== void 0 ? t : `h${e}`;
  return Wy.includes(n) ? {
    fontSize: `var(--mantine-${n}-font-size)`,
    fontWeight: `var(--mantine-${n}-font-weight)`,
    lineHeight: `var(--mantine-${n}-line-height)`
  } : jy.includes(n) ? {
    fontSize: `var(--mantine-font-size-${n})`,
    fontWeight: `var(--mantine-h${e}-font-weight)`,
    lineHeight: `var(--mantine-h${e}-line-height)`
  } : {
    fontSize: E(n),
    fontWeight: `var(--mantine-h${e}-font-weight)`,
    lineHeight: `var(--mantine-h${e}-line-height)`
  };
}
var Yy = { root: "m_8a5d1357" };
const zc = Yy, Ky = {
  order: 1
}, Xy = (e, { order: t, size: n, lineClamp: o, textWrap: r }) => {
  const s = Gy(t, n);
  return {
    root: {
      "--title-fw": s.fontWeight,
      "--title-lh": s.lineHeight,
      "--title-fz": s.fontSize,
      "--title-line-clamp": typeof o == "number" ? o.toString() : void 0,
      "--title-text-wrap": r
    }
  };
}, Bc = F((e, t) => {
  const n = T("Title", Ky, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    order: c,
    vars: l,
    size: u,
    variant: d,
    lineClamp: p,
    textWrap: f,
    mod: h,
    ...m
  } = n, g = K({
    name: "Title",
    props: n,
    classes: zc,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: l,
    varsResolver: Xy
  });
  return [1, 2, 3, 4, 5, 6].includes(c) ? /* @__PURE__ */ v(
    D,
    {
      ...g("root"),
      component: `h${c}`,
      variant: d,
      ref: t,
      mod: [{ order: c, "data-line-clamp": typeof p == "number" }, h],
      size: u,
      ...m
    }
  ) : null;
});
Bc.classes = zc;
Bc.displayName = "@mantine/core/Title";
function Oa(e, t, n) {
  if (!e || !t)
    return [];
  const o = n.indexOf(e), r = n.indexOf(t), s = Math.min(o, r), a = Math.max(o, r);
  return n.slice(s, a + 1);
}
function Ts({
  node: e,
  getStyles: t,
  rootIndex: n,
  controller: o,
  expandOnClick: r,
  selectOnClick: s,
  isSubtree: a,
  level: i = 1,
  renderNode: c,
  flatValues: l,
  allowRangeSelection: u,
  expandOnSpace: d,
  checkOnSpace: p
}) {
  const f = G(null), h = (e.children || []).map((y) => /* @__PURE__ */ v(
    Ts,
    {
      node: y,
      flatValues: l,
      getStyles: t,
      rootIndex: void 0,
      level: i + 1,
      controller: o,
      expandOnClick: r,
      isSubtree: !0,
      renderNode: c,
      selectOnClick: s,
      allowRangeSelection: u,
      expandOnSpace: d,
      checkOnSpace: p
    },
    y.value
  )), m = (y) => {
    if (y.nativeEvent.code === "ArrowRight" && (y.stopPropagation(), y.preventDefault(), o.expandedState[e.value] ? y.currentTarget.querySelector("[role=treeitem]")?.focus() : o.expand(e.value)), y.nativeEvent.code === "ArrowLeft" && (y.stopPropagation(), y.preventDefault(), o.expandedState[e.value] && (e.children || []).length > 0 ? o.collapse(e.value) : a && Vt(y.currentTarget, "[role=treeitem]")?.focus()), y.nativeEvent.code === "ArrowDown" || y.nativeEvent.code === "ArrowUp") {
      const S = Vt(y.currentTarget, "[data-tree-root]");
      if (!S)
        return;
      y.stopPropagation(), y.preventDefault();
      const x = Array.from(S.querySelectorAll("[role=treeitem]")), C = x.indexOf(y.currentTarget);
      if (C === -1)
        return;
      const R = y.nativeEvent.code === "ArrowDown" ? C + 1 : C - 1;
      if (x[R]?.focus(), y.shiftKey) {
        const P = x[R];
        P && o.setSelectedState(
          Oa(o.anchorNode, P.dataset.value, l)
        );
      }
    }
    y.nativeEvent.code === "Space" && (d && (y.stopPropagation(), y.preventDefault(), o.toggleExpanded(e.value)), p && (y.stopPropagation(), y.preventDefault(), o.isNodeChecked(e.value) ? o.uncheckNode(e.value) : o.checkNode(e.value)));
  }, g = (y) => {
    y.stopPropagation(), u && y.shiftKey && o.anchorNode ? (o.setSelectedState(Oa(o.anchorNode, e.value, l)), f.current?.focus()) : (r && o.toggleExpanded(e.value), s && o.select(e.value), f.current?.focus());
  }, b = o.selectedState.includes(e.value), w = {
    ...t("label"),
    onClick: g,
    "data-selected": b || void 0,
    "data-value": e.value,
    "data-hovered": o.hoveredNode === e.value || void 0
  };
  return /* @__PURE__ */ Z(
    "li",
    {
      ...t("node", {
        style: { "--label-offset": `calc(var(--level-offset) * ${i - 1})` }
      }),
      role: "treeitem",
      "aria-selected": b,
      "data-value": e.value,
      "data-selected": b || void 0,
      "data-hovered": o.hoveredNode === e.value || void 0,
      "data-level": i,
      tabIndex: n === 0 ? 0 : -1,
      onKeyDown: m,
      ref: f,
      onMouseOver: (y) => {
        y.stopPropagation(), o.setHoveredNode(e.value);
      },
      onMouseLeave: (y) => {
        y.stopPropagation(), o.setHoveredNode(null);
      },
      children: [
        typeof c == "function" ? c({
          node: e,
          level: i,
          selected: b,
          tree: o,
          expanded: o.expandedState[e.value] || !1,
          hasChildren: Array.isArray(e.children) && e.children.length > 0,
          elementProps: w
        }) : /* @__PURE__ */ v("div", { ...w, children: e.label }),
        o.expandedState[e.value] && h.length > 0 && /* @__PURE__ */ v("ul", { role: "group", ...t("subtree"), "data-level": i, children: h })
      ]
    }
  );
}
Ts.displayName = "@mantine/core/TreeNode";
function _o(e, t, n = []) {
  const o = [];
  for (const r of e)
    if (Array.isArray(r.children) && r.children.length > 0) {
      const s = _o(r.children, t, n);
      if (s.currentTreeChecked.length === r.children.length) {
        const a = s.currentTreeChecked.every((c) => c.checked), i = {
          checked: a,
          indeterminate: !a,
          value: r.value,
          hasChildren: !0
        };
        o.push(i), n.push(i);
      } else if (s.currentTreeChecked.length > 0) {
        const a = { checked: !1, indeterminate: !0, value: r.value, hasChildren: !0 };
        o.push(a), n.push(a);
      }
    } else if (t.includes(r.value)) {
      const s = {
        checked: !0,
        indeterminate: !1,
        value: r.value,
        hasChildren: !1
      };
      o.push(s), n.push(s);
    }
  return { result: n, currentTreeChecked: o };
}
function Fc(e, t) {
  for (const n of t) {
    if (n.value === e)
      return n;
    if (Array.isArray(n.children)) {
      const o = Fc(e, n.children);
      if (o)
        return o;
    }
  }
  return null;
}
function Vn(e, t, n = []) {
  const o = Fc(e, t);
  return o ? !Array.isArray(o.children) || o.children.length === 0 ? [o.value] : (o.children.forEach((r) => {
    Array.isArray(r.children) && r.children.length > 0 ? Vn(r.value, t, n) : n.push(r.value);
  }), n) : n;
}
function Hc(e) {
  return e.reduce((t, n) => (Array.isArray(n.children) && n.children.length > 0 ? t.push(...Hc(n.children)) : t.push(n.value), t), []);
}
function Uy(e, t, n) {
  return n.length === 0 ? !1 : n.includes(e) ? !0 : _o(t, n).result.some((r) => r.value === e && r.checked);
}
const qy = ci(Uy);
function Zy(e, t, n) {
  return n.length === 0 ? !1 : _o(t, n).result.some((r) => r.value === e && r.indeterminate);
}
const Jy = ci(Zy);
function Vc(e, t, n, o = {}) {
  return t.forEach((r) => {
    o[r.value] = r.value in e ? e[r.value] : r.value === n, Array.isArray(r.children) && Vc(e, r.children, n, o);
  }), o;
}
function Qy(e, t) {
  const n = [];
  return e.forEach((o) => n.push(...Vn(o, t))), Array.from(new Set(n));
}
function eb({
  initialSelectedState: e = [],
  initialCheckedState: t = [],
  initialExpandedState: n = {},
  multiple: o = !1,
  onNodeCollapse: r,
  onNodeExpand: s
} = {}) {
  const [a, i] = W([]), [c, l] = W(n), [u, d] = W(e), [p, f] = W(t), [h, m] = W(null), [g, b] = W(null), w = Y(
    ($) => {
      l((k) => Vc(k, $, u)), f((k) => Qy(k, $)), i($);
    },
    [u, p]
  ), y = Y(
    ($) => {
      l((k) => {
        const A = { ...k, [$]: !k[$] };
        return A[$] ? s?.($) : r?.($), A;
      });
    },
    [r, s]
  ), S = Y(
    ($) => {
      l((k) => (k[$] !== !1 && r?.($), { ...k, [$]: !1 }));
    },
    [r]
  ), x = Y(
    ($) => {
      l((k) => (k[$] !== !0 && s?.($), { ...k, [$]: !0 }));
    },
    [s]
  ), C = Y(() => {
    l(($) => {
      const k = { ...$ };
      return Object.keys(k).forEach((A) => {
        k[A] = !0;
      }), k;
    });
  }, []), R = Y(() => {
    l(($) => {
      const k = { ...$ };
      return Object.keys(k).forEach((A) => {
        k[A] = !1;
      }), k;
    });
  }, []), P = Y(
    ($) => d((k) => o ? k.includes($) ? (m(null), k.filter((A) => A !== $)) : (m($), [...k, $]) : k.includes($) ? (m(null), []) : (m($), [$])),
    []
  ), M = Y(($) => {
    m($), d(
      (k) => o ? k.includes($) ? k : [...k, $] : [$]
    );
  }, []), I = Y(($) => {
    h === $ && m(null), d((k) => k.filter((A) => A !== $));
  }, []), H = Y(() => {
    d([]), m(null);
  }, []), z = Y(
    ($) => {
      const k = Vn($, a);
      f((A) => Array.from(/* @__PURE__ */ new Set([...A, ...k])));
    },
    [a]
  ), j = Y(
    ($) => {
      const k = Vn($, a);
      f((A) => A.filter((q) => !k.includes(q)));
    },
    [a]
  ), B = Y(() => {
    f(() => Hc(a));
  }, [a]), V = Y(() => {
    f([]);
  }, []);
  return {
    multiple: o,
    expandedState: c,
    selectedState: u,
    checkedState: p,
    anchorNode: h,
    initialize: w,
    toggleExpanded: y,
    collapse: S,
    expand: x,
    expandAllNodes: C,
    collapseAllNodes: R,
    setExpandedState: l,
    checkNode: z,
    uncheckNode: j,
    checkAllNodes: B,
    uncheckAllNodes: V,
    setCheckedState: f,
    toggleSelected: P,
    select: M,
    deselect: I,
    clearSelected: H,
    setSelectedState: d,
    hoveredNode: g,
    setHoveredNode: b,
    getCheckedNodes: () => _o(a, p).result,
    isNodeChecked: ($) => qy($, a, p),
    isNodeIndeterminate: ($) => Jy($, a, p)
  };
}
var tb = { root: "m_f698e191", subtree: "m_75f3ecf", node: "m_f6970eb1", label: "m_dc283425" };
const Wc = tb;
function jc(e) {
  return e.reduce((t, n) => (t.push(n.value), n.children && t.push(...jc(n.children)), t), []);
}
const nb = {
  expandOnClick: !0,
  allowRangeSelection: !0,
  expandOnSpace: !0
}, ob = (e, { levelOffset: t }) => ({
  root: {
    "--level-offset": we(t)
  }
}), Gc = F((e, t) => {
  const n = T("Tree", nb, e), {
    classNames: o,
    className: r,
    style: s,
    styles: a,
    unstyled: i,
    vars: c,
    data: l,
    expandOnClick: u,
    tree: d,
    renderNode: p,
    selectOnClick: f,
    clearSelectionOnOutsideClick: h,
    allowRangeSelection: m,
    expandOnSpace: g,
    levelOffset: b,
    checkOnSpace: w,
    ...y
  } = n, S = eb(), x = d || S, C = K({
    name: "Tree",
    classes: Wc,
    props: n,
    className: r,
    style: s,
    classNames: o,
    styles: a,
    unstyled: i,
    vars: c,
    varsResolver: ob
  }), R = Qa(
    () => h && x.clearSelected()
  ), P = ue(t, R), M = Nt(() => jc(l), [l]);
  U(() => {
    x.initialize(l);
  }, [l]);
  const I = l.map((H, z) => /* @__PURE__ */ v(
    Ts,
    {
      node: H,
      getStyles: C,
      rootIndex: z,
      expandOnClick: u,
      selectOnClick: f,
      controller: x,
      renderNode: p,
      flatValues: M,
      allowRangeSelection: m,
      expandOnSpace: g,
      checkOnSpace: w
    },
    H.value
  ));
  return /* @__PURE__ */ v(
    D,
    {
      component: "ul",
      ref: P,
      ...C("root"),
      ...y,
      role: "tree",
      "aria-multiselectable": x.multiple,
      "data-tree-root": !0,
      children: I
    }
  );
});
Gc.displayName = "@mantine/core/Tree";
Gc.classes = Wc;
function sn(e, t, n) {
  return Object.keys(e[t]).reduce((o, r) => (o[r] = `var(--mantine-${n}-${r})`, o), {});
}
function La(e, t) {
  return e in t.breakpoints ? t.breakpoints[e] : Qo(e);
}
function $b(e) {
  const t = fi(Un, e), n = sn(t, "fontSizes", "font-size"), o = sn(t, "lineHeights", "line-height"), r = sn(t, "shadows", "shadow"), s = sn(t, "radius", "radius"), a = sn(t, "spacing", "spacing"), i = Object.keys(t.headings.sizes).reduce(
    (l, u) => (l[u] = {
      fontSize: `var(--mantine-${u}-font-size)`,
      lineHeight: `var(--mantine-${u}-line-height)`,
      fontWeight: `var(--mantine-${u}-font-weight)`
    }, l),
    {}
  ), c = Object.keys(t.colors).reduce(
    (l, u) => (l[u] = {
      0: `var(--mantine-color-${u}-0)`,
      1: `var(--mantine-color-${u}-1)`,
      2: `var(--mantine-color-${u}-2)`,
      3: `var(--mantine-color-${u}-3)`,
      4: `var(--mantine-color-${u}-4)`,
      5: `var(--mantine-color-${u}-5)`,
      6: `var(--mantine-color-${u}-6)`,
      7: `var(--mantine-color-${u}-7)`,
      8: `var(--mantine-color-${u}-8)`,
      9: `var(--mantine-color-${u}-9)`,
      filled: `var(--mantine-color-${u}-filled)`,
      filledHover: `var(--mantine-color-${u}-filled-hover)`,
      light: `var(--mantine-color-${u}-light)`,
      lightHover: `var(--mantine-color-${u}-light-hover)`,
      lightColor: `var(--mantine-color-${u}-light-color)`,
      outline: `var(--mantine-color-${u}-outline)`,
      outlineHover: `var(--mantine-color-${u}-outline-hover)`
    }, l),
    {
      primary: "var(--mantine-primary-color-filled)",
      primaryColors: {
        0: "var(--mantine-primary-color-0)",
        1: "var(--mantine-primary-color-1)",
        2: "var(--mantine-primary-color-2)",
        3: "var(--mantine-primary-color-3)",
        4: "var(--mantine-primary-color-4)",
        5: "var(--mantine-primary-color-5)",
        6: "var(--mantine-primary-color-6)",
        7: "var(--mantine-primary-color-7)",
        8: "var(--mantine-primary-color-8)",
        9: "var(--mantine-primary-color-9)",
        filled: "var(--mantine-primary-color-filled)",
        filledHover: "var(--mantine-primary-color-filled-hover)",
        light: "var(--mantine-primary-color-light)",
        lightHover: "var(--mantine-primary-color-light-hover)",
        lightColor: "var(--mantine-primary-color-light-color)",
        outline: "var(--mantine-primary-color-outline)",
        outlineHover: "var(--mantine-primary-color-outline-hover)"
      },
      white: "var(--mantine-color-white)",
      black: "var(--mantine-color-black)",
      text: "var(--mantine-color-text)",
      body: "var(--mantine-color-body)",
      error: "var(--mantine-color-error)",
      placeholder: "var(--mantine-color-placeholder)",
      anchor: "var(--mantine-color-anchor)",
      default: "var(--mantine-color-default)",
      defaultHover: "var(--mantine-color-default-hover)",
      defaultColor: "var(--mantine-color-default-color)",
      defaultBorder: "var(--mantine-color-default-border)",
      dimmed: "var(--mantine-color-dimmed)"
    }
  );
  return {
    scale: "var(--mantine-scale)",
    cursorType: "var(--mantine-cursor-type)",
    webkitFontSmoothing: "var(--mantine-webkit-font-smoothing)",
    mozFontSmoothing: "var(--mantine-moz-font-smoothing)",
    lineHeight: "var(--mantine-line-height)",
    fontFamily: "var(--mantine-font-family)",
    fontFamilyMonospace: "var(--mantine-font-family-monospace)",
    fontFamilyHeadings: "var(--mantine-font-family-headings)",
    headingFontWeight: "var(--mantine-heading-font-weight)",
    radiusDefault: "var(--mantine-radius-default)",
    breakpoints: t.breakpoints,
    fontSizes: n,
    lineHeights: o,
    shadows: r,
    radius: s,
    headings: i,
    spacing: a,
    colors: c,
    rtlSelector: '[dir="rtl"] &',
    darkSelector: '[data-mantine-color-scheme="dark"] &',
    lightSelector: '[data-mantine-color-scheme="light"] &',
    smallerThan: (l) => `(max-width: ${La(l, t)})`,
    largerThan: (l) => `(min-width: ${La(l, t)})`
  };
}
export {
  cb as $,
  so as A,
  D as B,
  ds as C,
  $s as D,
  _y as E,
  $o as F,
  hl as G,
  Xl as H,
  lc as I,
  Jl as J,
  xl as K,
  sv as L,
  gr as M,
  E as N,
  kc as O,
  Qn as P,
  ib as Q,
  Sc as R,
  Ic as S,
  Lc as T,
  eb as U,
  Pl as V,
  Gc as W,
  bb as X,
  gb as Y,
  xs as Z,
  db as _,
  bn as a,
  Fl as a0,
  Vr as a1,
  Cn as a2,
  _s as a3,
  Ns as a4,
  Rs as a5,
  gn as a6,
  Yl as a7,
  St as a8,
  Mu as a9,
  st as aA,
  id as aB,
  ue as aC,
  ub as aD,
  So as aE,
  ac as aF,
  Gt as aG,
  sc as aH,
  lb as aI,
  Ac as aJ,
  ls as aK,
  vb as aL,
  $c as aM,
  tt as aN,
  xc as aO,
  hc as aP,
  mc as aQ,
  pc as aR,
  fc as aS,
  ye as aT,
  ei as aU,
  uc as aV,
  Vl as aW,
  wb as aX,
  Ud as aY,
  fb as aa,
  yc as ab,
  Ee as ac,
  _r as ad,
  Za as ae,
  oc as af,
  Il as ag,
  hb as ah,
  yb as ai,
  un as aj,
  ss as ak,
  oe as al,
  Dl as am,
  _e as an,
  Qr as ao,
  as as ap,
  es as aq,
  md as ar,
  pb as as,
  nl as at,
  ed as au,
  ms as av,
  ps as aw,
  ni as ax,
  mb as ay,
  qr as az,
  po as b,
  ve as c,
  jl as d,
  ql as e,
  Bc as f,
  fo as g,
  Xn as h,
  $t as i,
  xb as j,
  Sb as k,
  Ne as l,
  al as m,
  Hr as n,
  Pr as o,
  Mt as p,
  zv as q,
  Zr as r,
  xt as s,
  $b as t,
  ff as u,
  dc as v,
  gs as w,
  bs as x,
  vs as y,
  ys as z
};
