import { jsx as R, jsxs as Yt, Fragment as Ce } from "react/jsx-runtime";
import * as b from "react";
import { useRef as Re } from "react";
import { flushSync as Le } from "react-dom";
import { w as Me } from "./likec4-DgZMMrvs.js";
const dt = "__TSR_index", ie = "popstate", ae = "beforeunload";
function fe(e) {
  let n = e.getLocation();
  const t = /* @__PURE__ */ new Set(), o = (s) => {
    n = e.getLocation(), t.forEach((a) => a({ location: n, action: s }));
  }, r = (s) => {
    e.notifyOnIndexChange ?? !0 ? o(s) : n = e.getLocation();
  }, i = async ({
    task: s,
    navigateOpts: a,
    ...u
  }) => {
    var c, d;
    if (a?.ignoreBlocker ?? !1) {
      s();
      return;
    }
    const h = ((c = e.getBlockers) == null ? void 0 : c.call(e)) ?? [], f = u.type === "PUSH" || u.type === "REPLACE";
    if (typeof document < "u" && h.length && f)
      for (const p of h) {
        const _ = yt(u.path, u.state);
        if (await p.blockerFn({
          currentLocation: n,
          nextLocation: _,
          action: u.type
        })) {
          (d = e.onBlocked) == null || d.call(e);
          return;
        }
      }
    s();
  };
  return {
    get location() {
      return n;
    },
    get length() {
      return e.getLength();
    },
    subscribers: t,
    subscribe: (s) => (t.add(s), () => {
      t.delete(s);
    }),
    push: (s, a, u) => {
      const c = n.state[dt];
      a = Qt(c + 1, a), i({
        task: () => {
          e.pushState(s, a), o({ type: "PUSH" });
        },
        navigateOpts: u,
        type: "PUSH",
        path: s,
        state: a
      });
    },
    replace: (s, a, u) => {
      const c = n.state[dt];
      a = Qt(c, a), i({
        task: () => {
          e.replaceState(s, a), o({ type: "REPLACE" });
        },
        navigateOpts: u,
        type: "REPLACE",
        path: s,
        state: a
      });
    },
    go: (s, a) => {
      i({
        task: () => {
          e.go(s), r({ type: "GO", index: s });
        },
        navigateOpts: a,
        type: "GO"
      });
    },
    back: (s) => {
      i({
        task: () => {
          e.back(s?.ignoreBlocker ?? !1), r({ type: "BACK" });
        },
        navigateOpts: s,
        type: "BACK"
      });
    },
    forward: (s) => {
      i({
        task: () => {
          e.forward(s?.ignoreBlocker ?? !1), r({ type: "FORWARD" });
        },
        navigateOpts: s,
        type: "FORWARD"
      });
    },
    canGoBack: () => n.state[dt] !== 0,
    createHref: (s) => e.createHref(s),
    block: (s) => {
      var a;
      if (!e.setBlockers) return () => {
      };
      const u = ((a = e.getBlockers) == null ? void 0 : a.call(e)) ?? [];
      return e.setBlockers([...u, s]), () => {
        var c, d;
        const l = ((c = e.getBlockers) == null ? void 0 : c.call(e)) ?? [];
        (d = e.setBlockers) == null || d.call(e, l.filter((h) => h !== s));
      };
    },
    flush: () => {
      var s;
      return (s = e.flush) == null ? void 0 : s.call(e);
    },
    destroy: () => {
      var s;
      return (s = e.destroy) == null ? void 0 : s.call(e);
    },
    notify: o
  };
}
function Qt(e, n) {
  return n || (n = {}), {
    ...n,
    key: ke(),
    [dt]: e
  };
}
function pe(e) {
  const n = e?.window ?? (typeof document < "u" ? window : void 0), t = n.history.pushState, o = n.history.replaceState;
  let r = [];
  const i = () => r, s = (y) => r = y, a = e?.createHref ?? ((y) => y), u = e?.parseLocation ?? (() => yt(
    `${n.location.pathname}${n.location.search}${n.location.hash}`,
    n.history.state
  ));
  let c = u(), d, l = !1, h = !1, f = !1, p = !1;
  const _ = () => c;
  let g, M;
  const C = () => {
    g && (F._ignoreSubscribers = !0, (g.isPush ? n.history.pushState : n.history.replaceState)(
      g.state,
      "",
      g.href
    ), F._ignoreSubscribers = !1, g = void 0, M = void 0, d = void 0);
  }, L = (y, S, k) => {
    const m = a(S);
    M || (d = c), c = yt(S, k), g = {
      href: m,
      state: k,
      isPush: g?.isPush || y === "push"
    }, M || (M = Promise.resolve().then(() => C()));
  }, w = (y) => {
    c = u(), F.notify({ type: y });
  }, v = async () => {
    if (h) {
      h = !1;
      return;
    }
    const y = u(), S = y.state[dt] - c.state[dt], k = S === 1, m = S === -1, P = !k && !m || l;
    l = !1;
    const E = P ? "GO" : m ? "BACK" : "FORWARD", T = P ? {
      type: "GO",
      index: S
    } : {
      type: m ? "BACK" : "FORWARD"
    };
    if (f)
      f = !1;
    else {
      const I = i();
      if (typeof document < "u" && I.length) {
        for (const D of I)
          if (await D.blockerFn({
            currentLocation: c,
            nextLocation: y,
            action: E
          })) {
            h = !0, n.history.go(1), F.notify(T);
            return;
          }
      }
    }
    c = u(), F.notify(T);
  }, x = (y) => {
    if (p) {
      p = !1;
      return;
    }
    let S = !1;
    const k = i();
    if (typeof document < "u" && k.length)
      for (const m of k) {
        const P = m.enableBeforeUnload ?? !0;
        if (P === !0) {
          S = !0;
          break;
        }
        if (typeof P == "function" && P() === !0) {
          S = !0;
          break;
        }
      }
    if (S)
      return y.preventDefault(), y.returnValue = "";
  }, F = fe({
    getLocation: _,
    getLength: () => n.history.length,
    pushState: (y, S) => L("push", y, S),
    replaceState: (y, S) => L("replace", y, S),
    back: (y) => (y && (f = !0), p = !0, n.history.back()),
    forward: (y) => {
      y && (f = !0), p = !0, n.history.forward();
    },
    go: (y) => {
      l = !0, n.history.go(y);
    },
    createHref: (y) => a(y),
    flush: C,
    destroy: () => {
      n.history.pushState = t, n.history.replaceState = o, n.removeEventListener(ae, x, {
        capture: !0
      }), n.removeEventListener(ie, v);
    },
    onBlocked: () => {
      d && c !== d && (c = d);
    },
    getBlockers: i,
    setBlockers: s,
    notifyOnIndexChange: !1
  });
  return n.addEventListener(ae, x, { capture: !0 }), n.addEventListener(ie, v), n.history.pushState = function(...y) {
    const S = t.apply(n.history, y);
    return F._ignoreSubscribers || w("PUSH"), S;
  }, n.history.replaceState = function(...y) {
    const S = o.apply(n.history, y);
    return F._ignoreSubscribers || w("REPLACE"), S;
  }, F;
}
function Fo(e) {
  const n = typeof document < "u" ? window : void 0;
  return pe({
    window: n,
    parseLocation: () => {
      const t = n.location.hash.split("#").slice(1).join("#") ?? "/";
      return yt(t, n.history.state);
    },
    createHref: (t) => `${n.location.pathname}${n.location.search}#${t}`
  });
}
function xe(e = {
  initialEntries: ["/"]
}) {
  const n = e.initialEntries;
  let t = e.initialIndex ? Math.min(Math.max(e.initialIndex, 0), n.length - 1) : n.length - 1;
  const o = n.map(
    (i, s) => Qt(s, void 0)
  );
  return fe({
    getLocation: () => yt(n[t], o[t]),
    getLength: () => n.length,
    pushState: (i, s) => {
      t < n.length - 1 && (n.splice(t + 1), o.splice(t + 1)), o.push(s), n.push(i), t = Math.max(n.length - 1, 0);
    },
    replaceState: (i, s) => {
      o[t] = s, n[t] = i;
    },
    back: () => {
      t = Math.max(t - 1, 0);
    },
    forward: () => {
      t = Math.min(t + 1, n.length - 1);
    },
    go: (i) => {
      t = Math.min(Math.max(t + i, 0), n.length - 1);
    },
    createHref: (i) => i
  });
}
function yt(e, n) {
  const t = e.indexOf("#"), o = e.indexOf("?");
  return {
    href: e,
    pathname: e.substring(
      0,
      t > 0 ? o > 0 ? Math.min(t, o) : t : o > 0 ? o : e.length
    ),
    hash: t > -1 ? e.substring(t) : "",
    search: o > -1 ? e.slice(o, t === -1 ? void 0 : t) : "",
    state: n || { [dt]: 0 }
  };
}
function ke() {
  return (Math.random() + 1).toString(36).substring(7);
}
var Ie = !0, Ut = "Invariant failed";
function et(e, n) {
  if (!e) {
    if (Ie)
      throw new Error(Ut);
    var t = typeof n == "function" ? n() : n, o = t ? "".concat(Ut, ": ").concat(t) : Ut;
    throw new Error(o);
  }
}
var Ee = !0;
function Lt(e, n) {
  if (!Ee) {
    if (e)
      return;
    var t = "Warning: " + n;
    typeof console < "u" && console.warn(t);
    try {
      throw Error(t);
    } catch {
    }
  }
}
const mt = /* @__PURE__ */ new WeakMap(), Ft = /* @__PURE__ */ new WeakMap(), Bt = {
  current: []
};
let zt = !1, Ct = 0;
const wt = /* @__PURE__ */ new Set(), kt = /* @__PURE__ */ new Map();
function me(e) {
  const n = Array.from(e).sort((t, o) => t instanceof vt && t.options.deps.includes(o) ? 1 : o instanceof vt && o.options.deps.includes(t) ? -1 : 0);
  for (const t of n) {
    if (Bt.current.includes(t))
      continue;
    Bt.current.push(t), t.recompute();
    const o = Ft.get(t);
    if (o)
      for (const r of o) {
        const i = mt.get(r);
        i && me(i);
      }
  }
}
function Fe(e) {
  e.listeners.forEach(
    (n) => n({
      prevVal: e.prevState,
      currentVal: e.state
    })
  );
}
function Te(e) {
  e.listeners.forEach(
    (n) => n({
      prevVal: e.prevState,
      currentVal: e.state
    })
  );
}
function ve(e) {
  if (Ct > 0 && !kt.has(e) && kt.set(e, e.prevState), wt.add(e), !(Ct > 0) && !zt)
    try {
      for (zt = !0; wt.size > 0; ) {
        const n = Array.from(wt);
        wt.clear();
        for (const t of n) {
          const o = kt.get(t) ?? t.prevState;
          t.prevState = o, Fe(t);
        }
        for (const t of n) {
          const o = mt.get(t);
          o && (Bt.current.push(t), me(o));
        }
        for (const t of n) {
          const o = mt.get(t);
          if (o)
            for (const r of o)
              Te(r);
        }
      }
    } finally {
      zt = !1, Bt.current = [], kt.clear();
    }
}
function Wt(e) {
  Ct++;
  try {
    e();
  } finally {
    if (Ct--, Ct === 0) {
      const n = Array.from(wt)[0];
      n && ve(n);
    }
  }
}
class Zt {
  constructor(n, t) {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = (o) => {
      var r, i;
      this.listeners.add(o);
      const s = (i = (r = this.options) == null ? void 0 : r.onSubscribe) == null ? void 0 : i.call(r, o, this);
      return () => {
        this.listeners.delete(o), s?.();
      };
    }, this.setState = (o) => {
      var r, i, s;
      this.prevState = this.state, this.state = (r = this.options) != null && r.updateFn ? this.options.updateFn(this.prevState)(o) : o(this.prevState), (s = (i = this.options) == null ? void 0 : i.onUpdate) == null || s.call(i), ve(this);
    }, this.prevState = n, this.state = n, this.options = t;
  }
}
class vt {
  constructor(n) {
    this.listeners = /* @__PURE__ */ new Set(), this._subscriptions = [], this.lastSeenDepValues = [], this.getDepVals = () => {
      const t = [], o = [];
      for (const r of this.options.deps)
        t.push(r.prevState), o.push(r.state);
      return this.lastSeenDepValues = o, {
        prevDepVals: t,
        currDepVals: o,
        prevVal: this.prevState ?? void 0
      };
    }, this.recompute = () => {
      var t, o;
      this.prevState = this.state;
      const { prevDepVals: r, currDepVals: i, prevVal: s } = this.getDepVals();
      this.state = this.options.fn({
        prevDepVals: r,
        currDepVals: i,
        prevVal: s
      }), (o = (t = this.options).onUpdate) == null || o.call(t);
    }, this.checkIfRecalculationNeededDeeply = () => {
      for (const i of this.options.deps)
        i instanceof vt && i.checkIfRecalculationNeededDeeply();
      let t = !1;
      const o = this.lastSeenDepValues, { currDepVals: r } = this.getDepVals();
      for (let i = 0; i < r.length; i++)
        if (r[i] !== o[i]) {
          t = !0;
          break;
        }
      t && this.recompute();
    }, this.mount = () => (this.registerOnGraph(), this.checkIfRecalculationNeededDeeply(), () => {
      this.unregisterFromGraph();
      for (const t of this._subscriptions)
        t();
    }), this.subscribe = (t) => {
      var o, r;
      this.listeners.add(t);
      const i = (r = (o = this.options).onSubscribe) == null ? void 0 : r.call(o, t, this);
      return () => {
        this.listeners.delete(t), i?.();
      };
    }, this.options = n, this.state = n.fn({
      prevDepVals: void 0,
      prevVal: void 0,
      currDepVals: this.getDepVals().currDepVals
    });
  }
  registerOnGraph(n = this.options.deps) {
    for (const t of n)
      if (t instanceof vt)
        t.registerOnGraph(), this.registerOnGraph(t.options.deps);
      else if (t instanceof Zt) {
        let o = mt.get(t);
        o || (o = /* @__PURE__ */ new Set(), mt.set(t, o)), o.add(this);
        let r = Ft.get(this);
        r || (r = /* @__PURE__ */ new Set(), Ft.set(this, r)), r.add(t);
      }
  }
  unregisterFromGraph(n = this.options.deps) {
    for (const t of n)
      if (t instanceof vt)
        this.unregisterFromGraph(t.options.deps);
      else if (t instanceof Zt) {
        const o = mt.get(t);
        o && o.delete(this);
        const r = Ft.get(this);
        r && r.delete(t);
      }
  }
}
function Be(e, n = (t) => t) {
  return Me.useSyncExternalStoreWithSelector(
    e.subscribe,
    () => e.state,
    () => e.state,
    n,
    De
  );
}
function De(e, n) {
  if (Object.is(e, n))
    return !0;
  if (typeof e != "object" || e === null || typeof n != "object" || n === null)
    return !1;
  if (e instanceof Map && n instanceof Map) {
    if (e.size !== n.size) return !1;
    for (const [o, r] of e)
      if (!n.has(o) || !Object.is(r, n.get(o))) return !1;
    return !0;
  }
  if (e instanceof Set && n instanceof Set) {
    if (e.size !== n.size) return !1;
    for (const o of e)
      if (!n.has(o)) return !1;
    return !0;
  }
  const t = Object.keys(e);
  if (t.length !== Object.keys(n).length)
    return !1;
  for (let o = 0; o < t.length; o++)
    if (!Object.prototype.hasOwnProperty.call(n, t[o]) || !Object.is(e[t[o]], n[t[o]]))
      return !1;
  return !0;
}
const H = "__root__";
function Oe(e, n) {
  let t, o, r, i = "";
  for (t in e)
    if ((r = e[t]) !== void 0)
      if (Array.isArray(r))
        for (o = 0; o < r.length; o++)
          i && (i += "&"), i += encodeURIComponent(t) + "=" + encodeURIComponent(r[o]);
      else
        i && (i += "&"), i += encodeURIComponent(t) + "=" + encodeURIComponent(r);
  return "" + i;
}
function ce(e) {
  if (!e) return "";
  const n = decodeURIComponent(e);
  return n === "false" ? !1 : n === "true" ? !0 : +n * 0 === 0 && +n + "" === n ? +n : n;
}
function Ae(e, n) {
  let t, o;
  const r = {}, i = e.split("&");
  for (; t = i.shift(); ) {
    const s = t.indexOf("=");
    if (s !== -1) {
      o = t.slice(0, s), o = decodeURIComponent(o);
      const a = t.slice(s + 1);
      r[o] !== void 0 ? r[o] = [].concat(r[o], ce(a)) : r[o] = ce(a);
    } else
      o = t, o = decodeURIComponent(o), r[o] = "";
  }
  return r;
}
const Ve = Ke(JSON.parse), Ne = $e(
  JSON.stringify,
  JSON.parse
);
function Ke(e) {
  return (n) => {
    n.substring(0, 1) === "?" && (n = n.substring(1));
    const t = Ae(n);
    for (const o in t) {
      const r = t[o];
      if (typeof r == "string")
        try {
          t[o] = e(r);
        } catch {
        }
    }
    return t;
  };
}
function $e(e, n) {
  function t(o) {
    if (typeof o == "object" && o !== null)
      try {
        return e(o);
      } catch {
      }
    else if (typeof o == "string" && typeof n == "function")
      try {
        return n(o), e(o);
      } catch {
      }
    return o;
  }
  return (o) => {
    o = { ...o }, Object.keys(o).forEach((i) => {
      const s = o[i];
      typeof s > "u" || s === void 0 ? delete o[i] : o[i] = t(s);
    });
    const r = Oe(o).toString();
    return r ? `?${r}` : "";
  };
}
function Rt(e) {
  return e[e.length - 1];
}
function Ue(e) {
  return typeof e == "function";
}
function lt(e, n) {
  return Ue(e) ? e(n) : e;
}
function te(e, n) {
  return n.reduce((t, o) => (t[o] = e[o], t), {});
}
function q(e, n) {
  if (e === n)
    return e;
  const t = n, o = ue(e) && ue(t);
  if (o || Dt(e) && Dt(t)) {
    const r = o ? e : Object.keys(e), i = r.length, s = o ? t : Object.keys(t), a = s.length, u = o ? [] : {};
    let c = 0;
    for (let d = 0; d < a; d++) {
      const l = o ? d : s[d];
      (!o && r.includes(l) || o) && e[l] === void 0 && t[l] === void 0 ? (u[l] = void 0, c++) : (u[l] = q(e[l], t[l]), u[l] === e[l] && e[l] !== void 0 && c++);
    }
    return i === a && c === i ? e : u;
  }
  return t;
}
function Dt(e) {
  if (!le(e))
    return !1;
  const n = e.constructor;
  if (typeof n > "u")
    return !0;
  const t = n.prototype;
  return !(!le(t) || !t.hasOwnProperty("isPrototypeOf"));
}
function le(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function ue(e) {
  return Array.isArray(e) && e.length === Object.keys(e).length;
}
function de(e, n) {
  let t = Object.keys(e);
  return n && (t = t.filter((o) => e[o] !== void 0)), t;
}
function gt(e, n, t) {
  if (e === n)
    return !0;
  if (typeof e != typeof n)
    return !1;
  if (Dt(e) && Dt(n)) {
    const o = t?.ignoreUndefined ?? !0, r = de(e, o), i = de(n, o);
    return !t?.partial && r.length !== i.length ? !1 : i.every((s) => gt(e[s], n[s], t));
  }
  return Array.isArray(e) && Array.isArray(n) ? e.length !== n.length ? !1 : !e.some((o, r) => !gt(o, n[r], t)) : !1;
}
const bt = typeof window < "u" ? b.useLayoutEffect : b.useEffect;
function pt(e) {
  let n, t;
  const o = new Promise((r, i) => {
    n = r, t = i;
  });
  return o.status = "pending", o.resolve = (r) => {
    o.status = "resolved", o.value = r, n(r), e?.(r);
  }, o.reject = (r) => {
    o.status = "rejected", t(r);
  }, o;
}
function Ht(e) {
  const n = b.useRef({
    value: e,
    prev: null
  }), t = n.current.value;
  return e !== t && (n.current = {
    value: e,
    prev: t
  }), n.current.prev;
}
function ze(e, n, t = {}, o = {}) {
  const r = b.useRef(
    typeof IntersectionObserver == "function"
  ), i = b.useRef(null);
  return b.useEffect(() => {
    if (!(!e.current || !r.current || o.disabled))
      return i.current = new IntersectionObserver(([s]) => {
        n(s);
      }, t), i.current.observe(e.current), () => {
        var s;
        (s = i.current) == null || s.disconnect();
      };
  }, [n, t, o.disabled, e]), i.current;
}
function We(e) {
  const n = b.useRef(null);
  return b.useEffect(() => {
    e && (typeof e == "function" ? e(n.current) : e.current = n.current);
  }), n;
}
function nt(e) {
  return Vt(
    e.filter((n) => n !== void 0).join("/")
  );
}
function Vt(e) {
  return e.replace(/\/{2,}/g, "/");
}
function oe(e) {
  return e === "/" ? e : e.replace(/^\/{1,}/, "");
}
function ut(e) {
  return e === "/" ? e : e.replace(/\/{1,}$/, "");
}
function He(e) {
  return ut(oe(e));
}
function Ot(e, n) {
  return e.endsWith("/") && e !== "/" && e !== `${n}/` ? e.slice(0, -1) : e;
}
function Ge(e, n, t) {
  return Ot(e, t) === Ot(n, t);
}
function je({
  basepath: e,
  base: n,
  to: t,
  trailingSlash: o = "never",
  caseSensitive: r
}) {
  var i, s;
  n = At(e, n, r), t = At(e, t, r);
  let a = _t(n);
  const u = _t(t);
  a.length > 1 && ((i = Rt(a)) == null ? void 0 : i.value) === "/" && a.pop(), u.forEach((d, l) => {
    d.value === "/" ? l ? l === u.length - 1 && a.push(d) : a = [d] : d.value === ".." ? a.pop() : d.value === "." || a.push(d);
  }), a.length > 1 && (((s = Rt(a)) == null ? void 0 : s.value) === "/" ? o === "never" && a.pop() : o === "always" && a.push({ type: "pathname", value: "/" }));
  const c = nt([e, ...a.map((d) => d.value)]);
  return Vt(c);
}
function _t(e) {
  if (!e)
    return [];
  e = Vt(e);
  const n = [];
  if (e.slice(0, 1) === "/" && (e = e.substring(1), n.push({
    type: "pathname",
    value: "/"
  })), !e)
    return n;
  const t = e.split("/").filter(Boolean);
  return n.push(
    ...t.map((o) => o === "$" || o === "*" ? {
      type: "wildcard",
      value: o
    } : o.charAt(0) === "$" ? {
      type: "param",
      value: o
    } : {
      type: "pathname",
      value: decodeURI(o)
    })
  ), e.slice(-1) === "/" && (e = e.substring(1), n.push({
    type: "pathname",
    value: "/"
  })), n;
}
function It({
  path: e,
  params: n,
  leaveWildcards: t,
  leaveParams: o,
  decodeCharMap: r
}) {
  const i = _t(e), s = {};
  for (const [a, u] of Object.entries(n)) {
    const c = typeof u == "string";
    ["*", "_splat"].includes(a) ? s[a] = c ? encodeURI(u) : u : s[a] = c ? qe(u, r) : u;
  }
  return nt(
    i.map((a) => {
      if (a.type === "wildcard") {
        const u = s._splat;
        return t ? `${a.value}${u ?? ""}` : u;
      }
      if (a.type === "param") {
        if (o) {
          const u = s[a.value];
          return `${a.value}${u ?? ""}`;
        }
        return s[a.value.substring(1)] ?? "undefined";
      }
      return a.value;
    })
  );
}
function qe(e, n) {
  let t = encodeURIComponent(e);
  if (n)
    for (const [o, r] of n)
      t = t.replaceAll(o, r);
  return t;
}
function Et(e, n, t) {
  const o = Xe(e, n, t);
  if (!(t.to && !o))
    return o ?? {};
}
function At(e, n, t = !1) {
  const o = t ? e : e.toLowerCase(), r = t ? n : n.toLowerCase();
  switch (!0) {
    case o === "/":
      return n;
    case r === o:
      return "";
    case n.length < e.length:
      return n;
    case r[o.length] !== "/":
      return n;
    case r.startsWith(o):
      return n.slice(e.length);
    default:
      return n;
  }
}
function Xe(e, n, t) {
  if (e !== "/" && !n.startsWith(e))
    return;
  n = At(e, n, t.caseSensitive);
  const o = At(
    e,
    `${t.to ?? "$"}`,
    t.caseSensitive
  ), r = _t(n), i = _t(o);
  n.startsWith("/") || r.unshift({
    type: "pathname",
    value: "/"
  }), o.startsWith("/") || i.unshift({
    type: "pathname",
    value: "/"
  });
  const s = {};
  return (() => {
    for (let u = 0; u < Math.max(r.length, i.length); u++) {
      const c = r[u], d = i[u], l = u >= r.length - 1, h = u >= i.length - 1;
      if (d) {
        if (d.type === "wildcard") {
          const f = decodeURI(
            nt(r.slice(u).map((p) => p.value))
          );
          return s["*"] = f, s._splat = f, !0;
        }
        if (d.type === "pathname") {
          if (d.value === "/" && !c?.value)
            return !0;
          if (c) {
            if (t.caseSensitive) {
              if (d.value !== c.value)
                return !1;
            } else if (d.value.toLowerCase() !== c.value.toLowerCase())
              return !1;
          }
        }
        if (!c)
          return !1;
        if (d.type === "param") {
          if (c.value === "/")
            return !1;
          c.value.charAt(0) !== "$" && (s[d.value.substring(1)] = decodeURIComponent(
            c.value
          ));
        }
      }
      if (!l && h)
        return s["**"] = nt(r.slice(u + 1).map((f) => f.value)), !!t.fuzzy && d?.value !== "/";
    }
    return !0;
  })() ? s : void 0;
}
function ct(e) {
  return !!e?.isRedirect;
}
function Gt(e) {
  return !!e?.isRedirect && e.href;
}
function ne(e) {
  const n = e.errorComponent ?? Nt;
  return /* @__PURE__ */ R(
    Je,
    {
      getResetKey: e.getResetKey,
      onCatch: e.onCatch,
      children: ({ error: t, reset: o }) => t ? b.createElement(n, {
        error: t,
        reset: o
      }) : e.children
    }
  );
}
class Je extends b.Component {
  constructor() {
    super(...arguments), this.state = { error: null };
  }
  static getDerivedStateFromProps(n) {
    return { resetKey: n.getResetKey() };
  }
  static getDerivedStateFromError(n) {
    return { error: n };
  }
  reset() {
    this.setState({ error: null });
  }
  componentDidUpdate(n, t) {
    t.error && t.resetKey !== this.state.resetKey && this.reset();
  }
  componentDidCatch(n, t) {
    this.props.onCatch && this.props.onCatch(n, t);
  }
  render() {
    return this.props.children({
      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
      reset: () => {
        this.reset();
      }
    });
  }
}
function Nt({ error: e }) {
  const [n, t] = b.useState(!1);
  return /* @__PURE__ */ Yt("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
    /* @__PURE__ */ Yt("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
      /* @__PURE__ */ R("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
      /* @__PURE__ */ R(
        "button",
        {
          style: {
            appearance: "none",
            fontSize: ".6em",
            border: "1px solid currentColor",
            padding: ".1rem .2rem",
            fontWeight: "bold",
            borderRadius: ".25rem"
          },
          onClick: () => t((o) => !o),
          children: n ? "Hide Error" : "Show Error"
        }
      )
    ] }),
    /* @__PURE__ */ R("div", { style: { height: ".25rem" } }),
    n ? /* @__PURE__ */ R("div", { children: /* @__PURE__ */ R(
      "pre",
      {
        style: {
          fontSize: ".7em",
          border: "1px solid red",
          borderRadius: ".25rem",
          padding: ".3rem",
          color: "red",
          overflow: "auto"
        },
        children: e.message ? /* @__PURE__ */ R("code", { children: e.message }) : null
      }
    ) }) : null
  ] });
}
const jt = b.createContext(null);
function ge() {
  return typeof document > "u" ? jt : window.__TSR_ROUTER_CONTEXT__ ? window.__TSR_ROUTER_CONTEXT__ : (window.__TSR_ROUTER_CONTEXT__ = jt, jt);
}
function rt(e) {
  const n = b.useContext(ge());
  return Lt(
    !((e?.warn ?? !0) && !n),
    "useRouter must be used inside a <RouterProvider> component!"
  ), n;
}
function z(e) {
  const n = rt({
    warn: e?.router === void 0
  }), t = e?.router || n, o = Re(void 0);
  return Be(t.__store, (r) => {
    if (e?.select) {
      if (e.structuralSharing ?? t.options.defaultStructuralSharing) {
        const i = q(
          o.current,
          e.select(r)
        );
        return o.current = i, i;
      }
      return e.select(r);
    }
    return r;
  });
}
function To(e = {}) {
  if (e.isNotFound = !0, e.throw) throw e;
  return e;
}
function tt(e) {
  return !!e?.isNotFound;
}
function Ye(e) {
  const n = z({
    select: (t) => `not-found-${t.location.pathname}-${t.status}`
  });
  return /* @__PURE__ */ R(
    ne,
    {
      getResetKey: () => n,
      onCatch: (t, o) => {
        var r;
        if (tt(t))
          (r = e.onCatch) == null || r.call(e, t, o);
        else
          throw t;
      },
      errorComponent: ({ error: t }) => {
        var o;
        if (tt(t))
          return (o = e.fallback) == null ? void 0 : o.call(e, t);
        throw t;
      },
      children: e.children
    }
  );
}
function Qe() {
  return /* @__PURE__ */ R("p", { children: "Not Found" });
}
const ye = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent"
];
function Ze(e) {
  var n;
  for (const t of ye)
    if ((n = e.options[t]) != null && n.preload)
      return !0;
  return !1;
}
function qt(e, n) {
  if (e == null) return {};
  if ("~standard" in e) {
    const t = e["~standard"].validate(n);
    if (t instanceof Promise)
      throw new ee("Async validation not supported");
    if (t.issues)
      throw new ee(JSON.stringify(t.issues, void 0, 2));
    return t.value;
  }
  return "parse" in e ? e.parse(n) : typeof e == "function" ? e(n) : {};
}
function Bo(e) {
  return new to(e);
}
class to {
  /**
   * @deprecated Use the `createRouter` function instead
   */
  constructor(n) {
    this.tempLocationKey = `${Math.round(
      Math.random() * 1e7
    )}`, this.resetNextScroll = !0, this.shouldViewTransition = void 0, this.isViewTransitionTypesSupported = void 0, this.subscribers = /* @__PURE__ */ new Set(), this.startReactTransition = (t) => t(), this.update = (t) => {
      var o;
      t.notFoundRoute && console.warn(
        "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info."
      );
      const r = this.options;
      this.options = {
        ...this.options,
        ...t
      }, this.isServer = this.options.isServer ?? typeof document > "u", this.pathParamsDecodeCharMap = this.options.pathParamsAllowedCharacters ? new Map(
        this.options.pathParamsAllowedCharacters.map((i) => [
          encodeURIComponent(i),
          i
        ])
      ) : void 0, (!this.basepath || t.basepath && t.basepath !== r.basepath) && (t.basepath === void 0 || t.basepath === "" || t.basepath === "/" ? this.basepath = "/" : this.basepath = `/${He(t.basepath)}`), // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      (!this.history || this.options.history && this.options.history !== this.history) && (this.history = this.options.history ?? (this.isServer ? xe({
        initialEntries: [this.basepath || "/"]
      }) : pe()), this.latestLocation = this.parseLocation()), this.options.routeTree !== this.routeTree && (this.routeTree = this.options.routeTree, this.buildRouteTree()), this.__store || (this.__store = new Zt(oo(this.latestLocation), {
        onUpdate: () => {
          this.__store.state = {
            ...this.state,
            cachedMatches: this.state.cachedMatches.filter(
              (i) => !["redirected"].includes(i.status)
            )
          };
        }
      })), typeof window < "u" && "CSS" in window && // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      typeof ((o = window.CSS) == null ? void 0 : o.supports) == "function" && (this.isViewTransitionTypesSupported = window.CSS.supports(
        "selector(:active-view-transition-type(a)"
      ));
    }, this.buildRouteTree = () => {
      this.routesById = {}, this.routesByPath = {};
      const t = this.options.notFoundRoute;
      t && (t.init({
        originalIndex: 99999999999,
        defaultSsr: this.options.defaultSsr
      }), this.routesById[t.id] = t);
      const o = (s) => {
        s.forEach((a, u) => {
          a.init({
            originalIndex: u,
            defaultSsr: this.options.defaultSsr
          });
          const c = this.routesById[a.id];
          if (et(
            !c,
            `Duplicate routes found with id: ${String(a.id)}`
          ), this.routesById[a.id] = a, !a.isRoot && a.path) {
            const l = ut(a.fullPath);
            (!this.routesByPath[l] || a.fullPath.endsWith("/")) && (this.routesByPath[l] = a);
          }
          const d = a.children;
          d?.length && o(d);
        });
      };
      o([this.routeTree]);
      const r = [];
      Object.values(this.routesById).forEach((s, a) => {
        var u;
        if (s.isRoot || !s.path)
          return;
        const c = oe(s.fullPath), d = _t(c);
        for (; d.length > 1 && ((u = d[0]) == null ? void 0 : u.value) === "/"; )
          d.shift();
        const l = d.map((h) => h.value === "/" ? 0.75 : h.type === "param" ? 0.5 : h.type === "wildcard" ? 0.25 : 1);
        r.push({ child: s, trimmed: c, parsed: d, index: a, scores: l });
      }), this.flatRoutes = r.sort((s, a) => {
        const u = Math.min(s.scores.length, a.scores.length);
        for (let c = 0; c < u; c++)
          if (s.scores[c] !== a.scores[c])
            return a.scores[c] - s.scores[c];
        if (s.scores.length !== a.scores.length)
          return a.scores.length - s.scores.length;
        for (let c = 0; c < u; c++)
          if (s.parsed[c].value !== a.parsed[c].value)
            return s.parsed[c].value > a.parsed[c].value ? 1 : -1;
        return s.index - a.index;
      }).map((s, a) => (s.child.rank = a, s.child));
    }, this.subscribe = (t, o) => {
      const r = {
        eventType: t,
        fn: o
      };
      return this.subscribers.add(r), () => {
        this.subscribers.delete(r);
      };
    }, this.emit = (t) => {
      this.subscribers.forEach((o) => {
        o.eventType === t.type && o.fn(t);
      });
    }, this.parseLocation = (t, o) => {
      const r = ({
        pathname: u,
        search: c,
        hash: d,
        state: l
      }) => {
        const h = this.options.parseSearch(c), f = this.options.stringifySearch(h);
        return {
          pathname: u,
          searchStr: f,
          search: q(t?.search, h),
          hash: d.split("#").reverse()[0] ?? "",
          href: `${u}${f}${d}`,
          state: q(t?.state, l)
        };
      }, i = r(o ?? this.history.location), { __tempLocation: s, __tempKey: a } = i.state;
      if (s && (!a || a === this.tempLocationKey)) {
        const u = r(s);
        return u.state.key = i.state.key, delete u.state.__tempLocation, {
          ...u,
          maskedLocation: i
        };
      }
      return i;
    }, this.resolvePathWithBase = (t, o) => je({
      basepath: this.basepath,
      base: t,
      to: Vt(o),
      trailingSlash: this.options.trailingSlash,
      caseSensitive: this.options.caseSensitive
    }), this.getMatchedRoutes = (t, o) => {
      let r = {};
      const i = ut(t.pathname), s = (d) => Et(this.basepath, i, {
        to: d.fullPath,
        caseSensitive: d.options.caseSensitive ?? this.options.caseSensitive,
        fuzzy: !0
      });
      let a = o?.to !== void 0 ? this.routesByPath[o.to] : void 0;
      a ? r = s(a) : a = this.flatRoutes.find((d) => {
        const l = s(d);
        return l ? (r = l, !0) : !1;
      });
      let u = a || this.routesById[H];
      const c = [u];
      for (; u.parentRoute; )
        u = u.parentRoute, c.unshift(u);
      return { matchedRoutes: c, routeParams: r, foundRoute: a };
    }, this.cancelMatch = (t) => {
      const o = this.getMatch(t);
      o && (o.abortController.abort(), clearTimeout(o.pendingTimeout));
    }, this.cancelMatches = () => {
      var t;
      (t = this.state.pendingMatches) == null || t.forEach((o) => {
        this.cancelMatch(o.id);
      });
    }, this.buildLocation = (t) => {
      const o = (i = {}, s) => {
        var a, u, c, d, l, h;
        const f = i._fromLocation ? this.matchRoutes(i._fromLocation, { _buildLocation: !0 }) : this.state.matches, p = i.from != null ? f.find(
          (m) => Et(this.basepath, ut(m.pathname), {
            to: i.from,
            caseSensitive: !1,
            fuzzy: !1
          })
        ) : void 0, _ = p?.pathname || this.latestLocation.pathname;
        et(
          i.from == null || p != null,
          "Could not find match for from: " + i.from
        );
        const g = (a = this.state.pendingMatches) != null && a.length ? (u = Rt(this.state.pendingMatches)) == null ? void 0 : u.search : ((c = Rt(f)) == null ? void 0 : c.search) || this.latestLocation.search, M = s?.matchedRoutes.filter(
          (m) => f.find((P) => P.routeId === m.id)
        );
        let C;
        if (i.to)
          C = this.resolvePathWithBase(_, `${i.to}`);
        else {
          const m = this.routesById[(d = M?.find((P) => {
            const E = It({
              path: P.fullPath,
              params: s?.routeParams ?? {},
              decodeCharMap: this.pathParamsDecodeCharMap
            });
            return nt([this.basepath, E]) === _;
          })) == null ? void 0 : d.id];
          C = this.resolvePathWithBase(
            _,
            m?.to ?? _
          );
        }
        const L = { ...(l = Rt(f)) == null ? void 0 : l.params };
        let w = (i.params ?? !0) === !0 ? L : {
          ...L,
          ...lt(i.params, L)
        };
        Object.keys(w).length > 0 && s?.matchedRoutes.map((m) => {
          var P;
          return ((P = m.options.params) == null ? void 0 : P.stringify) ?? m.options.stringifyParams;
        }).filter(Boolean).forEach((m) => {
          w = { ...w, ...m(w) };
        }), C = It({
          path: C,
          params: w ?? {},
          leaveWildcards: !1,
          leaveParams: t.leaveParams,
          decodeCharMap: this.pathParamsDecodeCharMap
        });
        let v = g;
        if (t._includeValidateSearch && ((h = this.options.search) != null && h.strict)) {
          let m = {};
          s?.matchedRoutes.forEach((P) => {
            try {
              P.options.validateSearch && (m = {
                ...m,
                ...qt(P.options.validateSearch, {
                  ...m,
                  ...v
                }) ?? {}
              });
            } catch {
            }
          }), v = m;
        }
        v = ((m) => {
          const P = s?.matchedRoutes.reduce(
            (I, D) => {
              var W;
              const X = [];
              if ("search" in D.options)
                (W = D.options.search) != null && W.middlewares && X.push(...D.options.search.middlewares);
              else if (D.options.preSearchFilters || D.options.postSearchFilters) {
                const J = ({
                  search: G,
                  next: ot
                }) => {
                  let O = G;
                  "preSearchFilters" in D.options && D.options.preSearchFilters && (O = D.options.preSearchFilters.reduce(
                    (A, V) => V(A),
                    G
                  ));
                  const $ = ot(O);
                  return "postSearchFilters" in D.options && D.options.postSearchFilters ? D.options.postSearchFilters.reduce(
                    (A, V) => V(A),
                    $
                  ) : $;
                };
                X.push(J);
              }
              if (t._includeValidateSearch && D.options.validateSearch) {
                const J = ({ search: G, next: ot }) => {
                  try {
                    const O = ot(G);
                    return {
                      ...O,
                      ...qt(
                        D.options.validateSearch,
                        O
                      ) ?? {}
                    };
                  } catch {
                  }
                };
                X.push(J);
              }
              return I.concat(X);
            },
            []
          ) ?? [], E = ({ search: I }) => i.search ? i.search === !0 ? I : lt(i.search, I) : {};
          P.push(E);
          const T = (I, D) => {
            if (I >= P.length)
              return D;
            const W = P[I];
            return W({ search: D, next: (J) => T(I + 1, J) });
          };
          return T(0, m);
        })(v), v = q(g, v);
        const F = this.options.stringifySearch(v), y = i.hash === !0 ? this.latestLocation.hash : i.hash ? lt(i.hash, this.latestLocation.hash) : void 0, S = y ? `#${y}` : "";
        let k = i.state === !0 ? this.latestLocation.state : i.state ? lt(i.state, this.latestLocation.state) : {};
        return k = q(this.latestLocation.state, k), {
          pathname: C,
          search: v,
          searchStr: F,
          state: k,
          hash: y ?? "",
          href: `${C}${F}${S}`,
          unmaskOnReload: i.unmaskOnReload
        };
      }, r = (i = {}, s) => {
        var a;
        const u = o(i);
        let c = s ? o(s) : void 0;
        if (!c) {
          let h = {};
          const f = (a = this.options.routeMasks) == null ? void 0 : a.find((p) => {
            const _ = Et(this.basepath, u.pathname, {
              to: p.from,
              caseSensitive: !1,
              fuzzy: !1
            });
            return _ ? (h = _, !0) : !1;
          });
          if (f) {
            const { from: p, ..._ } = f;
            s = {
              ...te(t, ["from"]),
              ..._,
              params: h
            }, c = o(s);
          }
        }
        const d = this.getMatchedRoutes(u, i), l = o(i, d);
        if (c) {
          const h = this.getMatchedRoutes(c, s), f = o(s, h);
          l.maskedLocation = f;
        }
        return l;
      };
      return t.mask ? r(t, {
        ...te(t, ["from"]),
        ...t.mask
      }) : r(t);
    }, this.commitLocation = ({
      viewTransition: t,
      ignoreBlocker: o,
      ...r
    }) => {
      const i = () => {
        r.state.key = this.latestLocation.state.key;
        const u = gt(r.state, this.latestLocation.state);
        return delete r.state.key, u;
      }, s = this.latestLocation.href === r.href, a = this.commitLocationPromise;
      if (this.commitLocationPromise = pt(() => {
        a?.resolve();
      }), s && i())
        this.load();
      else {
        let { maskedLocation: u, hashScrollIntoView: c, ...d } = r;
        u && (d = {
          ...u,
          state: {
            ...u.state,
            __tempKey: void 0,
            __tempLocation: {
              ...d,
              search: d.searchStr,
              state: {
                ...d.state,
                __tempKey: void 0,
                __tempLocation: void 0,
                key: void 0
              }
            }
          }
        }, (d.unmaskOnReload ?? this.options.unmaskOnReload ?? !1) && (d.state.__tempKey = this.tempLocationKey)), d.state.__hashScrollIntoViewOptions = c ?? this.options.defaultHashScrollIntoView ?? !0, this.shouldViewTransition = t, this.history[r.replace ? "replace" : "push"](
          d.href,
          d.state,
          { ignoreBlocker: o }
        );
      }
      return this.resetNextScroll = r.resetScroll ?? !0, this.history.subscribers.size || this.load(), this.commitLocationPromise;
    }, this.buildAndCommitLocation = ({
      replace: t,
      resetScroll: o,
      hashScrollIntoView: r,
      viewTransition: i,
      ignoreBlocker: s,
      href: a,
      ...u
    } = {}) => {
      if (a) {
        const d = this.history.location.state.__TSR_index, l = yt(a, {
          __TSR_index: t ? d : d + 1
        });
        u.to = l.pathname, u.search = this.options.parseSearch(l.search), u.hash = l.hash.slice(1);
      }
      const c = this.buildLocation({
        ...u,
        _includeValidateSearch: !0
      });
      return this.commitLocation({
        ...c,
        viewTransition: i,
        replace: t,
        resetScroll: o,
        hashScrollIntoView: r,
        ignoreBlocker: s
      });
    }, this.navigate = ({ to: t, reloadDocument: o, href: r, ...i }) => {
      if (o) {
        r || (r = this.buildLocation({ to: t, ...i }).href), i.replace ? window.location.replace(r) : window.location.href = r;
        return;
      }
      return this.buildAndCommitLocation({
        ...i,
        href: r,
        to: t
      });
    }, this.load = async (t) => {
      this.latestLocation = this.parseLocation(this.latestLocation);
      let o, r, i;
      for (i = new Promise((s) => {
        this.startReactTransition(async () => {
          var a;
          try {
            const u = this.latestLocation, c = this.state.resolvedLocation, d = c.href !== u.href, l = c.pathname !== u.pathname;
            this.cancelMatches();
            let h;
            Wt(() => {
              h = this.matchRoutes(u), this.__store.setState((f) => ({
                ...f,
                status: "pending",
                isLoading: !0,
                location: u,
                pendingMatches: h,
                // If a cached moved to pendingMatches, remove it from cachedMatches
                cachedMatches: f.cachedMatches.filter((p) => !h.find((_) => _.id === p.id))
              }));
            }), this.state.redirect || this.emit({
              type: "onBeforeNavigate",
              fromLocation: c,
              toLocation: u,
              pathChanged: l,
              hrefChanged: d
            }), this.emit({
              type: "onBeforeLoad",
              fromLocation: c,
              toLocation: u,
              pathChanged: l,
              hrefChanged: d
            }), await this.loadMatches({
              sync: t?.sync,
              matches: h,
              location: u,
              // eslint-disable-next-line @typescript-eslint/require-await
              onReady: async () => {
                this.startViewTransition(async () => {
                  let f, p, _;
                  Wt(() => {
                    this.__store.setState((g) => {
                      const M = g.matches, C = g.pendingMatches || g.matches;
                      return f = M.filter(
                        (L) => !C.find((w) => w.id === L.id)
                      ), p = C.filter(
                        (L) => !M.find((w) => w.id === L.id)
                      ), _ = M.filter(
                        (L) => C.find((w) => w.id === L.id)
                      ), {
                        ...g,
                        isLoading: !1,
                        loadedAt: Date.now(),
                        matches: C,
                        pendingMatches: void 0,
                        cachedMatches: [
                          ...g.cachedMatches,
                          ...f.filter((L) => L.status !== "error")
                        ]
                      };
                    }), this.clearExpiredCache();
                  }), [
                    [f, "onLeave"],
                    [p, "onEnter"],
                    [_, "onStay"]
                  ].forEach(([g, M]) => {
                    g.forEach((C) => {
                      var L, w;
                      (w = (L = this.looseRoutesById[C.routeId].options)[M]) == null || w.call(L, C);
                    });
                  });
                });
              }
            });
          } catch (u) {
            Gt(u) ? (o = u, this.isServer || this.navigate({
              ...o,
              replace: !0,
              ignoreBlocker: !0
            })) : tt(u) && (r = u), this.__store.setState((c) => ({
              ...c,
              statusCode: o ? o.statusCode : r ? 404 : c.matches.some((d) => d.status === "error") ? 500 : 200,
              redirect: o
            }));
          }
          this.latestLoadPromise === i && ((a = this.commitLocationPromise) == null || a.resolve(), this.latestLoadPromise = void 0, this.commitLocationPromise = void 0), s();
        });
      }), this.latestLoadPromise = i, await i; this.latestLoadPromise && i !== this.latestLoadPromise; )
        await this.latestLoadPromise;
    }, this.startViewTransition = (t) => {
      const o = this.shouldViewTransition ?? this.options.defaultViewTransition;
      if (delete this.shouldViewTransition, o && typeof document < "u" && "startViewTransition" in document && typeof document.startViewTransition == "function") {
        let r;
        typeof o == "object" && this.isViewTransitionTypesSupported ? r = {
          update: t,
          types: o.types
        } : r = t, document.startViewTransition(r);
      } else
        t();
    }, this.updateMatch = (t, o) => {
      var r;
      let i;
      const s = (r = this.state.pendingMatches) == null ? void 0 : r.find((d) => d.id === t), a = this.state.matches.find((d) => d.id === t), u = this.state.cachedMatches.find((d) => d.id === t), c = s ? "pendingMatches" : a ? "matches" : u ? "cachedMatches" : "";
      return c && this.__store.setState((d) => {
        var l;
        return {
          ...d,
          [c]: (l = d[c]) == null ? void 0 : l.map(
            (h) => h.id === t ? i = o(h) : h
          )
        };
      }), i;
    }, this.getMatch = (t) => [
      ...this.state.cachedMatches,
      ...this.state.pendingMatches ?? [],
      ...this.state.matches
    ].find((o) => o.id === t), this.loadMatches = async ({
      location: t,
      matches: o,
      preload: r,
      onReady: i,
      updateMatch: s = this.updateMatch,
      sync: a
    }) => {
      let u, c = !1;
      const d = async () => {
        c || (c = !0, await i?.());
      }, l = (f) => !!(r && !this.state.matches.find((p) => p.id === f));
      !this.isServer && !this.state.matches.length && d();
      const h = (f, p) => {
        var _, g, M;
        if (Gt(p) && !p.reloadDocument)
          throw p;
        if (ct(p) || tt(p)) {
          if (s(f.id, (C) => ({
            ...C,
            status: ct(p) ? "redirected" : tt(p) ? "notFound" : "error",
            isFetching: !1,
            error: p,
            beforeLoadPromise: void 0,
            loaderPromise: void 0
          })), p.routeId || (p.routeId = f.routeId), (_ = f.beforeLoadPromise) == null || _.resolve(), (g = f.loaderPromise) == null || g.resolve(), (M = f.loadPromise) == null || M.resolve(), ct(p))
            throw c = !0, p = this.resolveRedirect({ ...p, _fromLocation: t }), p;
          if (tt(p))
            throw this._handleNotFound(o, p, {
              updateMatch: s
            }), p;
        }
      };
      try {
        await new Promise((f, p) => {
          (async () => {
            var _, g, M;
            try {
              const C = (v, x, F) => {
                var y, S;
                const { id: k, routeId: m } = o[v], P = this.looseRoutesById[m];
                if (x instanceof Promise)
                  throw x;
                x.routerCode = F, u = u ?? v, h(this.getMatch(k), x);
                try {
                  (S = (y = P.options).onError) == null || S.call(y, x);
                } catch (E) {
                  x = E, h(this.getMatch(k), x);
                }
                s(k, (E) => {
                  var T, I;
                  return (T = E.beforeLoadPromise) == null || T.resolve(), (I = E.loadPromise) == null || I.resolve(), {
                    ...E,
                    error: x,
                    status: "error",
                    isFetching: !1,
                    updatedAt: Date.now(),
                    abortController: new AbortController(),
                    beforeLoadPromise: void 0
                  };
                });
              };
              for (const [v, { id: x, routeId: F }] of o.entries()) {
                const y = this.getMatch(x), S = (_ = o[v - 1]) == null ? void 0 : _.id, k = this.looseRoutesById[F], m = k.options.pendingMs ?? this.options.defaultPendingMs, P = !!(i && !this.isServer && !l(x) && (k.options.loader || k.options.beforeLoad) && typeof m == "number" && m !== 1 / 0 && (k.options.pendingComponent ?? this.options.defaultPendingComponent));
                let E = !0;
                if (
                  // If we are in the middle of a load, either of these will be present
                  // (not to be confused with `loadPromise`, which is always defined)
                  (y.beforeLoadPromise || y.loaderPromise) && (P && setTimeout(() => {
                    try {
                      d();
                    } catch {
                    }
                  }, m), await y.beforeLoadPromise, E = this.getMatch(x).status !== "success"), E
                ) {
                  try {
                    s(x, (N) => ({
                      ...N,
                      loadPromise: pt(() => {
                        var j;
                        (j = N.loadPromise) == null || j.resolve();
                      }),
                      beforeLoadPromise: pt()
                    }));
                    const T = new AbortController();
                    let I;
                    P && (I = setTimeout(() => {
                      try {
                        d();
                      } catch {
                      }
                    }, m));
                    const { paramsError: D, searchError: W } = this.getMatch(x);
                    D && C(v, D, "PARSE_PARAMS"), W && C(v, W, "VALIDATE_SEARCH");
                    const X = () => S ? this.getMatch(S).context : this.options.context ?? {};
                    s(x, (N) => ({
                      ...N,
                      isFetching: "beforeLoad",
                      fetchCount: N.fetchCount + 1,
                      abortController: T,
                      pendingTimeout: I,
                      context: {
                        ...X(),
                        ...N.__routeContext
                      }
                    }));
                    const { search: J, params: G, context: ot, cause: O } = this.getMatch(x), $ = l(x), A = {
                      search: J,
                      abortController: T,
                      params: G,
                      preload: $,
                      context: ot,
                      location: t,
                      navigate: (N) => this.navigate({ ...N, _fromLocation: t }),
                      buildLocation: this.buildLocation,
                      cause: $ ? "preload" : O,
                      matches: o
                    }, V = await ((M = (g = k.options).beforeLoad) == null ? void 0 : M.call(g, A)) ?? {};
                    (ct(V) || tt(V)) && C(v, V, "BEFORE_LOAD"), s(x, (N) => ({
                      ...N,
                      __beforeLoadContext: V,
                      context: {
                        ...X(),
                        ...N.__routeContext,
                        ...V
                      },
                      abortController: T
                    }));
                  } catch (T) {
                    C(v, T, "BEFORE_LOAD");
                  }
                  s(x, (T) => {
                    var I;
                    return (I = T.beforeLoadPromise) == null || I.resolve(), {
                      ...T,
                      beforeLoadPromise: void 0,
                      isFetching: !1
                    };
                  });
                }
              }
              const L = o.slice(0, u), w = [];
              L.forEach(({ id: v, routeId: x }, F) => {
                w.push(
                  (async () => {
                    const { loaderPromise: y } = this.getMatch(v);
                    let S = !1, k = !1;
                    if (y) {
                      await y;
                      const m = this.getMatch(v);
                      m.error && h(m, m.error);
                    } else {
                      const m = w[F - 1], P = this.looseRoutesById[x], E = () => {
                        const {
                          params: O,
                          loaderDeps: $,
                          abortController: A,
                          context: V,
                          cause: N
                        } = this.getMatch(v), j = l(v);
                        return {
                          params: O,
                          deps: $,
                          preload: !!j,
                          parentMatchPromise: m,
                          abortController: A,
                          context: V,
                          location: t,
                          navigate: (Y) => this.navigate({ ...Y, _fromLocation: t }),
                          cause: j ? "preload" : N,
                          route: P
                        };
                      }, T = Date.now() - this.getMatch(v).updatedAt, I = l(v), D = I ? P.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : P.options.staleTime ?? this.options.defaultStaleTime ?? 0, W = P.options.shouldReload, X = typeof W == "function" ? W(E()) : W;
                      s(v, (O) => ({
                        ...O,
                        loaderPromise: pt(),
                        preload: !!I && !this.state.matches.find(($) => $.id === v)
                      }));
                      const J = async () => {
                        var O, $, A, V, N, j, Y, Mt, xt;
                        try {
                          const it = async () => {
                            const U = this.getMatch(v);
                            U.minPendingPromise && await U.minPendingPromise;
                          };
                          try {
                            this.loadRouteChunk(P), s(v, (ft) => ({
                              ...ft,
                              isFetching: "loader"
                            }));
                            const U = await (($ = (O = P.options).loader) == null ? void 0 : $.call(O, E()));
                            h(
                              this.getMatch(v),
                              U
                            ), await P._lazyPromise, await it();
                            const Q = (V = (A = P.options).head) == null ? void 0 : V.call(A, {
                              matches: o,
                              match: this.getMatch(v),
                              params: this.getMatch(v).params,
                              loaderData: U
                            }), st = Q?.meta, at = Q?.links, St = Q?.scripts, Pt = (j = (N = P.options).headers) == null ? void 0 : j.call(N, {
                              loaderData: U
                            });
                            s(v, (ft) => ({
                              ...ft,
                              error: void 0,
                              status: "success",
                              isFetching: !1,
                              updatedAt: Date.now(),
                              loaderData: U,
                              meta: st,
                              links: at,
                              scripts: St,
                              headers: Pt
                            }));
                          } catch (U) {
                            let Q = U;
                            await it(), h(this.getMatch(v), U);
                            try {
                              (Mt = (Y = P.options).onError) == null || Mt.call(Y, U);
                            } catch (st) {
                              Q = st, h(
                                this.getMatch(v),
                                st
                              );
                            }
                            s(v, (st) => ({
                              ...st,
                              error: Q,
                              status: "error",
                              isFetching: !1
                            }));
                          }
                          (xt = this.serverSsr) == null || xt.onMatchSettled({
                            router: this,
                            match: this.getMatch(v)
                          }), await P._componentsPromise;
                        } catch (it) {
                          s(v, (U) => ({
                            ...U,
                            loaderPromise: void 0
                          })), h(this.getMatch(v), it);
                        }
                      }, { status: G, invalid: ot } = this.getMatch(v);
                      S = G === "success" && (ot || (X ?? T > D)), I && P.options.preload === !1 || (S && !a ? (k = !0, (async () => {
                        try {
                          await J();
                          const { loaderPromise: O, loadPromise: $ } = this.getMatch(v);
                          O?.resolve(), $?.resolve(), s(v, (A) => ({
                            ...A,
                            loaderPromise: void 0
                          }));
                        } catch (O) {
                          Gt(O) && await this.navigate(O);
                        }
                      })()) : (G !== "success" || S && a) && await J());
                    }
                    if (!k) {
                      const { loaderPromise: m, loadPromise: P } = this.getMatch(v);
                      m?.resolve(), P?.resolve();
                    }
                    return s(v, (m) => ({
                      ...m,
                      isFetching: k ? m.isFetching : !1,
                      loaderPromise: k ? m.loaderPromise : void 0,
                      invalid: !1
                    })), this.getMatch(v);
                  })()
                );
              }), await Promise.all(w), f();
            } catch (C) {
              p(C);
            }
          })();
        }), await d();
      } catch (f) {
        if (ct(f) || tt(f))
          throw tt(f) && !r && await d(), f;
      }
      return o;
    }, this.invalidate = (t) => {
      const o = (r) => {
        var i;
        return ((i = t?.filter) == null ? void 0 : i.call(t, r)) ?? !0 ? {
          ...r,
          invalid: !0,
          ...r.status === "error" ? { status: "pending", error: void 0 } : {}
        } : r;
      };
      return this.__store.setState((r) => {
        var i;
        return {
          ...r,
          matches: r.matches.map(o),
          cachedMatches: r.cachedMatches.map(o),
          pendingMatches: (i = r.pendingMatches) == null ? void 0 : i.map(o)
        };
      }), this.load({ sync: t?.sync });
    }, this.resolveRedirect = (t) => {
      const o = t;
      return o.href || (o.href = this.buildLocation(o).href), o;
    }, this.clearCache = (t) => {
      const o = t?.filter;
      o !== void 0 ? this.__store.setState((r) => ({
        ...r,
        cachedMatches: r.cachedMatches.filter(
          (i) => !o(i)
        )
      })) : this.__store.setState((r) => ({
        ...r,
        cachedMatches: []
      }));
    }, this.clearExpiredCache = () => {
      const t = (o) => {
        const r = this.looseRoutesById[o.routeId];
        if (!r.options.loader)
          return !0;
        const i = (o.preload ? r.options.preloadGcTime ?? this.options.defaultPreloadGcTime : r.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
        return !(o.status !== "error" && Date.now() - o.updatedAt < i);
      };
      this.clearCache({ filter: t });
    }, this.loadRouteChunk = (t) => (t._lazyPromise === void 0 && (t.lazyFn ? t._lazyPromise = t.lazyFn().then((o) => {
      const { id: r, ...i } = o.options;
      Object.assign(t.options, i);
    }) : t._lazyPromise = Promise.resolve()), t._componentsPromise === void 0 && (t._componentsPromise = t._lazyPromise.then(
      () => Promise.all(
        ye.map(async (o) => {
          const r = t.options[o];
          r?.preload && await r.preload();
        })
      )
    )), t._componentsPromise), this.preloadRoute = async (t) => {
      const o = this.buildLocation(t);
      let r = this.matchRoutes(o, {
        throwOnError: !0,
        preload: !0,
        dest: t
      });
      const i = new Set(
        [...this.state.matches, ...this.state.pendingMatches ?? []].map(
          (a) => a.id
        )
      ), s = /* @__PURE__ */ new Set([
        ...i,
        ...this.state.cachedMatches.map((a) => a.id)
      ]);
      Wt(() => {
        r.forEach((a) => {
          s.has(a.id) || this.__store.setState((u) => ({
            ...u,
            cachedMatches: [...u.cachedMatches, a]
          }));
        });
      });
      try {
        return r = await this.loadMatches({
          matches: r,
          location: o,
          preload: !0,
          updateMatch: (a, u) => {
            i.has(a) ? r = r.map((c) => c.id === a ? u(c) : c) : this.updateMatch(a, u);
          }
        }), r;
      } catch (a) {
        if (ct(a))
          return a.reloadDocument ? void 0 : await this.preloadRoute({
            ...a,
            _fromLocation: o
          });
        console.error(a);
        return;
      }
    }, this.matchRoute = (t, o) => {
      const r = {
        ...t,
        to: t.to ? this.resolvePathWithBase(
          t.from || "",
          t.to
        ) : void 0,
        params: t.params || {},
        leaveParams: !0
      }, i = this.buildLocation(r);
      if (o?.pending && this.state.status !== "pending")
        return !1;
      const a = (o?.pending === void 0 ? !this.state.isLoading : o.pending) ? this.latestLocation : this.state.resolvedLocation, u = Et(this.basepath, a.pathname, {
        ...o,
        to: i.pathname
      });
      return !u || t.params && !gt(u, t.params, { partial: !0 }) ? !1 : u && (o?.includeSearch ?? !0) ? gt(a.search, i.search, { partial: !0 }) ? u : !1 : u;
    }, this._handleNotFound = (t, o, {
      updateMatch: r = this.updateMatch
    } = {}) => {
      const i = Object.fromEntries(
        t.map((u) => [u.routeId, u])
      );
      let s = (o.global ? this.looseRoutesById[H] : this.looseRoutesById[o.routeId]) || this.looseRoutesById[H];
      for (; !s.options.notFoundComponent && !this.options.defaultNotFoundComponent && s.id !== H; )
        s = s.parentRoute, et(
          s,
          "Found invalid route tree while trying to find not-found handler."
        );
      const a = i[s.id];
      et(a, "Could not find match for route: " + s.id), r(a.id, (u) => ({
        ...u,
        status: "notFound",
        error: o,
        isFetching: !1
      })), o.routerCode === "BEFORE_LOAD" && s.parentRoute && (o.routeId = s.parentRoute.id, this._handleNotFound(t, o, {
        updateMatch: r
      }));
    }, this.hasNotFoundMatch = () => this.__store.state.matches.some(
      (t) => t.status === "notFound" || t.globalNotFound
    ), this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...n,
      caseSensitive: n.caseSensitive ?? !1,
      notFoundMode: n.notFoundMode ?? "fuzzy",
      stringifySearch: n.stringifySearch ?? Ne,
      parseSearch: n.parseSearch ?? Ve
    }), typeof document < "u" && (window.__TSR_ROUTER__ = this);
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
  matchRoutes(n, t, o) {
    return typeof n == "string" ? this.matchRoutesInternal(
      {
        pathname: n,
        search: t
      },
      o
    ) : this.matchRoutesInternal(n, t);
  }
  matchRoutesInternal(n, t) {
    const { foundRoute: o, matchedRoutes: r, routeParams: i } = this.getMatchedRoutes(
      n,
      t?.dest
    );
    let s = !1;
    // If we found a route, and it's not an index route and we have left over path
    (o ? o.path !== "/" && i["**"] : (
      // Or if we didn't find a route and we have left over path
      ut(n.pathname)
    )) && (this.options.notFoundRoute ? r.push(this.options.notFoundRoute) : s = !0);
    const a = (() => {
      if (s) {
        if (this.options.notFoundMode !== "root")
          for (let l = r.length - 1; l >= 0; l--) {
            const h = r[l];
            if (h.children)
              return h.id;
          }
        return H;
      }
    })(), u = r.map((l) => {
      var h;
      let f;
      const p = ((h = l.options.params) == null ? void 0 : h.parse) ?? l.options.parseParams;
      if (p)
        try {
          const _ = p(i);
          Object.assign(i, _);
        } catch (_) {
          if (f = new eo(_.message, {
            cause: _
          }), t?.throwOnError)
            throw f;
          return f;
        }
    }), c = [], d = (l) => l?.id ? l.context ?? this.options.context ?? {} : this.options.context ?? {};
    return r.forEach((l, h) => {
      var f, p, _, g;
      const M = c[h - 1], [C, L] = (() => {
        const E = M?.search ?? n.search;
        try {
          const T = qt(l.options.validateSearch, E) ?? {};
          return [
            {
              ...E,
              ...T
            },
            void 0
          ];
        } catch (T) {
          const I = new ee(T.message, {
            cause: T
          });
          if (t?.throwOnError)
            throw I;
          return [E, I];
        }
      })(), w = ((p = (f = l.options).loaderDeps) == null ? void 0 : p.call(f, {
        search: C
      })) ?? "", v = w ? JSON.stringify(w) : "", x = It({
        path: l.fullPath,
        params: i,
        decodeCharMap: this.pathParamsDecodeCharMap
      }), F = It({
        path: l.id,
        params: i,
        leaveWildcards: !0,
        decodeCharMap: this.pathParamsDecodeCharMap
      }) + v, y = this.getMatch(F), S = this.state.matches.find(
        (E) => E.routeId === l.id
      ), k = S ? "stay" : "enter";
      let m;
      if (y)
        m = {
          ...y,
          cause: k,
          params: S ? q(S.params, i) : i,
          search: q(S ? S.search : y.search, C)
        };
      else {
        const E = l.options.loader || l.options.beforeLoad || l.lazyFn || Ze(l) ? "pending" : "success";
        m = {
          id: F,
          index: h,
          routeId: l.id,
          params: S ? q(S.params, i) : i,
          pathname: nt([this.basepath, x]),
          updatedAt: Date.now(),
          search: S ? q(S.search, C) : C,
          searchError: void 0,
          status: E,
          isFetching: !1,
          error: void 0,
          paramsError: u[h],
          __routeContext: {},
          __beforeLoadContext: {},
          context: {},
          abortController: new AbortController(),
          fetchCount: 0,
          cause: k,
          loaderDeps: S ? q(S.loaderDeps, w) : w,
          invalid: !1,
          preload: !1,
          links: void 0,
          scripts: void 0,
          meta: void 0,
          staticData: l.options.staticData || {},
          loadPromise: pt(),
          fullPath: l.fullPath
        };
      }
      m.status === "success" && (m.headers = (g = (_ = l.options).headers) == null ? void 0 : g.call(_, {
        loaderData: m.loaderData
      })), t?.preload || (m.globalNotFound = a === l.id), m.searchError = L;
      const P = d(M);
      m.context = {
        ...P,
        ...m.__routeContext,
        ...m.__beforeLoadContext
      }, c.push(m);
    }), c.forEach((l, h) => {
      var f, p, _, g;
      const M = this.looseRoutesById[l.routeId];
      if (!this.getMatch(l.id) && t?._buildLocation !== !0) {
        const w = c[h - 1], v = d(w), x = {
          deps: l.loaderDeps,
          params: l.params,
          context: v,
          location: n,
          navigate: (F) => this.navigate({ ...F, _fromLocation: n }),
          buildLocation: this.buildLocation,
          cause: l.cause,
          abortController: l.abortController,
          preload: !!l.preload,
          matches: c
        };
        l.__routeContext = ((p = (f = M.options).context) == null ? void 0 : p.call(f, x)) ?? {}, l.context = {
          ...v,
          ...l.__routeContext,
          ...l.__beforeLoadContext
        };
      }
      const L = (g = (_ = M.options).head) == null ? void 0 : g.call(_, {
        matches: c,
        match: l,
        params: l.params,
        loaderData: l.loaderData ?? void 0
      });
      l.links = L?.links, l.scripts = L?.scripts, l.meta = L?.meta;
    }), c;
  }
}
class ee extends Error {
}
class eo extends Error {
}
function oo(e) {
  return {
    loadedAt: 0,
    isLoading: !1,
    isTransitioning: !1,
    status: "idle",
    resolvedLocation: { ...e },
    location: e,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200
  };
}
const Kt = b.createContext(void 0), no = b.createContext(
  void 0
);
function ht(e) {
  const n = b.useContext(
    e.from ? no : Kt
  );
  return z({
    select: (o) => {
      const r = o.matches.find(
        (i) => e.from ? e.from === i.routeId : i.id === n
      );
      if (et(
        !((e.shouldThrow ?? !0) && !r),
        `Could not find ${e.from ? `an active match from "${e.from}"` : "a nearest match!"}`
      ), r !== void 0)
        return e.select ? e.select(r) : r;
    },
    structuralSharing: e.structuralSharing
  });
}
function ro(e) {
  return ht({
    from: e.from,
    strict: e.strict,
    structuralSharing: e.structuralSharing,
    select: (n) => e.select ? e.select(n.loaderData) : n.loaderData
  });
}
function so(e) {
  const { select: n, ...t } = e;
  return ht({
    ...t,
    select: (o) => n ? n(o.loaderDeps) : o.loaderDeps
  });
}
function io(e) {
  return ht({
    from: e.from,
    strict: e.strict,
    structuralSharing: e.structuralSharing,
    select: (n) => e.select ? e.select(n.params) : n.params
  });
}
function ao(e) {
  return ht({
    from: e.from,
    strict: e.strict,
    structuralSharing: e.structuralSharing,
    select: (n) => e.select ? e.select(n.search) : n.search
  });
}
function co(e) {
  const { navigate: n } = rt();
  return b.useCallback(
    (t) => n({
      ...t
    }),
    [n]
  );
}
class _e {
  /**
   * @deprecated Use the `createRoute` function instead.
   */
  constructor(n) {
    this.init = (t) => {
      var o, r;
      this.originalIndex = t.originalIndex;
      const i = this.options, s = !i?.path && !i?.id;
      this.parentRoute = (r = (o = this.options).getParentRoute) == null ? void 0 : r.call(o), s ? this._path = H : et(
        this.parentRoute,
        "Child Route instances must pass a 'getParentRoute: () => ParentRoute' option that returns a Route instance."
      );
      let a = s ? H : i.path;
      a && a !== "/" && (a = oe(a));
      const u = i?.id || a;
      let c = s ? H : nt([
        this.parentRoute.id === H ? "" : this.parentRoute.id,
        u
      ]);
      a === H && (a = "/"), c !== H && (c = nt(["/", c]));
      const d = c === H ? "/" : nt([this.parentRoute.fullPath, a]);
      this._path = a, this._id = c, this._fullPath = d, this._to = d, this._ssr = i?.ssr ?? t.defaultSsr ?? !0;
    }, this.updateLoader = (t) => (Object.assign(this.options, t), this), this.update = (t) => (Object.assign(this.options, t), this), this.lazy = (t) => (this.lazyFn = t, this), this.useMatch = (t) => ht({
      select: t?.select,
      from: this.id,
      structuralSharing: t?.structuralSharing
    }), this.useRouteContext = (t) => ht({
      ...t,
      from: this.id,
      select: (o) => t?.select ? t.select(o.context) : o.context
    }), this.useSearch = (t) => ao({
      select: t?.select,
      structuralSharing: t?.structuralSharing,
      from: this.id
    }), this.useParams = (t) => io({
      select: t?.select,
      structuralSharing: t?.structuralSharing,
      from: this.id
    }), this.useLoaderDeps = (t) => so({ ...t, from: this.id }), this.useLoaderData = (t) => ro({ ...t, from: this.id }), this.useNavigate = () => co({ from: this.id }), this.options = n || {}, this.isRoot = !n?.getParentRoute, et(
      !(n?.id && n?.path),
      "Route cannot have both an 'id' and a 'path' option."
    ), this.$$typeof = Symbol.for("react.memo");
  }
  get to() {
    return this._to;
  }
  get id() {
    return this._id;
  }
  get path() {
    return this._path;
  }
  get fullPath() {
    return this._fullPath;
  }
  get ssr() {
    return this._ssr;
  }
  addChildren(n) {
    return this._addFileChildren(n);
  }
  _addFileChildren(n) {
    return Array.isArray(n) && (this.children = n), typeof n == "object" && n !== null && (this.children = Object.values(n)), this;
  }
}
function lo(e) {
  return new _e(e);
}
function Do() {
  return (e) => ho(e);
}
class uo extends _e {
  /**
   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
   */
  constructor(n) {
    super(n);
  }
  addChildren(n) {
    return super.addChildren(n), this;
  }
  _addFileChildren(n) {
    return super._addFileChildren(n), this;
  }
  _addFileTypes() {
    return this;
  }
}
function ho(e) {
  return new uo(e);
}
function Oo(e) {
  return new fo(e, {
    silent: !0
  }).createRoute;
}
class fo {
  constructor(n, t) {
    this.path = n, this.createRoute = (o) => {
      Lt(
        this.silent,
        "FileRoute is deprecated and will be removed in the next major version. Use the createFileRoute(path)(options) function instead."
      );
      const r = lo(o);
      return r.isRoot = !1, r;
    }, this.silent = t?.silent;
  }
}
function Tt(e) {
  return /* @__PURE__ */ R(Ce, { children: e.children });
}
function Se(e, n, t) {
  return n.options.notFoundComponent ? /* @__PURE__ */ R(n.options.notFoundComponent, { data: t }) : e.options.defaultNotFoundComponent ? /* @__PURE__ */ R(e.options.defaultNotFoundComponent, { data: t }) : /* @__PURE__ */ R(Qe, {});
}
const Pe = b.memo(function({
  matchId: n
}) {
  var t, o;
  const r = rt(), i = z({
    select: (g) => {
      var M;
      return (M = g.matches.find((C) => C.id === n)) == null ? void 0 : M.routeId;
    }
  });
  et(
    i,
    `Could not find routeId for matchId "${n}". Please file an issue!`
  );
  const s = r.routesById[i], a = s.options.pendingComponent ?? r.options.defaultPendingComponent, u = a ? /* @__PURE__ */ R(a, {}) : null, c = s.options.errorComponent ?? r.options.defaultErrorComponent, d = s.options.onCatch ?? r.options.defaultOnCatch, l = s.isRoot ? (
    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
    s.options.notFoundComponent ?? ((t = r.options.notFoundRoute) == null ? void 0 : t.options.component)
  ) : s.options.notFoundComponent, h = (
    // If we're on the root route, allow forcefully wrapping in suspense
    (!s.isRoot || s.options.wrapInSuspense) && (s.options.wrapInSuspense ?? a ?? ((o = s.options.errorComponent) == null ? void 0 : o.preload)) ? b.Suspense : Tt
  ), f = c ? ne : Tt, p = l ? Ye : Tt, _ = z({
    select: (g) => g.loadedAt
  });
  return /* @__PURE__ */ R(Kt.Provider, { value: n, children: /* @__PURE__ */ R(h, { fallback: u, children: /* @__PURE__ */ R(
    f,
    {
      getResetKey: () => _,
      errorComponent: c || Nt,
      onCatch: (g, M) => {
        if (tt(g)) throw g;
        Lt(!1, `Error in route match: ${n}`), d?.(g, M);
      },
      children: /* @__PURE__ */ R(
        p,
        {
          fallback: (g) => {
            if (!l || g.routeId && g.routeId !== i || !g.routeId && !s.isRoot)
              throw g;
            return b.createElement(l, g);
          },
          children: /* @__PURE__ */ R(po, { matchId: n })
        }
      )
    }
  ) }) });
}), po = b.memo(function({
  matchId: n
}) {
  var t, o, r;
  const i = rt(), { match: s, matchIndex: a, routeId: u } = z({
    select: (h) => {
      const f = h.matches.findIndex((g) => g.id === n), p = h.matches[f];
      return {
        routeId: p.routeId,
        matchIndex: f,
        match: te(p, ["id", "status", "error"])
      };
    },
    structuralSharing: !0
  }), c = i.routesById[u], d = b.useMemo(() => {
    const h = c.options.component ?? i.options.defaultComponent;
    return h ? /* @__PURE__ */ R(h, {}) : /* @__PURE__ */ R(mo, {});
  }, [c.options.component, i.options.defaultComponent]), l = (c.options.errorComponent ?? i.options.defaultErrorComponent) || Nt;
  if (s.status === "notFound")
    return et(tt(s.error), "Expected a notFound error"), Se(i, c, s.error);
  if (s.status === "redirected")
    throw et(ct(s.error), "Expected a redirect error"), (t = i.getMatch(s.id)) == null ? void 0 : t.loadPromise;
  if (s.status === "error") {
    if (i.isServer)
      return /* @__PURE__ */ R(
        l,
        {
          error: s.error,
          info: {
            componentStack: ""
          }
        }
      );
    throw s.error;
  }
  if (s.status === "pending") {
    const h = c.options.pendingMinMs ?? i.options.defaultPendingMinMs;
    if (h && !((o = i.getMatch(s.id)) != null && o.minPendingPromise) && !i.isServer) {
      const f = pt();
      Promise.resolve().then(() => {
        i.updateMatch(s.id, (p) => ({
          ...p,
          minPendingPromise: f
        }));
      }), setTimeout(() => {
        f.resolve(), i.updateMatch(s.id, (p) => ({
          ...p,
          minPendingPromise: void 0
        }));
      }, h);
    }
    throw (r = i.getMatch(s.id)) == null ? void 0 : r.loadPromise;
  }
  return d;
}), mo = b.memo(function() {
  const n = rt(), t = b.useContext(Kt), o = z({
    select: (c) => {
      var d;
      return (d = c.matches.find((l) => l.id === t)) == null ? void 0 : d.routeId;
    }
  }), r = n.routesById[o], i = z({
    select: (c) => {
      const l = c.matches.find((h) => h.id === t);
      return et(
        l,
        `Could not find parent match for matchId "${t}"`
      ), l.globalNotFound;
    }
  }), s = z({
    select: (c) => {
      var d;
      const l = c.matches, h = l.findIndex((f) => f.id === t);
      return (d = l[h + 1]) == null ? void 0 : d.id;
    }
  });
  if (i)
    return Se(n, r, void 0);
  if (!s)
    return null;
  const a = /* @__PURE__ */ R(Pe, { matchId: s }), u = n.options.defaultPendingComponent ? /* @__PURE__ */ R(n.options.defaultPendingComponent, {}) : null;
  return t === H ? /* @__PURE__ */ R(b.Suspense, { fallback: u, children: a }) : a;
}), vo = "Error preloading route! ";
function go(e, n) {
  const t = rt(), [o, r] = b.useState(!1), i = b.useRef(!1), s = We(n), {
    // custom props
    activeProps: a = () => ({ className: "active" }),
    inactiveProps: u = () => ({}),
    activeOptions: c,
    to: d,
    preload: l,
    preloadDelay: h,
    hashScrollIntoView: f,
    replace: p,
    startTransition: _,
    resetScroll: g,
    viewTransition: M,
    // element props
    children: C,
    target: L,
    disabled: w,
    style: v,
    className: x,
    onClick: F,
    onFocus: y,
    onMouseEnter: S,
    onMouseLeave: k,
    onTouchStart: m,
    ignoreBlocker: P,
    ...E
  } = e, {
    // prevent these from being returned
    params: T,
    search: I,
    hash: D,
    state: W,
    mask: X,
    reloadDocument: J,
    ...G
  } = E, ot = b.useMemo(() => {
    try {
      return new URL(`${d}`), "external";
    } catch {
    }
    return "internal";
  }, [d]), O = z({
    select: (B) => B.location.search,
    structuralSharing: !0
  });
  e = {
    from: ht({ strict: !1, select: (B) => B.pathname }),
    ...e
  };
  const A = b.useMemo(
    () => t.buildLocation(e),
    [t, e, O]
  ), V = b.useMemo(() => e.reloadDocument ? !1 : l ?? t.options.defaultPreload, [t.options.defaultPreload, l, e.reloadDocument]), N = h ?? t.options.defaultPreloadDelay ?? 0, j = z({
    select: (B) => {
      if (c?.exact) {
        if (!Ge(
          B.location.pathname,
          A.pathname,
          t.basepath
        ))
          return !1;
      } else {
        const K = Ot(
          B.location.pathname,
          t.basepath
        ).split("/");
        if (!Ot(
          A.pathname,
          t.basepath
        ).split("/").every(
          (we, be) => we === K[be]
        ))
          return !1;
      }
      return (c?.includeSearch ?? !0) && !gt(B.location.search, A.search, {
        partial: !c?.exact,
        ignoreUndefined: !c?.explicitUndefined
      }) ? !1 : c?.includeHash ? B.location.hash === A.hash : !0;
    }
  }), Y = b.useCallback(() => {
    t.preloadRoute(e).catch((B) => {
      console.warn(B), console.warn(vo);
    });
  }, [e, t]), Mt = b.useCallback(
    (B) => {
      B?.isIntersecting && Y();
    },
    [Y]
  );
  if (ze(
    s,
    Mt,
    { rootMargin: "100px" },
    { disabled: !!w || V !== "viewport" }
  ), bt(() => {
    i.current || !w && V === "render" && (Y(), i.current = !0);
  }, [w, Y, V]), ot === "external")
    return {
      ...G,
      ref: s,
      type: ot,
      href: d,
      ...C && { children: C },
      ...L && { target: L },
      ...w && { disabled: w },
      ...v && { style: v },
      ...x && { className: x },
      ...F && { onClick: F },
      ...y && { onFocus: y },
      ...S && { onMouseEnter: S },
      ...k && { onMouseLeave: k },
      ...m && { onTouchStart: m }
    };
  const xt = (B) => {
    if (!w && !yo(B) && !B.defaultPrevented && (!L || L === "_self") && B.button === 0) {
      B.preventDefault(), Le(() => {
        r(!0);
      });
      const K = t.subscribe("onResolved", () => {
        K(), r(!1);
      });
      return t.navigate({
        ...e,
        replace: p,
        resetScroll: g,
        hashScrollIntoView: f,
        startTransition: _,
        viewTransition: M,
        ignoreBlocker: P
      });
    }
  }, it = (B) => {
    w || V && Y();
  }, U = it, Q = (B) => {
    if (w) return;
    const K = B.target || {};
    if (V) {
      if (K.preloadTimeout)
        return;
      K.preloadTimeout = setTimeout(() => {
        K.preloadTimeout = null, Y();
      }, N);
    }
  }, st = (B) => {
    if (w) return;
    const K = B.target || {};
    K.preloadTimeout && (clearTimeout(K.preloadTimeout), K.preloadTimeout = null);
  }, at = (B) => (K) => {
    var $t;
    ($t = K.persist) == null || $t.call(K), B.filter(Boolean).forEach((se) => {
      K.defaultPrevented || se(K);
    });
  }, St = j ? lt(a, {}) ?? {} : {}, Pt = j ? {} : lt(u, {}), ft = [
    x,
    St.className,
    Pt.className
  ].filter(Boolean).join(" "), re = {
    ...v,
    ...St.style,
    ...Pt.style
  };
  return {
    ...G,
    ...St,
    ...Pt,
    href: w ? void 0 : A.maskedLocation ? t.history.createHref(A.maskedLocation.href) : t.history.createHref(A.href),
    ref: s,
    onClick: at([F, xt]),
    onFocus: at([y, it]),
    onMouseEnter: at([S, Q]),
    onMouseLeave: at([k, st]),
    onTouchStart: at([m, U]),
    disabled: !!w,
    target: L,
    ...Object.keys(re).length && { style: re },
    ...ft && { className: ft },
    ...w && {
      role: "link",
      "aria-disabled": !0
    },
    ...j && { "data-status": "active", "aria-current": "page" },
    ...o && { "data-transitioning": "transitioning" }
  };
}
const Ao = b.forwardRef(
  (e, n) => {
    const { _asChild: t, ...o } = e, {
      type: r,
      ref: i,
      ...s
    } = go(o, n), a = typeof o.children == "function" ? o.children({
      isActive: s["data-status"] === "active"
    }) : o.children;
    return typeof t > "u" && delete s.disabled, b.createElement(
      t || "a",
      {
        ...s,
        ref: i
      },
      a
    );
  }
);
function yo(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function _o() {
  const e = rt(), n = b.useRef({ router: e, mounted: !1 }), t = z({
    select: ({ isLoading: l }) => l
  }), [o, r] = b.useState(!1), i = z({
    select: (l) => l.matches.some((h) => h.status === "pending"),
    structuralSharing: !0
  }), s = Ht(t), a = t || o || i, u = Ht(a), c = t || i, d = Ht(c);
  return e.isServer || (e.startReactTransition = (l) => {
    r(!0), b.startTransition(() => {
      l(), r(!1);
    });
  }), b.useEffect(() => {
    const l = e.history.subscribe(e.load), h = e.buildLocation({
      to: e.latestLocation.pathname,
      search: !0,
      params: !0,
      hash: !0,
      state: !0,
      _includeValidateSearch: !0
    });
    return ut(e.latestLocation.href) !== ut(h.href) && e.commitLocation({ ...h, replace: !0 }), () => {
      l();
    };
  }, [e, e.history]), bt(() => {
    if (typeof window < "u" && e.clientSsr || n.current.router === e && n.current.mounted)
      return;
    n.current = { router: e, mounted: !0 }, (async () => {
      try {
        await e.load();
      } catch (h) {
        console.error(h);
      }
    })();
  }, [e]), bt(() => {
    if (s && !t) {
      const l = e.state.location, h = e.state.resolvedLocation, f = h.pathname !== l.pathname, p = h.href !== l.href;
      e.emit({
        type: "onLoad",
        // When the new URL has committed, when the new matches have been loaded into state.matches
        fromLocation: h,
        toLocation: l,
        pathChanged: f,
        hrefChanged: p
      });
    }
  }, [s, e, t]), bt(() => {
    if (d && !c) {
      const l = e.state.location, h = e.state.resolvedLocation, f = h.pathname !== l.pathname, p = h.href !== l.href;
      e.emit({
        type: "onBeforeRouteMount",
        fromLocation: h,
        toLocation: l,
        pathChanged: f,
        hrefChanged: p
      });
    }
  }, [c, d, e]), bt(() => {
    if (u && !a) {
      const l = e.state.location, h = e.state.resolvedLocation, f = h.pathname !== l.pathname, p = h.href !== l.href;
      if (e.emit({
        type: "onResolved",
        fromLocation: h,
        toLocation: l,
        pathChanged: f,
        hrefChanged: p
      }), e.__store.setState((_) => ({
        ..._,
        status: "idle",
        resolvedLocation: _.location
      })), typeof document < "u" && document.querySelector) {
        const _ = e.state.location.state.__hashScrollIntoViewOptions ?? !0;
        if (_ && e.state.location.hash !== "") {
          const g = document.getElementById(e.state.location.hash);
          g && g.scrollIntoView(_);
        }
      }
    }
  }, [a, u, e]), null;
}
function So() {
  const e = rt(), n = e.options.defaultPendingComponent ? /* @__PURE__ */ R(e.options.defaultPendingComponent, {}) : null, t = e.isServer || typeof document < "u" && e.clientSsr ? Tt : b.Suspense, o = /* @__PURE__ */ Yt(t, { fallback: n, children: [
    /* @__PURE__ */ R(_o, {}),
    /* @__PURE__ */ R(Po, {})
  ] });
  return e.options.InnerWrap ? /* @__PURE__ */ R(e.options.InnerWrap, { children: o }) : o;
}
function Po() {
  const e = z({
    select: (t) => {
      var o;
      return (o = t.matches[0]) == null ? void 0 : o.id;
    }
  }), n = z({
    select: (t) => t.loadedAt
  });
  return /* @__PURE__ */ R(Kt.Provider, { value: e, children: /* @__PURE__ */ R(
    ne,
    {
      getResetKey: () => n,
      errorComponent: Nt,
      onCatch: (t) => {
        Lt(
          !1,
          "The following error wasn't caught by any route! At the very least, consider setting an 'errorComponent' in your RootRoute!"
        ), Lt(!1, t.message || t.toString());
      },
      children: e ? /* @__PURE__ */ R(Pe, { matchId: e }) : null
    }
  ) });
}
function wo({
  router: e,
  children: n,
  ...t
}) {
  e.update({
    ...e.options,
    ...t,
    context: {
      ...e.options.context,
      ...t.context
    }
  });
  const o = ge(), r = /* @__PURE__ */ R(o.Provider, { value: e, children: n });
  return e.options.Wrap ? /* @__PURE__ */ R(e.options.Wrap, { children: r }) : r;
}
function Vo({ router: e, ...n }) {
  return /* @__PURE__ */ R(wo, { router: e, ...n, children: /* @__PURE__ */ R(So, {}) });
}
const bo = typeof window < "u" ? b.useLayoutEffect : b.useEffect, Xt = "window", he = "___";
let Jt = /* @__PURE__ */ new WeakSet();
const Co = typeof window < "u" && window.sessionStorage, Z = Co ? (() => {
  const e = "tsr-scroll-restoration-v2";
  return {
    state: JSON.parse(
      window.sessionStorage.getItem(e) || "null"
    ) || { cached: {}, next: {} },
    set: (t) => {
      Z.state = lt(t, Z.state), window.sessionStorage.setItem(e, JSON.stringify(Z.state));
    }
  };
})() : void 0, Ro = (e) => e.state.key || e.href;
function Lo(e) {
  const n = rt();
  bo(() => {
    const t = e?.getKey || Ro, { history: o } = window;
    o.scrollRestoration = "manual";
    const r = (a) => {
      if (Jt.has(a.target)) return;
      Jt.add(a.target);
      let u = "";
      if (a.target === document || a.target === window)
        u = Xt;
      else {
        const c = a.target.getAttribute(
          "data-scroll-restoration-id"
        );
        c ? u = `[data-scroll-restoration-id="${c}"]` : u = Mo(a.target);
      }
      Z.state.next[u] || Z.set((c) => ({
        ...c,
        next: {
          ...c.next,
          [u]: {
            scrollX: NaN,
            scrollY: NaN
          }
        }
      }));
    };
    typeof document < "u" && document.addEventListener("scroll", r, !0);
    const i = n.subscribe("onBeforeLoad", (a) => {
      if (a.hrefChanged) {
        const u = t(a.fromLocation);
        for (const c in Z.state.next) {
          const d = Z.state.next[c];
          if (c === Xt)
            d.scrollX = window.scrollX || 0, d.scrollY = window.scrollY || 0;
          else if (c) {
            const l = document.querySelector(c);
            d.scrollX = l?.scrollLeft || 0, d.scrollY = l?.scrollTop || 0;
          }
          Z.set((l) => {
            const h = { ...l.next };
            return delete h[c], {
              ...l,
              next: h,
              cached: {
                ...l.cached,
                [[u, c].join(he)]: d
              }
            };
          });
        }
      }
    }), s = n.subscribe(
      "onBeforeRouteMount",
      (a) => {
        if (a.hrefChanged) {
          if (!n.resetNextScroll)
            return;
          n.resetNextScroll = !0;
          const u = t(a.toLocation);
          let c = !1;
          for (const d in Z.state.cached) {
            const l = Z.state.cached[d], [h, f] = d.split(he);
            if (h === u) {
              if (f === Xt)
                c = !0, window.scrollTo({
                  top: l.scrollY,
                  left: l.scrollX,
                  behavior: e?.scrollBehavior
                });
              else if (f) {
                const p = document.querySelector(f);
                p && (p.scrollLeft = l.scrollX, p.scrollTop = l.scrollY);
              }
            }
          }
          c || window.scrollTo(0, 0), Z.set((d) => ({ ...d, next: {} })), Jt = /* @__PURE__ */ new WeakSet();
        }
      }
    );
    return () => {
      document.removeEventListener("scroll", r), i(), s();
    };
  }, [e?.getKey, n]);
}
function No(e) {
  return Lo(e), null;
}
function Mo(e) {
  const n = [];
  let t;
  for (; t = e.parentNode; )
    n.unshift(
      `${e.tagName}:nth-child(${[].indexOf.call(t.children, e) + 1})`
    ), e = t;
  return `${n.join(" > ")}`.toLowerCase();
}
export {
  Ao as L,
  mo as O,
  Vo as R,
  No as S,
  Oo as a,
  io as b,
  Do as c,
  z as d,
  Bo as e,
  Fo as f,
  pe as g,
  tt as i,
  To as n,
  rt as u
};
