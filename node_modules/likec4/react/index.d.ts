import { CSSProperties } from 'react';
import type { DependencyList } from 'react';
import { DiagramEdge } from '@likec4/core';
import { DiagramNode } from '@likec4/core';
import { DiagramView } from '@likec4/core';
import { Fqn } from '@likec4/core';
import { JSX } from 'react/jsx-runtime';
import { JSX as JSX_2 } from 'react';
import { MouseEvent as MouseEvent_2 } from 'react';
import { PropsWithChildren } from 'react';
import { ReactNode } from 'react';
import { RelationId } from '@likec4/core';
import { ViewChange } from '@likec4/core';
import { ViewId } from '@likec4/core';
import { WhereOperator } from '@likec4/core';

declare type AllKeys<T> = T extends any ? keyof T : never

declare type AnyStore<Value = any> = {
    get(): Value
    readonly value: undefined | Value
}

/**
 * Create store with atomic value. It could be a string or an object, which you
 * will replace completely.
 *
 * If you want to change keys in the object inside store, use {@link map}.
 *
 * ```js
 * import { atom, onMount } from 'nanostores'
 *
 * // Initial value
 * export const $router = atom({ path: '', page: 'home' })
 *
 * function parse () {
 *   $router.set({ path: location.pathname, page: parse(location.pathname) })
 * }
 *
 * // Listen for URL changes on first store’s listener.
 * onMount($router, () => {
 *   parse()
 *   window.addEventListener('popstate', parse)
 *   return () => {
 *     window.removeEventListener('popstate', parse)
 *   }
 * })
 * ```
 *
 * @param initialValue Initial value of the store.
 * @returns The store object with methods to subscribe.
 */
declare function atom<Value, StoreExt = {}>(
...args: undefined extends Value ? [] | [Value] : [Value]
): PreinitializedWritableAtom<Value> & StoreExt

export declare const BundledStyles: () => any;

declare type ChangeEvent = {
    change: ViewChange;
};

declare type ColorScheme = 'light' | 'dark';

declare interface Computed {
    <Value extends any, OriginStore extends Store>(
    stores: OriginStore,
    cb: (value: StoreValue<OriginStore>) => Task<Value>
    ): ReadableAtom<undefined | Value>
    <Value extends any, OriginStores extends AnyStore[]>(
    stores: [...OriginStores],
    cb: (...values: StoreValues<OriginStores>) => Task<Value>
    ): ReadableAtom<undefined | Value>
    <Value extends any, OriginStore extends Store>(
    stores: OriginStore,
    cb: (value: StoreValue<OriginStore>) => Value
    ): ReadableAtom<Value>
    /**
     * Create derived store, which use generates value from another stores.
     *
     * ```js
     * import { computed } from 'nanostores'
     *
     * import { $users } from './users.js'
     *
     * export const $admins = computed($users, users => {
     *   return users.filter(user => user.isAdmin)
     * })
     * ```
     *
     * An async function can be evaluated by using {@link task}.
     *
     * ```js
     * import { computed, task } from 'nanostores'
     *
     * import { $userId } from './users.js'
     *
     * export const $user = computed($userId, userId => task(async () => {
     *   const response = await fetch(`https://my-api/users/${userId}`)
     *   return response.json()
     * }))
     * ```
     */
    <Value extends any, OriginStores extends AnyStore[]>(
    stores: [...OriginStores],
    cb: (...values: StoreValues<OriginStores>) => Task<Value> | Value
    ): ReadableAtom<Value>
}

declare const computed: Computed;

declare type DiagramNodeWithNavigate<ID = ViewId> = Omit<DiagramNode, 'navigateTo'> & {
    navigateTo: ID;
};

declare type ElementIconRenderer = (props: ElementIconRendererProps) => ReactNode;

declare type ElementIconRendererProps = {
    node: {
        id: string;
        title: string;
        icon?: string | null | undefined;
    };
};

export declare const FontCss: string;

declare type Get<T, K extends KeyofBase> = Extract<T, { [K1 in K]: any }>[K]

declare type KeyofBase = keyof any

declare interface LikeC4BrowserProps {
    /**
     * Background pattern for the browser view.
     * @default 'dots'
     */
    background?: 'dots' | 'lines' | 'cross' | 'transparent' | 'solid' | undefined;
    /**
     * Seems like this is percentage of the view size
     * @default 0.1
     */
    fitViewPadding?: number | undefined;
    /**
     * Show/hide panel with top left controls,
     * @default true
     */
    controls?: boolean | undefined;
    /**
     * Display diagram title / description
     *
     * @default true
     */
    showDiagramTitle?: boolean | undefined;
    /**
     * Show back/forward navigation buttons
     * @default true
     */
    showNavigationButtons?: undefined | boolean;
    /**
     * Enable search popup for elements and views
     * @default true
     */
    enableSearch?: boolean | undefined;
    /**
     * If double click on a node should enable focus mode
     *
     * @default true
     */
    enableFocusMode?: boolean | undefined;
    /**
     * If Walkthrough for dynamic views should be enabled
     * @default true
     */
    enableDynamicViewWalkthrough?: boolean | undefined;
    /**
     * Enable popup with element details
     * @default true
     */
    enableElementDetails?: boolean | undefined;
    /**
     * Experimental feature to browse relationships
     *
     * @default enableElementDetails
     */
    enableRelationshipBrowser?: boolean | undefined;
    /**
     * Display dropdown with details on relationship's label click
     * @default enableRelationshipBrowser
     */
    enableRelationshipDetails?: boolean | undefined;
    /**
     * Display notations of the view
     * @default true
     */
    showNotations?: boolean | undefined;
    className?: string | undefined;
    style?: CSSProperties | undefined;
}

declare interface LikeC4DiagramEventHandlers {
    onChange?: OnChange | null | undefined;
    onNavigateTo?: OnNavigateTo | null | undefined;
    onNodeClick?: OnNodeClick | null | undefined;
    onNodeContextMenu?: OnNodeClick | null | undefined;
    onCanvasContextMenu?: OnCanvasClick | null | undefined;
    onEdgeClick?: OnEdgeClick | null | undefined;
    onEdgeContextMenu?: OnEdgeClick | null | undefined;
    onCanvasClick?: OnCanvasClick | null | undefined;
    onCanvasDblClick?: OnCanvasClick | null | undefined;
    onBurgerMenuClick?: null | undefined | (() => void);
    onOpenSource?: null | undefined | ((params: OpenSourceParams) => void);
}

declare interface LikeC4DiagramProperties {
    view: DiagramView;
    className?: string | undefined;
    /**
     * Enable/disable panning
     * @default true
     */
    pannable?: boolean | undefined;
    /**
     * Enable/disable zooming
     * @default true
     */
    zoomable?: boolean | undefined;
    /**
     * Disable any editing (dragging still can be enabled with `nodesDraggable`)
     * @default true
     */
    readonly?: boolean | undefined;
    /**
     * Show/hide panel with top left controls,
     *
     * @default true if not readonly
     */
    controls?: boolean | undefined;
    /**
     * If set, initial viewport will show all nodes & edges
     * @default true
     */
    fitView?: boolean | undefined;
    /**
     * Seems like this is percentage of the view size
     * @default 0
     */
    fitViewPadding?: number | undefined;
    /**
     * @default false if readonly
     */
    nodesSelectable?: boolean | undefined;
    /**
     * @default false if readonly
     */
    nodesDraggable?: boolean | undefined;
    initialWidth?: number | undefined;
    initialHeight?: number | undefined;
    /**
     * Background pattern
     * @default 'dots'
     */
    background?: 'transparent' | 'solid' | 'dots' | 'lines' | 'cross' | undefined;
    /**
     * Display webview with diagram title / description
     * @default true
     */
    showDiagramTitle?: boolean | undefined;
    /**
     * Show back/forward history navigation buttons
     * @default true if `onNavigateTo` is set
     */
    showNavigationButtons?: undefined | boolean;
    /**
     * Display notations of the view
     * @default true
     */
    showNotations?: boolean | undefined;
    /**
     * Display dropdown with details on relationship's label click
     * @default false
     */
    enableRelationshipDetails?: boolean | undefined;
    /**
     * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
     * @default false
     */
    enableFocusMode?: boolean | undefined;
    /**
     * Enable search popup for elements and views
     * @default true
     */
    enableSearch?: boolean | undefined;
    /**
     * Enable modal with element details
     * @default false
     */
    enableElementDetails?: boolean | undefined;
    /**
     * Experimental feature to browse relationships
     *
     * @default false
     */
    enableRelationshipBrowser?: boolean | undefined;
    /**
     * If Walkthrough for dynamic views should be enabled
     * @default false
     */
    enableDynamicViewWalkthrough?: boolean | undefined;
    /**
     * Experimental feature to enable edge editing
     * @default false
     */
    experimentalEdgeEditing?: boolean | undefined;
    /**
     * Render icon for an element, bundled or remote
     * By default, if icon is http:// or https://, it will be rendered as an image
     */
    renderIcon?: ElementIconRenderer | undefined;
    /**
     * Dynamic filter, applies both to nodes and edges
     */
    where?: WhereOperator<string, string> | undefined;
}

declare type LikeC4DiagramProps = LikeC4DiagramProperties & LikeC4DiagramEventHandlers;

export declare const LikeC4ModelProvider: (props: LikeC4ModelProviderProps) => JSX_2.Element;

declare type LikeC4ModelProviderProps = PropsWithChildren<{
    likec4model: any;
}>;

export declare function LikeC4View<ViewId extends string = string, Tag = string, Kind = string>({ viewId, ...props }: LikeC4ViewProps<ViewId, Tag, Kind>): JSX.Element;

export declare interface LikeC4ViewProps<ViewId = string, Tag = string, Kind = string> {
    /**
     * View to display.
     */
    viewId: ViewId;
    /**
     * Enable/disable panning
     * @default false
     */
    pannable?: boolean | undefined;
    /**
     * Enable/disable zooming
     * @default false
     */
    zoomable?: boolean | undefined;
    /**
     * @default true
     */
    keepAspectRatio?: boolean | undefined;
    /**
     * Background pattern
     * @default 'transparent'
     */
    background?: 'dots' | 'lines' | 'cross' | 'transparent' | 'solid' | undefined;
    /**
     * Click on the view opens a modal with browser.
     * You can customize or disable the browser.
     *
     * @default true
     */
    browser?: boolean | LikeC4BrowserProps | undefined;
    /**
     * @default - determined by the user's system preferences.
     */
    colorScheme?: 'light' | 'dark' | undefined;
    /**
     * LikeC4 views are using 'IBM Plex Sans' font.
     * By default, component injects the CSS to document head.
     * Set to false if you want to handle the font yourself.
     *
     * @default true
     */
    injectFontCss?: boolean | undefined;
    /**
     * Show/hide panel with top left controls,
     * @default false
     */
    controls?: boolean | undefined;
    /**
     * If set, initial viewport will show all nodes & edges
     * @default true
     */
    fitView?: boolean | undefined;
    /**
     * Seems like this is percentage of the view size
     * @default 0.1
     */
    fitViewPadding?: number | undefined;
    /**
     * Display diagram title / description
     *
     * @default false
     */
    showDiagramTitle?: boolean | undefined;
    /**
     * Show back/forward navigation buttons
     * @default false
     */
    showNavigationButtons?: undefined | boolean;
    /**
     * Display notations of the view
     * @default false
     */
    showNotations?: boolean | undefined;
    /**
     * If double click on a node should enable focus mode, i.e. highlight incoming/outgoing edges
     * Conflicts with `browser` prop
     *
     * @default false
     */
    enableFocusMode?: boolean | undefined;
    /**
     * If Walkthrough for dynamic views should be enabled
     * @default enableFocusMode
     */
    enableDynamicViewWalkthrough?: boolean | undefined;
    /**
     * Enable popup with element details
     * @default false
     */
    enableElementDetails?: boolean | undefined;
    /**
     * Experimental feature to browse relationships
     *
     * @default enableElementDetails
     */
    enableRelationshipBrowser?: boolean | undefined;
    /**
     * Display dropdown with details on relationship's label click
     * @default enableRelationshipBrowser
     */
    enableRelationshipDetails?: boolean | undefined;
    where?: WhereOperator<Tag, Kind> | undefined;
    className?: string | undefined;
    style?: CSSProperties | undefined;
    /**
     * Override Mantine theme
     */
    mantineTheme?: any;
    /** Function to generate nonce attribute added to all generated `<style />` tags */
    styleNonce?: string | (() => string) | undefined;
    /**
     * Render custom icon for a node
     * By default, if icon is http:// or https://, it will be rendered as an image
     */
    renderIcon?: ElementIconRenderer | undefined;
}

/**
 * Create map store. Map store is a store with key-value object
 * as a store value.
 *
 * @param init Initialize store and return store destructor.
 * @returns The store object with methods to subscribe.
 */
declare function map<Value extends object, StoreExt extends object = {}>(
value?: Value
): PreinitializedMapStore<Value> & StoreExt

declare interface MapStore<Value extends object = any>
extends WritableAtom<Value> {
    /**
     * Subscribe to store changes.
     *
     * In contrast with {@link Store#subscribe} it do not call listener
     * immediately.
     *
     * @param listener Callback with store value and old value.
     * @param changedKey Key that was changed. Will present only if `setKey`
     *                   has been used to change a store.
     * @returns Function to remove listener.
     */
    listen(
    listener: (
    value: ReadonlyIfObject<Value>,
    oldValue: ReadonlyIfObject<Value>,
    changedKey: AllKeys<Value>
    ) => void
    ): () => void

    /**
     * Low-level method to notify listeners about changes in the store.
     *
     * Can cause unexpected behaviour when combined with frontend frameworks
     * that perform equality checks for values, such as React.
     */
    notify(oldValue?: ReadonlyIfObject<Value>, changedKey?: AllKeys<Value>): void

    /**
     * Change store value.
     *
     * ```js
     * $settings.set({ theme: 'dark' })
     * ```
     *
     * Operation is atomic, subscribers will be notified once with the new value.
     * `changedKey` will be undefined
     *
     * @param newValue New store value.
     */
    set(newValue: Value): void

    /**
     * Change key in store value.
     *
     * ```js
     * $settings.setKey('theme', 'dark')
     * ```
     *
     * To delete key set `undefined`.
     *
     * ```js
     * $settings.setKey('theme', undefined)
     * ```
     *
     * @param key The key name.
     * @param value New value.
     */
    setKey<Key extends AllKeys<Value>>(
    key: Key,
    value: Get<Value, Key> | Value[Key]
    ): void

    /**
     * Subscribe to store changes and call listener immediately.
     *
     * ```
     * import { $router } from '../store'
     *
     * $router.subscribe(page => {
     *   console.log(page)
     * })
     * ```
     *
     * @param listener Callback with store value and old value.
     * @param changedKey Key that was changed. Will present only
     *                   if `setKey` has been used to change a store.
     * @returns Function to remove listener.
     */
    subscribe(
    listener: (
    value: ReadonlyIfObject<Value>,
    oldValue: ReadonlyIfObject<Value> | undefined,
    changedKey: AllKeys<Value> | undefined
    ) => void
    ): () => void
}

export declare namespace nano {
    export {
        atom,
        computed,
        map,
        useStore
    }
}

/**
 * On pane/canvas click (not on any node or edge)
 */
declare type OnCanvasClick = (event: MouseEvent_2) => void;

declare type OnChange = (event: ChangeEvent) => void;

declare type OnEdgeClick = (edge: DiagramEdge, event: MouseEvent_2) => void;

declare type OnNavigateTo<ID = ViewId> = (to: ID, event?: MouseEvent_2, element?: DiagramNodeWithNavigate<ID>) => void;

declare type OnNodeClick = (node: DiagramNode, event: MouseEvent_2) => void;

declare type OpenSourceParams = {
    element: Fqn;
    property?: string;
} | {
    relation: RelationId;
} | {
    deployment: Fqn;
    property?: string;
} | {
    view: ViewId;
};

declare interface PreinitializedMapStore<Value extends object = any>
extends MapStore<Value> {
    readonly value: Value
}

declare interface PreinitializedWritableAtom<Value extends any>
extends WritableAtom<Value> {
    readonly value: Value
}

declare type Primitive = boolean | number | string

export declare function ReactLikeC4<ViewId extends string = string, Tag = string, Kind = string>({ viewId, ...props }: ReactLikeC4Props<ViewId, Tag, Kind>): JSX.Element;

export declare namespace ReactLikeC4 {
    var displayName: string;
}

export declare type ReactLikeC4Props<ViewId = string, Tag = string, Kind = string> = Omit<LikeC4DiagramProps, 'view' | 'where' | 'onNavigateTo'> & {
    viewId: ViewId;
    /**
     * Keep aspect ratio of the diagram
     * Disable if you need to manage the viewport (use className)
     *
     * @default true
     */
    keepAspectRatio?: boolean | undefined;
    /**
     * By default determined by the user's system preferences.
     */
    colorScheme?: 'light' | 'dark' | undefined;
    /**
     * LikeC4 views are using 'IBM Plex Sans' font.
     * By default, component injects the CSS to document head.
     * Set to false if you want to handle the font yourself.
     *
     * @default true
     */
    injectFontCss?: boolean | undefined;
    style?: CSSProperties | undefined;
    where?: WhereOperator<Tag, Kind> | undefined;
    onNavigateTo?: OnNavigateTo<ViewId> | undefined;
    mantineTheme?: any;
    /** Function to generate nonce attribute added to all generated `<style />` tags */
    styleNonce?: string | (() => string) | undefined;
};

/**
 * Store object.
 */
declare interface ReadableAtom<Value = any> {
    /**
     * Get store value.
     *
     * In contrast with {@link ReadableAtom#value} this value will be always
     * initialized even if store had no listeners.
     *
     * ```js
     * $store.get()
     * ```
     *
     * @returns Store value.
     */
    get(): Value

    /**
     * Listeners count.
     */
    readonly lc: number

    /**
     * Subscribe to store changes.
     *
     * In contrast with {@link Store#subscribe} it do not call listener
     * immediately.
     *
     * @param listener Callback with store value and old value.
     * @returns Function to remove listener.
     */
    listen(
    listener: (
    value: ReadonlyIfObject<Value>,
    oldValue: ReadonlyIfObject<Value>
    ) => void
    ): () => void

    /**
     * Low-level method to notify listeners about changes in the store.
     *
     * Can cause unexpected behaviour when combined with frontend frameworks
     * that perform equality checks for values, such as React.
     */
    notify(oldValue?: ReadonlyIfObject<Value>): void

    /**
     * Unbind all listeners.
     */
    off(): void

    /**
     * Subscribe to store changes and call listener immediately.
     *
     * ```
     * import { $router } from '../store'
     *
     * $router.subscribe(page => {
     *   console.log(page)
     * })
     * ```
     *
     * @param listener Callback with store value and old value.
     * @returns Function to remove listener.
     */
    subscribe(
    listener: (
    value: ReadonlyIfObject<Value>,
    oldValue?: ReadonlyIfObject<Value>
    ) => void
    ): () => void

    /**
     * Low-level method to read store’s value without calling `onStart`.
     *
     * Try to use only {@link ReadableAtom#get}.
     * Without subscribers, value can be undefined.
     */
    readonly value: undefined | Value
}

declare type ReadonlyIfObject<Value> = Value extends undefined
? Value
: Value extends (...args: any) => any
? Value
: Value extends Primitive
? Value
: Value extends object
? Readonly<Value>
: Value

declare type Store<Value = any> = ReadableAtom<Value> | WritableStore<Value>

declare type StoreKeys<T> = T extends { setKey: (k: infer K, v: any) => unknown }
? K
: never

declare type StoreValue<SomeStore> = SomeStore extends {
    get(): infer Value
}
? Value
: any

declare type StoreValues<Stores extends AnyStore[]> = {
    [Index in keyof Stores]: StoreValue<Stores[Index]>
}

declare interface Task<Value> extends Promise<Value> {
    t: true
}

export declare function useBundledStyleSheet(injectFontCss: boolean, styleNonce?: string | (() => string) | undefined): CSSStyleSheet[];

export declare function useColorScheme(explicit?: ColorScheme): ColorScheme;

/**
 * Subscribe to store changes and get store’s value.
 *
 * Can be user with store builder too.
 *
 * ```js
 * import { useStore } from 'nanostores/react'
 *
 * import { router } from '../store/router'
 *
 * export const Layout = () => {
 *   let page = useStore(router)
 *   if (page.route === 'home') {
 *     return <HomePage />
 *   } else {
 *     return <Error404 />
 *   }
 * }
 * ```
 *
 * @param store Store instance.
 * @returns Store value.
 */
declare function useStore<SomeStore extends Store>(
store: SomeStore,
options?: UseStoreOptions<SomeStore>
): StoreValue<SomeStore>

declare interface UseStoreOptions<SomeStore> {
    /**
     * @default
     * ```ts
     * [store, options.keys]
     * ```
     */
    deps?: DependencyList

    /**
     * Will re-render components only on specific key changes.
     */
    keys?: StoreKeys<SomeStore>[]
}

/**
 * Store with a way to manually change the value.
 */
declare interface WritableAtom<Value = any> extends ReadableAtom<Value> {
    /**
     * Change store value.
     *
     * ```js
     * $router.set({ path: location.pathname, page: parse(location.pathname) })
     * ```
     *
     * @param newValue New store value.
     */
    set(newValue: Value): void
}

declare type WritableStore<Value = any> =
| (Value extends object ? MapStore<Value> : never)
| WritableAtom<Value>

export { }
